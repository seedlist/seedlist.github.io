/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-node_modules_bnc-onboard_dist_esm_index-4a48b5ea_js"],{

/***/ "./node_modules/bnc-onboard/dist/esm/index-4a48b5ea.js":
/*!*************************************************************!*\
  !*** ./node_modules/bnc-onboard/dist/esm/index-4a48b5ea.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _onboard_584c044d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./onboard-584c044d.js */ \"./node_modules/bnc-onboard/dist/esm/onboard-584c044d.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bignumber.js */ \"./node_modules/bignumber.js/bignumber.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bignumber_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var bnc_sdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bnc-sdk */ \"./node_modules/bnc-sdk/dist/esm/index.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bowser */ \"./node_modules/bowser/es5.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(bowser__WEBPACK_IMPORTED_MODULE_4__);\nvar _errorMessages;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n\n\n\n\n\nvar HANDLE_PIN_PRESS = 'handlePinPress';\nvar BUTTON_COLOR = \"#EBEBED\";\nvar BUTTON_DOT_COLOR = \"#33394B\";\nvar ModalType;\n\n(function (ModalType) {\n  ModalType[ModalType[\"Pin\"] = 0] = \"Pin\";\n  ModalType[ModalType[\"Passphrase\"] = 1] = \"Passphrase\";\n})(ModalType || (ModalType = {}));\n\nvar pinButton = function pinButton(value, slot) {\n  var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '64px';\n  var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '64px';\n  return \"\\n  <button\\n    class=\\\"pin-button\\\"\\n    style=\\\"width: \".concat(width, \"; height: \").concat(height, \";\\\"\\n    type=\\\"button\\\"\\n    onclick=\\\"window.\").concat(HANDLE_PIN_PRESS, \"(\").concat(value, \")\\\">\\n      \").concat(slot || \"<svg class=\\\"pin-button-dot\\\" viewBox=\\\"0 0 18 18\\\" width=\\\"18\\\" height=\\\"18\\\">\\n          <circle cx=\\\"9\\\" cy=\\\"9\\\" r=\\\"9\\\" ></circle>\\n        </svg>\", \"\\n      <div class=\\\"pin-button-bg\\\">\\n  </button>\\n\");\n};\n\nvar pinButtons = \"\\n  <div class=\\\"pin-pad-buttons\\\">\\n    \".concat([7, 8, 9, 4, 5, 6, 1, 2, 3].map(function (val) {\n  return pinButton(val);\n}).join(''), \"\\n  </div>\\n\");\nvar delButtonIcon = \"<svg class=\\\"del-button-icon\\\" viewBox=\\\"0 0 24 24\\\" focusable=\\\"false\\\" class=\\\"chakra-icon css-onkibi\\\" aria-hidden=\\\"true\\\"><path fill=\\\"currentColor\\\" d=\\\"M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z\\\"></path></svg>\";\n\nvar pinPhraseInput = function pinPhraseInput(modalType) {\n  return \"\\n<form id=\\\"pin-phrase-form\\\" class=\\\"pin-phrase-input-container\\\">\\n  <input\\n    id=\\\"pin-phrase-input\\\"\\n    placeholder=\\\"\".concat(modalType === ModalType.Pin ? 'PIN' : '', \"\\\"\\n    type=\\\"password\\\"\\n    autocomplete=\\\"current-password\\\"\\n  />\\n  \").concat(modalType === ModalType.Pin ? \" <div class=\\\"del-button-wrapper\\\">\\n            \".concat(pinButton(-1, delButtonIcon, '38px', '38px'), \"\\n          </div>\") : '', \"\\n</form>\\n\");\n}; // Contains styles used by both the pin entry modal and the passphrase entry modal\n\n\nvar baseStyles = \"\\n  .keepkey-modal {\\n    max-width: 22rem;\\n    padding: 20px 10px;\\n  }\\n  .pin-phrase-input-container {\\n    display: flex;\\n    position: relative;\\n    align-items: center;\\n    margin: 20px 0;\\n    width: 100%;\\n  }\\n  #pin-phrase-input {\\n    background: inherit;\\n    font-size: 0.889em;\\n    font-family: inherit;\\n    border-width: 1px;\\n    border-style: solid;\\n    border-color: #242835;\\n    border-radius: 4px;\\n    padding-left: 0.5rem;\\n    padding-right: 4.1rem;\\n    transition: opacity 150ms ease-in-out;\\n    height: 42px;\\n    width: 100%;\\n    opacity: 0.6;\\n    outline: none;\\n  }\\n  #pin-phrase-input:hover, #pin-phrase-input:focus {\\n    opacity: 1;\\n  }\\n  .unlock-button {\\n    height: 26px;\\n    display: flex;\\n    align-items: center;\\n    width: 100%;\\n    justify-content: center;\\n  }\\n  \\n  /* Overrides the branding on the modal*/\\n  .keepkey-modal + .bn-branding { visibility: hidden !important; }\\n  .keepkey-modal .bn-onboard-prepare-button {\\n    width: 100%;\\n  }\\n\";\nvar pinModalStyles = \"\\n  #entry {\\n    align-items: center;\\n    display: flex;\\n    flex-flow: column;\\n    padding: 20px;\\n  }\\n  .pin-pad-buttons {\\n    display: grid;\\n    grid-template-columns: repeat(3, 75px);\\n    grid-template-rows: repeat(3, 75px);\\n    align-items: center;\\n    justify-items: center;\\n    margin-bottom: 15px;\\n  }\\n  .pin-button {\\n    align-items: center;\\n    border-radius: 6px;\\n    border: 1px solid \".concat(BUTTON_COLOR, \";\\n    cursor: pointer;\\n    display: flex;\\n    justify-content: center;\\n    font-size: 18px;\\n    overflow: hidden;\\n    padding: 0;\\n    background-color: unset;\\n    overflow: hidden;\\n  }\\n  .pin-button-bg {\\n    width: 100%;\\n    height: 100%;\\n    display: flex;\\n    overflow: hidden;\\n    background-color: \").concat(BUTTON_COLOR, \";\\n    transition: opacity 100ms ease-in;\\n  }\\n  .pin-button-bg:hover {\\n    opacity: .2;\\n  }\\n  .pin-button-dot {\\n    fill: \").concat(BUTTON_DOT_COLOR, \";\\n    position: absolute;\\n    pointer-events: none;\\n    z-index: 2;\\n  }\\n  .del-button-wrapper {\\n    position: absolute;\\n    height: 42px;\\n    width: 42px;\\n    right: 2px;\\n    display: flex;\\n    align-items: center;\\n    justify-content: center;\\n  }\\n  .del-button-wrapper > .pin-button {\\n    border: none;\\n  }\\n  .del-button-icon {\\n    position: absolute;\\n    width: 20px;\\n    z-index: 2;\\n    pointer-events: none;\\n  }\\n  .del-button-icon + div {\\n    opacity: .5;\\n  }\\n  .del-button-icon + div:hover {\\n    opacity: 1;\\n  }\\n\");\nvar passphraseModalStyles = \"\\n  .keepkey-modal {\\n    padding: 40px 30px;\\n  }\\n\";\nvar pinHTML = \"\\n    <style>\".concat(baseStyles).concat(pinModalStyles, \"</style>\\n    <h2>Enter Your Pin</h2>\\n    <p>\\n      Use PIN layout shown on your device to find the location to press on this pin pad.\\n    </p>\\n    <div id=\\\"entry\\\" class=\\\"bn-onboard-custom\\\">\\n      \").concat(pinButtons, \"\\n      \").concat(pinPhraseInput(ModalType.Pin), \"\\n    </div>\\n  \");\nvar passphraseHTML = \"\\n  <style>\".concat(baseStyles).concat(passphraseModalStyles, \"</style>\\n  <h2 style=\\\"margin-bottom: 35px\\\">Enter Your Passphrase</h2>\\n  <div id=\\\"entry\\\" class=\\\"bn-onboard-custom\\\">\\n    \").concat(pinPhraseInput(ModalType.Passphrase), \"\\n  </div>\\n\");\n\nvar renderModal = function renderModal(wallet, modalType) {\n  var _document$getElementB;\n\n  var modalHtml = modalType === ModalType.Pin ? pinHTML : passphraseHTML;\n\n  var getInput = function getInput() {\n    return document.getElementById('pin-phrase-input');\n  };\n\n  var deleteWindowProperties = function deleteWindowProperties() {\n    delete window[HANDLE_PIN_PRESS];\n  };\n\n  if (modalType === ModalType.Pin) {\n    window[HANDLE_PIN_PRESS] = function (value) {\n      var input = getInput(); // A value of -1 signals a backspace e.g. we delete the last char from the input\n\n      input.value = value === -1 ? input.value.slice(0, -1) : input.value + value;\n    };\n  } // Creates a modal component which gets mounted to the body and is passed the pin html into it's slot\n\n\n  var div = document.createElement('div');\n  div.innerHTML = modalHtml;\n  div.className = 'keepkey-modal';\n  var pinModal = new _onboard_584c044d_js__WEBPACK_IMPORTED_MODULE_1__.M({\n    target: document.body,\n    props: {\n      closeModal: function closeModal() {\n        // Cancels any action that the keepkey wallet may be doing\n        wallet.cancel();\n        deleteWindowProperties();\n        pinModal.$destroy();\n      },\n      $$slots: createSlot(div),\n      $$scope: {}\n    }\n  }); // Submits the pin or passphrase to the Keepkey device\n\n  var submit = /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {\n      var value;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              value = getInput().value;\n\n              if (!(modalType === ModalType.Pin)) {\n                _context.next = 6;\n                break;\n              }\n\n              _context.next = 4;\n              return wallet.sendPin(value);\n\n            case 4:\n              _context.next = 8;\n              break;\n\n            case 6:\n              _context.next = 8;\n              return wallet.sendPassphrase(value);\n\n            case 8:\n              pinModal.$destroy();\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function submit() {\n      return _ref.apply(this, arguments);\n    };\n  }();\n\n  (_document$getElementB = document.getElementById('pin-phrase-form')) === null || _document$getElementB === void 0 ? void 0 : _document$getElementB.addEventListener('submit', function (e) {\n    e.preventDefault();\n    submit();\n  }); // Creates a new Button component used to trigger sending the pin to Keepkey\n\n  var entryEl = document.getElementById('entry');\n\n  if (entryEl) {\n    var span = document.createElement('span');\n    span.innerHTML = \"Unlock\";\n    span.className = \"unlock-button\";\n    new _onboard_584c044d_js__WEBPACK_IMPORTED_MODULE_1__.B({\n      target: entryEl,\n      props: {\n        onclick: function () {\n          var _onclick = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n            return regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    submit();\n                    deleteWindowProperties();\n\n                  case 2:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          function onclick() {\n            return _onclick.apply(this, arguments);\n          }\n\n          return onclick;\n        }(),\n        $$slots: createSlot(span),\n        $$scope: {}\n      }\n    });\n  }\n};\n/**\r\n * createSlot - creates the necessary object needed to pass\r\n * arbitrary html into a component's default slot\r\n * @param element The html element which is inserted into the components slot\r\n */\n\n\nfunction createSlot(element) {\n  return {\n    \"default\": [function () {\n      return {\n        c: _onboard_584c044d_js__WEBPACK_IMPORTED_MODULE_1__.b,\n        m: function mount(target, anchor) {\n          (0,_onboard_584c044d_js__WEBPACK_IMPORTED_MODULE_1__.c)(target, element, anchor);\n        },\n        d: function destroy(detaching) {\n          if (detaching) {\n            (0,_onboard_584c044d_js__WEBPACK_IMPORTED_MODULE_1__.d)(element);\n          }\n        },\n        l: _onboard_584c044d_js__WEBPACK_IMPORTED_MODULE_1__.b\n      };\n    }]\n  };\n}\n\nvar img = \"data:image/png;base64,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\";\n/* -= CONSTANTS =- */\n\nvar ACCOUNTS_TO_GET = 5;\nvar WALLET_NAME = 'KeepKey';\nvar ERROR_BUSY = 'busy';\nvar ERROR_PAIRING = 'pairing';\nvar errorMessages = (_errorMessages = {}, _defineProperty(_errorMessages, ERROR_BUSY, \"Your KeepKey is currently connected to another application.\\n  Please close any other browser tabs or applications that may be connected to your device and try again.\"), _defineProperty(_errorMessages, ERROR_PAIRING, 'There was an error pairing the device. Please disconnect and reconnect the device and try again.'), _errorMessages);\n\nfunction keepkey(options) {\n  var label = options.label,\n      iconSrc = options.iconSrc,\n      rpcUrl = options.rpcUrl,\n      networkId = options.networkId,\n      preferred = options.preferred; // Used to signal if the keep key could not be paired or if the keep key is already paired with another app\n\n  var _installMessage;\n\n  return {\n    name: label || WALLET_NAME,\n    iconSrc: iconSrc || img,\n    wallet: function () {\n      var _wallet = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(_ref2) {\n        var BigNumber, resetWalletState, _yield$createKeepKeyP, provider, error;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                BigNumber = _ref2.BigNumber, resetWalletState = _ref2.resetWalletState;\n                _context6.next = 3;\n                return createKeepKeyProvider({\n                  resetWalletState: resetWalletState,\n                  BigNumber: BigNumber,\n                  rpcUrl: rpcUrl,\n                  networkId: networkId\n                });\n\n              case 3:\n                _yield$createKeepKeyP = _context6.sent;\n                provider = _yield$createKeepKeyP.provider;\n                error = _yield$createKeepKeyP.error;\n                _installMessage = errorMessages[error] || '';\n                return _context6.abrupt(\"return\", {\n                  provider: provider,\n                  \"interface\": !error ? {\n                    name: WALLET_NAME,\n                    connect: provider.enable,\n                    disconnect: provider.disconnect,\n                    address: {\n                      get: function () {\n                        var _get = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {\n                          return regeneratorRuntime.wrap(function _callee3$(_context3) {\n                            while (1) {\n                              switch (_context3.prev = _context3.next) {\n                                case 0:\n                                  return _context3.abrupt(\"return\", provider.getPrimaryAddress());\n\n                                case 1:\n                                case \"end\":\n                                  return _context3.stop();\n                              }\n                            }\n                          }, _callee3);\n                        }));\n\n                        function get() {\n                          return _get.apply(this, arguments);\n                        }\n\n                        return get;\n                      }()\n                    },\n                    network: {\n                      get: function () {\n                        var _get2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n                          return regeneratorRuntime.wrap(function _callee4$(_context4) {\n                            while (1) {\n                              switch (_context4.prev = _context4.next) {\n                                case 0:\n                                  return _context4.abrupt(\"return\", networkId);\n\n                                case 1:\n                                case \"end\":\n                                  return _context4.stop();\n                              }\n                            }\n                          }, _callee4);\n                        }));\n\n                        function get() {\n                          return _get2.apply(this, arguments);\n                        }\n\n                        return get;\n                      }()\n                    },\n                    balance: {\n                      get: function () {\n                        var _get3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {\n                          var address;\n                          return regeneratorRuntime.wrap(function _callee5$(_context5) {\n                            while (1) {\n                              switch (_context5.prev = _context5.next) {\n                                case 0:\n                                  address = provider.getPrimaryAddress();\n                                  return _context5.abrupt(\"return\", address && provider.getBalance(address));\n\n                                case 2:\n                                case \"end\":\n                                  return _context5.stop();\n                              }\n                            }\n                          }, _callee5);\n                        }));\n\n                        function get() {\n                          return _get3.apply(this, arguments);\n                        }\n\n                        return get;\n                      }()\n                    }\n                  } : null\n                });\n\n              case 8:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      function wallet(_x) {\n        return _wallet.apply(this, arguments);\n      }\n\n      return wallet;\n    }(),\n    // The style tag here is used to hide the 'Open KeepKey button'\n    installMessage: function installMessage() {\n      return _installMessage ? \"<style>footer a > button { display: none !important }</style>\\n        <p style=\\\"font-size: 0.889rem; font-family: inherit; margin: 0.889rem 0;\\\">\\n          \".concat(_installMessage, \"\\n        </p>\") : '';\n    },\n    type: 'hardware',\n    mobile: false,\n    desktop: true,\n    preferred: preferred\n  };\n}\n\nfunction createKeepKeyProvider(_x2) {\n  return _createKeepKeyProvider.apply(this, arguments);\n}\n\nfunction _createKeepKeyProvider() {\n  _createKeepKeyProvider = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee16(_ref3) {\n    var BigNumber, rpcUrl, resetWalletState, networkId, _yield$import, WebUSBKeepKeyAdapter, _yield$import2, Keyring, Events, bip32ToAddressNList, HDWalletErrorType, _yield$import3, createProvider, _yield$import4, isValidPath, keyring, keepKeyAdapter, keepKeyWallet, DEFAULT_DERIVATION_PATH, dPath, addressToPath, enabled, customPath, provider, enable, _enable, disconnect, setPath, _setPath, isCustomPath, getAddress, _getAddress, addresses, setPrimaryAccount, getPrimaryAddress, getMoreAccounts, _getMoreAccounts, _getAccounts, _getAccounts2, getBalances, getBalance, _signTransaction, _signTransaction2, _signMessage, _signMessage2;\n\n    return regeneratorRuntime.wrap(function _callee16$(_context16) {\n      while (1) {\n        switch (_context16.prev = _context16.next) {\n          case 0:\n            _signMessage2 = function _signMessage4() {\n              _signMessage2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee15(_ref8) {\n                var message, addressNList, _yield$keepKeyWallet$2, signature;\n\n                return regeneratorRuntime.wrap(function _callee15$(_context15) {\n                  while (1) {\n                    switch (_context15.prev = _context15.next) {\n                      case 0:\n                        message = _ref8.data;\n\n                        if (!(addressToPath.size === 0)) {\n                          _context15.next = 4;\n                          break;\n                        }\n\n                        _context15.next = 4;\n                        return enable();\n\n                      case 4:\n                        addressNList = _toConsumableArray(addressToPath.values())[0];\n                        _context15.next = 7;\n                        return keepKeyWallet.ethSignMessage({\n                          addressNList: addressNList,\n                          message: message\n                        });\n\n                      case 7:\n                        _yield$keepKeyWallet$2 = _context15.sent;\n                        signature = _yield$keepKeyWallet$2.signature;\n                        return _context15.abrupt(\"return\", signature);\n\n                      case 10:\n                      case \"end\":\n                        return _context15.stop();\n                    }\n                  }\n                }, _callee15);\n              }));\n              return _signMessage2.apply(this, arguments);\n            };\n\n            _signMessage = function _signMessage3(_x10) {\n              return _signMessage2.apply(this, arguments);\n            };\n\n            _signTransaction2 = function _signTransaction4() {\n              _signTransaction2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee14(transactionData) {\n                var addressNList, nonce, gasPrice, gas, to, value, data, _yield$keepKeyWallet$, serialized;\n\n                return regeneratorRuntime.wrap(function _callee14$(_context14) {\n                  while (1) {\n                    switch (_context14.prev = _context14.next) {\n                      case 0:\n                        if (!(addressToPath.size === 0)) {\n                          _context14.next = 3;\n                          break;\n                        }\n\n                        _context14.next = 3;\n                        return enable();\n\n                      case 3:\n                        addressNList = _toConsumableArray(addressToPath.values())[0];\n                        nonce = transactionData.nonce, gasPrice = transactionData.gasPrice, gas = transactionData.gas, to = transactionData.to, value = transactionData.value, data = transactionData.data;\n                        _context14.next = 7;\n                        return keepKeyWallet.ethSignTx({\n                          addressNList: addressNList,\n                          nonce: nonce,\n                          gasPrice: gasPrice,\n                          gasLimit: gas,\n                          to: to,\n                          value: value || '',\n                          data: data || '',\n                          chainId: networkId\n                        });\n\n                      case 7:\n                        _yield$keepKeyWallet$ = _context14.sent;\n                        serialized = _yield$keepKeyWallet$.serialized;\n                        return _context14.abrupt(\"return\", serialized);\n\n                      case 10:\n                      case \"end\":\n                        return _context14.stop();\n                    }\n                  }\n                }, _callee14);\n              }));\n              return _signTransaction2.apply(this, arguments);\n            };\n\n            _signTransaction = function _signTransaction3(_x9) {\n              return _signTransaction2.apply(this, arguments);\n            };\n\n            getBalance = function _getBalance(address) {\n              return new Promise(function (resolve, reject) {\n                provider.sendAsync({\n                  jsonrpc: '2.0',\n                  method: 'eth_getBalance',\n                  params: [address, 'latest'],\n                  id: 42\n                }, function (e, res) {\n                  e && reject(e);\n                  var result = res && res.result;\n\n                  if (result != null) {\n                    resolve(new BigNumber(result).toString(10));\n                  } else {\n                    resolve(null);\n                  }\n                });\n              });\n            };\n\n            getBalances = function _getBalances(addresses) {\n              return Promise.all(addresses.map(function (address) {\n                return new Promise( /*#__PURE__*/function () {\n                  var _ref7 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8(resolve) {\n                    var balance;\n                    return regeneratorRuntime.wrap(function _callee8$(_context8) {\n                      while (1) {\n                        switch (_context8.prev = _context8.next) {\n                          case 0:\n                            _context8.next = 2;\n                            return getBalance(address);\n\n                          case 2:\n                            balance = _context8.sent;\n                            resolve({\n                              address: address,\n                              balance: balance\n                            });\n\n                          case 4:\n                          case \"end\":\n                            return _context8.stop();\n                        }\n                      }\n                    }, _callee8);\n                  }));\n\n                  return function (_x8) {\n                    return _ref7.apply(this, arguments);\n                  };\n                }());\n              }));\n            };\n\n            _getAccounts2 = function _getAccounts4() {\n              _getAccounts2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(getMore) {\n                var _keepKeyWallet$descri, accountIdx, startingIndex, i, addressNList, address;\n\n                return regeneratorRuntime.wrap(function _callee13$(_context13) {\n                  while (1) {\n                    switch (_context13.prev = _context13.next) {\n                      case 0:\n                        if (enabled) {\n                          _context13.next = 2;\n                          break;\n                        }\n\n                        return _context13.abrupt(\"return\", []);\n\n                      case 2:\n                        if (!(addressToPath.size > 0 && !getMore)) {\n                          _context13.next = 4;\n                          break;\n                        }\n\n                        return _context13.abrupt(\"return\", addresses());\n\n                      case 4:\n                        dPath = dPath || DEFAULT_DERIVATION_PATH; // Get the account index from the derivation path\n\n                        _keepKeyWallet$descri = keepKeyWallet.describePath({\n                          path: bip32ToAddressNList(dPath),\n                          coin: 'Ethereum'\n                        }), accountIdx = _keepKeyWallet$descri.accountIdx; // This would only happen if the user provides an invalid dPath and it wasn't caught by the setPath method\n\n                        if (!(accountIdx === undefined)) {\n                          _context13.next = 8;\n                          break;\n                        }\n\n                        throw new Error(\"Could not derive account from path: \".concat(dPath));\n\n                      case 8:\n                        // Calculate the index to start from based on the dPath index and the current number of generated addresses\n                        startingIndex = accountIdx + addressToPath.size;\n                        i = startingIndex;\n\n                      case 10:\n                        if (!(i < ACCOUNTS_TO_GET + startingIndex)) {\n                          _context13.next = 19;\n                          break;\n                        }\n\n                        // Retrieve the array form of the derivation path for a given account index\n                        addressNList = keepKeyWallet.ethGetAccountPaths({\n                          coin: 'Ethereum',\n                          accountIdx: i\n                        })[0].addressNList; // Retrieve the address associated with the given account index\n\n                        _context13.next = 14;\n                        return keepKeyWallet.ethGetAddress({\n                          addressNList: addressNList,\n                          showDisplay: false\n                        });\n\n                      case 14:\n                        address = _context13.sent;\n                        // Store the address in our set of generated addresses\n                        addressToPath.set(address, addressNList);\n\n                      case 16:\n                        i++;\n                        _context13.next = 10;\n                        break;\n\n                      case 19:\n                        return _context13.abrupt(\"return\", addresses());\n\n                      case 20:\n                      case \"end\":\n                        return _context13.stop();\n                    }\n                  }\n                }, _callee13);\n              }));\n              return _getAccounts2.apply(this, arguments);\n            };\n\n            _getAccounts = function _getAccounts3(_x7) {\n              return _getAccounts2.apply(this, arguments);\n            };\n\n            _getMoreAccounts = function _getMoreAccounts3() {\n              _getMoreAccounts = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {\n                var accounts;\n                return regeneratorRuntime.wrap(function _callee12$(_context12) {\n                  while (1) {\n                    switch (_context12.prev = _context12.next) {\n                      case 0:\n                        _context12.next = 2;\n                        return _getAccounts(true);\n\n                      case 2:\n                        accounts = _context12.sent;\n                        return _context12.abrupt(\"return\", accounts && getBalances(accounts));\n\n                      case 4:\n                      case \"end\":\n                        return _context12.stop();\n                    }\n                  }\n                }, _callee12);\n              }));\n              return _getMoreAccounts.apply(this, arguments);\n            };\n\n            getMoreAccounts = function _getMoreAccounts2() {\n              return _getMoreAccounts.apply(this, arguments);\n            };\n\n            getPrimaryAddress = function _getPrimaryAddress() {\n              return enabled ? addresses()[0] : undefined;\n            };\n\n            setPrimaryAccount = function _setPrimaryAccount(address) {\n              // make a copy and put in an array\n              var accounts = _toConsumableArray(addressToPath.entries());\n\n              var accountIndex = accounts.findIndex(function (_ref5) {\n                var _ref6 = _slicedToArray(_ref5, 1),\n                    accountAddress = _ref6[0];\n\n                return accountAddress === address;\n              }); // pull the item at the account index out of the array and place at the front\n\n              accounts.unshift(accounts.splice(accountIndex, 1)[0]); // reassign addressToPath to new ordered accounts\n\n              addressToPath = new Map(accounts);\n            };\n\n            addresses = function _addresses() {\n              return Array.from(addressToPath.keys());\n            };\n\n            _getAddress = function _getAddress3() {\n              _getAddress = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(addressNList, path) {\n                return regeneratorRuntime.wrap(function _callee11$(_context11) {\n                  while (1) {\n                    switch (_context11.prev = _context11.next) {\n                      case 0:\n                        _context11.prev = 0;\n                        return _context11.abrupt(\"return\", keepKeyWallet.ethGetAddress({\n                          addressNList: addressNList\n                        }));\n\n                      case 4:\n                        _context11.prev = 4;\n                        _context11.t0 = _context11[\"catch\"](0);\n                        throw new Error(\"Unable to derive address from path \".concat(path));\n\n                      case 7:\n                      case \"end\":\n                        return _context11.stop();\n                    }\n                  }\n                }, _callee11, null, [[0, 4]]);\n              }));\n              return _getAddress.apply(this, arguments);\n            };\n\n            getAddress = function _getAddress2(_x5, _x6) {\n              return _getAddress.apply(this, arguments);\n            };\n\n            isCustomPath = function _isCustomPath() {\n              return customPath;\n            };\n\n            _setPath = function _setPath3() {\n              _setPath = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(path, custom) {\n                var addressNList, address;\n                return regeneratorRuntime.wrap(function _callee10$(_context10) {\n                  while (1) {\n                    switch (_context10.prev = _context10.next) {\n                      case 0:\n                        if (isValidPath(path)) {\n                          _context10.next = 2;\n                          break;\n                        }\n\n                        return _context10.abrupt(\"return\", false);\n\n                      case 2:\n                        if (path !== dPath) {\n                          // clear any existing addresses if different path\n                          addressToPath = new Map();\n                        }\n\n                        if (!custom) {\n                          _context10.next = 18;\n                          break;\n                        }\n\n                        _context10.prev = 4;\n                        // Convert the path to the addressNList which is what is used by keepkey for signing\n                        addressNList = bip32ToAddressNList(path);\n                        _context10.next = 8;\n                        return getAddress(addressNList, path);\n\n                      case 8:\n                        address = _context10.sent;\n                        addressToPath.set(address, addressNList);\n                        dPath = path;\n                        customPath = true;\n                        return _context10.abrupt(\"return\", true);\n\n                      case 15:\n                        _context10.prev = 15;\n                        _context10.t0 = _context10[\"catch\"](4);\n                        throw new Error(\"There was a problem deriving an address from path \".concat(path));\n\n                      case 18:\n                        customPath = false;\n                        dPath = path;\n                        return _context10.abrupt(\"return\", true);\n\n                      case 21:\n                      case \"end\":\n                        return _context10.stop();\n                    }\n                  }\n                }, _callee10, null, [[4, 15]]);\n              }));\n              return _setPath.apply(this, arguments);\n            };\n\n            setPath = function _setPath2(_x3, _x4) {\n              return _setPath.apply(this, arguments);\n            };\n\n            disconnect = function _disconnect() {\n              dPath = '';\n              addressToPath = new Map();\n              enabled = false;\n              keepKeyWallet.clearSession();\n              provider.stop();\n            };\n\n            _enable = function _enable3() {\n              _enable = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {\n                return regeneratorRuntime.wrap(function _callee9$(_context9) {\n                  while (1) {\n                    switch (_context9.prev = _context9.next) {\n                      case 0:\n                        // Cancel any user prompt that may be displayed on the keepkey i.e. the pin matrix\n                        keepKeyWallet.cancel()[\"catch\"](function (err) {\n                          return err;\n                        });\n                        enabled = true;\n                        return _context9.abrupt(\"return\", _getAccounts()[\"catch\"](function (error) {\n                          var _error$message;\n\n                          // If the error.message is an object, then the error message originated from keepkey\n                          // So we grab the string and rethrow so the walletcheck can capture and display\n                          if (error !== null && error !== void 0 && (_error$message = error.message) !== null && _error$message !== void 0 && _error$message.message) {\n                            var _error$message2;\n\n                            throw new Error(error === null || error === void 0 ? void 0 : (_error$message2 = error.message) === null || _error$message2 === void 0 ? void 0 : _error$message2.message);\n                          }\n\n                          return [];\n                        }));\n\n                      case 3:\n                      case \"end\":\n                        return _context9.stop();\n                    }\n                  }\n                }, _callee9);\n              }));\n              return _enable.apply(this, arguments);\n            };\n\n            enable = function _enable2() {\n              return _enable.apply(this, arguments);\n            };\n\n            BigNumber = _ref3.BigNumber, rpcUrl = _ref3.rpcUrl, resetWalletState = _ref3.resetWalletState, networkId = _ref3.networkId;\n            _context16.next = 24;\n            return Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_buffer_index_js\"), __webpack_require__.e(\"vendors-node_modules_events_events_js\"), __webpack_require__.e(\"vendors-node_modules_create-hash_browser_js-node_modules_elliptic_lib_elliptic_js-node_module-ad4815\"), __webpack_require__.e(\"vendors-node_modules_assert_build_assert_js-node_modules_assert_build_internal_assert_asserti-d1eadf\"), __webpack_require__.e(\"vendors-node_modules_crypto-browserify_index_js\"), __webpack_require__.e(\"vendors-node_modules_rxjs__esm5_index_js\"), __webpack_require__.e(\"vendors-node_modules_rxjs__esm5_operators_index_js\"), __webpack_require__.e(\"vendors-node_modules_ethereumjs-util_dist_index_js\"), __webpack_require__.e(\"vendors-node_modules_shapeshiftoss_hdwallet-core_dist_index_js\"), __webpack_require__.e(\"vendors-node_modules_ethereumjs-tx_es5_index_js-node_modules_native-url_dist_index_js-node_mo-915f2e\"), __webpack_require__.e(\"vendors-node_modules_shapeshiftoss_hdwallet-keepkey-webusb_dist_index_js\"), __webpack_require__.e(\"_3fc0-_f9d4-_7a28-_cad2-_593c-_802b-_1e44-_f462-_ea3f-_7874-_ed1b-_d17e-_7ce8-_3e83-_19e6\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! @shapeshiftoss/hdwallet-keepkey-webusb */ \"./node_modules/@shapeshiftoss/hdwallet-keepkey-webusb/dist/index.js\", 23));\n\n          case 24:\n            _yield$import = _context16.sent;\n            WebUSBKeepKeyAdapter = _yield$import.WebUSBKeepKeyAdapter;\n            _context16.next = 28;\n            return Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_buffer_index_js\"), __webpack_require__.e(\"vendors-node_modules_rxjs__esm5_index_js\"), __webpack_require__.e(\"vendors-node_modules_rxjs__esm5_operators_index_js\"), __webpack_require__.e(\"vendors-node_modules_shapeshiftoss_hdwallet-core_dist_index_js\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! @shapeshiftoss/hdwallet-core */ \"./node_modules/@shapeshiftoss/hdwallet-core/dist/index.js\", 23));\n\n          case 28:\n            _yield$import2 = _context16.sent;\n            Keyring = _yield$import2.Keyring;\n            Events = _yield$import2.Events;\n            bip32ToAddressNList = _yield$import2.bip32ToAddressNList;\n            HDWalletErrorType = _yield$import2.HDWalletErrorType;\n            _context16.next = 35;\n            return Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_buffer_index_js\"), __webpack_require__.e(\"vendors-node_modules_events_events_js\"), __webpack_require__.e(\"vendors-node_modules_create-hash_browser_js-node_modules_elliptic_lib_elliptic_js-node_module-ad4815\"), __webpack_require__.e(\"vendors-node_modules_assert_build_assert_js-node_modules_assert_build_internal_assert_asserti-d1eadf\"), __webpack_require__.e(\"vendors-node_modules_eth-block-tracker_src_polling_js-node_modules_eth-json-rpc-filters_subsc-c58c54\"), __webpack_require__.e(\"vendors-node_modules_ethereumjs-abi_index_js\"), __webpack_require__.e(\"vendors-node_modules_json-stable-stringify_index_js-node_modules_lodash_keys_js-node_modules_-f278bc\"), __webpack_require__.e(\"vendors-node_modules_async_eachSeries_js-node_modules_async_map_js-node_modules_async_paralle-cac9b5\"), __webpack_require__.e(\"vendors-node_modules_bnc-onboard_dist_esm_providerEngine-413ddff7_js\"), __webpack_require__.e(\"_4ad5-_3fc0-_802b-_1e44-_3e83-_19e6\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./providerEngine-413ddff7.js */ \"./node_modules/bnc-onboard/dist/esm/providerEngine-413ddff7.js\"));\n\n          case 35:\n            _yield$import3 = _context16.sent;\n            createProvider = _yield$import3[\"default\"];\n            _context16.next = 39;\n            return Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_buffer_index_js\"), __webpack_require__.e(\"vendors-node_modules_events_events_js\"), __webpack_require__.e(\"vendors-node_modules_create-hash_browser_js-node_modules_elliptic_lib_elliptic_js-node_module-ad4815\"), __webpack_require__.e(\"vendors-node_modules_assert_build_assert_js-node_modules_assert_build_internal_assert_asserti-d1eadf\"), __webpack_require__.e(\"vendors-node_modules_crypto-browserify_index_js\"), __webpack_require__.e(\"vendors-node_modules_bnc-onboard_node_modules_ethereumjs-util_dist_browser_index_js\"), __webpack_require__.e(\"vendors-node_modules_hdkey_lib_hdkey_js\"), __webpack_require__.e(\"node_modules_bnc-onboard_dist_esm_hd-wallet-6fc43476_js\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./hd-wallet-6fc43476.js */ \"./node_modules/bnc-onboard/dist/esm/hd-wallet-6fc43476.js\"));\n\n          case 39:\n            _yield$import4 = _context16.sent;\n            isValidPath = _yield$import4.isValidPath;\n            // Initialize the adapter and pair the device\n            keyring = new Keyring();\n            keepKeyAdapter = WebUSBKeepKeyAdapter.useKeyring(keyring);\n            _context16.prev = 43;\n            _context16.next = 46;\n            return keepKeyAdapter.pairDevice();\n\n          case 46:\n            keepKeyWallet = _context16.sent;\n            _context16.next = 57;\n            break;\n\n          case 49:\n            _context16.prev = 49;\n            _context16.t0 = _context16[\"catch\"](43);\n\n            if (!(_context16.t0.name === HDWalletErrorType.ConflictingApp)) {\n              _context16.next = 55;\n              break;\n            }\n\n            return _context16.abrupt(\"return\", {\n              provider: undefined,\n              error: ERROR_BUSY\n            });\n\n          case 55:\n            if (!(_context16.t0.name === HDWalletErrorType.WebUSBCouldNotPair)) {\n              _context16.next = 57;\n              break;\n            }\n\n            return _context16.abrupt(\"return\", {\n              provider: undefined,\n              error: ERROR_PAIRING\n            });\n\n          case 57:\n            DEFAULT_DERIVATION_PATH = \"m/44'/60'/0'/0/0\"; // The currently selected derivation path\n\n            dPath = '';\n            addressToPath = new Map();\n            enabled = false;\n            customPath = false;\n            provider = createProvider({\n              getAccounts: function getAccounts(callback) {\n                _getAccounts().then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              signTransaction: function signTransaction(transactionData, callback) {\n                _signTransaction(transactionData).then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              processMessage: function processMessage(messageData, callback) {\n                _signMessage(messageData).then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              processPersonalMessage: function processPersonalMessage(messageData, callback) {\n                _signMessage(messageData).then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              signMessage: function signMessage(messageData, callback) {\n                _signMessage(messageData).then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              signPersonalMessage: function signPersonalMessage(messageData, callback) {\n                _signMessage(messageData).then(function (res) {\n                  return callback(null, res);\n                })[\"catch\"](function (err) {\n                  return callback(err, null);\n                });\n              },\n              rpcUrl: rpcUrl\n            });\n            keyring.on(['*', '*', Events.DISCONNECT], /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {\n              return regeneratorRuntime.wrap(function _callee7$(_context7) {\n                while (1) {\n                  switch (_context7.prev = _context7.next) {\n                    case 0:\n                      resetWalletState({\n                        disconnected: true,\n                        walletName: WALLET_NAME\n                      });\n\n                    case 1:\n                    case \"end\":\n                      return _context7.stop();\n                  }\n                }\n              }, _callee7);\n            }))); // If the wallet asks for a PIN, open the PIN modal\n\n            keyring.on(['*', '*', Events.PIN_REQUEST], function () {\n              renderModal(keepKeyWallet, ModalType.Pin);\n            }); // If the wallet asks for a PIN, open the PIN modal\n\n            keyring.on(['*', '*', Events.PASSPHRASE_REQUEST], function () {\n              renderModal(keepKeyWallet, ModalType.Passphrase);\n            });\n            provider.setPath = setPath;\n            provider.dPath = dPath;\n            provider.enable = enable;\n            provider.setPrimaryAccount = setPrimaryAccount;\n            provider.getPrimaryAddress = getPrimaryAddress;\n            provider.getAccounts = _getAccounts;\n            provider.getMoreAccounts = getMoreAccounts;\n            provider.getBalance = getBalance;\n            provider.getBalances = getBalances;\n            provider.send = provider.sendAsync;\n            provider.disconnect = disconnect;\n            provider.isCustomPath = isCustomPath;\n            return _context16.abrupt(\"return\", {\n              provider: provider\n            });\n\n          case 79:\n          case \"end\":\n            return _context16.stop();\n        }\n      }\n    }, _callee16, null, [[43, 49]]);\n  }));\n  return _createKeepKeyProvider.apply(this, arguments);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (keepkey);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JuYy1vbmJvYXJkL2Rpc3QvZXNtL2luZGV4LTRhNDhiNWVhLmpzP2Q3YmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUE7O0FBRUEsaUNBQWlDLDJIQUEySDs7QUFFNUosNkJBQTZCLGtLQUFrSzs7QUFFL0wsd0NBQXdDLDhGQUE4Rix3QkFBd0IsZUFBZSxlQUFlLGdCQUFnQixZQUFZLE1BQU0sd0JBQXdCLCtCQUErQixhQUFhLHFCQUFxQixtQ0FBbUMsRUFBRSxFQUFFLGNBQWMsV0FBVyxVQUFVLEVBQUUsVUFBVSxNQUFNLGlEQUFpRCxFQUFFLFVBQVUsa0JBQWtCLEVBQUUsRUFBRSxhQUFhOztBQUVuZiwrQkFBK0Isb0NBQW9DOztBQUVuRSxrQ0FBa0MscUhBQXFIOztBQUV2SiwrQkFBK0IsNkpBQTZKOztBQUU1TCxpREFBaUQsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRCxrSEFBa0g7O0FBRTlaLGlDQUFpQywySEFBMkg7O0FBRTVKLGtDQUFrQyx1REFBdUQ7O0FBRXpGLHNDQUFzQyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxrQkFBa0IsRUFBRSxhQUFhOztBQUVyTCwyQ0FBMkMsa0JBQWtCLGtDQUFrQyxxRUFBcUUsRUFBRSxFQUFFLE9BQU8sa0JBQWtCLEVBQUUsWUFBWTs7QUFFL00sNEVBQTRFLE1BQU0sMEJBQTBCLHdCQUF3QixFQUFFLGdCQUFnQixlQUFlLFFBQVEsRUFBRSxpQkFBaUIsZ0JBQWdCLEVBQUUsT0FBTyw0Q0FBNEMsRUFBRTs7QUFFdlEsZ0NBQWdDLHFCQUFxQixtQ0FBbUMsZ0RBQWdELGdDQUFnQyx3QkFBd0Isd0VBQXdFLEVBQUUsdUJBQXVCLHVFQUF1RSxFQUFFLGtCQUFrQixFQUFFLEVBQUUsR0FBRzs7QUFFOVY7QUFDZ0U7QUFDL0U7QUFDTDtBQUNEO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENB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QkFBaUI7QUFDakI7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixhQUFhLElBQUk7O0FBRWpCO0FBQ0E7QUFDQSxhQUFhLEVBQUU7O0FBRWY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOztBQUVBLCtEQUFlLE9BQU8iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm5jLW9uYm9hcmQvZGlzdC9lc20vaW5kZXgtNGE0OGI1ZWEuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX2Vycm9yTWVzc2FnZXM7XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2kgPSBhcnIgJiYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXSk7IGlmIChfaSA9PSBudWxsKSByZXR1cm47IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX3MsIF9lOyB0cnkgeyBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHsgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuaW1wb3J0ICdyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUnO1xuaW1wb3J0IHsgTSBhcyBNb2RhbCwgYiBhcyBub29wLCBjIGFzIGluc2VydCwgZCBhcyBkZXRhY2gsIEIgYXMgQnV0dG9uIH0gZnJvbSAnLi9vbmJvYXJkLTU4NGMwNDRkLmpzJztcbmltcG9ydCAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAnYm5jLXNkayc7XG5pbXBvcnQgJ2Jvd3Nlcic7XG52YXIgSEFORExFX1BJTl9QUkVTUyA9ICdoYW5kbGVQaW5QcmVzcyc7XG52YXIgQlVUVE9OX0NPTE9SID0gXCIjRUJFQkVEXCI7XG52YXIgQlVUVE9OX0RPVF9DT0xPUiA9IFwiIzMzMzk0QlwiO1xudmFyIE1vZGFsVHlwZTtcblxuKGZ1bmN0aW9uIChNb2RhbFR5cGUpIHtcbiAgTW9kYWxUeXBlW01vZGFsVHlwZVtcIlBpblwiXSA9IDBdID0gXCJQaW5cIjtcbiAgTW9kYWxUeXBlW01vZGFsVHlwZVtcIlBhc3NwaHJhc2VcIl0gPSAxXSA9IFwiUGFzc3BocmFzZVwiO1xufSkoTW9kYWxUeXBlIHx8IChNb2RhbFR5cGUgPSB7fSkpO1xuXG52YXIgcGluQnV0dG9uID0gZnVuY3Rpb24gcGluQnV0dG9uKHZhbHVlLCBzbG90KSB7XG4gIHZhciB3aWR0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJzY0cHgnO1xuICB2YXIgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAnNjRweCc7XG4gIHJldHVybiBcIlxcbiAgPGJ1dHRvblxcbiAgICBjbGFzcz1cXFwicGluLWJ1dHRvblxcXCJcXG4gICAgc3R5bGU9XFxcIndpZHRoOiBcIi5jb25jYXQod2lkdGgsIFwiOyBoZWlnaHQ6IFwiKS5jb25jYXQoaGVpZ2h0LCBcIjtcXFwiXFxuICAgIHR5cGU9XFxcImJ1dHRvblxcXCJcXG4gICAgb25jbGljaz1cXFwid2luZG93LlwiKS5jb25jYXQoSEFORExFX1BJTl9QUkVTUywgXCIoXCIpLmNvbmNhdCh2YWx1ZSwgXCIpXFxcIj5cXG4gICAgICBcIikuY29uY2F0KHNsb3QgfHwgXCI8c3ZnIGNsYXNzPVxcXCJwaW4tYnV0dG9uLWRvdFxcXCIgdmlld0JveD1cXFwiMCAwIDE4IDE4XFxcIiB3aWR0aD1cXFwiMThcXFwiIGhlaWdodD1cXFwiMThcXFwiPlxcbiAgICAgICAgICA8Y2lyY2xlIGN4PVxcXCI5XFxcIiBjeT1cXFwiOVxcXCIgcj1cXFwiOVxcXCIgPjwvY2lyY2xlPlxcbiAgICAgICAgPC9zdmc+XCIsIFwiXFxuICAgICAgPGRpdiBjbGFzcz1cXFwicGluLWJ1dHRvbi1iZ1xcXCI+XFxuICA8L2J1dHRvbj5cXG5cIik7XG59O1xuXG52YXIgcGluQnV0dG9ucyA9IFwiXFxuICA8ZGl2IGNsYXNzPVxcXCJwaW4tcGFkLWJ1dHRvbnNcXFwiPlxcbiAgICBcIi5jb25jYXQoWzcsIDgsIDksIDQsIDUsIDYsIDEsIDIsIDNdLm1hcChmdW5jdGlvbiAodmFsKSB7XG4gIHJldHVybiBwaW5CdXR0b24odmFsKTtcbn0pLmpvaW4oJycpLCBcIlxcbiAgPC9kaXY+XFxuXCIpO1xudmFyIGRlbEJ1dHRvbkljb24gPSBcIjxzdmcgY2xhc3M9XFxcImRlbC1idXR0b24taWNvblxcXCIgdmlld0JveD1cXFwiMCAwIDI0IDI0XFxcIiBmb2N1c2FibGU9XFxcImZhbHNlXFxcIiBjbGFzcz1cXFwiY2hha3JhLWljb24gY3NzLW9ua2liaVxcXCIgYXJpYS1oaWRkZW49XFxcInRydWVcXFwiPjxwYXRoIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCIgZD1cXFwiTTIwIDExSDcuODNsNS41OS01LjU5TDEyIDRsLTggOCA4IDggMS40MS0xLjQxTDcuODMgMTNIMjB2LTJ6XFxcIj48L3BhdGg+PC9zdmc+XCI7XG5cbnZhciBwaW5QaHJhc2VJbnB1dCA9IGZ1bmN0aW9uIHBpblBocmFzZUlucHV0KG1vZGFsVHlwZSkge1xuICByZXR1cm4gXCJcXG48Zm9ybSBpZD1cXFwicGluLXBocmFzZS1mb3JtXFxcIiBjbGFzcz1cXFwicGluLXBocmFzZS1pbnB1dC1jb250YWluZXJcXFwiPlxcbiAgPGlucHV0XFxuICAgIGlkPVxcXCJwaW4tcGhyYXNlLWlucHV0XFxcIlxcbiAgICBwbGFjZWhvbGRlcj1cXFwiXCIuY29uY2F0KG1vZGFsVHlwZSA9PT0gTW9kYWxUeXBlLlBpbiA/ICdQSU4nIDogJycsIFwiXFxcIlxcbiAgICB0eXBlPVxcXCJwYXNzd29yZFxcXCJcXG4gICAgYXV0b2NvbXBsZXRlPVxcXCJjdXJyZW50LXBhc3N3b3JkXFxcIlxcbiAgLz5cXG4gIFwiKS5jb25jYXQobW9kYWxUeXBlID09PSBNb2RhbFR5cGUuUGluID8gXCIgPGRpdiBjbGFzcz1cXFwiZGVsLWJ1dHRvbi13cmFwcGVyXFxcIj5cXG4gICAgICAgICAgICBcIi5jb25jYXQocGluQnV0dG9uKC0xLCBkZWxCdXR0b25JY29uLCAnMzhweCcsICczOHB4JyksIFwiXFxuICAgICAgICAgIDwvZGl2PlwiKSA6ICcnLCBcIlxcbjwvZm9ybT5cXG5cIik7XG59OyAvLyBDb250YWlucyBzdHlsZXMgdXNlZCBieSBib3RoIHRoZSBwaW4gZW50cnkgbW9kYWwgYW5kIHRoZSBwYXNzcGhyYXNlIGVudHJ5IG1vZGFsXG5cblxudmFyIGJhc2VTdHlsZXMgPSBcIlxcbiAgLmtlZXBrZXktbW9kYWwge1xcbiAgICBtYXgtd2lkdGg6IDIycmVtO1xcbiAgICBwYWRkaW5nOiAyMHB4IDEwcHg7XFxuICB9XFxuICAucGluLXBocmFzZS1pbnB1dC1jb250YWluZXIge1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIG1hcmdpbjogMjBweCAwO1xcbiAgICB3aWR0aDogMTAwJTtcXG4gIH1cXG4gICNwaW4tcGhyYXNlLWlucHV0IHtcXG4gICAgYmFja2dyb3VuZDogaW5oZXJpdDtcXG4gICAgZm9udC1zaXplOiAwLjg4OWVtO1xcbiAgICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gICAgYm9yZGVyLXdpZHRoOiAxcHg7XFxuICAgIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICAgIGJvcmRlci1jb2xvcjogIzI0MjgzNTtcXG4gICAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgICBwYWRkaW5nLWxlZnQ6IDAuNXJlbTtcXG4gICAgcGFkZGluZy1yaWdodDogNC4xcmVtO1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDE1MG1zIGVhc2UtaW4tb3V0O1xcbiAgICBoZWlnaHQ6IDQycHg7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBvcGFjaXR5OiAwLjY7XFxuICAgIG91dGxpbmU6IG5vbmU7XFxuICB9XFxuICAjcGluLXBocmFzZS1pbnB1dDpob3ZlciwgI3Bpbi1waHJhc2UtaW5wdXQ6Zm9jdXMge1xcbiAgICBvcGFjaXR5OiAxO1xcbiAgfVxcbiAgLnVubG9jay1idXR0b24ge1xcbiAgICBoZWlnaHQ6IDI2cHg7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIH1cXG4gIFxcbiAgLyogT3ZlcnJpZGVzIHRoZSBicmFuZGluZyBvbiB0aGUgbW9kYWwqL1xcbiAgLmtlZXBrZXktbW9kYWwgKyAuYm4tYnJhbmRpbmcgeyB2aXNpYmlsaXR5OiBoaWRkZW4gIWltcG9ydGFudDsgfVxcbiAgLmtlZXBrZXktbW9kYWwgLmJuLW9uYm9hcmQtcHJlcGFyZS1idXR0b24ge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gIH1cXG5cIjtcbnZhciBwaW5Nb2RhbFN0eWxlcyA9IFwiXFxuICAjZW50cnkge1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWZsb3c6IGNvbHVtbjtcXG4gICAgcGFkZGluZzogMjBweDtcXG4gIH1cXG4gIC5waW4tcGFkLWJ1dHRvbnMge1xcbiAgICBkaXNwbGF5OiBncmlkO1xcbiAgICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IHJlcGVhdCgzLCA3NXB4KTtcXG4gICAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiByZXBlYXQoMywgNzVweCk7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktaXRlbXM6IGNlbnRlcjtcXG4gICAgbWFyZ2luLWJvdHRvbTogMTVweDtcXG4gIH1cXG4gIC5waW4tYnV0dG9uIHtcXG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gICAgYm9yZGVyLXJhZGl1czogNnB4O1xcbiAgICBib3JkZXI6IDFweCBzb2xpZCBcIi5jb25jYXQoQlVUVE9OX0NPTE9SLCBcIjtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gICAgZm9udC1zaXplOiAxOHB4O1xcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB1bnNldDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIH1cXG4gIC5waW4tYnV0dG9uLWJnIHtcXG4gICAgd2lkdGg6IDEwMCU7XFxuICAgIGhlaWdodDogMTAwJTtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogXCIpLmNvbmNhdChCVVRUT05fQ09MT1IsIFwiO1xcbiAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDEwMG1zIGVhc2UtaW47XFxuICB9XFxuICAucGluLWJ1dHRvbi1iZzpob3ZlciB7XFxuICAgIG9wYWNpdHk6IC4yO1xcbiAgfVxcbiAgLnBpbi1idXR0b24tZG90IHtcXG4gICAgZmlsbDogXCIpLmNvbmNhdChCVVRUT05fRE9UX0NPTE9SLCBcIjtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4gICAgei1pbmRleDogMjtcXG4gIH1cXG4gIC5kZWwtYnV0dG9uLXdyYXBwZXIge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIGhlaWdodDogNDJweDtcXG4gICAgd2lkdGg6IDQycHg7XFxuICAgIHJpZ2h0OiAycHg7XFxuICAgIGRpc3BsYXk6IGZsZXg7XFxuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgfVxcbiAgLmRlbC1idXR0b24td3JhcHBlciA+IC5waW4tYnV0dG9uIHtcXG4gICAgYm9yZGVyOiBub25lO1xcbiAgfVxcbiAgLmRlbC1idXR0b24taWNvbiB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgd2lkdGg6IDIwcHg7XFxuICAgIHotaW5kZXg6IDI7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgfVxcbiAgLmRlbC1idXR0b24taWNvbiArIGRpdiB7XFxuICAgIG9wYWNpdHk6IC41O1xcbiAgfVxcbiAgLmRlbC1idXR0b24taWNvbiArIGRpdjpob3ZlciB7XFxuICAgIG9wYWNpdHk6IDE7XFxuICB9XFxuXCIpO1xudmFyIHBhc3NwaHJhc2VNb2RhbFN0eWxlcyA9IFwiXFxuICAua2VlcGtleS1tb2RhbCB7XFxuICAgIHBhZGRpbmc6IDQwcHggMzBweDtcXG4gIH1cXG5cIjtcbnZhciBwaW5IVE1MID0gXCJcXG4gICAgPHN0eWxlPlwiLmNvbmNhdChiYXNlU3R5bGVzKS5jb25jYXQocGluTW9kYWxTdHlsZXMsIFwiPC9zdHlsZT5cXG4gICAgPGgyPkVudGVyIFlvdXIgUGluPC9oMj5cXG4gICAgPHA+XFxuICAgICAgVXNlIFBJTiBsYXlvdXQgc2hvd24gb24geW91ciBkZXZpY2UgdG8gZmluZCB0aGUgbG9jYXRpb24gdG8gcHJlc3Mgb24gdGhpcyBwaW4gcGFkLlxcbiAgICA8L3A+XFxuICAgIDxkaXYgaWQ9XFxcImVudHJ5XFxcIiBjbGFzcz1cXFwiYm4tb25ib2FyZC1jdXN0b21cXFwiPlxcbiAgICAgIFwiKS5jb25jYXQocGluQnV0dG9ucywgXCJcXG4gICAgICBcIikuY29uY2F0KHBpblBocmFzZUlucHV0KE1vZGFsVHlwZS5QaW4pLCBcIlxcbiAgICA8L2Rpdj5cXG4gIFwiKTtcbnZhciBwYXNzcGhyYXNlSFRNTCA9IFwiXFxuICA8c3R5bGU+XCIuY29uY2F0KGJhc2VTdHlsZXMpLmNvbmNhdChwYXNzcGhyYXNlTW9kYWxTdHlsZXMsIFwiPC9zdHlsZT5cXG4gIDxoMiBzdHlsZT1cXFwibWFyZ2luLWJvdHRvbTogMzVweFxcXCI+RW50ZXIgWW91ciBQYXNzcGhyYXNlPC9oMj5cXG4gIDxkaXYgaWQ9XFxcImVudHJ5XFxcIiBjbGFzcz1cXFwiYm4tb25ib2FyZC1jdXN0b21cXFwiPlxcbiAgICBcIikuY29uY2F0KHBpblBocmFzZUlucHV0KE1vZGFsVHlwZS5QYXNzcGhyYXNlKSwgXCJcXG4gIDwvZGl2PlxcblwiKTtcblxudmFyIHJlbmRlck1vZGFsID0gZnVuY3Rpb24gcmVuZGVyTW9kYWwod2FsbGV0LCBtb2RhbFR5cGUpIHtcbiAgdmFyIF9kb2N1bWVudCRnZXRFbGVtZW50QjtcblxuICB2YXIgbW9kYWxIdG1sID0gbW9kYWxUeXBlID09PSBNb2RhbFR5cGUuUGluID8gcGluSFRNTCA6IHBhc3NwaHJhc2VIVE1MO1xuXG4gIHZhciBnZXRJbnB1dCA9IGZ1bmN0aW9uIGdldElucHV0KCkge1xuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncGluLXBocmFzZS1pbnB1dCcpO1xuICB9O1xuXG4gIHZhciBkZWxldGVXaW5kb3dQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVsZXRlV2luZG93UHJvcGVydGllcygpIHtcbiAgICBkZWxldGUgd2luZG93W0hBTkRMRV9QSU5fUFJFU1NdO1xuICB9O1xuXG4gIGlmIChtb2RhbFR5cGUgPT09IE1vZGFsVHlwZS5QaW4pIHtcbiAgICB3aW5kb3dbSEFORExFX1BJTl9QUkVTU10gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHZhciBpbnB1dCA9IGdldElucHV0KCk7IC8vIEEgdmFsdWUgb2YgLTEgc2lnbmFscyBhIGJhY2tzcGFjZSBlLmcuIHdlIGRlbGV0ZSB0aGUgbGFzdCBjaGFyIGZyb20gdGhlIGlucHV0XG5cbiAgICAgIGlucHV0LnZhbHVlID0gdmFsdWUgPT09IC0xID8gaW5wdXQudmFsdWUuc2xpY2UoMCwgLTEpIDogaW5wdXQudmFsdWUgKyB2YWx1ZTtcbiAgICB9O1xuICB9IC8vIENyZWF0ZXMgYSBtb2RhbCBjb21wb25lbnQgd2hpY2ggZ2V0cyBtb3VudGVkIHRvIHRoZSBib2R5IGFuZCBpcyBwYXNzZWQgdGhlIHBpbiBodG1sIGludG8gaXQncyBzbG90XG5cblxuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIGRpdi5pbm5lckhUTUwgPSBtb2RhbEh0bWw7XG4gIGRpdi5jbGFzc05hbWUgPSAna2VlcGtleS1tb2RhbCc7XG4gIHZhciBwaW5Nb2RhbCA9IG5ldyBNb2RhbCh7XG4gICAgdGFyZ2V0OiBkb2N1bWVudC5ib2R5LFxuICAgIHByb3BzOiB7XG4gICAgICBjbG9zZU1vZGFsOiBmdW5jdGlvbiBjbG9zZU1vZGFsKCkge1xuICAgICAgICAvLyBDYW5jZWxzIGFueSBhY3Rpb24gdGhhdCB0aGUga2VlcGtleSB3YWxsZXQgbWF5IGJlIGRvaW5nXG4gICAgICAgIHdhbGxldC5jYW5jZWwoKTtcbiAgICAgICAgZGVsZXRlV2luZG93UHJvcGVydGllcygpO1xuICAgICAgICBwaW5Nb2RhbC4kZGVzdHJveSgpO1xuICAgICAgfSxcbiAgICAgICQkc2xvdHM6IGNyZWF0ZVNsb3QoZGl2KSxcbiAgICAgICQkc2NvcGU6IHt9XG4gICAgfVxuICB9KTsgLy8gU3VibWl0cyB0aGUgcGluIG9yIHBhc3NwaHJhc2UgdG8gdGhlIEtlZXBrZXkgZGV2aWNlXG5cbiAgdmFyIHN1Ym1pdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICB2YXIgdmFsdWU7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHZhbHVlID0gZ2V0SW5wdXQoKS52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoIShtb2RhbFR5cGUgPT09IE1vZGFsVHlwZS5QaW4pKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5zZW5kUGluKHZhbHVlKTtcblxuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgIHJldHVybiB3YWxsZXQuc2VuZFBhc3NwaHJhc2UodmFsdWUpO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHBpbk1vZGFsLiRkZXN0cm95KCk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiBzdWJtaXQoKSB7XG4gICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0oKTtcblxuICAoX2RvY3VtZW50JGdldEVsZW1lbnRCID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bpbi1waHJhc2UtZm9ybScpKSA9PT0gbnVsbCB8fCBfZG9jdW1lbnQkZ2V0RWxlbWVudEIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kb2N1bWVudCRnZXRFbGVtZW50Qi5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBzdWJtaXQoKTtcbiAgfSk7IC8vIENyZWF0ZXMgYSBuZXcgQnV0dG9uIGNvbXBvbmVudCB1c2VkIHRvIHRyaWdnZXIgc2VuZGluZyB0aGUgcGluIHRvIEtlZXBrZXlcblxuICB2YXIgZW50cnlFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdlbnRyeScpO1xuXG4gIGlmIChlbnRyeUVsKSB7XG4gICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgc3Bhbi5pbm5lckhUTUwgPSBcIlVubG9ja1wiO1xuICAgIHNwYW4uY2xhc3NOYW1lID0gXCJ1bmxvY2stYnV0dG9uXCI7XG4gICAgbmV3IEJ1dHRvbih7XG4gICAgICB0YXJnZXQ6IGVudHJ5RWwsXG4gICAgICBwcm9wczoge1xuICAgICAgICBvbmNsaWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9vbmNsaWNrID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMigpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGVXaW5kb3dQcm9wZXJ0aWVzKCk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgZnVuY3Rpb24gb25jbGljaygpIHtcbiAgICAgICAgICAgIHJldHVybiBfb25jbGljay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBvbmNsaWNrO1xuICAgICAgICB9KCksXG4gICAgICAgICQkc2xvdHM6IGNyZWF0ZVNsb3Qoc3BhbiksXG4gICAgICAgICQkc2NvcGU6IHt9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG4vKipcclxuICogY3JlYXRlU2xvdCAtIGNyZWF0ZXMgdGhlIG5lY2Vzc2FyeSBvYmplY3QgbmVlZGVkIHRvIHBhc3NcclxuICogYXJiaXRyYXJ5IGh0bWwgaW50byBhIGNvbXBvbmVudCdzIGRlZmF1bHQgc2xvdFxyXG4gKiBAcGFyYW0gZWxlbWVudCBUaGUgaHRtbCBlbGVtZW50IHdoaWNoIGlzIGluc2VydGVkIGludG8gdGhlIGNvbXBvbmVudHMgc2xvdFxyXG4gKi9cblxuXG5mdW5jdGlvbiBjcmVhdGVTbG90KGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBcImRlZmF1bHRcIjogW2Z1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGM6IG5vb3AsXG4gICAgICAgIG06IGZ1bmN0aW9uIG1vdW50KHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICAgICAgaW5zZXJ0KHRhcmdldCwgZWxlbWVudCwgYW5jaG9yKTtcbiAgICAgICAgfSxcbiAgICAgICAgZDogZnVuY3Rpb24gZGVzdHJveShkZXRhY2hpbmcpIHtcbiAgICAgICAgICBpZiAoZGV0YWNoaW5nKSB7XG4gICAgICAgICAgICBkZXRhY2goZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsOiBub29wXG4gICAgICB9O1xuICAgIH1dXG4gIH07XG59XG5cbnZhciBpbWcgPSBcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBWkVBQUFGR0NBWUFBQUNyR3FMQUFBQUFDWEJJV1hNQUFBc1RBQUFMRXdFQW1wd1lBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUVCdVNVUkJWSGdCN1owSm1GMVZtYTcvbXBNaVhDU3BEUFNWZ2tkQ3FDUlZDSWt5U05RMExWT0RnbUpRYVFjVUcwVVVRYUhCQUZxSUlMU0NWN2xDVDdSeVc2RVZCN2hCaENBU0pOQXloYWxTcVlTQ0d5bzhTU0FERFlRa05lWiszem5yeEpPaUtuVnExMTU3T3QvN1BDdDduNU5UNSt5MTExNy90OWIvcjZIQ0JqRnIxcXlKT0V4RG1vQTAwYVZhRzU3TmZYMTltNnVycXpkdjJMQ2hDMm1MQ1NHRUtBc3ErQStFb3hGQzBBZ2hhS3lvcURnQWJ6VWhOZUM4RWNmR0hUdDIxTy9tTzdvS0NaOWJodU56U08yZzA0UVFRbVNhaXRtelo1OEtzWGdmQkdBT2puTkdFSXhTb0tBc1Jyb2IzL1VZeEtUTGhCQkNaSktxS1ZPbS9Bbkh2MFppcjZQR3hzNWVTSE9RanE2c3JOenpiVzk3MjVaTm16YXR4K3QrRTBJSWtTa29JdjlvZm1DUDV2Q3FxcW9aK0kwdGlKV3NNZ21KRUVKa2lrcnp6enlrYTVxYW1vNDFJWVFRbVNJS0VTRU0ybCtPQVA0aEpvUVFJak5FSlNMR3dEMWlKTitZUEhueUJCTkNDSkVKSWhNUngwa1FrYjh4SVlRUW1TQlNFZUh3NFlxS2luTk5DQ0ZFSm9pNkoySVFrU000dWRHRUVFS2tuc2hGaEwwUnhFWStZRUlJSVZKUDVDTGllTGNKSVlSSVBYR0p5TUVtaEJBaTljUWlJbkJwdmQyRUVFS2tucmg2SWdxc0N5RkVCb2hMUklRUVFtUUFpWWdRUW9qQVNFU0VFRUlFUmlJaWhCQWlNTlU3ZHV6NFZVVkZCUmRGNUQ3cTNGdWRRVzh0a2lpRUVHSkVxdnY2K3M2dXE2dHJ3SkV6eVE5eTIrUTI0LzhPUTVwb1FnZ2h4REJVRFBWbVMwdEwwOERBd0Nkd2VqclNkUFBBOHVYTEswd0lJVVNxMmEwaGIyNXVQaE05RTI2ZkczcVBSQ0lpaEJEcFo3ZUI5YmEydHBzZ0luZWJFRUlJTVFTbGpNNzZEeE5DQ0NHR1lFUVJRY0Q5Y1JOQ0NDR0dZRVFSV2JWcTFVWVRRZ2doaGtDVERZVVFRZ1JHSWlLRUVDSXdFaEVoaEJDQmtZZ0lJWVFJakVSRUNDRkVZQ1FpUWdnaEFpTVJFVUlJRVJpSmlCQkNpTUJJUklRUVFnUkdJaUtFRUNJd0VoRWhoQkNCa1lnSUlZUUlqRVJFQ0NGRVlDUWlRZ2doQWlNUkVVSUlFUmlKaUJCQ2lNQklSSVFRUWdSR0lpS0VFQ0l3RWhFaGhCQ0JrWWdJSVlRSVRMVUpJVVNHbVRWcjFyVEI3MjNZc0dFTGs2V0ExdFpXdStHR0d5WTBORFJNR1B4L0ZSVVZ0bno1OHZVV0l4V2xmR2oyN05rN0xHU1E4WkorV3lTVHlaTW5UMkRDNlVTazJyNit2Z25WMWRVVGh2Z28vNStWdGFmNFRYeCtDejVmZUg5emUzdjc1c0dmRWFQSEdjeGF5OTkzR3BtOWQrellVVGZvWTRYL0g4cjRGTjdMbFFmS0pWWUROVnBjL2dzcDkyemlIalFOL2h6dXlRWWNObGsrdjh4cnAzc0dZMkhCZ2dXRzMrZjFNazNBOVUyalFCUWRKK0U0ZWFpL3hmOTF1TStzWjcycXFhbGhQdGJEeGthU0g0bElpZURoWk9FMldvamdvWG5LVW9BVGpFS2xaT0o1NGFIZUY4ZDZQTUFOT0RZTThlZU4rTCtOK0wrdHhXKzY5emJpeVBmWDRQekZnWUdCMTNCY2gvZGV4WHRkY1ZicU5PQ2VTUnFacVRoT3hIM2Jrd1lUYWJ6OTVWbmxzYjc0Ny9BNXZtN0U1enFHK05yQ2UxMzQzRFlhS0p4dmhuSGFETkZmajliNytnUzI0R3RuekpoeEdLNlBlVG9ZNlNDOFIrRm9kSGtkRnQ0RGZLWUxwMHVSMm5IK05KNjdUdk5Na1dpd0xrM0Y3KzZEYXpuQTh1WFM0SzZmWmRWVTZuZTZ2R3pFS2ZQRGNuc2VhUjNTR3RoYnZ1ZWxrU1lSS1kxYVZOaXZWVlpXSG00aDB0Ylc5bUZMS001QVRiZjhRMzZnYTgzeEFXOGN6WU05R3B6UThPR25BVnVHOUR5TVZ4ZU1Bd1dseXdTZlE1YkJ2a1ZHaDZMUmhOY1Vpd2J6UTVkTEhVNVVua1BxaEpoMEpVRlFXbHBhM29FR3lNMjREM05HRW8wUm9BRytIZWx1Zk05RFlmZkNpb1NEOVdwZnBGbm15by9ITVY3N1d5alVKOVlsbkM5elpmZThFNVR3ZnFlVUQ1VzVpTlFpL3g5Qklkd1VkaUVuN1I2NEhzZDBaNXo0Z004ejE2S3pHR0FsS0ZRQUdJbEg4Rlk3akZablduelpZVUhoZ0pnMjF0Yld0dUIrektHeE5BOUdaeFRrV3U0c0d4eVhXOTRWNUwzMVBoek56YzN6Y1MzM1czaFFURmpmL3pNTWI4SGN1WE50MjdadEZJNVpLTHQzV3I1ZXNReDlpZjZRc0I1WnZ0eitoT1BUc0QraGxKbEVaQVNROTQvamNJMTVNS1JKdVFmMEkrTUJtMGtEaGQ3V1BCejVrRWY2Z0krRWExVXRocGdzaFVGOTVOVlhYMzBxNDJKUzZIVzhFK2w5TEJ2TEc1OUU0VndvZEFYZEhaVXJhREFlUkNRSDhuWjdUMC9QdGF0V3JWcHFBY0RmMTg2Y09aUEN3UWJaWHlNZGF6RTF5QWF4czhkbElZaUpSR1Ezd004NkQwR3FuNXVuZ28vN0hyZ2c1Q0Y0eU9jakhlTU1WUnBnYTRxVjRENFlyWGJMV0VBZTVUSUxZbjRrOG5nRVhwNWlDUlAwWVNoMkJUMFdwZnZSbDRnNCtLeDlIZmw1dE5RL1FQRlJRQ2dlUitMbFNVakh4dGhyM0IyNU1zTzFMY0sxTGcwYWlKZUlESU1Ua08rYXg5WmZqUGNnRjRoRS9rN0N3M095cnhpSGI5aFN4TFgvRm1sSkZtSW1ya2Q0RkU3cFBqMGxvWVpuSkRoZzRoYUtQSjd2aHl3Q2dmY3NJbVF4MHQrUEZFdHdNWTlwdUpiRGNBOCtscUl5Wkw3K2pXSVN4SDBuRVJrQ1ZHYkdCWDVpbnQwSGNkeURvbGJ1R1paQTkwZ0Fja1lMYnE2ZnV3cVF4bDRKNDI0VWorT1F6clIwOUR4MmkvTy8zNEJ5dWRlM3dFY2dJc3pQbFcxdGJaY085LzhubkhDQ2RYVjFIWWJUanlCOXdwTGh0aG9WcmxIMno3QkxmN1JSMUtPcVVqNDBaY3FVVmdzWitMTXZ0d1RpQk9RaXk3c1J2Qkx4UGFDaGVoL3lkaDdTK1hoOWdHVUR0dlFPUjU3MnczUGFqZlBWVzdkdVRZMlFzUGN4ZGVyVWorTDZMOEhMQlRab09HNks0ZWl4RHlDTmEyaG95QTBOTmsrZzNQZkg0UXp6eTB6OHptK1JqMTFjUHB3SUNKR2NnRGpkOFhoSnUvRVpwTDBzblhDazJOekpreWUvZ3J5dVJWNjNsZkpIV3Zha0NBNXJkUUx5ZWNzUXpCY0hDQ0J2MzhmTDAxUHFKaGtKQmkydlFRWDRyQnVlbkhod25ZeEhuWWZUSDZVb0hsVXlmTTZRemtYUDkxdDBEMXU2bVl4OGZLbjREYnF2ZnZuTFgwNkVTSDRXTDYrMy9ET1lhbEJlTTNHNEdzZXpZRE5LcWtjU0VZY3pQR2RaOWdTRTNXcm02OW9zR3FwQk5LS2lYNDNqV1VrWEVocFZHbGVjWHBSUlVkOEo4bmNLNDR0cEZ4SzQ1ajdwVm1uSURkdEZENFJlaTdQY001YzY5OVZ1MkE5NXVyUlVJWkdJNU9IU0NKL0JqYnZNTWdSZGM4alQxMTIrVXU5bkx3VWFaSmZmcEFvSmgrNGVUNk5LNDJybHc3d01DQWs2SFExejJBUFp2bjM3UG5oOUVlekdaVmxzQkNCUGV6Z2hPZDN5eStRTWkwVEVUU2JFY1dHV0hvWkNiSWZ1aEt5M2RBZFRMQ1NGbG1OQ3lEMXJ1TFlmV0RZR05ZeVdMQWpKZTkyczh5OGlmVDdMZFl0Q0FodHlRWE56ODRtNysxelppNGk3UVp4TW1KbVdldEhnZ0V5NTVrWkRRVWdnSWd4VzExb0M0Q2dpSEs1SjY1RHFrTWdKQ1VjSld2cW93RE0xQStYM2R6U3VWaDdzaDNRbEdqL0RsbGRaaTRockVWMWxHZkpudXNFQkhIMVZ0Z0pTZ0VLQ2U5SHFqSGVzOEZuRDliQjNsQ1hmZVZEbWNUUmFXZ1pBRklQcjVoeVFDOHFwZCsrQzdRdUg2OVdYcllqZ0FUN00rYVd6MUNwa2kvc3NQT1JubUNqQUJTTXZjd01NWW9FOVE5OFRWMVBJNll4RFdrSjZpYVhpN0VVNU5nUk9oNGdNR2NNclN4Rng3cDRyTEdPVm1xNDV1bkRLTFFaU0Fod0pkYTdGWUxDS2hvMUxRTjdLd3BhV2xpTk5wQUc2OGhiQ3JmV1dEYjdLVGtTSzRnV3BIOU5kRE9jYzRIQ1ZCR1JZem83QnJWWHJXdHRsNzFvY2hvYUJnWUdGUSswOEtKSUhlMkZjem1YdysyVWxJbG1ORnpCZm5ITlE1Z0hiM2VJbXZsMFdwY0Z5cmV5RkpuYkhzWGgyUDJZaURYQ1pwaThNN28yVXpSN3JoY21FakJmQW1KaEh1T1RHVW90MkRhZVBKbWpPQVplMzZIRzdFdzZKMjRtUFJOMENuZWNNMWcvTk0zemUyTXEyWkl6NjIxSklLSmMzaC9vQXlxVEczTmFzTGtYSkYzRy9mamVHWmVTWnI2ZDU0cDZ0dFBWc2Nsc1JJdzh2Rjk1QVB0N2dUcFZGcnd2bGs5dnkxMkxDTlZTNU12Ry9GZDRyRnhIaFRUODlpbmdCQ3Z2Ty92NytLNnVycTdkYUJMZ0poZWQ3RnNiaG9GQnljYjMxM044Wnh5M2NYNEo3ZjhDQXJobnVqOXoycFlYdWNXR0xVRzdhRThWb0hScXNYMFN3ZC9oSExUNlhhVzZQN1VMQ2ZWN0xyWWlaVUM2Ymh2cUR3cGE2YnB2anY3SjhtVFM2NU5WbzhUbW9xcW82QjZmbld3QjZlbnBXNCs5YmVlNmVyWVB4bmJPNVI0NGxNM0MvR2RlM3htMEZ2UjVIMWlGdXdMYXk4QUczZFhSRDBldkNsc2RNYjdkbzYwd3g3STE4R3VuL21Hc29sOE1xdm9YSmhGNDJsaHJFVWhqMHYzLzIyV2M3TEJwcTRUSzVCb2JoUElzV0dpZnU0OUhoZGgxYzJkZlgxN0ZxMWFxTk5rbzRhZ3AvVHlOeUZDb045MkJnYkdlNmVZVHJWYlcxdFhucmpUaGhYeFN4ZTVFVnV0TWxybWJjd1hLcHI2L3ZlT0tKSjBiVm9KazdkMjc5MXExYldTYUh1cVZ5RGtaaXVmanNvZEJvemcxanhWOTMvUVUzR2V0K0VvU0VQVUh1NGQ2RjU2OGRaZk1rR3BvZG83VVY4K2ZQNThLdGpXaW9GdGNaenVGZ25Za3FuenRZVDFHSG51R0x6SXRJVTFQVFNialpQemJQQXVLNjAxOUdKUWkwQzFvUUVDaCtEMzczRG92T1pjSzl6eC9GQS9RNGwvaGVzV0xGTWd1UkdUTm1OTlRXMXA2TTd6NGV2OEhSVEY3Y0V1d3R2Znp5eSsvMnRUTWloUDBIRVFvNzNTQXJrS2ZIY1A1SHR6ZDRxRXV2UXhSWkZpZmpON2hKRnBjNzkyS3M4UDBMWVppK2F5SEJCZ3BYQjhBOStZakZCNSt4cDNBTmYyYWRRVm9XcExFMUZGeCs1Wmxubm1tQUdCMkRsMGRiZERzblVnOFd3b1p6emJCc2l3Z25lTUVvL1RDQ2hRYzc4WEJjQ0tONnUwVkhMVVRrUDVDMzA4dy9yQWhMVWNudmd1dmcxckFxd1hCUVRHcHFhcml2Qml2L1llWUJsTmVKS0srN0xHVGM2TC8vc21pRW5iMk9KY2pMNzlEaldEemFIc2Rvb1ppNDBXYjBpWWN1OEQ3RUhZTGVoUHR6ajBVL3Q0TTl3MGNwSHNqWEhiQjMzaHFYWEk1KzBhSkY5ZDNkM1dlNjJDaEYzM2V2NUQ3azZRTTh5YXlJdUdXMnVUeXo3L0g1OUdsZWloYlVUUlloRUJDNkdQNHJnaUc5blJRUHBCc2pkTlBsUUMveVdQUWlDM01zd3E0VWQrSVovS0NGVEVTOWtOemdEVzdHVlZkWGQ2dHY4U2lHcnFMdDI3ZC94ZklqSEVOM08vb1FkOVNWNzZHZVJMbE1DWHVDM0EzeFpwL2lNWmpwMDZjYkdsOXowUHU2MER5NzhmRHN2WWw3MnNndGRUTTV4TmY1cExuTXRtOEIyWXpmdVNGcUFTRW94TTlHSUNBMFZGZkRVSDBqYWdFaEhSMGRpOW5Ed3pVc3RwREJkeDRkOWl4MkRoL21jdUhtRndiTi81UDNoYzlkbEFKQytIc3dITmZ3dWJCOFR5aFVVSi9PdEpEQmQvN2FJb0p1YmU3Yk0yN2N1SzlHS1NDa3M3UFRwazZkdWd6WGNERmUvc1k4amhCMXRvZHhzdXpORTZGaGNLdlgraDd5eWdMNktkeGwxMXJFdUdDMFQyT1ZhK25pSG40akRrTlZET011Q0NLeVFmQ29oWWhib1BGa0N4RThkMno5K1hSalVVRCtwYmUzOSt0aHg2TkdDNThMNVBjNmQwMWg4cjZ3MTlSQzYvd1ppNFlIOFZ5MTR0NWNIMWVkV2JKa0NYZDZmQkduRjNPa3FIbUVRWDBlTXlVaWJ0SWRsN2Z3UFptUVJ2WTNxTXpmamVOaGNjYlBtN0ZpeTU4Q0V1VWdnZDNoaElTTEY0WTZMRGZraGdabnA0ZmVpaTRpSnlCbzRWN2hPeVpWS3VpaDNvekRMUll1Zks2UHRoQ0pxSTQrZ3JRdzRyam9rRkJJOEp5OFNEZTc1VWRSK29ETG9HUkxSTndLazl6QjcyenpqRE95RjhWVW1XczlCOU9Yc3VXZkZBRXBRTmVXNWNlbWh3WkhHNFUxZzUweEtvOERPQmhvemdsSW5MM0N3ZkJha09mdldjaHVMWlRMcVpZdVhrU2QrV2JVN3F2ZGdiSXhYTk1LSkphUEw3ZFdiZ2g3VmtTa2x2dEdSTFQ0WU1ISWhqcU1zbFJnckZod3ZtSTluZXlCeE8wcUdRNWNHNGRxaDJhdzNGTHg4eTBFOEYyZk1VL2dHbitaTkFFcHdIb0ExK3IvdG5CNVQ4STJFOXNkM1J6QTR4bzVpZUswMDA2eit2cjYyM0RxeTUyWGE0QmxRVVJ5a3dtNWIwUUVBdElldDVIRjc0ZnF4eTlpTTMzY1NldUJGRU9EaFd2OHFZVUl2dS85TmthY3dmdVErZUZSR09uTGt5Z2dCZENvK3JtRjJ4dHBiR2hvYUxaMDhEamNlamRhQXVIUVg4U0R1TXpOemVhQndtVGExSXRJWWJjNDh6OE9uSlhrTzNFYldSZzlYd01HZnVWODNJa0crZWRJbXpBbkNjNjNNZUlNbm8vbmJ6TmpRWEgxZWt2RnVYVnZ0UkJCT2IvSGtrODN2QjgvU3JMQWp4L1AxVkpza1lWYlozWWgxU0lTNFc1eHVWWTZmSjZoVnBUUlF2KzlKNzk3SjJmMkpya3lGT0JRWTl5RDBIcUNiRTJOTlM2Q2UzZU0rZUZYU1hTVERBVjZTd3dvaCtaN1IzMTdweVVjVG82c3JhMzFPZ0pxckxnZ08zdndiZWFKMUlvSTkyaU9hTGU0M0tpWUpMVFNmUmtyK3JUam1BY1NGRTUrdEJEQmZSMVRxeGZYODdjV1BqbGh0NVJBRnkvdXd3c1dFdHlHMWhJT0dpQjNwYUhoVlZWVnhXdDkzRHlSU2hGeFMwdGNZdjRGaEMyclc1SVMxTVNEOEFFTG4wN24wMDROcUJRUFdJZ2cvek10SUc1T3c4RVdNbWtUZHNmREZoS3VoNWprUGRpNWlrY2lCNkFNQnJhU0N5YUdQakcwUUd4THdlTUJPZDRDNG9ZQW5tNSt5YzBGNFJER3BMUTIyRG9MZThsM0dxdWt6RHNvRlU0ZWcrRm4rWVN5ckFOYS9ETXNPSWQ1R05DeFBtM0M3bmphd29YekVCSTcwQVAxY2JXbGdMNitQbDVyNXc1UDIwWEVKaUpqNmFwSHRNVDJFczRGU1VwUTA4VkR3czUzVnhxTkZVVzl1Ym41SmR5UGQxZ0l1S1cwZy82dGp6M0NmNU0yWVNkaEd5b243b2tWRWU1allpbGd6ejMzdEkwYk4zcHJDTWNtSWp1U3ZaVXJsL3k0SWttall1aTNEN3Nsd1dYazAyaXNIQ3liVUVRRTkyRi9DODRoRmk0OTZCMUd2aFpiR09BK3ZtUWhndnR3Z0NXWUZOZWRVQ21yUGRaTHBETkpTMzRVR0l2ZmZqZkV2a1JEUW1nWXcrUzJVRVdFSTM2U090bHpKT3JxNnNLZXVmNTJFNGxISXJJckhBcDNkUkluM0kzUmJ6OFVYZVBIai8remlSd05EUTM3MnloeGdkOVFoNWU3VGNaU1NkaXhROVRGcVBjQUVRR1FpUHdGemdYNVVSekx1cGVDMnpZMnpPLzdReHFHSjBaRlZWWFZxQmUwUk1BeTlQMDBjQjJoYjVTVllyenNiQ25DUlNLU0o3ZkFYVktYTDNDRWJiQWVNMUhNcUllVDF0VFVoQktUS1dKemhNdVdoMDVZaTFrV1NIamNWRGhpQzZ3bmlCNHVjQWNCU2VRQ2Q0UnVrN0NIa1RLWWpPODl3OUpMMkFacjFDS041NllwNU1FT1c3WnQyM1lheXNYU0NPK0hpYkpESW1MMm02UXZjRWUzQ1Zxb0ZqSVhvZEpiV2dsN3BCcnVSUkNSM3R2Q2hSdXEvY1NFU0JIbDdzNWFtcVM1SU1OUlcxdnJlM1ZpRVFBMFBrS1BpWWhkU2RHUzhHVkxPWXZJbzI0b2I2SUZoT0E2RldCTUlKV1ZsUkozendRWk5TZWlwVnpkV1Z3djZyS09qbzdFem9ZdHhvUHZYWVJEa3RkMnlnUkJSczJKYUNuSG5naUg4bDZkbGlXMlJhS1JPMHVVUGVVb0lsdmd5NzdYaEJnakVleWtLVVRpS1VjUmFZUXYrMXdGN0lSSVB2QWFyRGVSYU1vMXNINDJSR1NCaGJTVXVCRENEeW5jVTZYc0tFc1JvUnNDTFp4V3R6KzdFRUtJZ0pUekVOOUc3cy9PWFJKTmlQelNOMEtJVVZMdWt3M25vVWR5VWNLMzRSUVJNREF3c05wRTB1Z3hrWGkwQUtQWjV5RWtuekhGUjhxYXlzcEtiVENVTUZBdlE5M2tTdmhCSXBKbllWTlQwN0VteXBuTk5uclVVdlpMNGxlVEVCS1JBZzNWMWRXWHc2MFY5bGFuWVNGajVaa2d1L0twcGV3WHhDeURDTHVJR0szaTY4QURPd2N1alc5QlNNNXViMjlQMU5qMHNQZXVkblM2SkN6d3JueWg3Zk5leEtNV3JGZVVSZTQya1hna0lrWEFXSitDMWlVM0JiclNFdFQ2eHpWMWVWZzc2NDhRelIrWVNCby9Scms4YXNLNnU3c1ZwMG9Cc1lrSWpPTFRGaEFZMVgzTjArSjMrTzRMWnMrZXZXTDU4dVgvYWRsbW5DWnlqWm5RZTZ4c01LaGNSSnFJVTBSYUxTQ29hSCtEdzFubVlVU1ZXdy9wR3JpMVhvQmJLeEV0UWk3OTRHRVRwblJ1bjVjc1ZscklhTmwva1RaaUU1RVZLMWJjYmdHQmdWOEdJemdEcDc1R1ZIR0h1U3Z3TytkQVNHS1BHN0JsaXQ2UmhRbTN4N1c4Q0N0b0g1elFKeWppdVp1TFE5Wjd3U0pEcEhKMEZqZVNnaEc4Z3FmbWoyTlJvYzlQMEVURXNGMG5EUzB0TFdFSGhjc0tIeE1VOFZ3M214QXBJclZEZkNFazNGRHFPK1p4SkF0RTVBd2NUcmNFVEVSMEFmOVFnY0dhYnlJd0NJQ3ZzdkI1bDFaUUVHa2kxZk5FRVB5K0ZZZC9NVTh1R2JkUTQ0VUpXYWd4OUdHK3lOK0pKZ0xqNXBhRTdkTGlUbjVIbTBnRFd1WENNakRaY055NGNWZkEwTjlwL2lnczFCaDNJUG94Q3huY3Q2T1JyVVlUZ1hCelMxWmJ5S0JjUG1FaThjQWQvSFpMQWQzZDNkYlgxK2ROOEZJdklxeklxSFNYV0g2U2xpKzRVT01sTWJzWkhyYVFZVThMTHBtL014RVlQQmR0Rmo3djArclN5YWUzdHpjVlpZUTZidFhWMWQ0RUx4UExubkQwVW45Ly8yWG1kd2IyNlhFdTFPakpkVUkrRFlPbFlhWEJlY0RDcDZHcXF1b2NFNGtHaHZrZ1N3R3Z2dnBxQlE1TjVvbk1ySjNWMGRHeEdFYitPdk83Wk1SQ3hFZGlpU080SGxmb3JWNzBScHJRVXZtVWlVQ2dUSmFZQndZR0JqNlpBQmVxR0o0SzFKMlRMUVd3SitKejFGK21GbUJFYS8xbUhHNHhmM01mR1BTOEtxNkZHdkVnM0dzZXdQZCtPY0dMVHlZYU43dmN4MXByRFJ6VU1Ybnk1QWttRWduSzU0alpzMmNuMnFYVjJ0cHFHelpzNERQMExndWZuSjNObElpd3RRNkQrRDBVN21MemhHdTVmeXVPZ0RSY0hIZVpIeHBkbmxJL3ROUzU1cUoyT1hwNTN2QWNud1lSV1dEcHB6YUxMbFBZZ2oxUWI3NWtDUjZsdFdqUklwczRjZUw3TE44QURwWENLdGFaV3dxZUV4RVJIL21XZVp5SXlJVWE4ZkNjRzNVcnNhYW1obk5Gdkt3d3pEemhjRmFLVzc2MWFCWCtOUjdzODFwYVdvNjBDTUh6ZG9kNXdBMHhiNTB4WThZOFN5bHNiS0ZjUHM1eXllTDhGN29kbzM3ZVJzTXp6enhUQjF2MVJmTkRMZ2FkeWYxRVZxeFlzY3p5RXhGOUx1bCtkdFN0UkRlazFGc3ZDdy9iWlM1UHFSci96dGdCWWxXZmdxSDZQbDVlaElxOU1NcVdMMzd2VCtZdkZ0ZUl4c04zMHlZa2JJeFExUEZNZlIwdnIwVzZ5UElUZDdQR1pKVC9ONUxvMXBvN2Q2NGRjTUFCWEhuRDE3eWpiUFpFQ25BaUloN2dHOHp2Uk1USVc0bjR6ZHZNRTRVOG9VSjhKQTA5RWdvRjBvZmNFTzhmY1U4WTkxL0hSamxZWU5XcVZWeXkvSS9tajNscEVoTEcxL0Q4ZkphaWpqSTUxNXdyaFRHZWpBNFdPQTdwb2lRSkNRVmsrL2J0QjFaWFY3ZTZSV1hEaGl2Q1BzNlRUTzlzV0Z0Ynl4YlFiOHdmdVZaaWxHUDY2K3JxYUt4OGJodktXTTgxTkFKSmRUOVE0R2hRNlNKQnVoNXZuVDY0b2tROVdBQXVyVnZOTDhWQ2tzaWVJa1VkaHZSVXh0ZVFyaTRTOVFLTkdSNHM4SG5MQzBuc0lybGd3UUlLeUNTY25qZEVHWVJKYnU1YVZTbWZuREpsU3F1RnpJWU5HeTQzejZ4YnQ2NFhEK3hqZUhDUHdzdi9hWDVneGFqRzcvd1plZHBtbm1HZXBrNmR5cnk4eC95eEY0ekErM0hzUWI0MklsOGJMQmt3UU51eXh4NTduRnhWVmZWVnk3dEg5aHJtczh6RHRJYUdobnVqS0JjRUx6ZmdtajYrbStzSmcwYjh4Z3pVeHkwb2w3VlI1S3NVS0I2NEhvbzY4LzlOSkJxdW1xRSt5OVczNit2ck8zSHRvYThGdHp0ODJMQWhZTDczeG0rOWl2eXR4WG0vUmN6OCtmTnQ5ZXJWdEVsbklMR08xSmdmTm84Yk4rNHkycU5NaTRqN25kY21UWnJVQllQQzRKZXZqYXhtUS9GZnhtODlaUkU4T01qUEp2d21aNXI3YkpIeTRXT2dlbThZaUQ2a0RURWFyWng0UUR5UHgvV2NoZlFGdkhkQUNYL0hDVll2NExxZk1NOXMyclJwYXdUaVR0aFRQTXcxWEY1SDNoaUxpZHhZa1dMeFFQMml3ZUxnakpGY0p6WDQ3Q3lJK3ozdTJpTWhJaEVoTGJnZkxmZzlOc0M2bzJ5QTBWTzRkZXZXUXpoaWpDdVFlM0pqRmZqZDAwOC96ZWtVMmU2SkZOaTRjZVB6cU9COU9LV1FqTGZ3cVVHaE5jTzRyOFJ2K1ZqWmRSZndHK3Z3Z0I2TzMvUTJDN1VJVm9xamFMVDIzbnZ2QVR5Z20vR2dScklIQ2QxcCtNMjUrK3l6ejlFVUQ3ejFaVlNNRmh0RjZ3clhleUFNMXYxUlZPYUl4SjJ3dDhPZzlUVFV6ZkhJMzQ0b3hZVHVXengvaHcwU2o5RU1JZVVjbUdwYzh4OHNvbXVPVUVUSVBzamZCL0kvTzZVQ3FkZW5ZTko5aGQrYmhuUWMwcm1vSTF4WncxY1BoT3lBKy9hYnNFTXIrS0tpbEwrQW55LzBEYjRSK0M3cHQ4TUNnYVo2K0Ftdk1VODdJaElVNExLQmdZRlB0UVB6RENveURldnZMVnIvK0ZJOG9OeE1iRGxTcDQ4TnUxd2NoaU9ycGlOLzc3VDh2aTV6eHRpcSt1a3JyN3p5RlZSa0g4dkc3QUt1LzNaY2IyUXptZkZiaFJGN2QrTFplOWJ5NVJLNndlSlEzYjYrdmtZRWF1a3FZUTkxSHVkTVdVQjQzZmkrajNWMGRQaGNQSFVuUG14WWlYRFFCZXZNL1pZZkV0c0oyeGRLK2VBZTFycjVhb3pKemtjNjB6ek1CeG1DVGIyOXZVMXVRRW41aUFqaERVZkw2Y2Q0K0U4eWY5eUM3LytLajRwY2pCTkZ6bUQzN1Q1NUMzaDRPNUJIQ3NwRE9IK1Jyank4dlJsNUh1MlE2bG9uR2hQeFBWTXQ3MjVrWUpMR2lRSGtVQ1owMG1EQndINEIxL2N6OHd6eU04K0plNlRCWSthUlpZSlRwbmFjcjhGeFBWdkFveFZQVnlhOC9vS2dUME85T1pSQjJoQUV2ZmlhMmVqNk1PZDJtV2RpRkpFY2c4c0hSdmpsbXBvYTFwZk5wWW9LZXh5NFY0VXltWXJ2ZkFlKzg0aXhDdnBvd1cvOUhOZnh5Y0xyc2hJUk1uUG16RG1vRVA5aGVXUGxCZHprYitCdzkwaWZRMEU4WldNQWVUbkY1U1cyMFM0MEJNZ3ZsLzVZd3lOZXY0SGptKzYvV1RsNjNPZjJ4dnQxN24zMm5pYmkyc2ZqdmYxd3ZpOWRjemluYUhocFNWSDRZTEErR01WMng4M056YjlBWGs2eitHQUxjWm5MTXczMEpuTnpwdkJlTjY3dFZmZTVYRGtVL1IzUGEvRVpsZ2ZMZ2VYUjVOTkE0WGV1Yld0clcyaWV0Mm1PVzBRR3dmTHBjSW03dEs0cDFCc2NhVDl5OWNhZDAwM0Z2eW1VMWI1SVRjNlYzZVE1N2pFVWJ5RDlMZXozMHNJYlpTY2lCUG5oZmcxY3JOSExoTFFpRjhOdVFlWDVzSTJSQkJpc3dXeEUvblBkWEZ4WGw3c1hoQWFwM3IxZmJ5SDFNa2JKRFhqdXpqZlBCc3MxVkg1bm5wNnZJRkJRM0NuTEk5ZnlkL09DaXN1aE1XcWp4T2NENlcrZmZmWlpINnNoN3lSaElqSVV3OVdiSnZkZVhIVm1GM0FkdjBORGJCZFBUbG1LQ0dscGFia01yYlJMTGNZeDkySGNneVFhcktRU3BSOGVkWWJ4dDM4d1VRcUxHUXdPNEE0dG1SU0lTQnA0QXdIMWozTEY5T0kzTXozWmNIZEVNQkV4RXJqRUMwVGszOHh6NnpvTHNEV0h3UERsTUNoUnRPZ1lleHVUdTdLTTRPQUpUdGJUZHJNSkJtVjAxMkFCSVdVckltNGRLcTduODZDbG5PN3U3aCthaDUwUHM0Z0xEbitocXFyS3E4RkNMNU8rYmc1amoyd3VSTXI1S2x5elBwWXJGK0h3SW5vaC96alVmNVN0aUJCV2RCd1kxUE1lYlBVSmg5cWhnTDlyS2M5SFZNQzRud1Uzb1BlVlY5Rkw1TkRPbjVoNmlhWEFRUDZGNkNWbWJxWGZETkRONVlYY3dyWnZvYXhGaEhDVVFRUTdJbm9ub3AwZHM4STR6MnNLN2FTM3QvZHFsTXM5SmtiRTdiNG5FVWtldjZtcnE3dHh1UDhzZXhFaGJrZkUxTGNZczVJUG56Qk9BYU4rRStKSXY3Y0ljTDNFVnN1QTI5UWpuTWZ5ZTVUTDFlUEdqVnRyNmFFYzZobWYyNHVkKzM5SUpDS1dqNDlrb2NWWXlBZE9mMjBTa3NHc2c0RGN4amdGeEhhaDI5WTJFcHdiZ0c3VDVTYUs2YUdvSTkwSVVmOWFXMXZiVGJzelZnbUVBM095WE04b0lBdWQyMzlZcWsza1lJc1JmdkpXTjlFcXRmdU5NeC93SzEvc1hwNXFHdkhDVmk0cnd3TjlmWDAzRlpacWlCcTZUVkV1VitMMDI1WmZwcUxjWWZ6dUlTNmo0MkpIYVFPWHZ1TmlOeEh3STVhOWVsWVFrS1VqZlZBOWtTTFlZblFqYXRaWmluRXRCd3BKT2ZkSWN1SlJhT1hpbmx3VGw0QVU0RVpwZE5uZzlCRXJYM0k5UXQ0SDlKb3ZTS21BNUpneVpRcVgvR0U5eTFxUHBHUUJJZXFKRElJUGRRc1lHQmpnUkxIVWJwNURJWEU5RWhwVDlraktKV0RKL0Q2Snl2MW5HS3IvMjk3ZVhsSkZpQXE2YkpxYW10WlVWVlZ4b3V2aFZqNDlSVGJNT0c4bTFoNWhtQ3hac29UN2Q3ejR5aXV2Rkhva3gxcTY2eG1GOEQ2a3Ewb1ZFQ0lSR1FKT1JPenU3dDRmaHVoemxtSW9KSFBuemowUGVWbUx2SHdVYjgyMjdKSm84U2lHSStrZzhQVDlmOG55VzZ0bVdlQTdVU1pQb2t5ZVFJL3dqaWhqVVZGUUVKSU5Help3enRscUpOYXpOTG9ydVZyQVBkeVJjclJsVkxiTG5veUVtOVhNVlYvZmE1Nkk4aDY0OWNLNFZEVHprNlhXNzR1V1g3VzJqZUl4bWhaVTNMaG43SXRJSDdKc0NUd0Q1dHdPNFRrWXBYdDZlbnJ1aUx2bjRjR0c3Y0N6dGpNYzBOcmFhb3NXTGFwSGcrMFR5RHQzM0V6c05zYURZTytEUGNUZndMMFlxSWNvRWRrTnlEY2ZCQTZaOWRLeWlQb2V1SFcyYUxTNGZIeWFqZFlXVkZRR1ptbWtIb1I0M0p2V0ZxNWIwcC83ajN6Szh1NnROUGRLNkxKaXVUd0RkL0FmK3Z2N2x5YkZiZVZiUkFwTW56N2RhbXBxV00vT3hqUDZicmNuVGxKaFdUMk1jdnI1VU11WmxJcEVaQVNhbTV2NU1IekhQRlR1T081QndXZ2hUeC9HQTM2b3BhZnJ6UllUQnd3d21Na0JFQThueVVpTkZZVGh1S3ozeDVHT3hrdVdTMXJpY1p6YytweGJlWmJiRUQrVXhONWdWQ0pDQ3IyU3JWdTNjazJ3djNPalBaTlV6K2hpZkFwQ2QzY1l2VVNKeUFnNG84dGhtVit4a0x1bmNkNkRHVE5tTkNEMmN6SmFqTWM1TWFGckpXbmRiOFk1Nkt1bHk0cDdsVHdKNFhoeXVPVVhzZ0I3djZqZ0gwSmVqN0M4NGRuSGtzZE80WUFoYWtlZy9HRThSOHVTTE9oUmlrZ0JiaUwxOU5OUDUrb1pHd2RJczFHdUIxZzhEUVEyd2lnZTdXR0pSd0dKU0FrNGcvdnZLSUFQV29nazRSNFV4QVI1b3l1RmV4ZFFUUGF6ZU9DRFRwY0loV005cm1rVkh2aVZXUmVPb1hDdTFLT1F1TVlYeFlSbEVsZnZwQ0RtTEJ2Mk9EclRJQnpGeENFaUJRYjFUSTVDbW1INU1tVmQ4MW1taGQ0N0U5MjlTeEgzdURmc01wT0lsQWpqQ1NqOEwxdUl0TGUzSjJiMGwrdHhNWStIT2tIaC9pUTBYQlBObjUrZVJtbHpVWG9Kdjc4U0JtcGxWVlZWeDBnelpjc0JGM3cvQ21WeXFETSswMXhpRDhWSHo1R0N3VjMyWHNidjVYWkV4UGxhaWptT0s4ZU5HN2NzWmJQS2M4UXBJc1hNbnovZk5tellVQ2hUcnQrMlArNXpvVXpIV3RkWWh3cUN6OFQ2dE14M0kwd2lJdDRDQlFXdHBpWVljcnE1OWtXTHM5RTk2QlB3NE8rSmM3YWU5aWo2azhFdWw1d2hLbnI5SnY1dUM3ZG14ZmxtbnZNekZBekx0NUs0SDNpWFJHUDNVRkJnRUpxcXE2c1B3ajFrbXNLeXdERjMvOTArOVFXNEZmRmdnN1RMSkZvS2hmczdpZ1ZIVk5Id2NJZTlUU2p6WE5uVTE5ZDNwRkUwQnBNVUVTbW00TzVDSUo3YjNiSTh1Yk1rNjFwdW0ySno5VzI0ditlV3VwYXZheXk3elhqTlh1TEdxQnRoRWhGUkVnejh3ckEwTU9FQm5ZU0hkdWRlNkRSb2d6NiswUm1tSEh5d1lmdzI0WE5iVVdHNnVydTdOMllsSUI0bmRFWFcxZFUxd0dqa3RsQkZiMkZuT2VDZWo2ZjRGMy9laWZaT25GQ1FMZ2pUMXF6TjRTZ21pU0l5RklXZUNzcXl2bERmaHZzc1ByT1JDWi9aR21jRFRDSWloTWc4YVJHUk5LS2JJSVFRSWpBU0VTR0VFSUdSaUFnaGhBaU1SRVFJSVVSZ0pDSkNDQ0VDSXhFUlFnZ1JHSW1JRUVLSXdFaEVoQkJDQkVZaUlvUVFJakFTRVNHRUVJR1JpQWdoaEFpTVJFUUlJVVJnSkNKQ0NDRUNJeEVSUWdnUkdJbUlFRUtJd0VoRWhCQkNCRVlpSW9RUUlqQVNFU0dFRUlHUmlBZ2hoQWlNUkVRSUlVUmdKQ0pDQ0NFQ0l4RVJRZ2dSR0ltSUVFS0l3RWhFaEJCQ0JFWWlJb1FRSWpEVkprcGl3WUlGdG56NWNndVQ5dloyU3p1OEw2UndiNlpNbVdMZDNkMGwvLzFycjcyMjgrOG1UNTVzdDkxMm15V1IxdGJXME11L1ZKSnlUd3BsSFRWSmZTWkVIb2xJaWNEZ1Q2eW9xR2kwY0huS1VrUkJTR253MzNqakRkdTJiVnZ1dnVDL2FuRnZwdkV6YTlldTNiT21wbVpDcWQrSnYxdkg0NFlOR3pZajljeWFOV3Y5K1BIamJjODk5OHo5eGdjLytNR2NBWStiRzI2NFlRSkVydVI4aFFudTBlWWRPM2IwV0l6Z0dtcGRXY2Z4MjdIblh3eVBSS1FFcXFxcWFuRTRDdy96NFJZdUg3YUVNMy8rL056eGxWZGVLUWpwTkFqRkpBZ0Z6MmxVOWtXcXgvbEIvQnplYjhCNVErbS9ZQjN1MkFWRHNRMS91M0w3OXUyYklTQ2I4VjNyWUx6WHo1MDdkd3NGNjdUVFRvdE5VQ1pObW5RRURoK3dHR2h1YnY2WFo1OTk5Z1dMRVZ6RDJ3Y0dCczZ5R0VoQy9zWHdTRVJHZ0FMUzFOUjBLb3piWlRCeTlWWUdzTWVCWG9FdFhicTBGc2RwdmIyOSs4R2dzeGQyQU5KQjdyeVFjdURlMkZEbkpkQTB4SHRkK0kwdUhEc2FHaG9vS3MvaC9qOEhRZWs2OHNnanQvVDA5TmdUVHp4aFVZTG5ZQjd5ZFpIRkFINzNiaHhpTmFLNEJwWjEyZVpmREk5RVpEZXdGYjV4NDhZVDhSQmZYUTRDZ2hhL1FURFk0NkJ3SEFqeFpPK2lCUVo5RG96NG5BanZRVUdnNXVGMytacUNzaFNDOHVUcnI3L093TVJ6Qng5OGNDZXVLM0l4RVVMc2lrUmtHRTQ0NFFSNy92bm4zMXRiVzN1VkZiVzRzMGhCUE5EaW40NlhoeUM5Q3diNktCeDNDc2NvZXhkaHcvdC9PZ1NGcVFQWHNyUy92LzhlcEtjb0poTW5UclFsUzVhWUVDSjZKQ0pEUUtQYTFkVjFPQXpwVlRCWVRaWlI2TFphdVhKbHNYZ2NoM1FLVWk2bUViTndESWtyRHlaZTUrMFVFN2pjSG9XYnErdTQ0NDVMUkJCZWlISkNJaklJQ29nenF0OUdtbWNaaFQwdHVxMHNuOGRkeENNbDhGby9qM1FLZWllM3dNMTFOMkltRDhJRnVVVzlFaUdpUTVNTmkyREwzQWtJQTRqSFdnWmhIamxZZ0QwdHZEd1A2VWJMRytNMENVZ3hEZWlkbkFzaHVRNHhrOCtoVjlKSWdSUkNSSU5FeEVIajZzYkJuMjk1bzVvNTJNdGlIaEV3LzRUbGUxb1V5N1NLeHk3UXpWVlpXZmxkaU1uWEtaQ0ZvY2xDQ0w5SVJCekxseStuZ0hBdXlCbVdRV2hVWFMvcnkwamZ0d3oydERnSWdMMFNuSDU3N2RxMTc2Vm9DaUg4b3BpSTVlZUNRRHcrazlXNUlCUVFHdFdhbXBwUFcwWjdXWU00Rm5tdGgyaCtIMlg3ZXdUZk5kdFpDRStVZlUra01Ka1Fwd3N6TGlBY3Fsd09BbEtBQXdaK05IUG16QlBsMmhMQ0gyVXRJalF1TkRJNHZkb3lFaHNvWnBDQVpIYWsyVzdnL0pLcmVBOW16WnBsUW9qd0tWc1JvVkdoY2NGcEppY1Rjb1JTbVF0SURnYmNlUS9ncWp3a3JsVm9oY2d5WlNraURMalNxR1IxTW1IeFpFa3JZd0VwZ3N1bmZNdk5peEZDaEVqWmlVaGhsQktOaW1YUXdCYk5kY24wWk1uUmdzWUNKMU9lN1Zaa0ZrS0VSRm1KaUZ1ZE5yY2FxVE1xbWNNTlZlWmNsMHhPbGh3TGFEaGNnQmpZZkxtMWhBaVBzaEdSd21SQ0dCTE9JOGprS0NYR2Vkd2loV2VZZUF0dUhzbGxFRnE1dFlRSWliS1pKOElXT293ck45VTUyL3pDT1FrUHVtTmtjT0hCMjI2N2pZc29YbGd1KzU0RVpGNWxaZVduRURmNjNpaVhrVitQK3pyaVRwU010VmsyMlp6eS9QL2VoQmZLUWtUY1pNTFRvNWhNaU4vZ0V1V3QxZFhWV3kxQ3VIM3JsQ2xUdnVVMkQ0b2JDdWdtcERkeFBWdUcrZ0R1VXcwT2RMM3RpUlRwdHJPNHBpOGpidlJibkhhVytqZTQzaVg0dS9VbGZPNjNsa0hxNnVvNnQyN2RldmxJbjB0cS90RncrSm9KTDJSZVJJb21FMGJSUW4rUUFySml4WXBsRmlGdTcvTlRZb3p6VUNoZVJGcnYwbjhqcllGQjJUZ3dNTEJwcUQvQS80M0hvUkhYUEFubmY0Vnp1cGoycy94d2E5L0I3MFlZbFhQUUd6bS8xTjdJczg4K3kyMThPMGI2M096WnN5Mkw0RDZ4VVhUN1NKOUxhdjVkK1FrUFpGcEVPQkpyL2ZyMVhPYWNrd2w5dDlDNTQ5N0NxQVdFY09ncWpPSWxFZS8vd2Q0R2R4eGNqdDlkQlNGNEVvS3hzcjYrdnNNWm5KS0JNYTlISzdjSmduOG92dXRRdkhVd0VrZVk3V09ld0xWK2N0dTJiVCsyVWZSR2hCQnZKYk1pVXBoTVdGdGIyeHFCaTRlRzZFcjBCcFpheExqOVR6NGY0WHlYSHZ4V08wVGpNYVJIY0g0dlJLekx4b0FUbldVdXNUWExvY25jV1pHckNYREplaDg5RTY1UWNBWjZjWmNpbG1SQ2lHQmtVa1NjWVozbEpoUE9NYjlzaGpHOXVxMnQ3VmFMQWJTbU9lZmxxeFlOZEZreE5uRDcrUEhqRjQrMngxRXFUb3lYUWt3ZXdwR0xScDVrSG5vbDZMMmRDZ0c4RHFlYlRRZ1JpTXdOOFMyYWJIZUorWjlzUitQenp4Q1FteXdHM0h5SE04ei91bDkwWGQwSHNicTJ0N2YzQXJqc2J2Y2xJTVZRVE1hTkc4ZU5zMzVvSHR4T3J2ZDJ2QWtoQXBNcEVYRnpRUmlnNVdaTHA1dGZhRmgvQWlQM0hZc0pGd3M1MWZ4Q29mdzFZZ2ovQUxHOGZ0V3FWUnN0UWloV0VKTnIyTnN6UC9HTE03WEtyeERCeVl5SWNKNkUyNW1RODBCOFR5YWtnUHdhcmZLcm8yaVI3NGFUUE1kQ2NqMHRwSXZqR0RCUURIdDdUa2hDZFQzaE80OXdxeGdJSVFLUUdSSGhQQW5MNzB4NGdmbG5DZExGVWJmS2kwRStHV3oralBrakp5RHNhYUVuTUtiQWVWZzR0K0V0RmlJYzlvMTcrYmNtaEFoRUprU0VjMEVhR2hvV1JMUXpJV2VqWHhHM1lVWFFtVDBRWHpHZm5hNjZtSHRhUS9HOVVtWk9qd1o4M3pIc3lRb2hSay9xUmFRd21SQUMwaHFCZ05BbnZ6Q09vYnlEUVY1UE5rL2dYaTVLZ0t0dVNDamVLUFB2V3JqTHlyelA5V1NGRUtNazFTTGlkaWFjYjlGTUp1eWtUejRKQWtKWEZwS1gyZWxzNWVPN0w0M1RWVGNTdGJXMWQrSWF3NXlCM0RCcDBxUm1FMEtNbXRTS0NPZUNjREloVjJVMS93TEN1U0RYeFRXVWR6QjBaWG1hLzhKRjlpNVAraElSN0NIMTkvZi96RUtrc3JKeXZna2hSazBxUmNSTkpwd2UwYzU5dVFCelhWM2R6WllRWU9oOUJZSi94VGtnbGdKZzlIOWg0YnEwampRaHhLaUpiY2I2a1VjR3I3T3Z2LzQ2SnhOeUxvaHZBYUdSdWlWSkFXYTM1UHY3TFh6V3d6RC93RklDWXlQTnpjMHZoRGpFT2JjSHU1WkFFV0oweENZaUVJSVRMRGdmc1dnMmx2bzEwdmVTRkdCbUFIank1TW52c3BDQk1mNUZDbGM2ZlJncExCRnBkSnRWamJqY3V4RGlMOFFtSW93eFdFQWlXbXlRUTNrdlRzb2NpUUl1QUJ6Mk1pZnJxNnFxL3NuU3gyTkluN09RR0JnWW9EamZhVUtJa29sTlJDSmNkVFlJajFoK0tHK2lCSVJBZk45ajRYTm5TdmRiZU1aQ0JPNjgvVTBranI2K1BnMi9UakJsc3ozdUtPanM3Ky8vWmtkSFIreERlWWNDSXZKT0N4ZkdmUkl6YUdBMG9DSHlrb1VJUk9SQUU0a0R2ZVQ5VFNTV3pLM2lPMFplNUZ3UUNNaGlTeUFNcXVQNkRyTVE0WHlMSk14OUNVTFlQVVc0czZhYlNCeDRSbjJ2VWkzR2dFVGtMM0F1eVBWSm1Rc3lGQXlxaCswR3hQZmRaU0lIZWlKVFRBZ3hLaVFpZWJoSE9PZUMzR2dKQmtIMS9TMWtJQ0lQV0VvSmU3MHIzSXY5TFptRU9SOUdpRkJSVEFRVkZEMlFYMEpBa3JqWTRDNTRNSEpiRUxSOG5Gc0pweEUzM05sQ0pKRnVrN0JqUDBLRVNkbUxDQmNiNUZJZlNSY1E0aUhBdUwybXB1YURsbElhR2hvbVdjZ2tjY0poRWtjSkNsR2czRVhrUVM0MmlEaElLaW9wcm5VL0NKNkZDRnZlLzI0cEJmZkR3c1p0YktZOTE0VW9rYktOaWJnOUtSYW1hWDVFZ24zMm1hRzN0MWNqdElRWUJlVXFJcDEwWWFWdGFLdUdPdnFudHJiVzk1NDBRbVNLY2hTUkxad0xrcGJWYW9VUUlzbVVvNGhzUnkva3Z4aEFUU0hUVEFnaEVrUTVpZ2hkUXBlNEFHcXFTUGg2WTBLSU1xUmNZeUtuSTUzRi9kbE5DQ0ZFWU1wMmRCYmlJcGZObkRuenhCTk9HTXUySmlLRGJERWhSTW1VOHhCZmpzSzVxcXVyNi9ENTgrZWJFS1NucDJlMUNTRktwcXpYem5JeGhtOXYyTENoTWV4MW1FUTZXYlZxMVVZVFFwU01GbUEwT3hhdXJYTzVEcE1KSVlRWUZSS1JQR2MzTkRRc1VLQzk3TkZ5SjBLTUVvbUk1ZU1qNkkyMEl0QStmKzdjdVpaZzFwdndTYWNKSVVhRlJPUXZORUpNTHR1K2ZmdjBwRTVFNUM2RUpyeUIrL3VLQ1NGR2hmWVQyWlY1U09jdlg3NzhNaXNmMThhalNKdE1XSDkvL3g5TUNERXFZaE1SdDRwdUlOQmliTVRCeTR4emZQY1pPSFFpUHZKakdKV2s3U2puWXc3RGp5c3JLeDgxd1JWOE5USkxpRkVTcDRoY2JnR0JvVDhNaDY4amhSNElkL05IRmg1NDRJR2RNSzZMMnR2YkxTbmcybFpieUVBbzE2UG5KVGVaRUNJUXNZbklXRmJSUmZCN01XSVgrK1AwRSthSGh1cnE2bFlZN1RXSWp6eVZsSjN1SUo2YlF0NlV5cERQdDVzUVFnUWtsWUYxdDVYdHhVaVBtQ2Rnck9mQWFIOExQWkVrclp6clkzVFdPMDBJSVFLUzJ0RlozSGNhcnBodm1zZGhtUkNTVTNBNE8wSHpSM3k0blE1TDZiTDRRb2dFa09vaHZoMGRIWXZSVzdqT1BJNmt3dmRmME5UVWRHb1NGbXJFdGZqb2lSeWN4bVh4eXdtVWV5b213V3Jwb1BJazlmTkU2dXJxYnNiaEZpUXZJNmxjb1AzcUpDelU2UGFERDNXRUZ2T0hkTFNKeE5MYzNKeUt1SldXRGlwUFVpOGlMajd5UGJUVzdqRi9jRWh4YnFIR3VGMC95T2NxQ3hsODUyY1NQbE8vck9udDdaMXVLV0RTcEVrelRKUWRtWml4N3VJanJUdzFmK1FXYXNSdnhlMzZDWDFPQi9KMU5HZnFtd2lEMEh2RTFkWFY3N0FVZ05qaFVTYktqc3dzZTdKaXhZcGxPRnlKdE03OGNUWU03dWx4QnRxNVA3eUZERjFhbFpXVjU4eWFOY3ZFMk1EejhaS0ZETXJuL1VrZi9NQTZnZXM4elVUWmthbTFzOUJMdUJYRzhFYnpHeCs1a0FzMXhtVndmYzB1SHhnWStDUU00Q0VhcVRWbXVpeDgzcFBrd1E5OFpsQWZqclQ4c2tHaXpNamNBb3kxdGJYWDR2QnI4MGR1b1VZWTNGbHhHRndYWFBkaHFCcVFwMjhrd0YwWENqRU9ndkN4TkExamNzY25WZUQ1ektBUnN0QkVXWkk1RVNtYWlQaWcrWU10cmt2aU1yZ3c5bmVaSDA2SzIxMDNWbWhvRHo3NFlJdHJFSVNQcFdrY1p5ZFI0UG1zY0dBR1RvODFVWlprY2lsNEJ0cHhZTXZJNS80UXA3UHl4R0Z3Ky9yNjdqVVBGTHZyMHJqdlBLK1pLd3owOS9kL0ZHWHo5VGlNTG43M09mUERQQXA4a3NxRnp6N25VRm0rcm9reUpiUDdpY0NBTFBVOUVSRXNoTUU5TWVyNENGd0hmekovK2NxNTY5YXVYZnZldEFnSjczOTFkWFV0cnhrdnowTzZFWGs0bDBZMzZyS0JnQVZlbmJvRUxreEN1YkNIeC92dEJPUnFwQVlUWlV1bU42VnlFeEYvWXA0QzdaYXZQRmRGSFpCZXRXb1ZseXovby9salhrMU56VlUwV0VjZWVhUWxGZDV6em05aGZBb0c3ZE84WnJ4OWtmM0ZxRjNJc29seUpqVkVoTXMrKzNyZUd1TXVGNjdjd040ZTc3ZmxCYVRSUkZtVGFSRmhmS1MzdC9kcW54TVIwZUp0S2l6VUdLV3h3bS9lYkg3SkNjbnJyNzkrTk4wV1NRcnE4ajdUaVBLZWI5KysvV1M4ZFFuU0QrMnRvNE1hV1RaUnpxU213T00zWHpCL3hGSXVoZDRlVjI2d2ZHK1A5MXNDSXF5cWxBOU5tVEtsMVVJR2djL0ErNG1NaGsyYk5tMmROR25TU3B3ZWpzcnRhMFhlSnFTdER6end3T052dnZsbUpCdFo3YnZ2dmk4aE52SXg4N1E1bDROR3VLV2hvV0VyeW12TnU5NzFybTJkbmZGdFExNFE2YnZ1dW1zQ0ROcmY0UFRqU1A5Z2VmR29HZWJQbXVycjYxZE1uano1R2VUQm9nRDFwUm1IZDVrL2lzdmw1ZW5UcDI5eG9tcGh3dnM5ZnZ4NFc3MTZkUzErcXdYM2tBdklmUm1KZ2ZRYWl3ams5WUZYWG5sbGlZbEVrbmtSSVJzM2JseUhTdkF5SHNiMzQrV2U1Z0Y4OTd0UjRWNkVvWDBxQ2tPN2J0MjYzcWxUcC80UG5QcGU5Mm9mY3kzODExNTdiZnVycjc2NkFhNk0vcWdNTW1FTVlKOTk5ckhGaXhkUFFNL3k4QWtUSnB4U1dWbjVEZndYVjFuZWE2Uy94MmNaR0xuL25IUE8yYkJreVJMenpjU0pFK3Z3bXg4enZ4VEtwYTY3dTdzRzViRUY5MmpMbkRsejdOQkREdzBzS0lXZVRXTmpvOTEzMzMwVDBGQTVGT0xCMVJyKzN2SUMwbVFSSXhGSk5oV2xmR2oyN05uaDdvUmt1Y0IzU2I4ZEppMHRMWmNoS00yV3F5LzNCa2VGblRadTNMaEg0RW96M3lBL1RjalBRK2EzTjFJTVYwMitEUzY4eDFldVhObCt6REhIOU1DZ200OU51d3JCWXhpUHduYklzL0c3czNGTzkxV1FTVzAvaGFIOUNyN1B4enlPWFpneFkwWURYRTdzL1VaU0xyZ25IYmczZCtEMGNhUTFTTS9oOWVhOTl0ckwzdmEydDltTEw3N0lPdnlXdjN2aGhSZHMyN1p0YkNRYWhJaU5CSE85ZGFiOThCMEg0dlV4U1BQY3lMMVl3TzlmM3RiVzFtb2lrWlNWaUNBSVc0L0tjajBxeE9mTUg0dngvZWVnSlJpSjN3ZSs2cDl6RkpKRkJINkw4M0FXSTkwSkFYc1d4MDdrTmZTUllzaFhJMXJCalhCYk5hSlZUei84c1l3L1dVQjQzYmplTCtCYWYyWVJFSFc1T0RqZ2dzdi9MTVc5ZXQ3eUkvaVk2R0lkYWhzQk5xYlkyNkI3a09mVGNNMk04UjNFVGRrc0lURVBpVWl5S1NzUkljZ0xLd1lOeVh2Tkh6Y2czVG5TaDNBUGZtOWpCUGxocTV5dDBFam5STkFvdzlBc3hTbDdRdlNkc0FXOERxMzl6WEFkYm1Fcm1OVFYxZVY2RXdVSzd4UEVqempuaGU3R0NYQ1pUSFI1b0p1R3h1d1F0N3ZrbkxCYXdhN0ZmcHliUitRVmlNalIrRDJXYnl3VE41M1lkeUcvWGE2c1ZnN3hzVW40dndiOFg0TTdSdTZxS2dXSlNMSXBPeEVoenZCeTZLK1hsV3NMRlhpa3o2Rml6TFFRUUg3K0dZZXpMRDV5TFdBYWFiVDIxM0F2ZUhNdFg4UXd0c0MxODBiUlovY3BPdDhEYVU4WXIwbm9iZXhyK1padmswOWpobXU3ZHNXS0ZRdjcrL3U5RG9CZ3IzZjc5dTNzc1dsbDJ6RWlFVWsyMVZhR2NDSmljM1B6ZFRCVzN6RVBMWGpYY282c1ZRY0QvQU1ZN3c5WjNwY2RCNXlYUVhjVEE3QzVOeWdvUEVKQU9PUjFZOUZuZDk0WHRvQXR2MllYenkwaXpqN3d3QU1mUUR4cGtZOVlUZ0VPTDhkdi9Bamw4bTZMcVRjaVJCU1VwWWdRVGtSRVMvRUFuSDdGVWw3SnVTZ2pETmEvd21CeG9sMGk4bExjbTRoUUlFYUVBZy8vZnl0aUk0L1owSEdDMEtpdHJiMFR6eGgvUjcwUmtWa3lQZGx3ZDBReEVURkt1cnU3ZjRURFl5Wkd4QVdOUCs5NzNUTStZeEQyNzV1ZmxYMkZTQVJsS3lLRXM0dTVJeUtNaXMvMWppS0JlWEVHeTJ2ck9rTjhsWHRnK0o3eGpmakw3V2lvL05hRXlDaGxMU0tFT3lKQ1JEangwZWVPaUpGQWc0WDR5TCthdjdXYnNrUUQ5OERnMGlubUdZaklWVmxvcUFneEZHVXZJc1FaWCs2SW1IcTNBOTFhTUZxTFRKVENRYmhYVTh3empGbTVoa3A4YThaRWc4ODlmRVJDa1lnNHVDTWlETW92TGVXdGVMY0E0S1dtQ3IwNzJGaTRqOE45NitycUlqSHN6cTNsZTJ1Q09PSHpwbjFGeWhDSmlJTkJVTmRhWEdJcHgyMmh5d3I5aUlsZG9Gc0p4dndtTG4vVDF0WjJ2ZHNKTXhMYzFnU2MwNU1sSVdHamk1TXFGM0xvdk1tVlduWklSSXB3TTVtdnNBeTRIVmloKy92N3Y4bFRFNlFUQXNKMXZ5NkhNVi9JV0poRkRBVnIzTGh4bkp0RUlVbDlETTd5ZWJnWnJ1Q3ZPUUZoL09jbEUyV0ZSR1FRYmtkRWJyYVQrdFppUjBjSFoweGZhZVh0MnFLaCt6M0x0Syt2NzB0MEswWForeGhNa1pCd1A0NjBDang3Ryt6bC9oQjVPYy8xZkF0NFgxSkdKSXV5bld5NE8rRG11R24yN05sY2tpVDFFeEVoaXJjaUwxelhpcnYrY1NIRGNwazlUZkhnaUtnSDBGSytZNUNoaXhVbll0ZWdYR2h3ejdUOE9tNXBLUmYyMHU5SEwvZFhycEVpeWh5SnlEQndJaUtDN2Z2RC9YR3FwUnoycm1Dd0dDUDVFdEp4RnZGaWpSRkRJL2VjSlZBOEJrT0Juemx6NWtwYzV4Zng4bGlrL1N5NTBCMzRKSzcxSHJnRGI0MnpOeWVTaFVSa0dEaktxYVdsNVZJRVlBL2dpcktXY3B5UXNPVzdHb25yYk0yMjdFRDNDdmZRYUtlUlEzazlsR1R4S0lheG1ibHo1NTdYM2QxOUpxNmZPd2Z5V2R2SGtzTk84VURENmc3V0N4T2lDSW5JYnFBaFFrdnhjaGlsLzJYSmJpV1dCQWNPd0dCOVovdjI3ZHdINUZPV2QyK2x1VmZDdUJYakNoU00reEh6dURlTlJzNjE2cTlIbytWZU5GcTQ2UlozNEl4VFRIaGYyWnZyeExOL3Y4UkQ3QTZKeUFnd0VOdmMzSHdBV21PdDVtOUh4TWh3QnV0V0dLd25rYWVQSTNGNzNVTXRQWG5iZ212T3VhelFPbTdIK1I4UTNGMldCZmVLNnoxeE1jMDduSmdjYWZudENnNDAvekVUQ2dmalNCU09weURJRCsreHh4NUw1YllTSXlFUktRSDRnRytFdTJFV0ROWW5MU09CYVdld1d1SGkrZ1B5OVNFWWppTXNiN0NTNUVvcHNObHRydlFpanF1UUhrWmdkMmxXVzhjRk1YRWJxQjNsMGpzc3Y5OEt5eWVNM21OaDE4TjF1Si9yblNCejQ2cUgydHJhTk1KS2xFeEpJb0tINnlkV3hyQTFoZ3JOaVlqYjR0eHIyZ2R1ZlA5U3QxSFhVY2pmWEJqcldaWjMzOFhWTytHTWNpNGt1ZFBBb1dYT1NZTEwydHZieThiQXVYbExUT3c1TnVFZUhPcTJycVhZVDhSeEg3eXVzYitJU25FRG9IZ2V5cHY0N0JaOGxwdURiWEgzbE4rN2hzS0JYa2VIM0ZVaUtMSHRMaWlTeVl3Wk14cHFhbXFPZ1hHaHdacGgrWTJ1bUdpZ2ZQVENHQlRmaE45N21Uc2k0c2pXOFdvWXVaVTBjUERIeThBTmdyc205dlQwY0EvNkp0eW44ZWIyUXNmOU9xandHZHpMbFVYblhLMTZFejY3a2Nubm9BTzRmdS9IZGN5M0VOSE9oc2xHN2l5eEM4NWczOHBFZHdxTVQxTjFkVFZidjB4VFVLRW5zQVhNeitKOGF0R2ZUckszaWd4N0ZNVmI0OUl0MVZ0b0VWdmVuZkxmNWxyRWRGbmg5N29rR3J2SHhTazZYQklpVmlRaVlsaUszQ201U1dYc3BTQSsxTUFXTUYvVHRWTDA4WDJIY1BWdGRQdXRGK2pDWjdheFpjd1djVzF0YlpjQ3QwS2tHNG1JS0JuWFEyQlNDMWdJa1VOclp3a2hoQWlNUkVRSUlVUmdKQ0pDQ0NFQ0l4RVJRZ2dSR0ltSUVFS0l3RWhFaEJCQ0JFWWlJb1FRSWpBU0VTR0VFSUdSaUFnaGhBaU1SRVFJSVVSZ0pDSkNpRERwTVZGV1NFU0VFR0h5a29teVFpSWloQWlUTlNiS0NvbUlFRUtJd0VoRWhCQkNCRVlpSW9RUUlqQVNFU0dFRUlHUmlBZ2hoQWlNUkVRSUlVUmdKQ0pDQ0NFQ0l4RVJRb1RHd01CQWpZbXlRaUlpaEFpRkJRc1dXRVZGeFR0TWxCVVNFU0hFbUtHQXRMZTNUOFBwZTB5VUZSSVJJY1NZbURWckZnVmtJazdQUm1vMFVWWlVteEJDbEFoN0hHVDU4dVcyMTE1NzJXT1BQVllMRjlZc3ZIVThqaGZzMkxIRFJIa2hFUkZDbElUcmNkQmx4ZGpIeE5kZmYzMWFVMU1UWXlBbkloMExBYWszVVhaSVJJUVFKUUhoT0FTSGo3dVgrK0oxRTQ1TkVvL3lSaUlpaENnSmlNWXBFSXlMQ3EvbHVoSkVnWFVoaEJDQmtZZ0lJWVFJakVSRUNDRkVZQ1FpUWdnaEFpTVJFVUlrblI0VGlVVWlJb1JJTkR0MjdIakpSR0tSaUFnaEVrMUZSY1ZUSmhLTFJFUUlrV1MyMU5YVmRacElMQklSSVVSaWdTdHIyUk5QUExIVlJHS1JpQWdoRWd0Y1dUOHprV2drSWtLSXBOTFoyOXY3V3hPSlJpSWloRWdpUGVpRlhMZHExYXFOSmhLTlJFUUlrVGdnSVBjZ29INnppY1FqRVJGQ0pJMEgrL3Y3V3hWUVR3Y1NFU0ZFVXVETTlQdVFGcTVZc1dLWmlWU2cvVVNFRUtXeXhmekJ1U0QzRHd3TS9KTUVKRjFVbVJCQ2xNRGt5WlBwdWFoRDJtWjUyN0dualEzMlBQN2ZqaDA3N3F1c3JMeDUzTGh4MzMvbW1XZTZUS1NLQ2hOQ2lCS1pPM2R1L1p0dnZqbXZxcXJxVUJqL2d4QUFuNGJqUGpqdWJYbFJtYmliUDZkb2JFTGFqTFFlcVFOLzkyUlBUODhkR29XVlhpUWlRb2pBdExTME5QWDE5VFZCVlBiRnkwbHdSelVPOTFrSUJnUGxhNUM2OExtVmNsdGxnLzhQVTVrZElPRXh1eThBQUFBQVNVVk9SSzVDWUlJPVwiO1xuLyogLT0gQ09OU1RBTlRTID0tICovXG5cbnZhciBBQ0NPVU5UU19UT19HRVQgPSA1O1xudmFyIFdBTExFVF9OQU1FID0gJ0tlZXBLZXknO1xudmFyIEVSUk9SX0JVU1kgPSAnYnVzeSc7XG52YXIgRVJST1JfUEFJUklORyA9ICdwYWlyaW5nJztcbnZhciBlcnJvck1lc3NhZ2VzID0gKF9lcnJvck1lc3NhZ2VzID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfZXJyb3JNZXNzYWdlcywgRVJST1JfQlVTWSwgXCJZb3VyIEtlZXBLZXkgaXMgY3VycmVudGx5IGNvbm5lY3RlZCB0byBhbm90aGVyIGFwcGxpY2F0aW9uLlxcbiAgUGxlYXNlIGNsb3NlIGFueSBvdGhlciBicm93c2VyIHRhYnMgb3IgYXBwbGljYXRpb25zIHRoYXQgbWF5IGJlIGNvbm5lY3RlZCB0byB5b3VyIGRldmljZSBhbmQgdHJ5IGFnYWluLlwiKSwgX2RlZmluZVByb3BlcnR5KF9lcnJvck1lc3NhZ2VzLCBFUlJPUl9QQUlSSU5HLCAnVGhlcmUgd2FzIGFuIGVycm9yIHBhaXJpbmcgdGhlIGRldmljZS4gUGxlYXNlIGRpc2Nvbm5lY3QgYW5kIHJlY29ubmVjdCB0aGUgZGV2aWNlIGFuZCB0cnkgYWdhaW4uJyksIF9lcnJvck1lc3NhZ2VzKTtcblxuZnVuY3Rpb24ga2VlcGtleShvcHRpb25zKSB7XG4gIHZhciBsYWJlbCA9IG9wdGlvbnMubGFiZWwsXG4gICAgICBpY29uU3JjID0gb3B0aW9ucy5pY29uU3JjLFxuICAgICAgcnBjVXJsID0gb3B0aW9ucy5ycGNVcmwsXG4gICAgICBuZXR3b3JrSWQgPSBvcHRpb25zLm5ldHdvcmtJZCxcbiAgICAgIHByZWZlcnJlZCA9IG9wdGlvbnMucHJlZmVycmVkOyAvLyBVc2VkIHRvIHNpZ25hbCBpZiB0aGUga2VlcCBrZXkgY291bGQgbm90IGJlIHBhaXJlZCBvciBpZiB0aGUga2VlcCBrZXkgaXMgYWxyZWFkeSBwYWlyZWQgd2l0aCBhbm90aGVyIGFwcFxuXG4gIHZhciBfaW5zdGFsbE1lc3NhZ2U7XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBsYWJlbCB8fCBXQUxMRVRfTkFNRSxcbiAgICBpY29uU3JjOiBpY29uU3JjIHx8IGltZyxcbiAgICB3YWxsZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfd2FsbGV0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNihfcmVmMikge1xuICAgICAgICB2YXIgQmlnTnVtYmVyLCByZXNldFdhbGxldFN0YXRlLCBfeWllbGQkY3JlYXRlS2VlcEtleVAsIHByb3ZpZGVyLCBlcnJvcjtcblxuICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYkKF9jb250ZXh0Nikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ni5wcmV2ID0gX2NvbnRleHQ2Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIEJpZ051bWJlciA9IF9yZWYyLkJpZ051bWJlciwgcmVzZXRXYWxsZXRTdGF0ZSA9IF9yZWYyLnJlc2V0V2FsbGV0U3RhdGU7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVLZWVwS2V5UHJvdmlkZXIoe1xuICAgICAgICAgICAgICAgICAgcmVzZXRXYWxsZXRTdGF0ZTogcmVzZXRXYWxsZXRTdGF0ZSxcbiAgICAgICAgICAgICAgICAgIEJpZ051bWJlcjogQmlnTnVtYmVyLFxuICAgICAgICAgICAgICAgICAgcnBjVXJsOiBycGNVcmwsXG4gICAgICAgICAgICAgICAgICBuZXR3b3JrSWQ6IG5ldHdvcmtJZFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBfeWllbGQkY3JlYXRlS2VlcEtleVAgPSBfY29udGV4dDYuc2VudDtcbiAgICAgICAgICAgICAgICBwcm92aWRlciA9IF95aWVsZCRjcmVhdGVLZWVwS2V5UC5wcm92aWRlcjtcbiAgICAgICAgICAgICAgICBlcnJvciA9IF95aWVsZCRjcmVhdGVLZWVwS2V5UC5lcnJvcjtcbiAgICAgICAgICAgICAgICBfaW5zdGFsbE1lc3NhZ2UgPSBlcnJvck1lc3NhZ2VzW2Vycm9yXSB8fCAnJztcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICBwcm92aWRlcjogcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImludGVyZmFjZVwiOiAhZXJyb3IgPyB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFdBTExFVF9OQU1FLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0OiBwcm92aWRlci5lbmFibGUsXG4gICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3Q6IHByb3ZpZGVyLmRpc2Nvbm5lY3QsXG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHtcbiAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZ2V0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBwcm92aWRlci5nZXRQcmltYXJ5QWRkcmVzcygpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgIH0oKVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBuZXR3b3JrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2dldDIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIG5ldHdvcmtJZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgfSgpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGJhbGFuY2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfZ2V0MyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUkKF9jb250ZXh0NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBwcm92aWRlci5nZXRQcmltYXJ5QWRkcmVzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIsIGFkZHJlc3MgJiYgcHJvdmlkZXIuZ2V0QmFsYW5jZShhZGRyZXNzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlNSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXQzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgfSgpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gOiBudWxsXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNik7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHdhbGxldChfeCkge1xuICAgICAgICByZXR1cm4gX3dhbGxldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gd2FsbGV0O1xuICAgIH0oKSxcbiAgICAvLyBUaGUgc3R5bGUgdGFnIGhlcmUgaXMgdXNlZCB0byBoaWRlIHRoZSAnT3BlbiBLZWVwS2V5IGJ1dHRvbidcbiAgICBpbnN0YWxsTWVzc2FnZTogZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2UoKSB7XG4gICAgICByZXR1cm4gX2luc3RhbGxNZXNzYWdlID8gXCI8c3R5bGU+Zm9vdGVyIGEgPiBidXR0b24geyBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQgfTwvc3R5bGU+XFxuICAgICAgICA8cCBzdHlsZT1cXFwiZm9udC1zaXplOiAwLjg4OXJlbTsgZm9udC1mYW1pbHk6IGluaGVyaXQ7IG1hcmdpbjogMC44ODlyZW0gMDtcXFwiPlxcbiAgICAgICAgICBcIi5jb25jYXQoX2luc3RhbGxNZXNzYWdlLCBcIlxcbiAgICAgICAgPC9wPlwiKSA6ICcnO1xuICAgIH0sXG4gICAgdHlwZTogJ2hhcmR3YXJlJyxcbiAgICBtb2JpbGU6IGZhbHNlLFxuICAgIGRlc2t0b3A6IHRydWUsXG4gICAgcHJlZmVycmVkOiBwcmVmZXJyZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2VlcEtleVByb3ZpZGVyKF94Mikge1xuICByZXR1cm4gX2NyZWF0ZUtlZXBLZXlQcm92aWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfY3JlYXRlS2VlcEtleVByb3ZpZGVyKCkge1xuICBfY3JlYXRlS2VlcEtleVByb3ZpZGVyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTYoX3JlZjMpIHtcbiAgICB2YXIgQmlnTnVtYmVyLCBycGNVcmwsIHJlc2V0V2FsbGV0U3RhdGUsIG5ldHdvcmtJZCwgX3lpZWxkJGltcG9ydCwgV2ViVVNCS2VlcEtleUFkYXB0ZXIsIF95aWVsZCRpbXBvcnQyLCBLZXlyaW5nLCBFdmVudHMsIGJpcDMyVG9BZGRyZXNzTkxpc3QsIEhEV2FsbGV0RXJyb3JUeXBlLCBfeWllbGQkaW1wb3J0MywgY3JlYXRlUHJvdmlkZXIsIF95aWVsZCRpbXBvcnQ0LCBpc1ZhbGlkUGF0aCwga2V5cmluZywga2VlcEtleUFkYXB0ZXIsIGtlZXBLZXlXYWxsZXQsIERFRkFVTFRfREVSSVZBVElPTl9QQVRILCBkUGF0aCwgYWRkcmVzc1RvUGF0aCwgZW5hYmxlZCwgY3VzdG9tUGF0aCwgcHJvdmlkZXIsIGVuYWJsZSwgX2VuYWJsZSwgZGlzY29ubmVjdCwgc2V0UGF0aCwgX3NldFBhdGgsIGlzQ3VzdG9tUGF0aCwgZ2V0QWRkcmVzcywgX2dldEFkZHJlc3MsIGFkZHJlc3Nlcywgc2V0UHJpbWFyeUFjY291bnQsIGdldFByaW1hcnlBZGRyZXNzLCBnZXRNb3JlQWNjb3VudHMsIF9nZXRNb3JlQWNjb3VudHMsIF9nZXRBY2NvdW50cywgX2dldEFjY291bnRzMiwgZ2V0QmFsYW5jZXMsIGdldEJhbGFuY2UsIF9zaWduVHJhbnNhY3Rpb24sIF9zaWduVHJhbnNhY3Rpb24yLCBfc2lnbk1lc3NhZ2UsIF9zaWduTWVzc2FnZTI7XG5cbiAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE2JChfY29udGV4dDE2KSB7XG4gICAgICB3aGlsZSAoMSkge1xuICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTYucHJldiA9IF9jb250ZXh0MTYubmV4dCkge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIF9zaWduTWVzc2FnZTIgPSBmdW5jdGlvbiBfc2lnbk1lc3NhZ2U0KCkge1xuICAgICAgICAgICAgICBfc2lnbk1lc3NhZ2UyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTUoX3JlZjgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSwgYWRkcmVzc05MaXN0LCBfeWllbGQka2VlcEtleVdhbGxldCQyLCBzaWduYXR1cmU7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE1JChfY29udGV4dDE1KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTUucHJldiA9IF9jb250ZXh0MTUubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfcmVmOC5kYXRhO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShhZGRyZXNzVG9QYXRoLnNpemUgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTUubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDE1Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc05MaXN0ID0gX3RvQ29uc3VtYWJsZUFycmF5KGFkZHJlc3NUb1BhdGgudmFsdWVzKCkpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZWVwS2V5V2FsbGV0LmV0aFNpZ25NZXNzYWdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc05MaXN0OiBhZGRyZXNzTkxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgICAgICAgICAgX3lpZWxkJGtlZXBLZXlXYWxsZXQkMiA9IF9jb250ZXh0MTUuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IF95aWVsZCRrZWVwS2V5V2FsbGV0JDIuc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTUuYWJydXB0KFwicmV0dXJuXCIsIHNpZ25hdHVyZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUxNSk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zaWduTWVzc2FnZTIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9zaWduTWVzc2FnZSA9IGZ1bmN0aW9uIF9zaWduTWVzc2FnZTMoX3gxMCkge1xuICAgICAgICAgICAgICByZXR1cm4gX3NpZ25NZXNzYWdlMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX3NpZ25UcmFuc2FjdGlvbjIgPSBmdW5jdGlvbiBfc2lnblRyYW5zYWN0aW9uNCgpIHtcbiAgICAgICAgICAgICAgX3NpZ25UcmFuc2FjdGlvbjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNCh0cmFuc2FjdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkcmVzc05MaXN0LCBub25jZSwgZ2FzUHJpY2UsIGdhcywgdG8sIHZhbHVlLCBkYXRhLCBfeWllbGQka2VlcEtleVdhbGxldCQsIHNlcmlhbGl6ZWQ7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE0JChfY29udGV4dDE0KSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTQucHJldiA9IF9jb250ZXh0MTQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGFkZHJlc3NUb1BhdGguc2l6ZSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZW5hYmxlKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzTkxpc3QgPSBfdG9Db25zdW1hYmxlQXJyYXkoYWRkcmVzc1RvUGF0aC52YWx1ZXMoKSlbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBub25jZSA9IHRyYW5zYWN0aW9uRGF0YS5ub25jZSwgZ2FzUHJpY2UgPSB0cmFuc2FjdGlvbkRhdGEuZ2FzUHJpY2UsIGdhcyA9IHRyYW5zYWN0aW9uRGF0YS5nYXMsIHRvID0gdHJhbnNhY3Rpb25EYXRhLnRvLCB2YWx1ZSA9IHRyYW5zYWN0aW9uRGF0YS52YWx1ZSwgZGF0YSA9IHRyYW5zYWN0aW9uRGF0YS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxNC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZWVwS2V5V2FsbGV0LmV0aFNpZ25UeCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NOTGlzdDogYWRkcmVzc05MaXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBub25jZTogbm9uY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdhc1ByaWNlOiBnYXNQcmljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZ2FzTGltaXQ6IGdhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRvLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGEgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IG5ldHdvcmtJZFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgICBfeWllbGQka2VlcEtleVdhbGxldCQgPSBfY29udGV4dDE0LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkID0gX3lpZWxkJGtlZXBLZXlXYWxsZXQkLnNlcmlhbGl6ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXCJyZXR1cm5cIiwgc2VyaWFsaXplZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUxNCk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zaWduVHJhbnNhY3Rpb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfc2lnblRyYW5zYWN0aW9uID0gZnVuY3Rpb24gX3NpZ25UcmFuc2FjdGlvbjMoX3g5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfc2lnblRyYW5zYWN0aW9uMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZ2V0QmFsYW5jZSA9IGZ1bmN0aW9uIF9nZXRCYWxhbmNlKGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5zZW5kQXN5bmMoe1xuICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICBtZXRob2Q6ICdldGhfZ2V0QmFsYW5jZScsXG4gICAgICAgICAgICAgICAgICBwYXJhbXM6IFthZGRyZXNzLCAnbGF0ZXN0J10sXG4gICAgICAgICAgICAgICAgICBpZDogNDJcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZSwgcmVzKSB7XG4gICAgICAgICAgICAgICAgICBlICYmIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSByZXMgJiYgcmVzLnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEJpZ051bWJlcihyZXN1bHQpLnRvU3RyaW5nKDEwKSk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKG51bGwpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGdldEJhbGFuY2VzID0gZnVuY3Rpb24gX2dldEJhbGFuY2VzKGFkZHJlc3Nlcykge1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYWRkcmVzc2VzLm1hcChmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmNyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmFsYW5jZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEJhbGFuY2UoYWRkcmVzcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhbGFuY2UgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWxhbmNlOiBiYWxhbmNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlOCk7XG4gICAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3g4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmNy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfZ2V0QWNjb3VudHMyID0gZnVuY3Rpb24gX2dldEFjY291bnRzNCgpIHtcbiAgICAgICAgICAgICAgX2dldEFjY291bnRzMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEzKGdldE1vcmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2tlZXBLZXlXYWxsZXQkZGVzY3JpLCBhY2NvdW50SWR4LCBzdGFydGluZ0luZGV4LCBpLCBhZGRyZXNzTkxpc3QsIGFkZHJlc3M7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEzJChfY29udGV4dDEzKSB7XG4gICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTMucHJldiA9IF9jb250ZXh0MTMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5hYnJ1cHQoXCJyZXR1cm5cIiwgW10pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYWRkcmVzc1RvUGF0aC5zaXplID4gMCAmJiAhZ2V0TW9yZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmFicnVwdChcInJldHVyblwiLCBhZGRyZXNzZXMoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBkUGF0aCA9IGRQYXRoIHx8IERFRkFVTFRfREVSSVZBVElPTl9QQVRIOyAvLyBHZXQgdGhlIGFjY291bnQgaW5kZXggZnJvbSB0aGUgZGVyaXZhdGlvbiBwYXRoXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9rZWVwS2V5V2FsbGV0JGRlc2NyaSA9IGtlZXBLZXlXYWxsZXQuZGVzY3JpYmVQYXRoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogYmlwMzJUb0FkZHJlc3NOTGlzdChkUGF0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvaW46ICdFdGhlcmV1bSdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBhY2NvdW50SWR4ID0gX2tlZXBLZXlXYWxsZXQkZGVzY3JpLmFjY291bnRJZHg7IC8vIFRoaXMgd291bGQgb25seSBoYXBwZW4gaWYgdGhlIHVzZXIgcHJvdmlkZXMgYW4gaW52YWxpZCBkUGF0aCBhbmQgaXQgd2Fzbid0IGNhdWdodCBieSB0aGUgc2V0UGF0aCBtZXRob2RcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoYWNjb3VudElkeCA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGRlcml2ZSBhY2NvdW50IGZyb20gcGF0aDogXCIuY29uY2F0KGRQYXRoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGluZGV4IHRvIHN0YXJ0IGZyb20gYmFzZWQgb24gdGhlIGRQYXRoIGluZGV4IGFuZCB0aGUgY3VycmVudCBudW1iZXIgb2YgZ2VuZXJhdGVkIGFkZHJlc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRpbmdJbmRleCA9IGFjY291bnRJZHggKyBhZGRyZXNzVG9QYXRoLnNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpID0gc3RhcnRpbmdJbmRleDtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgQUNDT1VOVFNfVE9fR0VUICsgc3RhcnRpbmdJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXRyaWV2ZSB0aGUgYXJyYXkgZm9ybSBvZiB0aGUgZGVyaXZhdGlvbiBwYXRoIGZvciBhIGdpdmVuIGFjY291bnQgaW5kZXhcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3NOTGlzdCA9IGtlZXBLZXlXYWxsZXQuZXRoR2V0QWNjb3VudFBhdGhzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29pbjogJ0V0aGVyZXVtJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudElkeDogaVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlbMF0uYWRkcmVzc05MaXN0OyAvLyBSZXRyaWV2ZSB0aGUgYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIGFjY291bnQgaW5kZXhcblxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ga2VlcEtleVdhbGxldC5ldGhHZXRBZGRyZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc05MaXN0OiBhZGRyZXNzTkxpc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dEaXNwbGF5OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzcyA9IF9jb250ZXh0MTMuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBhZGRyZXNzIGluIG91ciBzZXQgb2YgZ2VuZXJhdGVkIGFkZHJlc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1RvUGF0aC5zZXQoYWRkcmVzcywgYWRkcmVzc05MaXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmFicnVwdChcInJldHVyblwiLCBhZGRyZXNzZXMoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUxMyk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRBY2NvdW50czIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9nZXRBY2NvdW50cyA9IGZ1bmN0aW9uIF9nZXRBY2NvdW50czMoX3g3KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZ2V0QWNjb3VudHMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfZ2V0TW9yZUFjY291bnRzID0gZnVuY3Rpb24gX2dldE1vcmVBY2NvdW50czMoKSB7XG4gICAgICAgICAgICAgIF9nZXRNb3JlQWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMigpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWNjb3VudHM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMiQoX2NvbnRleHQxMikge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEyLnByZXYgPSBfY29udGV4dDEyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9nZXRBY2NvdW50cyh0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnRzID0gX2NvbnRleHQxMi5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KFwicmV0dXJuXCIsIGFjY291bnRzICYmIGdldEJhbGFuY2VzKGFjY291bnRzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgX2NhbGxlZTEyKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICByZXR1cm4gX2dldE1vcmVBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgZ2V0TW9yZUFjY291bnRzID0gZnVuY3Rpb24gX2dldE1vcmVBY2NvdW50czIoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZ2V0TW9yZUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBnZXRQcmltYXJ5QWRkcmVzcyA9IGZ1bmN0aW9uIF9nZXRQcmltYXJ5QWRkcmVzcygpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVuYWJsZWQgPyBhZGRyZXNzZXMoKVswXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNldFByaW1hcnlBY2NvdW50ID0gZnVuY3Rpb24gX3NldFByaW1hcnlBY2NvdW50KGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgLy8gbWFrZSBhIGNvcHkgYW5kIHB1dCBpbiBhbiBhcnJheVxuICAgICAgICAgICAgICB2YXIgYWNjb3VudHMgPSBfdG9Db25zdW1hYmxlQXJyYXkoYWRkcmVzc1RvUGF0aC5lbnRyaWVzKCkpO1xuXG4gICAgICAgICAgICAgIHZhciBhY2NvdW50SW5kZXggPSBhY2NvdW50cy5maW5kSW5kZXgoZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDEpLFxuICAgICAgICAgICAgICAgICAgICBhY2NvdW50QWRkcmVzcyA9IF9yZWY2WzBdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY291bnRBZGRyZXNzID09PSBhZGRyZXNzO1xuICAgICAgICAgICAgICB9KTsgLy8gcHVsbCB0aGUgaXRlbSBhdCB0aGUgYWNjb3VudCBpbmRleCBvdXQgb2YgdGhlIGFycmF5IGFuZCBwbGFjZSBhdCB0aGUgZnJvbnRcblxuICAgICAgICAgICAgICBhY2NvdW50cy51bnNoaWZ0KGFjY291bnRzLnNwbGljZShhY2NvdW50SW5kZXgsIDEpWzBdKTsgLy8gcmVhc3NpZ24gYWRkcmVzc1RvUGF0aCB0byBuZXcgb3JkZXJlZCBhY2NvdW50c1xuXG4gICAgICAgICAgICAgIGFkZHJlc3NUb1BhdGggPSBuZXcgTWFwKGFjY291bnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFkZHJlc3NlcyA9IGZ1bmN0aW9uIF9hZGRyZXNzZXMoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKGFkZHJlc3NUb1BhdGgua2V5cygpKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIF9nZXRBZGRyZXNzID0gZnVuY3Rpb24gX2dldEFkZHJlc3MzKCkge1xuICAgICAgICAgICAgICBfZ2V0QWRkcmVzcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKGFkZHJlc3NOTGlzdCwgcGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMS5wcmV2ID0gX2NvbnRleHQxMS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCBrZWVwS2V5V2FsbGV0LmV0aEdldEFkZHJlc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzTkxpc3Q6IGFkZHJlc3NOTGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMS5wcmV2ID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTEudDAgPSBfY29udGV4dDExW1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZGVyaXZlIGFkZHJlc3MgZnJvbSBwYXRoIFwiLmNvbmNhdChwYXRoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTEuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgX2NhbGxlZTExLCBudWxsLCBbWzAsIDRdXSk7XG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9nZXRBZGRyZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBnZXRBZGRyZXNzID0gZnVuY3Rpb24gX2dldEFkZHJlc3MyKF94NSwgX3g2KSB7XG4gICAgICAgICAgICAgIHJldHVybiBfZ2V0QWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaXNDdXN0b21QYXRoID0gZnVuY3Rpb24gX2lzQ3VzdG9tUGF0aCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN1c3RvbVBhdGg7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfc2V0UGF0aCA9IGZ1bmN0aW9uIF9zZXRQYXRoMygpIHtcbiAgICAgICAgICAgICAgX3NldFBhdGggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMChwYXRoLCBjdXN0b20pIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRkcmVzc05MaXN0LCBhZGRyZXNzO1xuICAgICAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRQYXRoKHBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGggIT09IGRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNsZWFyIGFueSBleGlzdGluZyBhZGRyZXNzZXMgaWYgZGlmZmVyZW50IHBhdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1RvUGF0aCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXN0b20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEwLnByZXYgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcGF0aCB0byB0aGUgYWRkcmVzc05MaXN0IHdoaWNoIGlzIHdoYXQgaXMgdXNlZCBieSBrZWVwa2V5IGZvciBzaWduaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzTkxpc3QgPSBiaXAzMlRvQWRkcmVzc05MaXN0KHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGFkZHJlc3NOTGlzdCwgcGF0aCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzID0gX2NvbnRleHQxMC5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc1RvUGF0aC5zZXQoYWRkcmVzcywgYWRkcmVzc05MaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRQYXRoID0gcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIHRydWUpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAucHJldiA9IDE1O1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMC50MCA9IF9jb250ZXh0MTBbXCJjYXRjaFwiXSg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZXJlIHdhcyBhIHByb2JsZW0gZGVyaXZpbmcgYW4gYWRkcmVzcyBmcm9tIHBhdGggXCIuY29uY2F0KHBhdGgpKTtcblxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXN0b21QYXRoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBkUGF0aCA9IHBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5hYnJ1cHQoXCJyZXR1cm5cIiwgdHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUxMCwgbnVsbCwgW1s0LCAxNV1dKTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICByZXR1cm4gX3NldFBhdGguYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHNldFBhdGggPSBmdW5jdGlvbiBfc2V0UGF0aDIoX3gzLCBfeDQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9zZXRQYXRoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkaXNjb25uZWN0ID0gZnVuY3Rpb24gX2Rpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICAgIGRQYXRoID0gJyc7XG4gICAgICAgICAgICAgIGFkZHJlc3NUb1BhdGggPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgIGVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAga2VlcEtleVdhbGxldC5jbGVhclNlc3Npb24oKTtcbiAgICAgICAgICAgICAgcHJvdmlkZXIuc3RvcCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgX2VuYWJsZSA9IGZ1bmN0aW9uIF9lbmFibGUzKCkge1xuICAgICAgICAgICAgICBfZW5hYmxlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIGFueSB1c2VyIHByb21wdCB0aGF0IG1heSBiZSBkaXNwbGF5ZWQgb24gdGhlIGtlZXBrZXkgaS5lLiB0aGUgcGluIG1hdHJpeFxuICAgICAgICAgICAgICAgICAgICAgICAga2VlcEtleVdhbGxldC5jYW5jZWwoKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCBfZ2V0QWNjb3VudHMoKVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2Vycm9yJG1lc3NhZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGVycm9yLm1lc3NhZ2UgaXMgYW4gb2JqZWN0LCB0aGVuIHRoZSBlcnJvciBtZXNzYWdlIG9yaWdpbmF0ZWQgZnJvbSBrZWVwa2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNvIHdlIGdyYWIgdGhlIHN0cmluZyBhbmQgcmV0aHJvdyBzbyB0aGUgd2FsbGV0Y2hlY2sgY2FuIGNhcHR1cmUgYW5kIGRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yICE9PSBudWxsICYmIGVycm9yICE9PSB2b2lkIDAgJiYgKF9lcnJvciRtZXNzYWdlID0gZXJyb3IubWVzc2FnZSkgIT09IG51bGwgJiYgX2Vycm9yJG1lc3NhZ2UgIT09IHZvaWQgMCAmJiBfZXJyb3IkbWVzc2FnZS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9lcnJvciRtZXNzYWdlMjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9lcnJvciRtZXNzYWdlMiA9IGVycm9yLm1lc3NhZ2UpID09PSBudWxsIHx8IF9lcnJvciRtZXNzYWdlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Vycm9yJG1lc3NhZ2UyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgX2NhbGxlZTkpO1xuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHJldHVybiBfZW5hYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBlbmFibGUgPSBmdW5jdGlvbiBfZW5hYmxlMigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9lbmFibGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIEJpZ051bWJlciA9IF9yZWYzLkJpZ051bWJlciwgcnBjVXJsID0gX3JlZjMucnBjVXJsLCByZXNldFdhbGxldFN0YXRlID0gX3JlZjMucmVzZXRXYWxsZXRTdGF0ZSwgbmV0d29ya0lkID0gX3JlZjMubmV0d29ya0lkO1xuICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gMjQ7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0KCdAc2hhcGVzaGlmdG9zcy9oZHdhbGxldC1rZWVwa2V5LXdlYnVzYicpO1xuXG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIF95aWVsZCRpbXBvcnQgPSBfY29udGV4dDE2LnNlbnQ7XG4gICAgICAgICAgICBXZWJVU0JLZWVwS2V5QWRhcHRlciA9IF95aWVsZCRpbXBvcnQuV2ViVVNCS2VlcEtleUFkYXB0ZXI7XG4gICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSAyODtcbiAgICAgICAgICAgIHJldHVybiBpbXBvcnQoJ0BzaGFwZXNoaWZ0b3NzL2hkd2FsbGV0LWNvcmUnKTtcblxuICAgICAgICAgIGNhc2UgMjg6XG4gICAgICAgICAgICBfeWllbGQkaW1wb3J0MiA9IF9jb250ZXh0MTYuc2VudDtcbiAgICAgICAgICAgIEtleXJpbmcgPSBfeWllbGQkaW1wb3J0Mi5LZXlyaW5nO1xuICAgICAgICAgICAgRXZlbnRzID0gX3lpZWxkJGltcG9ydDIuRXZlbnRzO1xuICAgICAgICAgICAgYmlwMzJUb0FkZHJlc3NOTGlzdCA9IF95aWVsZCRpbXBvcnQyLmJpcDMyVG9BZGRyZXNzTkxpc3Q7XG4gICAgICAgICAgICBIRFdhbGxldEVycm9yVHlwZSA9IF95aWVsZCRpbXBvcnQyLkhEV2FsbGV0RXJyb3JUeXBlO1xuICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gMzU7XG4gICAgICAgICAgICByZXR1cm4gaW1wb3J0KCcuL3Byb3ZpZGVyRW5naW5lLTQxM2RkZmY3LmpzJyk7XG5cbiAgICAgICAgICBjYXNlIDM1OlxuICAgICAgICAgICAgX3lpZWxkJGltcG9ydDMgPSBfY29udGV4dDE2LnNlbnQ7XG4gICAgICAgICAgICBjcmVhdGVQcm92aWRlciA9IF95aWVsZCRpbXBvcnQzW1wiZGVmYXVsdFwiXTtcbiAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDM5O1xuICAgICAgICAgICAgcmV0dXJuIGltcG9ydCgnLi9oZC13YWxsZXQtNmZjNDM0NzYuanMnKTtcblxuICAgICAgICAgIGNhc2UgMzk6XG4gICAgICAgICAgICBfeWllbGQkaW1wb3J0NCA9IF9jb250ZXh0MTYuc2VudDtcbiAgICAgICAgICAgIGlzVmFsaWRQYXRoID0gX3lpZWxkJGltcG9ydDQuaXNWYWxpZFBhdGg7XG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSBhZGFwdGVyIGFuZCBwYWlyIHRoZSBkZXZpY2VcbiAgICAgICAgICAgIGtleXJpbmcgPSBuZXcgS2V5cmluZygpO1xuICAgICAgICAgICAga2VlcEtleUFkYXB0ZXIgPSBXZWJVU0JLZWVwS2V5QWRhcHRlci51c2VLZXlyaW5nKGtleXJpbmcpO1xuICAgICAgICAgICAgX2NvbnRleHQxNi5wcmV2ID0gNDM7XG4gICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSA0NjtcbiAgICAgICAgICAgIHJldHVybiBrZWVwS2V5QWRhcHRlci5wYWlyRGV2aWNlKCk7XG5cbiAgICAgICAgICBjYXNlIDQ2OlxuICAgICAgICAgICAga2VlcEtleVdhbGxldCA9IF9jb250ZXh0MTYuc2VudDtcbiAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDU3O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDQ5OlxuICAgICAgICAgICAgX2NvbnRleHQxNi5wcmV2ID0gNDk7XG4gICAgICAgICAgICBfY29udGV4dDE2LnQwID0gX2NvbnRleHQxNltcImNhdGNoXCJdKDQzKTtcblxuICAgICAgICAgICAgaWYgKCEoX2NvbnRleHQxNi50MC5uYW1lID09PSBIRFdhbGxldEVycm9yVHlwZS5Db25mbGljdGluZ0FwcCkpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gNTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICBwcm92aWRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICBlcnJvcjogRVJST1JfQlVTWVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlIDU1OlxuICAgICAgICAgICAgaWYgKCEoX2NvbnRleHQxNi50MC5uYW1lID09PSBIRFdhbGxldEVycm9yVHlwZS5XZWJVU0JDb3VsZE5vdFBhaXIpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTYubmV4dCA9IDU3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTYuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgcHJvdmlkZXI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgZXJyb3I6IEVSUk9SX1BBSVJJTkdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA1NzpcbiAgICAgICAgICAgIERFRkFVTFRfREVSSVZBVElPTl9QQVRIID0gXCJtLzQ0Jy82MCcvMCcvMC8wXCI7IC8vIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgZGVyaXZhdGlvbiBwYXRoXG5cbiAgICAgICAgICAgIGRQYXRoID0gJyc7XG4gICAgICAgICAgICBhZGRyZXNzVG9QYXRoID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY3VzdG9tUGF0aCA9IGZhbHNlO1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBjcmVhdGVQcm92aWRlcih7XG4gICAgICAgICAgICAgIGdldEFjY291bnRzOiBmdW5jdGlvbiBnZXRBY2NvdW50cyhjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF9nZXRBY2NvdW50cygpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2lnblRyYW5zYWN0aW9uOiBmdW5jdGlvbiBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25EYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF9zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25EYXRhKS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHByb2Nlc3NNZXNzYWdlOiBmdW5jdGlvbiBwcm9jZXNzTWVzc2FnZShtZXNzYWdlRGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfc2lnbk1lc3NhZ2UobWVzc2FnZURhdGEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZTogZnVuY3Rpb24gcHJvY2Vzc1BlcnNvbmFsTWVzc2FnZShtZXNzYWdlRGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfc2lnbk1lc3NhZ2UobWVzc2FnZURhdGEpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc2lnbk1lc3NhZ2U6IGZ1bmN0aW9uIHNpZ25NZXNzYWdlKG1lc3NhZ2VEYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF9zaWduTWVzc2FnZShtZXNzYWdlRGF0YSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBzaWduUGVyc29uYWxNZXNzYWdlOiBmdW5jdGlvbiBzaWduUGVyc29uYWxNZXNzYWdlKG1lc3NhZ2VEYXRhLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIF9zaWduTWVzc2FnZShtZXNzYWdlRGF0YSkudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzKTtcbiAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIG51bGwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBycGNVcmw6IHJwY1VybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBrZXlyaW5nLm9uKFsnKicsICcqJywgRXZlbnRzLkRJU0NPTk5FQ1RdLCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNygpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDcucHJldiA9IF9jb250ZXh0Ny5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICByZXNldFdhbGxldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhbGxldE5hbWU6IFdBTExFVF9OQU1FXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBfY2FsbGVlNyk7XG4gICAgICAgICAgICB9KSkpOyAvLyBJZiB0aGUgd2FsbGV0IGFza3MgZm9yIGEgUElOLCBvcGVuIHRoZSBQSU4gbW9kYWxcblxuICAgICAgICAgICAga2V5cmluZy5vbihbJyonLCAnKicsIEV2ZW50cy5QSU5fUkVRVUVTVF0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgcmVuZGVyTW9kYWwoa2VlcEtleVdhbGxldCwgTW9kYWxUeXBlLlBpbik7XG4gICAgICAgICAgICB9KTsgLy8gSWYgdGhlIHdhbGxldCBhc2tzIGZvciBhIFBJTiwgb3BlbiB0aGUgUElOIG1vZGFsXG5cbiAgICAgICAgICAgIGtleXJpbmcub24oWycqJywgJyonLCBFdmVudHMuUEFTU1BIUkFTRV9SRVFVRVNUXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZW5kZXJNb2RhbChrZWVwS2V5V2FsbGV0LCBNb2RhbFR5cGUuUGFzc3BocmFzZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3ZpZGVyLnNldFBhdGggPSBzZXRQYXRoO1xuICAgICAgICAgICAgcHJvdmlkZXIuZFBhdGggPSBkUGF0aDtcbiAgICAgICAgICAgIHByb3ZpZGVyLmVuYWJsZSA9IGVuYWJsZTtcbiAgICAgICAgICAgIHByb3ZpZGVyLnNldFByaW1hcnlBY2NvdW50ID0gc2V0UHJpbWFyeUFjY291bnQ7XG4gICAgICAgICAgICBwcm92aWRlci5nZXRQcmltYXJ5QWRkcmVzcyA9IGdldFByaW1hcnlBZGRyZXNzO1xuICAgICAgICAgICAgcHJvdmlkZXIuZ2V0QWNjb3VudHMgPSBfZ2V0QWNjb3VudHM7XG4gICAgICAgICAgICBwcm92aWRlci5nZXRNb3JlQWNjb3VudHMgPSBnZXRNb3JlQWNjb3VudHM7XG4gICAgICAgICAgICBwcm92aWRlci5nZXRCYWxhbmNlID0gZ2V0QmFsYW5jZTtcbiAgICAgICAgICAgIHByb3ZpZGVyLmdldEJhbGFuY2VzID0gZ2V0QmFsYW5jZXM7XG4gICAgICAgICAgICBwcm92aWRlci5zZW5kID0gcHJvdmlkZXIuc2VuZEFzeW5jO1xuICAgICAgICAgICAgcHJvdmlkZXIuZGlzY29ubmVjdCA9IGRpc2Nvbm5lY3Q7XG4gICAgICAgICAgICBwcm92aWRlci5pc0N1c3RvbVBhdGggPSBpc0N1c3RvbVBhdGg7XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICBwcm92aWRlcjogcHJvdmlkZXJcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY2FzZSA3OTpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMTYsIG51bGwsIFtbNDMsIDQ5XV0pO1xuICB9KSk7XG4gIHJldHVybiBfY3JlYXRlS2VlcEtleVByb3ZpZGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtlZXBrZXk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bnc-onboard/dist/esm/index-4a48b5ea.js\n");

/***/ })

}]);
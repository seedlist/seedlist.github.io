/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["vendors-node_modules_bnc-onboard_dist_esm_onboard_js"],{

/***/ "./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v9.0.1\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                    // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(v, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor call without `new`.\r\n      if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n      if (b == null) {\r\n\r\n        if (v && v._isBigNumber === true) {\r\n          x.s = v.s;\r\n\r\n          if (!v.c || v.e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else if (v.e < MIN_EXP) {\r\n            x.c = [x.e = 0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.c = v.c.slice();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n          // Fast path for integers, where n < 2147483648 (2**31).\r\n          if (v === ~~v) {\r\n            for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n            if (e > MAX_EXP) {\r\n              x.c = x.e = null;\r\n            } else {\r\n              x.e = e;\r\n              x.c = [v];\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          str = String(v);\r\n        } else {\r\n\r\n          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10) {\r\n          x = new BigNumber(v);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        str = String(v);\r\n\r\n        if (isNum = typeof v == 'number') {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + v);\r\n          }\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp, so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(v), isNum, b);\r\n          }\r\n        }\r\n\r\n        // Prevent later check for length on converted number.\r\n        isNum = false;\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      if (str = str.slice(i, ++len)) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * v));\r\n        }\r\n\r\n         // Overflow?\r\n        if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            i = LOG_BASE - (str = str.slice(i)).length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if less than two characters,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      if (!v || v._isBigNumber !== true) return false;\r\n      if (!BigNumber.DEBUG) return true;\r\n\r\n      var i, n,\r\n        c = v.c,\r\n        e = v.e,\r\n        s = v.s;\r\n\r\n      out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n          // If the first element is zero, the BigNumber value must be zero.\r\n          if (c[0] === 0) {\r\n            if (e === 0 && c.length === 1) return true;\r\n            break out;\r\n          }\r\n\r\n          // Calculate number of digits that c[0] should have, based on the exponent.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (i < 1) i += LOG_BASE;\r\n\r\n          // Calculate number of digits of c[0].\r\n          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n          if (String(c[0]).length == i) {\r\n\r\n            for (i = 0; i < c.length; i++) {\r\n              n = c[i];\r\n              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n            }\r\n\r\n            // Last element cannot be zero, unless it is the only element.\r\n            if (n !== 0) return true;\r\n          }\r\n        }\r\n\r\n      // Infinity/NaN\r\n      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n        return true;\r\n      }\r\n\r\n      throw Error\r\n        (bignumberError + 'Invalid BigNumber: ' + v);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, P.lt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, P.gt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    function maxOrMin(args, method) {\r\n      var n,\r\n        i = 1,\r\n        m = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        n = new BigNumber(args[i]);\r\n\r\n        // If any number is NaN, return NaN.\r\n        if (!n.s) {\r\n          m = n;\r\n          break;\r\n        } else if (method.call(m, n)) {\r\n          m = n;\r\n        }\r\n      }\r\n\r\n      return m;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on ±Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.s = null;\r\n        }\r\n\r\n        x.c = x.e = null;\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = n / pows10[d - j - 1] % 10 | 0;\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and ±Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to ±Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = ±Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return ±0, else return ±Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;\r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, ±Infinity or ±0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return ±Infinity if either is ±Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return ±0 if either is ±0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;\r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return ±Infinity if either ±Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;\r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '5e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) i = g1, g1 = g2, g2 = i, len -= i;\r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(coeffToString(n.c), e)\r\n           : toFixedPoint(coeffToString(n.c), e, '0');\r\n        } else if (b === 10) {\r\n          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n          str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n  // These functions don't need access to variables,\r\n  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== mathfloor(n)) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIuanM/OTAxZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxtQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHdEQUF3RDtBQUN6Rjs7O0FBR0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOzs7QUFHQTs7O0FBR0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQkFBbUIsS0FBSztBQUN4QjtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCOztBQUVBO0FBQ0EsWUFBWSxPQUFPOztBQUVuQjtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxZQUFZOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsS0FBSzs7QUFFdkM7QUFDQTs7QUFFQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLEtBQUs7QUFDbkI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFD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QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxPQUFPOztBQUV0QjtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsS0FBSztBQUM3Qjs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsOEJBQThCLEtBQUs7QUFDbkM7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSxJQUF5QztBQUMvQyxJQUFJLG1DQUFPLGFBQWEsa0JBQWtCLEVBQUU7QUFBQSxrR0FBQzs7QUFFN0M7QUFDQSxHQUFHLE1BQU0sRUFVTjtBQUNILENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlnbnVtYmVyLmpzL2JpZ251bWJlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24gKGdsb2JhbE9iamVjdCkge1xyXG4gICd1c2Ugc3RyaWN0JztcclxuXHJcbi8qXHJcbiAqICAgICAgYmlnbnVtYmVyLmpzIHY5LjAuMVxyXG4gKiAgICAgIEEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBhcmJpdHJhcnktcHJlY2lzaW9uIGFyaXRobWV0aWMuXHJcbiAqICAgICAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvYmlnbnVtYmVyLmpzXHJcbiAqICAgICAgQ29weXJpZ2h0IChjKSAyMDIwIE1pY2hhZWwgTWNsYXVnaGxpbiA8TThjaDg4bEBnbWFpbC5jb20+XHJcbiAqICAgICAgTUlUIExpY2Vuc2VkLlxyXG4gKlxyXG4gKiAgICAgIEJpZ051bWJlci5wcm90b3R5cGUgbWV0aG9kcyAgICAgfCAgQmlnTnVtYmVyIG1ldGhvZHNcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBhYnNvbHV0ZVZhbHVlICAgICAgICAgICAgYWJzICAgIHwgIGNsb25lXHJcbiAqICAgICAgY29tcGFyZWRUbyAgICAgICAgICAgICAgICAgICAgICB8ICBjb25maWcgICAgICAgICAgICAgICBzZXRcclxuICogICAgICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgZHAgICAgIHwgICAgICBERUNJTUFMX1BMQUNFU1xyXG4gKiAgICAgIGRpdmlkZWRCeSAgICAgICAgICAgICAgICBkaXYgICAgfCAgICAgIFJPVU5ESU5HX01PREVcclxuICogICAgICBkaXZpZGVkVG9JbnRlZ2VyQnkgICAgICAgaWRpdiAgIHwgICAgICBFWFBPTkVOVElBTF9BVFxyXG4gKiAgICAgIGV4cG9uZW50aWF0ZWRCeSAgICAgICAgICBwb3cgICAgfCAgICAgIFJBTkdFXHJcbiAqICAgICAgaW50ZWdlclZhbHVlICAgICAgICAgICAgICAgICAgICB8ICAgICAgQ1JZUFRPXHJcbiAqICAgICAgaXNFcXVhbFRvICAgICAgICAgICAgICAgIGVxICAgICB8ICAgICAgTU9EVUxPX01PREVcclxuICogICAgICBpc0Zpbml0ZSAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICBQT1dfUFJFQ0lTSU9OXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbiAgICAgICAgICAgIGd0ICAgICB8ICAgICAgRk9STUFUXHJcbiAqICAgICAgaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyAgIGd0ZSAgICB8ICAgICAgQUxQSEFCRVRcclxuICogICAgICBpc0ludGVnZXIgICAgICAgICAgICAgICAgICAgICAgIHwgIGlzQmlnTnVtYmVyXHJcbiAqICAgICAgaXNMZXNzVGhhbiAgICAgICAgICAgICAgIGx0ICAgICB8ICBtYXhpbXVtICAgICAgICAgICAgICBtYXhcclxuICogICAgICBpc0xlc3NUaGFuT3JFcXVhbFRvICAgICAgbHRlICAgIHwgIG1pbmltdW0gICAgICAgICAgICAgIG1pblxyXG4gKiAgICAgIGlzTmFOICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgcmFuZG9tXHJcbiAqICAgICAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICAgICAgICB8ICBzdW1cclxuICogICAgICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBpc1plcm8gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtaW51cyAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBtb2R1bG8gICAgICAgICAgICAgICAgICAgbW9kICAgIHxcclxuICogICAgICBtdWx0aXBsaWVkQnkgICAgICAgICAgICAgdGltZXMgIHxcclxuICogICAgICBuZWdhdGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwbHVzICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBwcmVjaXNpb24gICAgICAgICAgICAgICAgc2QgICAgIHxcclxuICogICAgICBzaGlmdGVkQnkgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICBzcXVhcmVSb290ICAgICAgICAgICAgICAgc3FydCAgIHxcclxuICogICAgICB0b0V4cG9uZW50aWFsICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZpeGVkICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0Zvcm1hdCAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0ZyYWN0aW9uICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b0pTT04gICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b051bWJlciAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1ByZWNpc2lvbiAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB0b1N0cmluZyAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICogICAgICB2YWx1ZU9mICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICpcclxuICovXHJcblxyXG5cclxuICB2YXIgQmlnTnVtYmVyLFxyXG4gICAgaXNOdW1lcmljID0gL14tPyg/OlxcZCsoPzpcXC5cXGQqKT98XFwuXFxkKykoPzplWystXT9cXGQrKT8kL2ksXHJcbiAgICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICAgIG1hdGhmbG9vciA9IE1hdGguZmxvb3IsXHJcblxyXG4gICAgYmlnbnVtYmVyRXJyb3IgPSAnW0JpZ051bWJlciBFcnJvcl0gJyxcclxuICAgIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICAgIEJBU0UgPSAxZTE0LFxyXG4gICAgTE9HX0JBU0UgPSAxNCxcclxuICAgIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgICAvLyBNQVhfSU5UMzIgPSAweDdmZmZmZmZmLCAgICAgICAgICAgICAgICAgICAvLyAyXjMxIC0gMVxyXG4gICAgUE9XU19URU4gPSBbMSwgMTAsIDEwMCwgMWUzLCAxZTQsIDFlNSwgMWU2LCAxZTcsIDFlOCwgMWU5LCAxZTEwLCAxZTExLCAxZTEyLCAxZTEzXSxcclxuICAgIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgICAvLyBFRElUQUJMRVxyXG4gICAgLy8gVGhlIGxpbWl0IG9uIHRoZSB2YWx1ZSBvZiBERUNJTUFMX1BMQUNFUywgVE9fRVhQX05FRywgVE9fRVhQX1BPUywgTUlOX0VYUCwgTUFYX0VYUCwgYW5kXHJcbiAgICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgICBNQVggPSAxRTk7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWF9JTlQzMlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICAgKi9cclxuICBmdW5jdGlvbiBjbG9uZShjb25maWdPYmplY3QpIHtcclxuICAgIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICAgIFAgPSBCaWdOdW1iZXIucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQmlnTnVtYmVyLCB0b1N0cmluZzogbnVsbCwgdmFsdWVPZjogbnVsbCB9LFxyXG4gICAgICBPTkUgPSBuZXcgQmlnTnVtYmVyKDEpLFxyXG5cclxuXHJcbiAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgICAvLyBUaGUgZGVmYXVsdCB2YWx1ZXMgYmVsb3cgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZXMgc3RhdGVkLlxyXG4gICAgICAvLyBUaGUgdmFsdWVzIGNhbiBhbHNvIGJlIGNoYW5nZWQgYXQgcnVuLXRpbWUgdXNpbmcgQmlnTnVtYmVyLnNldC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICAgIERFQ0lNQUxfUExBQ0VTID0gMjAsICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBtb2RlIHVzZWQgd2hlbiByb3VuZGluZyB0byB0aGUgYWJvdmUgZGVjaW1hbCBwbGFjZXMsIGFuZCB3aGVuIHVzaW5nXHJcbiAgICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgICAgLy8gVVAgICAgICAgICAwIEF3YXkgZnJvbSB6ZXJvLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVG93YXJkcyB6ZXJvLlxyXG4gICAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUb3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgLy8gSEFMRl9VUCAgICA0IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB1cC5cclxuICAgICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgICAvLyBIQUxGX0VWRU4gIDYgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgZXZlbiBuZWlnaGJvdXIuXHJcbiAgICAgIC8vIEhBTEZfQ0VJTCAgNyBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIFJPVU5ESU5HX01PREUgPSA0LCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBFWFBPTkVOVElBTF9BVCA6IFtUT19FWFBfTkVHICwgVE9fRVhQX1BPU11cclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBOdW1iZXIgdHlwZTogLTdcclxuICAgICAgVE9fRVhQX05FRyA9IC03LCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAgLy8gTnVtYmVyIHR5cGU6IDIxXHJcbiAgICAgIFRPX0VYUF9QT1MgPSAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IHZhbHVlLCBhYm92ZSB3aGljaCBvdmVyZmxvdyB0byBJbmZpbml0eSBvY2N1cnMuXHJcbiAgICAgIC8vIE51bWJlciB0eXBlOiAgMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgICAgTUFYX0VYUCA9IDFlNywgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIE1BWFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAgIC8vIFRoZSBxdW90aWVudCAocSA9IGEgLyBuKSBpcyBjYWxjdWxhdGVkIGFjY29yZGluZyB0byB0aGUgY29ycmVzcG9uZGluZyByb3VuZGluZyBtb2RlLlxyXG4gICAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBVUCAgICAgICAgMCBUaGUgcmVtYWluZGVyIGlzIHBvc2l0aXZlIGlmIHRoZSBkaXZpZGVuZCBpcyBuZWdhdGl2ZSwgZWxzZSBpcyBuZWdhdGl2ZS5cclxuICAgICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoaXMgbW9kdWxvIG1vZGUgaXMgY29tbW9ubHkga25vd24gYXMgJ3RydW5jYXRlZCBkaXZpc2lvbicgYW5kIGlzXHJcbiAgICAgIC8vICAgICAgICAgICAgIGVxdWl2YWxlbnQgdG8gKGEgJSBuKSBpbiBKYXZhU2NyaXB0LlxyXG4gICAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiA2IFRoaXMgbW9kdWxvIG1vZGUgaW1wbGVtZW50cyB0aGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgOSBFdWNsaWRpYW4gZGl2aXNpb24uIHEgPSBzaWduKG4pICogZmxvb3IoYSAvIGFicyhuKSkuXHJcbiAgICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBUaGUgdHJ1bmNhdGVkIGRpdmlzaW9uLCBmbG9vcmVkIGRpdmlzaW9uLCBFdWNsaWRpYW4gZGl2aXNpb24gYW5kIElFRUUgNzU0IHJlbWFpbmRlclxyXG4gICAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgICAvLyBBbHRob3VnaCB0aGUgb3RoZXIgcm91bmRpbmcgbW9kZXMgY2FuIGFsc28gYmUgdXNlZCwgdGhleSBtYXkgbm90IGdpdmUgdXNlZnVsIHJlc3VsdHMuXHJcbiAgICAgIE1PRFVMT19NT0RFID0gMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAgIC8vIElmIFBPV19QUkVDSVNJT04gaXMgMCwgdGhlcmUgd2lsbCBiZSB1bmxpbWl0ZWQgc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICBQT1dfUFJFQ0lTSU9OID0gMCwgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICAgIEZPUk1BVCA9IHtcclxuICAgICAgICBwcmVmaXg6ICcnLFxyXG4gICAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3I6ICcsJyxcclxuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgICAgZnJhY3Rpb25Hcm91cFNlcGFyYXRvcjogJ1xceEEwJywgICAgICAvLyBub24tYnJlYWtpbmcgc3BhY2VcclxuICAgICAgICBzdWZmaXg6ICcnXHJcbiAgICAgIH0sXHJcblxyXG4gICAgICAvLyBUaGUgYWxwaGFiZXQgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLiBJdCBtdXN0IGJlIGF0IGxlYXN0IDIgY2hhcmFjdGVycyBsb25nLCB3aXRoIG5vICcrJyxcclxuICAgICAgLy8gJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICAgIEFMUEhBQkVUID0gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5eic7XHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAgIC8vIENPTlNUUlVDVE9SXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgQmlnTnVtYmVyIG9iamVjdC5cclxuICAgICAqXHJcbiAgICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAgICogW2JdIHtudW1iZXJ9IFRoZSBiYXNlIG9mIHYuIEludGVnZXIsIDIgdG8gQUxQSEFCRVQubGVuZ3RoIGluY2x1c2l2ZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgICAgdmFyIGFscGhhYmV0LCBjLCBjYXNlQ2hhbmdlZCwgZSwgaSwgaXNOdW0sIGxlbiwgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIEJpZ051bWJlcikpIHJldHVybiBuZXcgQmlnTnVtYmVyKHYsIGIpO1xyXG5cclxuICAgICAgaWYgKGIgPT0gbnVsbCkge1xyXG5cclxuICAgICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgICAgIGlmICghdi5jIHx8IHYuZSA+IE1BWF9FWFApIHtcclxuICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgIH0gZWxzZSBpZiAodi5lIDwgTUlOX0VYUCkge1xyXG4gICAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgICAgIHguYyA9IHYuYy5zbGljZSgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIFVzZSBgMSAvIG5gIHRvIGhhbmRsZSBtaW51cyB6ZXJvIGFsc28uXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAodiA9IC12LCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgICBpZiAodiA9PT0gfn52KSB7XHJcbiAgICAgICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwLCBlKyspO1xyXG5cclxuICAgICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICAgIHguYyA9IFt2XTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIGlmICghaXNOdW1lcmljLnRlc3Qoc3RyID0gU3RyaW5nKHYpKSkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSBzdHIuY2hhckNvZGVBdCgwKSA9PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSBleHBvbmVudC5cclxuICAgICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnN1YnN0cmluZygwLCBpKTtcclxuICAgICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgICAgIGUgPSBzdHIubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAgIC8vIEFsbG93IGV4cG9uZW50aWFsIG5vdGF0aW9uIHRvIGJlIHVzZWQgd2l0aCBiYXNlIDEwIGFyZ3VtZW50LCB3aGlsZVxyXG4gICAgICAgIC8vIGFsc28gcm91bmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYXMgd2l0aCBvdGhlciBiYXNlcy5cclxuICAgICAgICBpZiAoYiA9PSAxMCkge1xyXG4gICAgICAgICAgeCA9IG5ldyBCaWdOdW1iZXIodik7XHJcbiAgICAgICAgICByZXR1cm4gcm91bmQoeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0ciA9IFN0cmluZyh2KTtcclxuXHJcbiAgICAgICAgaWYgKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgICAvLyBBdm9pZCBwb3RlbnRpYWwgaW50ZXJwcmV0YXRpb24gb2YgSW5maW5pdHkgYW5kIE5hTiBhcyBiYXNlIDQ0KyB2YWx1ZXMuXHJcbiAgICAgICAgICBpZiAodiAqIDAgIT0gMCkgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBzdHIsIGlzTnVtLCBiKTtcclxuXHJcbiAgICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiB7bn0nXHJcbiAgICAgICAgICBpZiAoQmlnTnVtYmVyLkRFQlVHICYmIHN0ci5yZXBsYWNlKC9eMFxcLjAqfFxcLi8sICcnKS5sZW5ndGggPiAxNSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gc3RyLmNoYXJDb2RlQXQoMCkgPT09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGFscGhhYmV0ID0gQUxQSEFCRVQuc2xpY2UoMCwgYik7XHJcbiAgICAgICAgZSA9IGkgPSAwO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB0aGF0IHN0ciBpcyBhIHZhbGlkIGJhc2UgYiBudW1iZXIuXHJcbiAgICAgICAgLy8gRG9uJ3QgdXNlIFJlZ0V4cCwgc28gYWxwaGFiZXQgY2FuIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICBpZiAoYWxwaGFiZXQuaW5kZXhPZihjID0gc3RyLmNoYXJBdChpKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIGlmIChjID09ICcuJykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiAnLicgaXMgbm90IHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGl0IGhhcyBub3QgYmUgZm91bmQgYmVmb3JlLlxyXG4gICAgICAgICAgICAgIGlmIChpID4gZSkge1xyXG4gICAgICAgICAgICAgICAgZSA9IGxlbjtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghY2FzZUNoYW5nZWQpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQWxsb3cgZS5nLiBoZXhhZGVjaW1hbCAnRkYnIGFzIHdlbGwgYXMgJ2ZmJy5cclxuICAgICAgICAgICAgICBpZiAoc3RyID09IHN0ci50b1VwcGVyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9Mb3dlckNhc2UoKSkgfHxcclxuICAgICAgICAgICAgICAgICAgc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICAgIGNhc2VDaGFuZ2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGkgPSAtMTtcclxuICAgICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcGFyc2VOdW1lcmljKHgsIFN0cmluZyh2KSwgaXNOdW0sIGIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUHJldmVudCBsYXRlciBjaGVjayBmb3IgbGVuZ3RoIG9uIGNvbnZlcnRlZCBudW1iZXIuXHJcbiAgICAgICAgaXNOdW0gPSBmYWxzZTtcclxuICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZShzdHIsIGIsIDEwLCB4LnMpO1xyXG5cclxuICAgICAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgICAgIGlmICgoZSA9IHN0ci5pbmRleE9mKCcuJykpID4gLTEpIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICAgIGVsc2UgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQoLS1sZW4pID09PSA0ODspO1xyXG5cclxuICAgICAgaWYgKHN0ciA9IHN0ci5zbGljZShpLCArK2xlbikpIHtcclxuICAgICAgICBsZW4gLT0gaTtcclxuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE51bWJlciBwcmltaXRpdmUgaGFzIG1vcmUgdGhhbiAxNSBzaWduaWZpY2FudCBkaWdpdHM6IHtufSdcclxuICAgICAgICBpZiAoaXNOdW0gJiYgQmlnTnVtYmVyLkRFQlVHICYmXHJcbiAgICAgICAgICBsZW4gPiAxNSAmJiAodiA+IE1BWF9TQUZFX0lOVEVHRVIgfHwgdiAhPT0gbWF0aGZsb29yKHYpKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyAoeC5zICogdikpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICAgIGlmICgoZSA9IGUgLSBpIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgICAgfSBlbHNlIGlmIChlIDwgTUlOX0VYUCkge1xyXG5cclxuICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgICAvLyBUcmFuc2Zvcm0gYmFzZVxyXG5cclxuICAgICAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgICAgICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTsgIC8vIGkgPCAxXHJcblxyXG4gICAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgICAgaWYgKGkpIHguYy5wdXNoKCtzdHIuc2xpY2UoMCwgaSkpO1xyXG5cclxuICAgICAgICAgICAgZm9yIChsZW4gLT0gTE9HX0JBU0U7IGkgPCBsZW47KSB7XHJcbiAgICAgICAgICAgICAgeC5jLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGkgPSBMT0dfQkFTRSAtIChzdHIgPSBzdHIuc2xpY2UoaSkpLmxlbmd0aDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgeC5jLnB1c2goK3N0cik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBDT05TVFJVQ1RPUiBQUk9QRVJUSUVTXHJcblxyXG5cclxuICAgIEJpZ051bWJlci5jbG9uZSA9IGNsb25lO1xyXG5cclxuICAgIEJpZ051bWJlci5ST1VORF9VUCA9IDA7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRE9XTiA9IDE7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfRkxPT1IgPSAzO1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfVVAgPSA0O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICAgIEJpZ051bWJlci5ST1VORF9IQUxGX0NFSUwgPSA3O1xyXG4gICAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gICAgQmlnTnVtYmVyLkVVQ0xJRCA9IDk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBBY2NlcHQgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBvcHRpb25hbCBwcm9wZXJ0aWVzIChpZiB0aGUgdmFsdWUgb2YgYSBwcm9wZXJ0eSBpc1xyXG4gICAgICogYSBudW1iZXIsIGl0IG11c3QgYmUgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBzdGF0ZWQpOlxyXG4gICAgICpcclxuICAgICAqICAgREVDSU1BTF9QTEFDRVMgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgICAqICAgUk9VTkRJTkdfTU9ERSAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA4XHJcbiAgICAgKiAgIEVYUE9ORU5USUFMX0FUICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYICBvciAgWy1NQVggdG8gMCwgMCB0byBNQVhdXHJcbiAgICAgKiAgIFJBTkdFICAgICAgICAgICAge251bWJlcnxudW1iZXJbXX0gIC1NQVggdG8gTUFYIChub3QgemVybykgIG9yICBbLU1BWCB0byAtMSwgMSB0byBNQVhdXHJcbiAgICAgKiAgIENSWVBUTyAgICAgICAgICAge2Jvb2xlYW59ICAgICAgICAgIHRydWUgb3IgZmFsc2VcclxuICAgICAqICAgTU9EVUxPX01PREUgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA5XHJcbiAgICAgKiAgIFBPV19QUkVDSVNJT04gICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gTUFYXHJcbiAgICAgKiAgIEFMUEhBQkVUICAgICAgICAge3N0cmluZ30gICAgICAgICAgIEEgc3RyaW5nIG9mIHR3byBvciBtb3JlIHVuaXF1ZSBjaGFyYWN0ZXJzIHdoaWNoIGRvZXNcclxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90IGNvbnRhaW4gJy4nLlxyXG4gICAgICogICBGT1JNQVQgICAgICAgICAgIHtvYmplY3R9ICAgICAgICAgICBBbiBvYmplY3Qgd2l0aCBzb21lIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcclxuICAgICAqICAgICBwcmVmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZ3JvdXBTaXplICAgICAgICAgICAgICB7bnVtYmVyfVxyXG4gICAgICogICAgIHNlY29uZGFyeUdyb3VwU2l6ZSAgICAge251bWJlcn1cclxuICAgICAqICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgZGVjaW1hbFNlcGFyYXRvciAgICAgICB7c3RyaW5nfVxyXG4gICAgICogICAgIGZyYWN0aW9uR3JvdXBTaXplICAgICAge251bWJlcn1cclxuICAgICAqICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICAgKiAgICAgc3VmZml4ICAgICAgICAgICAgICAgICB7c3RyaW5nfVxyXG4gICAgICpcclxuICAgICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXHJcbiAgICAgKlxyXG4gICAgICogRS5nLlxyXG4gICAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICAgKlxyXG4gICAgICogSWdub3JlIHByb3BlcnRpZXMvcGFyYW1ldGVycyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWQsIGV4Y2VwdCBmb3IgQUxQSEFCRVQuXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGFuIG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIGN1cnJlbnQgdmFsdWVzLlxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgdmFyIHAsIHY7XHJcblxyXG4gICAgICBpZiAob2JqICE9IG51bGwpIHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgICAvLyBERUNJTUFMX1BMQUNFUyB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gREVDSU1BTF9QTEFDRVMge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0RFQ0lNQUxfUExBQ0VTJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgTUFYLCBwKTtcclxuICAgICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJPVU5ESU5HX01PREUge251bWJlcn0gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBST1VORElOR19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdST1VORElOR19NT0RFJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaW50Q2hlY2sodiwgMCwgOCwgcCk7XHJcbiAgICAgICAgICAgIFJPVU5ESU5HX01PREUgPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIHtudW1iZXJ8bnVtYmVyW119XHJcbiAgICAgICAgICAvLyBJbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAgIC8vIFtpbnRlZ2VyIC1NQVggdG8gMCBpbmNsdXNpdmUsIDAgdG8gTUFYIGluY2x1c2l2ZV0uXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRVhQT05FTlRJQUxfQVQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0VYUE9ORU5USUFMX0FUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAwLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIFRPX0VYUF9QT1MgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgVE9fRVhQX05FRyA9IC0oVE9fRVhQX1BPUyA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJBTkdFIHtudW1iZXJ8bnVtYmVyW119IE5vbi16ZXJvIGludGVnZXIsIC1NQVggdG8gTUFYIGluY2x1c2l2ZSBvclxyXG4gICAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAtMSBpbmNsdXNpdmUsIGludGVnZXIgMSB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBSQU5HRSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V8Y2Fubm90IGJlIHplcm99OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUkFOR0UnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHZbMF0sIC1NQVgsIC0xLCBwKTtcclxuICAgICAgICAgICAgICBpbnRDaGVjayh2WzFdLCAxLCBNQVgsIHApO1xyXG4gICAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdO1xyXG4gICAgICAgICAgICAgIE1BWF9FWFAgPSB2WzFdO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgICAgaWYgKHYpIHtcclxuICAgICAgICAgICAgICAgIE1JTl9FWFAgPSAtKE1BWF9FWFAgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgY2Fubm90IGJlIHplcm86ICcgKyB2KTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW59IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQ1JZUFRPIG5vdCB0cnVlIG9yIGZhbHNlOiB7dn0nXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gY3J5cHRvIHVuYXZhaWxhYmxlJ1xyXG4gICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0NSWVBUTycpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGlmICh2ID09PSAhIXYpIHtcclxuICAgICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8gIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvICYmXHJcbiAgICAgICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgQ1JZUFRPID0gIXY7XHJcbiAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnY3J5cHRvIHVuYXZhaWxhYmxlJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIENSWVBUTyA9IHY7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIG5vdCB0cnVlIG9yIGZhbHNlOiAnICsgdik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBNT0RVTE9fTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDkgaW5jbHVzaXZlLlxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE1PRFVMT19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdNT0RVTE9fTU9ERScpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIDksIHApO1xyXG4gICAgICAgICAgICBNT0RVTE9fTU9ERSA9IHY7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gUE9XX1BSRUNJU0lPTiB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUE9XX1BSRUNJU0lPTicpKSB7XHJcbiAgICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFBPV19QUkVDSVNJT04gPSB2O1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIEZPUk1BVCB7b2JqZWN0fVxyXG4gICAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEZPUk1BVCBub3QgYW4gb2JqZWN0OiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRk9STUFUJykpIHtcclxuICAgICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdvYmplY3QnKSBGT1JNQVQgPSB2O1xyXG4gICAgICAgICAgICBlbHNlIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBub3QgYW4gb2JqZWN0OiAnICsgdik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gQUxQSEFCRVQge3N0cmluZ31cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBBTFBIQUJFVCBpbnZhbGlkOiB7dn0nXHJcbiAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnQUxQSEFCRVQnKSkge1xyXG4gICAgICAgICAgICB2ID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAgICAgLy8gRGlzYWxsb3cgaWYgbGVzcyB0aGFuIHR3byBjaGFyYWN0ZXJzLFxyXG4gICAgICAgICAgICAvLyBvciBpZiBpdCBjb250YWlucyAnKycsICctJywgJy4nLCB3aGl0ZXNwYWNlLCBvciBhIHJlcGVhdGVkIGNoYXJhY3Rlci5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdzdHJpbmcnICYmICEvXi4/JHxbK1xcLS5cXHNdfCguKS4qXFwxLy50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgICAgQUxQSEFCRVQgPSB2O1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGludmFsaWQ6ICcgKyB2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBPYmplY3QgZXhwZWN0ZWQ6IHt2fSdcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ09iamVjdCBleHBlY3RlZDogJyArIG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIERFQ0lNQUxfUExBQ0VTOiBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICBST1VORElOR19NT0RFOiBST1VORElOR19NT0RFLFxyXG4gICAgICAgIEVYUE9ORU5USUFMX0FUOiBbVE9fRVhQX05FRywgVE9fRVhQX1BPU10sXHJcbiAgICAgICAgUkFOR0U6IFtNSU5fRVhQLCBNQVhfRVhQXSxcclxuICAgICAgICBDUllQVE86IENSWVBUTyxcclxuICAgICAgICBNT0RVTE9fTU9ERTogTU9EVUxPX01PREUsXHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTjogUE9XX1BSRUNJU0lPTixcclxuICAgICAgICBGT1JNQVQ6IEZPUk1BVCxcclxuICAgICAgICBBTFBIQUJFVDogQUxQSEFCRVRcclxuICAgICAgfTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB2IGlzIGEgQmlnTnVtYmVyIGluc3RhbmNlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIElmIEJpZ051bWJlci5ERUJVRyBpcyB0cnVlLCB0aHJvdyBpZiBhIEJpZ051bWJlciBpbnN0YW5jZSBpcyBub3Qgd2VsbC1mb3JtZWQuXHJcbiAgICAgKlxyXG4gICAgICogdiB7YW55fVxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBJbnZhbGlkIEJpZ051bWJlcjoge3Z9J1xyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgICBpZiAoIXYgfHwgdi5faXNCaWdOdW1iZXIgIT09IHRydWUpIHJldHVybiBmYWxzZTtcclxuICAgICAgaWYgKCFCaWdOdW1iZXIuREVCVUcpIHJldHVybiB0cnVlO1xyXG5cclxuICAgICAgdmFyIGksIG4sXHJcbiAgICAgICAgYyA9IHYuYyxcclxuICAgICAgICBlID0gdi5lLFxyXG4gICAgICAgIHMgPSB2LnM7XHJcblxyXG4gICAgICBvdXQ6IGlmICh7fS50b1N0cmluZy5jYWxsKGMpID09ICdbb2JqZWN0IEFycmF5XScpIHtcclxuXHJcbiAgICAgICAgaWYgKChzID09PSAxIHx8IHMgPT09IC0xKSAmJiBlID49IC1NQVggJiYgZSA8PSBNQVggJiYgZSA9PT0gbWF0aGZsb29yKGUpKSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgemVybywgdGhlIEJpZ051bWJlciB2YWx1ZSBtdXN0IGJlIHplcm8uXHJcbiAgICAgICAgICBpZiAoY1swXSA9PT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoZSA9PT0gMCAmJiBjLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyB0aGF0IGNbMF0gc2hvdWxkIGhhdmUsIGJhc2VkIG9uIHRoZSBleHBvbmVudC5cclxuICAgICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgICBpZiAoaSA8IDEpIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgLy8gQ2FsY3VsYXRlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgICAgICAgIC8vaWYgKE1hdGguY2VpbChNYXRoLmxvZyhjWzBdICsgMSkgLyBNYXRoLkxOMTApID09IGkpIHtcclxuICAgICAgICAgIGlmIChTdHJpbmcoY1swXSkubGVuZ3RoID09IGkpIHtcclxuXHJcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgbiA9IGNbaV07XHJcbiAgICAgICAgICAgICAgaWYgKG4gPCAwIHx8IG4gPj0gQkFTRSB8fCBuICE9PSBtYXRoZmxvb3IobikpIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgLy8gTGFzdCBlbGVtZW50IGNhbm5vdCBiZSB6ZXJvLCB1bmxlc3MgaXQgaXMgdGhlIG9ubHkgZWxlbWVudC5cclxuICAgICAgICAgICAgaWYgKG4gIT09IDApIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIC8vIEluZmluaXR5L05hTlxyXG4gICAgICB9IGVsc2UgaWYgKGMgPT09IG51bGwgJiYgZSA9PT0gbnVsbCAmJiAocyA9PT0gbnVsbCB8fCBzID09PSAxIHx8IHMgPT09IC0xKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdJbnZhbGlkIEJpZ051bWJlcjogJyArIHYpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWF4aW11bSA9IEJpZ051bWJlci5tYXggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAubHQpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBCaWdOdW1iZXIubWluaW11bSA9IEJpZ051bWJlci5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiBtYXhPck1pbihhcmd1bWVudHMsIFAuZ3QpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2l0aCBhIHJhbmRvbSB2YWx1ZSBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gMCBhbmQgbGVzcyB0aGFuIDEsXHJcbiAgICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgICAqIHplcm9zIGFyZSBwcm9kdWNlZCkuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB9J1xyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgICAqL1xyXG4gICAgQmlnTnVtYmVyLnJhbmRvbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBhIDUzIGJpdCBpbnRlZ2VyIG4sIHdoZXJlIDAgPD0gbiA8IDkwMDcxOTkyNTQ3NDA5OTIuXHJcbiAgICAgIC8vIENoZWNrIGlmIE1hdGgucmFuZG9tKCkgcHJvZHVjZXMgbW9yZSB0aGFuIDMyIGJpdHMgb2YgcmFuZG9tbmVzcy5cclxuICAgICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAgIC8vIDB4NDAwMDAwMDAgaXMgMl4zMCwgMHg4MDAwMDAgaXMgMl4yMywgMHgxZmZmZmYgaXMgMl4yMSAtIDEuXHJcbiAgICAgIHZhciByYW5kb201M2JpdEludCA9IChNYXRoLnJhbmRvbSgpICogcG93Ml81MykgJiAweDFmZmZmZlxyXG4gICAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICgoTWF0aC5yYW5kb20oKSAqIDB4NDAwMDAwMDAgfCAwKSAqIDB4ODAwMDAwKSArXHJcbiAgICAgICAgIChNYXRoLnJhbmRvbSgpICogMHg4MDAwMDAgfCAwKTsgfTtcclxuXHJcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgICB2YXIgYSwgYiwgZSwgaywgdixcclxuICAgICAgICAgIGkgPSAwLFxyXG4gICAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgICAgcmFuZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuXHJcbiAgICAgICAgaWYgKGRwID09IG51bGwpIGRwID0gREVDSU1BTF9QTEFDRVM7XHJcbiAgICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKGRwIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICBpZiAoQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgICAgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIGEgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheShrICo9IDIpKTtcclxuXHJcbiAgICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gNTMgYml0czpcclxuICAgICAgICAgICAgICAvLyAoKE1hdGgucG93KDIsIDMyKSAtIDEpICogTWF0aC5wb3coMiwgMjEpKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgICAgLy8gKChNYXRoLnBvdygyLCAzMikgLSAxKSA+Pj4gMTEpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTExMTEgMTExMTExMTEgMTExMTExMTFcclxuICAgICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgICAgdiA9IGFbaV0gKiAweDIwMDAwICsgKGFbaSArIDFdID4+PiAxMSk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFJlamVjdGlvbiBzYW1wbGluZzpcclxuICAgICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgICAgLy8gUHJvYmFiaWxpdHkgdGhhdCB2ID49IDllMTUsIGlzXHJcbiAgICAgICAgICAgICAgLy8gNzE5OTI1NDc0MDk5MiAvIDkwMDcxOTkyNTQ3NDA5OTIgfj0gMC4wMDA4LCBpLmUuIDEgaW4gMTI1MVxyXG4gICAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICAgIGIgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgyKSk7XHJcbiAgICAgICAgICAgICAgICBhW2ldID0gYlswXTtcclxuICAgICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIDAgPD0gdiA8PSA4OTk5OTk5OTk5OTk5OTk5XHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDI7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgICAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJ1ZmZlclxyXG4gICAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDB4MTAwMDAwMDAwMDAwMCBpcyAyXjQ4LCAweDEwMDAwMDAwMDAwIGlzIDJeNDBcclxuICAgICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDwgOTAwNzE5OTI1NDc0MDk5MlxyXG4gICAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyAyXSAqIDB4MTAwMDAwMDAwKSArIChhW2kgKyAzXSAqIDB4MTAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAgIChhW2kgKyA0XSA8PCAxNikgKyAoYVtpICsgNV0gPDwgOCkgKyBhW2kgKyA2XTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDcpLmNvcHkoYSwgaSk7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAgIGMucHVzaCh2ICUgMWUxNCk7XHJcbiAgICAgICAgICAgICAgICBpICs9IDc7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGkgPSBrIC8gNztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIENSWVBUTyA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICAgIGlmICghQ1JZUFRPKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG4gICAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgICAgaWYgKHYgPCA5ZTE1KSBjW2krK10gPSB2ICUgMWUxNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGsgPSBjWy0taV07XHJcbiAgICAgICAgZHAgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgICBpZiAoayAmJiBkcCkge1xyXG4gICAgICAgICAgdiA9IFBPV1NfVEVOW0xPR19CQVNFIC0gZHBdO1xyXG4gICAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgbGVhZGluZyBlbGVtZW50cyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgLy8gQ291bnQgdGhlIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvZiBjIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLCBhbmQuLi5cclxuICAgICAgICAgIGZvciAoaSA9IDEsIHYgPSBjWzBdOyB2ID49IDEwOyB2IC89IDEwLCBpKyspO1xyXG5cclxuICAgICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgICBpZiAoaSA8IExPR19CQVNFKSBlIC09IExPR19CQVNFIC0gaTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgICAgcmFuZC5jID0gYztcclxuICAgICAgICByZXR1cm4gcmFuZDtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gICAgICpcclxuICAgICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICAgKi9cclxuICAgIEJpZ051bWJlci5zdW0gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBpID0gMSxcclxuICAgICAgICBhcmdzID0gYXJndW1lbnRzLFxyXG4gICAgICAgIHN1bSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcbiAgICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgICByZXR1cm4gc3VtO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gICAgLy8gQ2FsbGVkIGJ5IEJpZ051bWJlciBhbmQgQmlnTnVtYmVyLnByb3RvdHlwZS50b1N0cmluZy5cclxuICAgIGNvbnZlcnRCYXNlID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgICAvKlxyXG4gICAgICAgKiBDb252ZXJ0IHN0cmluZyBvZiBiYXNlSW4gdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBiYXNlT3V0LlxyXG4gICAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgICAqIEVnLiB0b0Jhc2VPdXQoJ2ZmJywgMTYsIDEwKSByZXR1cm5zIFsyLCA1LCA1XS5cclxuICAgICAgICovXHJcbiAgICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgICB2YXIgaixcclxuICAgICAgICAgIGFyciA9IFswXSxcclxuICAgICAgICAgIGFyckwsXHJcbiAgICAgICAgICBpID0gMCxcclxuICAgICAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgICAgZm9yIChhcnJMID0gYXJyLmxlbmd0aDsgYXJyTC0tOyBhcnJbYXJyTF0gKj0gYmFzZUluKTtcclxuXHJcbiAgICAgICAgICBhcnJbMF0gKz0gYWxwaGFiZXQuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG5cclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICAgIGlmIChhcnJbal0gPiBiYXNlT3V0IC0gMSkge1xyXG4gICAgICAgICAgICAgIGlmIChhcnJbaiArIDFdID09IG51bGwpIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgICAgYXJyW2pdICU9IGJhc2VPdXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZUluIHRvIGEgbnVtZXJpYyBzdHJpbmcgb2YgYmFzZU91dC5cclxuICAgICAgLy8gSWYgdGhlIGNhbGxlciBpcyB0b1N0cmluZywgd2UgYXJlIGNvbnZlcnRpbmcgZnJvbSBiYXNlIDEwIHRvIGJhc2VPdXQuXHJcbiAgICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHN0ciwgYmFzZUluLCBiYXNlT3V0LCBzaWduLCBjYWxsZXJJc1RvU3RyaW5nKSB7XHJcbiAgICAgICAgdmFyIGFscGhhYmV0LCBkLCBlLCBrLCByLCB4LCB4YywgeSxcclxuICAgICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgICAgZHAgPSBERUNJTUFMX1BMQUNFUyxcclxuICAgICAgICAgIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuXHJcbiAgICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgICAgaWYgKGkgPj0gMCkge1xyXG4gICAgICAgICAgayA9IFBPV19QUkVDSVNJT047XHJcblxyXG4gICAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSAwO1xyXG4gICAgICAgICAgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgICAgeCA9IHkucG93KHN0ci5sZW5ndGggLSBpKTtcclxuICAgICAgICAgIFBPV19QUkVDSVNJT04gPSBrO1xyXG5cclxuICAgICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAgIC8vIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlci5cclxuXHJcbiAgICAgICAgICB5LmMgPSB0b0Jhc2VPdXQodG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcoeC5jKSwgeC5lLCAnMCcpLFxyXG4gICAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICAgIHkuZSA9IHkuYy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgICAgeGMgPSB0b0Jhc2VPdXQoc3RyLCBiYXNlSW4sIGJhc2VPdXQsIGNhbGxlcklzVG9TdHJpbmdcclxuICAgICAgICAgPyAoYWxwaGFiZXQgPSBBTFBIQUJFVCwgZGVjaW1hbClcclxuICAgICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgYXMgYW4gaW50ZWdlciBhbmQgY29udmVydGVkIHRvIGJhc2VPdXQuIGUgaXMgdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGUgPSBrID0geGMubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7IHhjWy0ta10gPT0gMDsgeGMucG9wKCkpO1xyXG5cclxuICAgICAgICAvLyBaZXJvP1xyXG4gICAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAgIC8vIERvZXMgc3RyIHJlcHJlc2VudCBhbiBpbnRlZ2VyPyBJZiBzbywgbm8gbmVlZCBmb3IgdGhlIGRpdmlzaW9uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgLS1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4LmMgPSB4YztcclxuICAgICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIHNpZ24gaXMgbmVlZGVkIGZvciBjb3JyZWN0IHJvdW5kaW5nLlxyXG4gICAgICAgICAgeC5zID0gc2lnbjtcclxuICAgICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICAgIHhjID0geC5jO1xyXG4gICAgICAgICAgciA9IHgucjtcclxuICAgICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyB4YyBub3cgcmVwcmVzZW50cyBzdHIgY29udmVydGVkIHRvIGJhc2VPdXQuXHJcblxyXG4gICAgICAgIC8vIFRIZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgZCA9IGUgKyBkcCArIDE7XHJcblxyXG4gICAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdDogdGhlIGRpZ2l0IHRvIHRoZSByaWdodCBvZiB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAgIC8vIExvb2sgYXQgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhbmQgbW9kZSB0byBkZXRlcm1pbmUgd2hldGhlciB0byByb3VuZCB1cC5cclxuXHJcbiAgICAgICAgayA9IGJhc2VPdXQgLyAyO1xyXG4gICAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0ID8gKGkgIT0gbnVsbCB8fCByKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgICAgICAgICA6IGkgPiBrIHx8IGkgPT0gayAmJihybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJiB4Y1tkIC0gMV0gJiAxIHx8XHJcbiAgICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGluZGV4IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBub3QgZ3JlYXRlciB0aGFuIHplcm8sIG9yIHhjIHJlcHJlc2VudHNcclxuICAgICAgICAvLyB6ZXJvLCB0aGVuIHRoZSByZXN1bHQgb2YgdGhlIGJhc2UgY29udmVyc2lvbiBpcyB6ZXJvIG9yLCBpZiByb3VuZGluZyB1cCwgYSB2YWx1ZVxyXG4gICAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgICBpZiAoZCA8IDEgfHwgIXhjWzBdKSB7XHJcblxyXG4gICAgICAgICAgLy8gMV4tZHAgb3IgMFxyXG4gICAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIFRydW5jYXRlIHhjIHRvIHRoZSByZXF1aXJlZCBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICAgIGZvciAoLS1iYXNlT3V0OyArK3hjWy0tZF0gPiBiYXNlT3V0Oykge1xyXG4gICAgICAgICAgICAgIHhjW2RdID0gMDtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgICB4YyA9IFsxXS5jb25jYXQoeGMpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoayA9IHhjLmxlbmd0aDsgIXhjWy0ta107KTtcclxuXHJcbiAgICAgICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVyb3MsIGRlY2ltYWwgcG9pbnQgYW5kIHRyYWlsaW5nIHplcm9zIGFzIHJlcXVpcmVkLlxyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgYWxwaGFiZXQuY2hhckF0KDApKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFRoZSBjYWxsZXIgd2lsbCBhZGQgdGhlIHNpZ24uXHJcbiAgICAgICAgcmV0dXJuIHN0cjtcclxuICAgICAgfTtcclxuICAgIH0pKCk7XHJcblxyXG5cclxuICAgIC8vIFBlcmZvcm0gZGl2aXNpb24gaW4gdGhlIHNwZWNpZmllZCBiYXNlLiBDYWxsZWQgYnkgZGl2IGFuZCBjb252ZXJ0QmFzZS5cclxuICAgIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgICAvLyBBc3N1bWUgbm9uLXplcm8geCBhbmQgay5cclxuICAgICAgZnVuY3Rpb24gbXVsdGlwbHkoeCwgaywgYmFzZSkge1xyXG4gICAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICAgIGNhcnJ5ID0gMCxcclxuICAgICAgICAgIGkgPSB4Lmxlbmd0aCxcclxuICAgICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAgICBraGkgPSBrIC8gU1FSVF9CQVNFIHwgMDtcclxuXHJcbiAgICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgICAgeGhpID0geFtpXSAvIFNRUlRfQkFTRSB8IDA7XHJcbiAgICAgICAgICBtID0ga2hpICogeGxvICsgeGhpICoga2xvO1xyXG4gICAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgICBjYXJyeSA9ICh0ZW1wIC8gYmFzZSB8IDApICsgKG0gLyBTUVJUX0JBU0UgfCAwKSArIGtoaSAqIHhoaTtcclxuICAgICAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYXJyeSkgeCA9IFtjYXJyeV0uY29uY2F0KHgpO1xyXG5cclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgICB2YXIgaSwgY21wO1xyXG5cclxuICAgICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICAgIGNtcCA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgICAgaWYgKGFbaV0gIT0gYltpXSkge1xyXG4gICAgICAgICAgICAgIGNtcCA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gY21wO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB4OiBkaXZpZGVuZCwgeTogZGl2aXNvci5cclxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgICB2YXIgY21wLCBlLCBpLCBtb3JlLCBuLCBwcm9kLCBwcm9kTCwgcSwgcWMsIHJlbSwgcmVtTCwgcmVtMCwgeGksIHhMLCB5YzAsXHJcbiAgICAgICAgICB5TCwgeXosXHJcbiAgICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgICAgeWMgPSB5LmM7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgICAgaWYgKCF4YyB8fCAheGNbMF0gfHwgIXljIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKFxyXG5cclxuICAgICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgICAheC5zIHx8ICF5LnMgfHwgKHhjID8geWMgJiYgeGNbMF0gPT0geWNbMF0gOiAheWMpID8gTmFOIDpcclxuXHJcbiAgICAgICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyDCsTAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIMKxMC5cclxuICAgICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgICBxYyA9IHEuYyA9IFtdO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICAgIGlmICghYmFzZSkge1xyXG4gICAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgICAgcyA9IHMgLyBMT0dfQkFTRSB8IDA7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgICAvLyBUaGUgY29lZmZpY2llbnRzIG9mIHRoZSBCaWdOdW1iZXJzIGZyb20gY29udmVydEJhc2UgbWF5IGhhdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0gMDsgeWNbaV0gPT0gKHhjW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgICAgaWYgKHMgPCAwKSB7XHJcbiAgICAgICAgICBxYy5wdXNoKDEpO1xyXG4gICAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgIHMgKz0gMjtcclxuXHJcbiAgICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgICAgbiA9IG1hdGhmbG9vcihiYXNlIC8gKHljWzBdICsgMSkpO1xyXG5cclxuICAgICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBoYW5kbGUgb2RkIGJhc2VzIHdoZXJlIHljWzBdID09IChiYXNlIC8gMikgLSAxLlxyXG4gICAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICAgIGlmIChuID4gMSkge1xyXG4gICAgICAgICAgICB5YyA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgIHlMID0geWMubGVuZ3RoO1xyXG4gICAgICAgICAgICB4TCA9IHhjLmxlbmd0aDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB4aSA9IHlMO1xyXG4gICAgICAgICAgcmVtID0geGMuc2xpY2UoMCwgeUwpO1xyXG4gICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgLy8gQWRkIHplcm9zIHRvIG1ha2UgcmVtYWluZGVyIGFzIGxvbmcgYXMgZGl2aXNvci5cclxuICAgICAgICAgIGZvciAoOyByZW1MIDwgeUw7IHJlbVtyZW1MKytdID0gMCk7XHJcbiAgICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICB5eiA9IFswXS5jb25jYXQoeXopO1xyXG4gICAgICAgICAgeWMwID0geWNbMF07XHJcbiAgICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIHByZXZlbnQgdHJpYWwgZGlnaXQgbiA+IGJhc2UsIHdoZW4gdXNpbmcgYmFzZSAzLlxyXG4gICAgICAgICAgLy8gZWxzZSBpZiAoYmFzZSA9PSAzICYmIHljMCA9PSAxKSB5YzAgPSAxICsgMWUtMTU7XHJcblxyXG4gICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBuID0gMDtcclxuXHJcbiAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIG4gPSBtYXRoZmxvb3IocmVtMCAvIHljMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAgIC8vICBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCBpcyBncmVhdGVyIHRoYW4gcmVtYWluZGVyOlxyXG4gICAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgICAgLy8gIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gIElmIHByb2R1Y3Qgd2FzIGxlc3MgdGhhbiByZW1haW5kZXIgYXQgdGhlIGxhc3QgY29tcGFyZTpcclxuICAgICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgICAgLy8gICAgSWYgcmVtYWluZGVyIGlzIGdyZWF0ZXIgdGhhbiBkaXZpc29yOlxyXG4gICAgICAgICAgICAgIC8vICAgICAgU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlciwgaW5jcmVtZW50IHRyaWFsIGRpZ2l0LlxyXG5cclxuICAgICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIG1heSBiZSA+IGJhc2Ugb25seSB3aGVuIGJhc2UgaXMgMy5cclxuICAgICAgICAgICAgICAgIGlmIChuID49IGJhc2UpIG4gPSBiYXNlIC0gMTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IG11bHRpcGx5KHljLCBuLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIHByb2R1Y3QgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3QgPiByZW1haW5kZXIgdGhlbiB0cmlhbCBkaWdpdCBuIHRvbyBoaWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAgIC8vIGV2ZXIgYmVlbiBtb3JlIHRoYW4gMSB0b28gaGlnaC5cclxuICAgICAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKHByb2QsIHJlbSwgcHJvZEwsIHJlbUwpID09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICAgIHN1YnRyYWN0KHByb2QsIHlMIDwgcHJvZEwgPyB5eiA6IHljLCBwcm9kTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgIGNtcCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBuIGlzIDAgb3IgMSwgY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgbiBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWMgYW5kIHJlbSBhZ2FpbiBiZWxvdyxcclxuICAgICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAgIC8vIElmIG4gaXMgMSwgbGVhdmUgY21wIGFzIC0xLCBzbyB5YyBhbmQgcmVtIGFyZSBjb21wYXJlZCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIGlmIChuID09IDApIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgICBjbXAgPSBuID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgICAgcHJvZCA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgICAgICAgICBwcm9kTCA9IHByb2QubGVuZ3RoO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZCA9IFswXS5jb25jYXQocHJvZCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIG5ldyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgbmV3IHJlbWFpbmRlciwgc3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAgIC8vIG4gaXMgMSB0b28gbG93IGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgdmVyeSByYXJlbHkgMiB0b28gbG93LlxyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoeWMsIHJlbSwgeUwsIHJlbUwpIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWMsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgbisrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbmV4dCBkaWdpdCwgbiwgdG8gdGhlIHJlc3VsdCBhcnJheS5cclxuICAgICAgICAgICAgcWNbaSsrXSA9IG47XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgaWYgKHJlbVswXSkge1xyXG4gICAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGNbeGldIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgcmVtID0gW3hjW3hpXV07XHJcbiAgICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9IG51bGwpICYmIHMtLSk7XHJcblxyXG4gICAgICAgICAgbW9yZSA9IHJlbVswXSAhPSBudWxsO1xyXG5cclxuICAgICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICAgIGlmICghcWNbMF0pIHFjLnNwbGljZSgwLCAxKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWNbMF0uXHJcbiAgICAgICAgICBmb3IgKGkgPSAxLCBzID0gcWNbMF07IHMgPj0gMTA7IHMgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgICAvLyBDYWxsZXIgaXMgY29udmVydEJhc2UuXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgICBxLnIgPSArbW9yZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBxO1xyXG4gICAgICB9O1xyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIEJpZ051bWJlciBuIGluIGZpeGVkLXBvaW50IG9yIGV4cG9uZW50aWFsXHJcbiAgICAgKiBub3RhdGlvbiByb3VuZGVkIHRvIHRoZSBzcGVjaWZpZWQgZGVjaW1hbCBwbGFjZXMgb3Igc2lnbmlmaWNhbnQgZGlnaXRzLlxyXG4gICAgICpcclxuICAgICAqIG46IGEgQmlnTnVtYmVyLlxyXG4gICAgICogaTogdGhlIGluZGV4IG9mIHRoZSBsYXN0IGRpZ2l0IHJlcXVpcmVkIChpLmUuIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwKS5cclxuICAgICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgICAqIGlkOiAxICh0b0V4cG9uZW50aWFsKSBvciAyICh0b1ByZWNpc2lvbikuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgICAgdmFyIGMwLCBlLCBuZSwgbGVuLCBzdHI7XHJcblxyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIGlmICghbi5jKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgYzAgPSBuLmNbMF07XHJcbiAgICAgIG5lID0gbi5lO1xyXG5cclxuICAgICAgaWYgKGkgPT0gbnVsbCkge1xyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgbmUpXHJcbiAgICAgICAgIDogdG9GaXhlZFBvaW50KHN0ciwgbmUsICcwJyk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIGksIHJtKTtcclxuXHJcbiAgICAgICAgLy8gbi5lIG1heSBoYXZlIGNoYW5nZWQgaWYgdGhlIHZhbHVlIHdhcyByb3VuZGVkIHVwLlxyXG4gICAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICAgIHN0ciA9IGNvZWZmVG9TdHJpbmcobi5jKTtcclxuICAgICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG5cclxuICAgICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgICAgLy8gc3BlY2lmaWVkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBuZWNlc3NhcnkgdG8gcmVwcmVzZW50IHRoZSBpbnRlZ2VyXHJcbiAgICAgICAgLy8gcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24uXHJcblxyXG4gICAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAgIGlmIChpZCA9PSAxIHx8IGlkID09IDIgJiYgKGkgPD0gZSB8fCBlIDw9IFRPX0VYUF9ORUcpKSB7XHJcblxyXG4gICAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICAgIHN0ciA9IHRvRXhwb25lbnRpYWwoc3RyLCBlKTtcclxuXHJcbiAgICAgICAgLy8gRml4ZWQtcG9pbnQgbm90YXRpb24uXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgLT0gbmU7XHJcbiAgICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgICAgIC8vIEFwcGVuZCB6ZXJvcz9cclxuICAgICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoLS1pID4gMCkgZm9yIChzdHIgKz0gJy4nOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgICBpZiAoaSA+IDApIHtcclxuICAgICAgICAgICAgICBpZiAoZSArIDEgPT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbi5zIDwgMCAmJiBjMCA/ICctJyArIHN0ciA6IHN0cjtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLy8gSGFuZGxlIEJpZ051bWJlci5tYXggYW5kIEJpZ051bWJlci5taW4uXHJcbiAgICBmdW5jdGlvbiBtYXhPck1pbihhcmdzLCBtZXRob2QpIHtcclxuICAgICAgdmFyIG4sXHJcbiAgICAgICAgaSA9IDEsXHJcbiAgICAgICAgbSA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihhcmdzW2ldKTtcclxuXHJcbiAgICAgICAgLy8gSWYgYW55IG51bWJlciBpcyBOYU4sIHJldHVybiBOYU4uXHJcbiAgICAgICAgaWYgKCFuLnMpIHtcclxuICAgICAgICAgIG0gPSBuO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChtZXRob2QuY2FsbChtLCBuKSkge1xyXG4gICAgICAgICAgbSA9IG47XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAgICogQ2FsbGVkIGJ5IG1pbnVzLCBwbHVzIGFuZCB0aW1lcy5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgICAgdmFyIGkgPSAxLFxyXG4gICAgICAgIGogPSBjLmxlbmd0aDtcclxuXHJcbiAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyAhY1stLWpdOyBjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYmFzZSAxMCBleHBvbmVudC4gRmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIGNbMF0uXHJcbiAgICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKChlID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpID4gTUFYX0VYUCkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICBuLmMgPSBuLmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgbi5jID0gW24uZSA9IDBdO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4uZSA9IGU7XHJcbiAgICAgICAgbi5jID0gYztcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICAgIHBhcnNlTnVtZXJpYyA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciBiYXNlUHJlZml4ID0gL14oLT8pMChbeGJvXSkoPz1cXHdbXFx3Ll0qJCkvaSxcclxuICAgICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICAgIGRvdEJlZm9yZSA9IC9eXFwuKFteLl0rKSQvLFxyXG4gICAgICAgIGlzSW5maW5pdHlPck5hTiA9IC9eLT8oSW5maW5pdHl8TmFOKSQvLFxyXG4gICAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKHgsIHN0ciwgaXNOdW0sIGIpIHtcclxuICAgICAgICB2YXIgYmFzZSxcclxuICAgICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgICAgLy8gTm8gZXhjZXB0aW9uIG9uIMKxSW5maW5pdHkgb3IgTmFOLlxyXG4gICAgICAgIGlmIChpc0luZmluaXR5T3JOYU4udGVzdChzKSkge1xyXG4gICAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGlmICghaXNOdW0pIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoYmFzZVByZWZpeCwgZnVuY3Rpb24gKG0sIHAxLCBwMikge1xyXG4gICAgICAgICAgICAgIGJhc2UgPSAocDIgPSBwMi50b0xvd2VyQ2FzZSgpKSA9PSAneCcgPyAxNiA6IHAyID09ICdiJyA/IDIgOiA4O1xyXG4gICAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgaWYgKGIpIHtcclxuICAgICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgICAgLy8gRS5nLiAnMS4nIHRvICcxJywgJy4xJyB0byAnMC4xJ1xyXG4gICAgICAgICAgICAgIHMgPSBzLnJlcGxhY2UoZG90QWZ0ZXIsICckMScpLnJlcGxhY2UoZG90QmVmb3JlLCAnMC4kMScpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBpZiAoc3RyICE9IHMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHMsIGJhc2UpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBiYXNlIHtifSBudW1iZXI6IHtufSdcclxuICAgICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnTm90IGEnICsgKGIgPyAnIGJhc2UgJyArIGIgOiAnJykgKyAnIG51bWJlcjogJyArIHN0cik7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgICB4LnMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfSkoKTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJvdW5kIHggdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0uIENoZWNrIGZvciBvdmVyL3VuZGVyLWZsb3cuXHJcbiAgICAgKiBJZiByIGlzIHRydXRoeSwgaXQgaXMga25vd24gdGhhdCB0aGVyZSBhcmUgbW9yZSBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiByb3VuZCh4LCBzZCwgcm0sIHIpIHtcclxuICAgICAgdmFyIGQsIGksIGosIGssIG4sIG5pLCByZCxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICBwb3dzMTAgPSBQT1dTX1RFTjtcclxuXHJcbiAgICAgIC8vIGlmIHggaXMgbm90IEluZmluaXR5IG9yIE5hTi4uLlxyXG4gICAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgICAgLy8gcmQgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgICAvLyBuIGlzIGEgYmFzZSAxZTE0IG51bWJlciwgdGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IG9mIGFycmF5IHguYyBjb250YWluaW5nIHJkLlxyXG4gICAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgICAgLy8gZCBpcyB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgIC8vIGkgaXMgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuIGluY2x1ZGluZyBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgICAgb3V0OiB7XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLlxyXG4gICAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgICAgaSA9IHNkIC0gZDtcclxuXHJcbiAgICAgICAgICAvLyBJZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgaW4gdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuLi5cclxuICAgICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgICAgICBqID0gc2Q7XHJcbiAgICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIG4uXHJcbiAgICAgICAgICAgIHJkID0gbiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTAgfCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbmkgPSBtYXRoY2VpbCgoaSArIDEpIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5lZWRlZCBieSBzcXJ0LlxyXG4gICAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgICBuID0gcmQgPSAwO1xyXG4gICAgICAgICAgICAgICAgZCA9IDE7XHJcbiAgICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIDE7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBuLlxyXG4gICAgICAgICAgICAgIGZvciAoZCA9IDE7IGsgPj0gMTA7IGsgLz0gMTAsIGQrKyk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gbiwgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyBkO1xyXG5cclxuICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygbi5cclxuICAgICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG4gLyBwb3dzMTBbZCAtIGogLSAxXSAlIDEwIHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHIgPSByIHx8IHNkIDwgMCB8fFxyXG5cclxuICAgICAgICAgIC8vIEFyZSB0aGVyZSBhbnkgbm9uLXplcm8gZGlnaXRzIGFmdGVyIHRoZSByb3VuZGluZyBkaWdpdD9cclxuICAgICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IGosIGUuZy4gaWYgbiBpcyA5MDg3MTQgYW5kIGogaXMgMiwgdGhlIGV4cHJlc3Npb24gZ2l2ZXMgNzE0LlxyXG4gICAgICAgICAgIHhjW25pICsgMV0gIT0gbnVsbCB8fCAoaiA8IDAgPyBuIDogbiAlIHBvd3MxMFtkIC0gaiAtIDFdKTtcclxuXHJcbiAgICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgICAgPyAocmQgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCByIHx8IHJtID09IDYgJiZcclxuXHJcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAgICgoaSA+IDAgPyBqID4gMCA/IG4gLyBwb3dzMTBbZCAtIGpdIDogMCA6IHhjW25pIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgICAgcm0gPT0gKHgucyA8IDAgPyA4IDogNykpO1xyXG5cclxuICAgICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICAgIHhjLmxlbmd0aCA9IDA7XHJcblxyXG4gICAgICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgICAgeC5lID0gLXNkIHx8IDA7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgICAgeGNbMF0gPSB4LmUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmk7XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICBuaS0tO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgeGMubGVuZ3RoID0gbmkgKyAxO1xyXG4gICAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vIGogPiAwIG1lYW5zIGkgPiBudW1iZXIgb2YgbGVhZGluZyB6ZXJvcyBvZiBuLlxyXG4gICAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgICAgICAgICAvLyBJZiB0aGUgZGlnaXQgdG8gYmUgcm91bmRlZCB1cCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaSB3aWxsIGJlIHRoZSBsZW5ndGggb2YgeGNbMF0gYmVmb3JlIGsgaXMgYWRkZWQuXHJcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcbiAgICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTAsIGsrKyk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gaWYgaSAhPSBrIHRoZSBsZW5ndGggaGFzIGluY3JlYXNlZC5cclxuICAgICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgICAgeC5lKys7XHJcbiAgICAgICAgICAgICAgICAgIGlmICh4Y1swXSA9PSBCQVNFKSB4Y1swXSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjW25pXSAhPSBCQVNFKSBicmVhaztcclxuICAgICAgICAgICAgICAgIHhjW25pLS1dID0gMDtcclxuICAgICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICAgIGZvciAoaSA9IHhjLmxlbmd0aDsgeGNbLS1pXSA9PT0gMDsgeGMucG9wKCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gT3ZlcmZsb3c/IEluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgICAvLyBVbmRlcmZsb3c/IFplcm8uXHJcbiAgICAgICAgfSBlbHNlIGlmICh4LmUgPCBNSU5fRVhQKSB7XHJcbiAgICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4geDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdmFsdWVPZihuKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAgIGlmIChlID09PSBudWxsKSByZXR1cm4gbi50b1N0cmluZygpO1xyXG5cclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgICAgc3RyID0gZSA8PSBUT19FWFBfTkVHIHx8IGUgPj0gVE9fRVhQX1BPU1xyXG4gICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIGUpXHJcbiAgICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgICAgcmV0dXJuIG4ucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlci5cclxuICAgICAqL1xyXG4gICAgUC5hYnNvbHV0ZVZhbHVlID0gUC5hYnMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVyblxyXG4gICAgICogICAxIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogICAwIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgICAqICAgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgZWl0aGVyIGlzIE5hTi5cclxuICAgICAqL1xyXG4gICAgUC5jb21wYXJlZFRvID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogSWYgZHAgaXMgdW5kZWZpbmVkIG9yIG51bGwgb3IgdHJ1ZSBvciBmYWxzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlXHJcbiAgICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKlxyXG4gICAgICogT3RoZXJ3aXNlLCBpZiBkcCBpcyBhIG51bWJlciwgcmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLmRlY2ltYWxQbGFjZXMgPSBQLmRwID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBudW1iZXIuXHJcbiAgICAgIGlmICh2ID0gY1t2XSkgZm9yICg7IHYgJSAxMCA9PSAwOyB2IC89IDEwLCBuLS0pO1xyXG4gICAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgICAgcmV0dXJuIG47XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLyAwID0gSVxyXG4gICAgICogIG4gLyBOID0gTlxyXG4gICAgICogIG4gLyBJID0gMFxyXG4gICAgICogIDAgLyBuID0gMFxyXG4gICAgICogIDAgLyAwID0gTlxyXG4gICAgICogIDAgLyBOID0gTlxyXG4gICAgICogIDAgLyBJID0gMFxyXG4gICAgICogIE4gLyBuID0gTlxyXG4gICAgICogIE4gLyAwID0gTlxyXG4gICAgICogIE4gLyBOID0gTlxyXG4gICAgICogIE4gLyBJID0gTlxyXG4gICAgICogIEkgLyBuID0gSVxyXG4gICAgICogIEkgLyAwID0gSVxyXG4gICAgICogIEkgLyBOID0gTlxyXG4gICAgICogIEkgLyBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGRpdmlkZWQgYnkgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgYnkgdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgICByZXR1cm4gZGl2KHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYiksIDAsIDEpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZXhwb25lbnRpYXRlZCBieSBuLlxyXG4gICAgICpcclxuICAgICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICAgKiBJZiBuIGlzIG5lZ2F0aXZlIHJvdW5kIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqIElmIFBPV19QUkVDSVNJT04gaXMgbm9uLXplcm8gYW5kIG0gaXMgbm90IHByZXNlbnQsIHJvdW5kIHRvIFBPV19QUkVDSVNJT04gdXNpbmcgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgbW9kdWxhciBwb3dlciBvcGVyYXRpb24gd29ya3MgZWZmaWNpZW50bHkgd2hlbiB4LCBuLCBhbmQgbSBhcmUgaW50ZWdlcnMsIG90aGVyd2lzZSBpdFxyXG4gICAgICogaXMgZXF1aXZhbGVudCB0byBjYWxjdWxhdGluZyB4LmV4cG9uZW50aWF0ZWRCeShuKS5tb2R1bG8obSkgd2l0aCBhIFBPV19QUkVDSVNJT04gb2YgMC5cclxuICAgICAqXHJcbiAgICAgKiBuIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIGV4cG9uZW50LiBBbiBpbnRlZ2VyLlxyXG4gICAgICogW21dIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gVGhlIG1vZHVsdXMuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEV4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiB7bn0nXHJcbiAgICAgKi9cclxuICAgIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgICB2YXIgaGFsZiwgaXNNb2RFeHAsIGksIGssIG1vcmUsIG5Jc0JpZywgbklzTmVnLCBuSXNPZGQsIHksXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAgIC8vIEFsbG93IE5hTiBhbmQgwrFJbmZpbml0eSwgYnV0IG5vdCBvdGhlciBub24taW50ZWdlcnMuXHJcbiAgICAgIGlmIChuLmMgJiYgIW4uaXNJbnRlZ2VyKCkpIHtcclxuICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0V4cG9uZW50IG5vdCBhbiBpbnRlZ2VyOiAnICsgdmFsdWVPZihuKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgICAgLy8gRXhwb25lbnQgb2YgTUFYX1NBRkVfSU5URUdFUiBpcyAxNS5cclxuICAgICAgbklzQmlnID0gbi5lID4gMTQ7XHJcblxyXG4gICAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgICBpZiAoIXguYyB8fCAheC5jWzBdIHx8IHguY1swXSA9PSAxICYmICF4LmUgJiYgeC5jLmxlbmd0aCA9PSAxIHx8ICFuLmMgfHwgIW4uY1swXSkge1xyXG5cclxuICAgICAgICAvLyBUaGUgc2lnbiBvZiB0aGUgcmVzdWx0IG9mIHBvdyB3aGVuIHggaXMgbmVnYXRpdmUgZGVwZW5kcyBvbiB0aGUgZXZlbm5lc3Mgb2Ygbi5cclxuICAgICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE1hdGgucG93KCt2YWx1ZU9mKHgpLCBuSXNCaWcgPyAyIC0gaXNPZGQobikgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgICAgaWYgKG0pIHtcclxuXHJcbiAgICAgICAgLy8geCAlIG0gcmV0dXJucyBOYU4gaWYgYWJzKG0pIGlzIHplcm8sIG9yIG0gaXMgTmFOLlxyXG4gICAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgICAgaXNNb2RFeHAgPSAhbklzTmVnICYmIHguaXNJbnRlZ2VyKCkgJiYgbS5pc0ludGVnZXIoKTtcclxuXHJcbiAgICAgICAgaWYgKGlzTW9kRXhwKSB4ID0geC5tb2QobSk7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAgIC8vIFVuZGVyZmxvdyB0byDCsTA6IDw9MC43OSoqMWUxMCBvciA8PTAuOTk5OTk3NSoqMWUxNS5cclxuICAgICAgfSBlbHNlIGlmIChuLmUgPiA5ICYmICh4LmUgPiAwIHx8IHguZSA8IC0xIHx8ICh4LmUgPT0gMFxyXG4gICAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgICAgPyB4LmNbMF0gPiAxIHx8IG5Jc0JpZyAmJiB4LmNbMV0gPj0gMjRlN1xyXG4gICAgICAgIC8vIFs4MDAwMDAwMDAwMDAwMF0gIFs5OTk5OTc1MDAwMDAwMF1cclxuICAgICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgICAvLyBJZiB4IGlzIG5lZ2F0aXZlIGFuZCBuIGlzIG9kZCwgayA9IC0wLCBlbHNlIGsgPSAwLlxyXG4gICAgICAgIGsgPSB4LnMgPCAwICYmIGlzT2RkKG4pID8gLTAgOiAwO1xyXG5cclxuICAgICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICh4LmUgPiAtMSkgayA9IDEgLyBrO1xyXG5cclxuICAgICAgICAvLyBJZiBuIGlzIG5lZ2F0aXZlIHJldHVybiDCsTAsIGVsc2UgcmV0dXJuIMKxSW5maW5pdHkuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICAgIH0gZWxzZSBpZiAoUE9XX1BSRUNJU0lPTikge1xyXG5cclxuICAgICAgICAvLyBUcnVuY2F0aW5nIGVhY2ggY29lZmZpY2llbnQgYXJyYXkgdG8gYSBsZW5ndGggb2YgayBhZnRlciBlYWNoIG11bHRpcGxpY2F0aW9uXHJcbiAgICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgICAgLy8gaS5lLiB0aGVyZSB3aWxsIGJlIGEgbWluaW11bSBvZiAyOCBndWFyZCBkaWdpdHMgcmV0YWluZWQuXHJcbiAgICAgICAgayA9IG1hdGhjZWlsKFBPV19QUkVDSVNJT04gLyBMT0dfQkFTRSArIDIpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAobklzQmlnKSB7XHJcbiAgICAgICAgaGFsZiA9IG5ldyBCaWdOdW1iZXIoMC41KTtcclxuICAgICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICAvLyBQZXJmb3JtcyA1NCBsb29wIGl0ZXJhdGlvbnMgZm9yIG4gb2YgOTAwNzE5OTI1NDc0MDk5MS5cclxuICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgICAgeSA9IHkudGltZXMoeCk7XHJcbiAgICAgICAgICBpZiAoIXkuYykgYnJlYWs7XHJcblxyXG4gICAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgICAgaWYgKHkuYy5sZW5ndGggPiBrKSB5LmMubGVuZ3RoID0gaztcclxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNNb2RFeHApIHtcclxuICAgICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGkpIHtcclxuICAgICAgICAgIGkgPSBtYXRoZmxvb3IoaSAvIDIpO1xyXG4gICAgICAgICAgaWYgKGkgPT09IDApIGJyZWFrO1xyXG4gICAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBuLnRpbWVzKGhhbGYpO1xyXG4gICAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgICAgaWYgKG4uZSA+IDE0KSB7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGlzT2RkKG4pO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaSA9ICt2YWx1ZU9mKG4pO1xyXG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICAgIGlmIChrKSB7XHJcbiAgICAgICAgICBpZiAoeC5jICYmIHguYy5sZW5ndGggPiBrKSB4LmMubGVuZ3RoID0gaztcclxuICAgICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgICB4ID0geC5tb2QobSk7ICAgIC8veCA9IHgubWludXMoZGl2KHgsIG0sIDAsIE1PRFVMT19NT0RFKS50aW1lcyhtKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHJldHVybiB5O1xyXG4gICAgICBpZiAobklzTmVnKSB5ID0gT05FLmRpdih5KTtcclxuXHJcbiAgICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAgICpcclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3JtfSdcclxuICAgICAqL1xyXG4gICAgUC5pbnRlZ2VyVmFsdWUgPSBmdW5jdGlvbiAocm0pIHtcclxuICAgICAgdmFyIG4gPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuICAgICAgcmV0dXJuIHJvdW5kKG4sIG4uZSArIDEsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZXF1YWwgdG8gdGhlIHZhbHVlIG9mIEJpZ051bWJlcih5LCBiKSxcclxuICAgICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNFcXVhbFRvID0gUC5lcSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNGaW5pdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhIXRoaXMuYztcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICAgKiBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkgPiAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYiksIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNHcmVhdGVyVGhhbk9yRXF1YWxUbyA9IFAuZ3RlID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgcmV0dXJuIChiID0gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKSkgPT09IDEgfHwgYiA9PT0gMDtcclxuXHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGFuIGludGVnZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNJbnRlZ2VyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5jLmxlbmd0aCAtIDI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc0xlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAgICovXHJcbiAgICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHJldHVybiAoYiA9IGNvbXBhcmUodGhpcywgbmV3IEJpZ051bWJlcih5LCBiKSkpID09PSAtMSB8fCBiID09PSAwO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiAhdGhpcy5zO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgICAqL1xyXG4gICAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMucyA+IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIDAgb3IgLTAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICAgKi9cclxuICAgIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICByZXR1cm4gISF0aGlzLmMgJiYgdGhpcy5jWzBdID09IDA7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gLSAwID0gblxyXG4gICAgICogIG4gLSBOID0gTlxyXG4gICAgICogIG4gLSBJID0gLUlcclxuICAgICAqICAwIC0gbiA9IC1uXHJcbiAgICAgKiAgMCAtIDAgPSAwXHJcbiAgICAgKiAgMCAtIE4gPSBOXHJcbiAgICAgKiAgMCAtIEkgPSAtSVxyXG4gICAgICogIE4gLSBuID0gTlxyXG4gICAgICogIE4gLSAwID0gTlxyXG4gICAgICogIE4gLSBOID0gTlxyXG4gICAgICogIE4gLSBJID0gTlxyXG4gICAgICogIEkgLSBuID0gSVxyXG4gICAgICogIEkgLSAwID0gSVxyXG4gICAgICogIEkgLSBOID0gTlxyXG4gICAgICogIEkgLSBJID0gTlxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1pbnVzIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAgICovXHJcbiAgICBQLm1pbnVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgICAgeCA9IHRoaXMsXHJcbiAgICAgICAgYSA9IHgucztcclxuXHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgICBiID0geS5zO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTj9cclxuICAgICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgICBpZiAoYSAhPSBiKSB7XHJcbiAgICAgICAgeS5zID0gLWI7XHJcbiAgICAgICAgcmV0dXJuIHgucGx1cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICAgICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgICAgLy8gRWl0aGVyIHplcm8/XHJcbiAgICAgICAgaWYgKCF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICAgIHJldHVybiB5Y1swXSA/ICh5LnMgPSAtYiwgeSkgOiBuZXcgQmlnTnVtYmVyKHhjWzBdID8geCA6XHJcblxyXG4gICAgICAgICAgIC8vIElFRUUgNzU0ICgyMDA4KSA2LjM6IG4gLSBuID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHlcclxuICAgICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICAgIHllID0gYml0Rmxvb3IoeWUpO1xyXG4gICAgICB4YyA9IHhjLnNsaWNlKCk7XHJcblxyXG4gICAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICAgIGlmIChhID0geGUgLSB5ZSkge1xyXG5cclxuICAgICAgICBpZiAoeExUeSA9IGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICB0ID0geGM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuXHJcbiAgICAgICAgZm9yIChiID0gYTsgYi0tOyB0LnB1c2goMCkpO1xyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBFeHBvbmVudHMgZXF1YWwuIENoZWNrIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gICAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgICAgZm9yIChhID0gYiA9IDA7IGIgPCBqOyBiKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoeGNbYl0gIT0geWNbYl0pIHtcclxuICAgICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8geCA8IHk/IFBvaW50IHhjIHRvIHRoZSBhcnJheSBvZiB0aGUgYmlnZ2VyIG51bWJlci5cclxuICAgICAgaWYgKHhMVHkpIHQgPSB4YywgeGMgPSB5YywgeWMgPSB0LCB5LnMgPSAteS5zO1xyXG5cclxuICAgICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAgIC8vIEFwcGVuZCB6ZXJvcyB0byB4YyBpZiBzaG9ydGVyLlxyXG4gICAgICAvLyBObyBuZWVkIHRvIGFkZCB6ZXJvcyB0byB5YyBpZiBzaG9ydGVyIGFzIHN1YnRyYWN0IG9ubHkgbmVlZHMgdG8gc3RhcnQgYXQgeWMubGVuZ3RoLlxyXG4gICAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgICAgYiA9IEJBU0UgLSAxO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgeWMgZnJvbSB4Yy5cclxuICAgICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgICBpZiAoeGNbLS1qXSA8IHljW2pdKSB7XHJcbiAgICAgICAgICBmb3IgKGkgPSBqOyBpICYmICF4Y1stLWldOyB4Y1tpXSA9IGIpO1xyXG4gICAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICAgIHhjW2pdICs9IEJBU0U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgICAvLyBaZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdKSB7XHJcblxyXG4gICAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAgIC8vIG4gLSBuID0gKzAgIGJ1dCAgbiAtIG4gPSAtMCAgd2hlbiByb3VuZGluZyB0b3dhcmRzIC1JbmZpbml0eS5cclxuICAgICAgICB5LnMgPSBST1VORElOR19NT0RFID09IDMgPyAtMSA6IDE7XHJcbiAgICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICAgIHJldHVybiB5O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgICAgLy8gZm9yIGZpbml0ZSB4IGFuZCB5LlxyXG4gICAgICByZXR1cm4gbm9ybWFsaXNlKHksIHhjLCB5ZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogICBuICUgMCA9ICBOXHJcbiAgICAgKiAgIG4gJSBOID0gIE5cclxuICAgICAqICAgbiAlIEkgPSAgblxyXG4gICAgICogICAwICUgbiA9ICAwXHJcbiAgICAgKiAgLTAgJSBuID0gLTBcclxuICAgICAqICAgMCAlIDAgPSAgTlxyXG4gICAgICogICAwICUgTiA9ICBOXHJcbiAgICAgKiAgIDAgJSBJID0gIDBcclxuICAgICAqICAgTiAlIG4gPSAgTlxyXG4gICAgICogICBOICUgMCA9ICBOXHJcbiAgICAgKiAgIE4gJSBOID0gIE5cclxuICAgICAqICAgTiAlIEkgPSAgTlxyXG4gICAgICogICBJICUgbiA9ICBOXHJcbiAgICAgKiAgIEkgJSAwID0gIE5cclxuICAgICAqICAgSSAlIE4gPSAgTlxyXG4gICAgICogICBJICUgSSA9ICBOXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbW9kdWxvIHRoZSB2YWx1ZSBvZlxyXG4gICAgICogQmlnTnVtYmVyKHksIGIpLiBUaGUgcmVzdWx0IGRlcGVuZHMgb24gdGhlIHZhbHVlIG9mIE1PRFVMT19NT0RFLlxyXG4gICAgICovXHJcbiAgICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIHEsIHMsXHJcbiAgICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyBJbmZpbml0eSBvciBOYU4sIG9yIHkgaXMgTmFOIG9yIHplcm8uXHJcbiAgICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHggaWYgeSBpcyBJbmZpbml0eSBvciB4IGlzIHplcm8uXHJcbiAgICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgICAgICAvLyByID0geCAtIHF5ICAgIHdoZXJlICAwIDw9IHIgPCBhYnMoeSlcclxuICAgICAgICBzID0geS5zO1xyXG4gICAgICAgIHkucyA9IDE7XHJcbiAgICAgICAgcSA9IGRpdih4LCB5LCAwLCAzKTtcclxuICAgICAgICB5LnMgPSBzO1xyXG4gICAgICAgIHEucyAqPSBzO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB5ID0geC5taW51cyhxLnRpbWVzKHkpKTtcclxuXHJcbiAgICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgICBpZiAoIXkuY1swXSAmJiBNT0RVTE9fTU9ERSA9PSAxKSB5LnMgPSB4LnM7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiAgbiAqIDAgPSAwXHJcbiAgICAgKiAgbiAqIE4gPSBOXHJcbiAgICAgKiAgbiAqIEkgPSBJXHJcbiAgICAgKiAgMCAqIG4gPSAwXHJcbiAgICAgKiAgMCAqIDAgPSAwXHJcbiAgICAgKiAgMCAqIE4gPSBOXHJcbiAgICAgKiAgMCAqIEkgPSBOXHJcbiAgICAgKiAgTiAqIG4gPSBOXHJcbiAgICAgKiAgTiAqIDAgPSBOXHJcbiAgICAgKiAgTiAqIE4gPSBOXHJcbiAgICAgKiAgTiAqIEkgPSBOXHJcbiAgICAgKiAgSSAqIG4gPSBJXHJcbiAgICAgKiAgSSAqIDAgPSBOXHJcbiAgICAgKiAgSSAqIE4gPSBOXHJcbiAgICAgKiAgSSAqIEkgPSBJXHJcbiAgICAgKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgICAqIG9mIEJpZ051bWJlcih5LCBiKS5cclxuICAgICAqL1xyXG4gICAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgICAgdmFyIGMsIGUsIGksIGosIGssIG0sIHhjTCwgeGxvLCB4aGksIHljTCwgeWxvLCB5aGksIHpjLFxyXG4gICAgICAgIGJhc2UsIHNxcnRCYXNlLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jLFxyXG4gICAgICAgIHljID0gKHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpKS5jO1xyXG5cclxuICAgICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICAgIGlmICgheGMgfHwgIXljIHx8ICF4Y1swXSB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLCBvciBvbmUgaXMgMCBhbmQgdGhlIG90aGVyIGlzIEluZmluaXR5LlxyXG4gICAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgICB5LmMgPSB5LmUgPSB5LnMgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciBpcyDCsUluZmluaXR5LlxyXG4gICAgICAgICAgaWYgKCF4YyB8fCAheWMpIHtcclxuICAgICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICAgIHkuZSA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgICAgeS5zICo9IHgucztcclxuICAgICAgeGNMID0geGMubGVuZ3RoO1xyXG4gICAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBFbnN1cmUgeGMgcG9pbnRzIHRvIGxvbmdlciBhcnJheSBhbmQgeGNMIHRvIGl0cyBsZW5ndGguXHJcbiAgICAgIGlmICh4Y0wgPCB5Y0wpIHpjID0geGMsIHhjID0geWMsIHljID0gemMsIGkgPSB4Y0wsIHhjTCA9IHljTCwgeWNMID0gaTtcclxuXHJcbiAgICAgIC8vIEluaXRpYWxpc2UgdGhlIHJlc3VsdCBhcnJheSB3aXRoIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgc3FydEJhc2UgPSBTUVJUX0JBU0U7XHJcblxyXG4gICAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICAgIGMgPSAwO1xyXG4gICAgICAgIHlsbyA9IHljW2ldICUgc3FydEJhc2U7XHJcbiAgICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICAgIGZvciAoayA9IHhjTCwgaiA9IGkgKyBrOyBqID4gaTspIHtcclxuICAgICAgICAgIHhsbyA9IHhjWy0ta10gJSBzcXJ0QmFzZTtcclxuICAgICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgICAgbSA9IHloaSAqIHhsbyArIHhoaSAqIHlsbztcclxuICAgICAgICAgIHhsbyA9IHlsbyAqIHhsbyArICgobSAlIHNxcnRCYXNlKSAqIHNxcnRCYXNlKSArIHpjW2pdICsgYztcclxuICAgICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgICAgemNbai0tXSA9IHhsbyAlIGJhc2U7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB6Y1tqXSA9IGM7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjKSB7XHJcbiAgICAgICAgKytlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHpjLnNwbGljZSgwLCAxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB6YywgZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbmVnYXRlZCxcclxuICAgICAqIGkuZS4gbXVsdGlwbGllZCBieSAtMS5cclxuICAgICAqL1xyXG4gICAgUC5uZWdhdGVkID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgeCA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogIG4gKyAwID0gblxyXG4gICAgICogIG4gKyBOID0gTlxyXG4gICAgICogIG4gKyBJID0gSVxyXG4gICAgICogIDAgKyBuID0gblxyXG4gICAgICogIDAgKyAwID0gMFxyXG4gICAgICogIDAgKyBOID0gTlxyXG4gICAgICogIDAgKyBJID0gSVxyXG4gICAgICogIE4gKyBuID0gTlxyXG4gICAgICogIE4gKyAwID0gTlxyXG4gICAgICogIE4gKyBOID0gTlxyXG4gICAgICogIE4gKyBJID0gTlxyXG4gICAgICogIEkgKyBuID0gSVxyXG4gICAgICogIEkgKyAwID0gSVxyXG4gICAgICogIEkgKyBOID0gTlxyXG4gICAgICogIEkgKyBJID0gSVxyXG4gICAgICpcclxuICAgICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHBsdXMgdGhlIHZhbHVlIG9mXHJcbiAgICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICAgKi9cclxuICAgIFAucGx1cyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICAgIHZhciB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGEgPSB4LnM7XHJcblxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgICAgYiA9IHkucztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4/XHJcbiAgICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgICB5LnMgPSAtYjtcclxuICAgICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgICAgeWUgPSB5LmUgLyBMT0dfQkFTRSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIGlmICgheGUgfHwgIXllKSB7XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsUluZmluaXR5IGlmIGVpdGhlciDCsUluZmluaXR5LlxyXG4gICAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICAgIC8vIFJldHVybiB5IGlmIHkgaXMgbm9uLXplcm8sIHggaWYgeCBpcyBub24temVybywgb3IgemVybyBpZiBib3RoIGFyZSB6ZXJvLlxyXG4gICAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHhlID0gYml0Rmxvb3IoeGUpO1xyXG4gICAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgICAgeGMgPSB4Yy5zbGljZSgpO1xyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgICBpZiAoYSA+IDApIHtcclxuICAgICAgICAgIHllID0geGU7XHJcbiAgICAgICAgICB0ID0geWM7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgIHQgPSB4YztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICAgIGIgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBQb2ludCB4YyB0byB0aGUgbG9uZ2VyIGFycmF5LCBhbmQgYiB0byB0aGUgc2hvcnRlciBsZW5ndGguXHJcbiAgICAgIGlmIChhIC0gYiA8IDApIHQgPSB5YywgeWMgPSB4YywgeGMgPSB0LCBiID0gYTtcclxuXHJcbiAgICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgICBmb3IgKGEgPSAwOyBiOykge1xyXG4gICAgICAgIGEgPSAoeGNbLS1iXSA9IHhjW2JdICsgeWNbYl0gKyBhKSAvIEJBU0UgfCAwO1xyXG4gICAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYSkge1xyXG4gICAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgKyt5ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgICAvLyB5ZSA9IE1BWF9FWFAgKyAxIHBvc3NpYmxlXHJcbiAgICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBJZiBzZCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2ZcclxuICAgICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICAgKiBJZiBzZCBpcyB0cnVlIGluY2x1ZGUgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zIGluIHRoZSBjb3VudC5cclxuICAgICAqXHJcbiAgICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICAgKiBCaWdOdW1iZXIgcm91bmRlZCB0byBhIG1heGltdW0gb2Ygc2Qgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICAgKiBST1VORElOR19NT0RFIGlmIHJtIGlzIG9taXR0ZWQuXHJcbiAgICAgKlxyXG4gICAgICogc2Qge251bWJlcnxib29sZWFufSBudW1iZXI6IHNpZ25pZmljYW50IGRpZ2l0czogaW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogICAgICAgICAgICAgICAgICAgICBib29sZWFuOiB3aGV0aGVyIHRvIGNvdW50IGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvczogdHJ1ZSBvciBmYWxzZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3NkfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgICB2YXIgYywgbiwgdixcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIGlmIChzZCAhPSBudWxsICYmIHNkICE9PSAhIXNkKSB7XHJcbiAgICAgICAgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIHNkLCBybSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgICAgdiA9IGMubGVuZ3RoIC0gMTtcclxuICAgICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgICBpZiAodiA9IGNbdl0pIHtcclxuXHJcbiAgICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCBlbGVtZW50LlxyXG4gICAgICAgIGZvciAodiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIG4rKyk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCAmJiB4LmUgKyAxID4gbikgbiA9IHguZSArIDE7XHJcblxyXG4gICAgICByZXR1cm4gbjtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBzaGlmdGVkIGJ5IGsgcGxhY2VzXHJcbiAgICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICAgKlxyXG4gICAgICogayB7bnVtYmVyfSBJbnRlZ2VyLCAtTUFYX1NBRkVfSU5URUdFUiB0byBNQVhfU0FGRV9JTlRFR0VSIGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2t9J1xyXG4gICAgICovXHJcbiAgICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICAgIGludENoZWNrKGssIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKTtcclxuICAgICAgcmV0dXJuIHRoaXMudGltZXMoJzFlJyArIGspO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqICBzcXJ0KC1uKSA9ICBOXHJcbiAgICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICAgKiAgc3FydCgtSSkgPSAgTlxyXG4gICAgICogIHNxcnQoSSkgPSAgSVxyXG4gICAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAgICogIHNxcnQoLTApID0gLTBcclxuICAgICAqXHJcbiAgICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICAgKiByb3VuZGVkIGFjY29yZGluZyB0byBERUNJTUFMX1BMQUNFUyBhbmQgUk9VTkRJTkdfTU9ERS5cclxuICAgICAqL1xyXG4gICAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICB2YXIgbSwgbiwgciwgcmVwLCB0LFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIGMgPSB4LmMsXHJcbiAgICAgICAgcyA9IHgucyxcclxuICAgICAgICBlID0geC5lLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICAgIGhhbGYgPSBuZXcgQmlnTnVtYmVyKCcwLjUnKTtcclxuXHJcbiAgICAgIC8vIE5lZ2F0aXZlL05hTi9JbmZpbml0eS96ZXJvP1xyXG4gICAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKCFzIHx8IHMgPCAwICYmICghYyB8fCBjWzBdKSA/IE5hTiA6IGMgPyB4IDogMSAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgICBzID0gTWF0aC5zcXJ0KCt2YWx1ZU9mKHgpKTtcclxuXHJcbiAgICAgIC8vIE1hdGguc3FydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICAgIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgICAgIG4gPSBjb2VmZlRvU3RyaW5nKGMpO1xyXG4gICAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgICAgcyA9IE1hdGguc3FydCgrbik7XHJcbiAgICAgICAgZSA9IGJpdEZsb29yKChlICsgMSkgLyAyKSAtIChlIDwgMCB8fCBlICUgMik7XHJcblxyXG4gICAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgciA9IG5ldyBCaWdOdW1iZXIocyArICcnKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIHplcm8uXHJcbiAgICAgIC8vIHIgY291bGQgYmUgemVybyBpZiBNSU5fRVhQIGlzIGNoYW5nZWQgYWZ0ZXIgdGhlIHRoaXMgdmFsdWUgd2FzIGNyZWF0ZWQuXHJcbiAgICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgICAgLy8gY29lZmZUb1N0cmluZyB0byB0aHJvdy5cclxuICAgICAgaWYgKHIuY1swXSkge1xyXG4gICAgICAgIGUgPSByLmU7XHJcbiAgICAgICAgcyA9IGUgKyBkcDtcclxuICAgICAgICBpZiAocyA8IDMpIHMgPSAwO1xyXG5cclxuICAgICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgICAgZm9yICg7IDspIHtcclxuICAgICAgICAgIHQgPSByO1xyXG4gICAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgICBpZiAoY29lZmZUb1N0cmluZyh0LmMpLnNsaWNlKDAsIHMpID09PSAobiA9IGNvZWZmVG9TdHJpbmcoci5jKSkuc2xpY2UoMCwgcykpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBleHBvbmVudCBvZiByIG1heSBoZXJlIGJlIG9uZSBsZXNzIHRoYW4gdGhlIGZpbmFsIHJlc3VsdCBleHBvbmVudCxcclxuICAgICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgICAgLy8gYXJlIGluZGV4ZWQgY29ycmVjdGx5LlxyXG4gICAgICAgICAgICBpZiAoci5lIDwgZSkgLS1zO1xyXG4gICAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzXHJcbiAgICAgICAgICAgIC8vIGFyZSA5OTk5IG9yIDQ5OTkgKGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSkgY29udGludWUgdGhlXHJcbiAgICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlXHJcbiAgICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgICAgIHJvdW5kKHQsIHQuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgICAgciA9IHQ7XHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgZHAgKz0gNDtcclxuICAgICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgICAgcmVwID0gMTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgICAgLy8gcmVzdWx0LiBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgICAgIGlmICghK24gfHwgIStuLnNsaWNlKDEpICYmIG4uY2hhckF0KDApID09ICc1Jykge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMiwgMSk7XHJcbiAgICAgICAgICAgICAgICBtID0gIXIudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICAgKiByb3VuZGVkIHVzaW5nIFJPVU5ESU5HX01PREUgdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMuXHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAgICovXHJcbiAgICBQLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgICAgZHArKztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZm9ybWF0KHRoaXMsIGRwLCBybSwgMSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24gcm91bmRpbmdcclxuICAgICAqIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBhcyB3aXRoIEphdmFTY3JpcHQncyBudW1iZXIgdHlwZSwgKC0wKS50b0ZpeGVkKDApIGlzICcwJyxcclxuICAgICAqIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAgICpcclxuICAgICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqL1xyXG4gICAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgICBpZiAoZHAgIT0gbnVsbCkge1xyXG4gICAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBmb3JtYXQodGhpcywgZHAsIHJtKTtcclxuICAgIH07XHJcblxyXG5cclxuICAgIC8qXHJcbiAgICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiByb3VuZGVkXHJcbiAgICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAgICogb2YgdGhlIGZvcm1hdCBvciBGT1JNQVQgb2JqZWN0IChzZWUgQmlnTnVtYmVyLnNldCkuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAgICpcclxuICAgICAqIEZPUk1BVCA9IHtcclxuICAgICAqICAgcHJlZml4OiAnJyxcclxuICAgICAqICAgZ3JvdXBTaXplOiAzLFxyXG4gICAgICogICBzZWNvbmRhcnlHcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICAgKiAgIGRlY2ltYWxTZXBhcmF0b3I6ICcuJyxcclxuICAgICAqICAgZnJhY3Rpb25Hcm91cFNpemU6IDAsXHJcbiAgICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgKiAgIHN1ZmZpeDogJydcclxuICAgICAqIH07XHJcbiAgICAgKlxyXG4gICAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2RwfHJtfSdcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgICAqL1xyXG4gICAgUC50b0Zvcm1hdCA9IGZ1bmN0aW9uIChkcCwgcm0sIGZvcm1hdCkge1xyXG4gICAgICB2YXIgc3RyLFxyXG4gICAgICAgIHggPSB0aGlzO1xyXG5cclxuICAgICAgaWYgKGZvcm1hdCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICBmb3JtYXQgPSBybTtcclxuICAgICAgICAgIHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgZm9ybWF0ID0gZHA7XHJcbiAgICAgICAgICBkcCA9IHJtID0gbnVsbDtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9ybWF0ID0gRk9STUFUO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgIChiaWdudW1iZXJFcnJvciArICdBcmd1bWVudCBub3QgYW4gb2JqZWN0OiAnICsgZm9ybWF0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0geC50b0ZpeGVkKGRwLCBybSk7XHJcblxyXG4gICAgICBpZiAoeC5jKSB7XHJcbiAgICAgICAgdmFyIGksXHJcbiAgICAgICAgICBhcnIgPSBzdHIuc3BsaXQoJy4nKSxcclxuICAgICAgICAgIGcxID0gK2Zvcm1hdC5ncm91cFNpemUsXHJcbiAgICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgICAgZ3JvdXBTZXBhcmF0b3IgPSBmb3JtYXQuZ3JvdXBTZXBhcmF0b3IgfHwgJycsXHJcbiAgICAgICAgICBpbnRQYXJ0ID0gYXJyWzBdLFxyXG4gICAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgICAgaXNOZWcgPSB4LnMgPCAwLFxyXG4gICAgICAgICAgaW50RGlnaXRzID0gaXNOZWcgPyBpbnRQYXJ0LnNsaWNlKDEpIDogaW50UGFydCxcclxuICAgICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICAgIGlmIChnMikgaSA9IGcxLCBnMSA9IGcyLCBnMiA9IGksIGxlbiAtPSBpO1xyXG5cclxuICAgICAgICBpZiAoZzEgPiAwICYmIGxlbiA+IDApIHtcclxuICAgICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICAgIGludFBhcnQgPSBpbnREaWdpdHMuc3Vic3RyKDAsIGkpO1xyXG4gICAgICAgICAgZm9yICg7IGkgPCBsZW47IGkgKz0gZzEpIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc3Vic3RyKGksIGcxKTtcclxuICAgICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgICBpZiAoaXNOZWcpIGludFBhcnQgPSAnLScgKyBpbnRQYXJ0O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICAgID8gaW50UGFydCArIChmb3JtYXQuZGVjaW1hbFNlcGFyYXRvciB8fCAnJykgKyAoKGcyID0gK2Zvcm1hdC5mcmFjdGlvbkdyb3VwU2l6ZSlcclxuICAgICAgICAgID8gZnJhY3Rpb25QYXJ0LnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXGR7JyArIGcyICsgJ31cXFxcQicsICdnJyksXHJcbiAgICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgICA6IGZyYWN0aW9uUGFydClcclxuICAgICAgICAgOiBpbnRQYXJ0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gKGZvcm1hdC5wcmVmaXggfHwgJycpICsgc3RyICsgKGZvcm1hdC5zdWZmaXggfHwgJycpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhbiBhcnJheSBvZiB0d28gQmlnTnVtYmVycyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGFzIGEgc2ltcGxlXHJcbiAgICAgKiBmcmFjdGlvbiB3aXRoIGFuIGludGVnZXIgbnVtZXJhdG9yIGFuZCBhbiBpbnRlZ2VyIGRlbm9taW5hdG9yLlxyXG4gICAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAgICogbWF4aW11bSBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlXHJcbiAgICAgKiB0aGUgbG93ZXN0IHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAgICpcclxuICAgICAqIFttZF0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBJbnRlZ2VyID49IDEsIG9yIEluZmluaXR5LiBUaGUgbWF4aW11bSBkZW5vbWluYXRvci5cclxuICAgICAqXHJcbiAgICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAgICovXHJcbiAgICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWQpIHtcclxuICAgICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICAgIHggPSB0aGlzLFxyXG4gICAgICAgIHhjID0geC5jO1xyXG5cclxuICAgICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgICBuID0gbmV3IEJpZ051bWJlcihtZCk7XHJcblxyXG4gICAgICAgIC8vIFRocm93IGlmIG1kIGlzIGxlc3MgdGhhbiBvbmUgb3IgaXMgbm90IGFuIGludGVnZXIsIHVubGVzcyBpdCBpcyBJbmZpbml0eS5cclxuICAgICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50ICcgK1xyXG4gICAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgICAgZCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgbjEgPSBkMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgICAgcyA9IGNvZWZmVG9TdHJpbmcoeGMpO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGluaXRpYWwgZGVub21pbmF0b3IuXHJcbiAgICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgICBlID0gZC5lID0gcy5sZW5ndGggLSB4LmUgLSAxO1xyXG4gICAgICBkLmNbMF0gPSBQT1dTX1RFTlsoZXhwID0gZSAlIExPR19CQVNFKSA8IDAgPyBMT0dfQkFTRSArIGV4cCA6IGV4cF07XHJcbiAgICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICAgIGV4cCA9IE1BWF9FWFA7XHJcbiAgICAgIE1BWF9FWFAgPSAxIC8gMDtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgICAvLyBuMCA9IGQxID0gMFxyXG4gICAgICBuMC5jWzBdID0gMDtcclxuXHJcbiAgICAgIGZvciAoOyA7KSAge1xyXG4gICAgICAgIHEgPSBkaXYobiwgZCwgMCwgMSk7XHJcbiAgICAgICAgZDIgPSBkMC5wbHVzKHEudGltZXMoZDEpKTtcclxuICAgICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgICAgZDAgPSBkMTtcclxuICAgICAgICBkMSA9IGQyO1xyXG4gICAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgICBuMCA9IGQyO1xyXG4gICAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIgPSBkKSk7XHJcbiAgICAgICAgbiA9IGQyO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBkMiA9IGRpdihtZC5taW51cyhkMCksIGQxLCAwLCAxKTtcclxuICAgICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgICBuMC5zID0gbjEucyA9IHgucztcclxuICAgICAgZSA9IGUgKiAyO1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMVxyXG4gICAgICByID0gZGl2KG4xLCBkMSwgZSwgUk9VTkRJTkdfTU9ERSkubWludXMoeCkuYWJzKCkuY29tcGFyZWRUbyhcclxuICAgICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgICAgTUFYX0VYUCA9IGV4cDtcclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgY29udmVydGVkIHRvIGEgbnVtYmVyIHByaW1pdGl2ZS5cclxuICAgICAqL1xyXG4gICAgUC50b051bWJlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuICt2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gc2Qgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAgICogbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbiwgdGhlbiB1c2VcclxuICAgICAqIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICpcclxuICAgICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICAgKlxyXG4gICAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtzZHxybX0nXHJcbiAgICAgKi9cclxuICAgIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICAgIGlmIChzZCAhPSBudWxsKSBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBzZCwgcm0sIDIpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgLypcclxuICAgICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGJhc2UgYiwgb3IgYmFzZSAxMCBpZiBiIGlzXHJcbiAgICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAgICogUk9VTkRJTkdfTU9ERS4gSWYgYSBiYXNlIGlzIG5vdCBzcGVjaWZpZWQsIGFuZCB0aGlzIEJpZ051bWJlciBoYXMgYSBwb3NpdGl2ZSBleHBvbmVudFxyXG4gICAgICogdGhhdCBpcyBlcXVhbCB0byBvciBncmVhdGVyIHRoYW4gVE9fRVhQX1BPUywgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW5cclxuICAgICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBbYl0ge251bWJlcn0gSW50ZWdlciwgMiB0byBBTFBIQUJFVC5sZW5ndGggaW5jbHVzaXZlLlxyXG4gICAgICpcclxuICAgICAqICdbQmlnTnVtYmVyIEVycm9yXSBCYXNlIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtifSdcclxuICAgICAqL1xyXG4gICAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICAgIHZhciBzdHIsXHJcbiAgICAgICAgbiA9IHRoaXMsXHJcbiAgICAgICAgcyA9IG4ucyxcclxuICAgICAgICBlID0gbi5lO1xyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICAgIGlmIChzKSB7XHJcbiAgICAgICAgICBzdHIgPSAnSW5maW5pdHknO1xyXG4gICAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHN0ciA9ICdOYU4nO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoYiA9PSBudWxsKSB7XHJcbiAgICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgICAgPyB0b0V4cG9uZW50aWFsKGNvZWZmVG9TdHJpbmcobi5jKSwgZSlcclxuICAgICAgICAgICA6IHRvRml4ZWRQb2ludChjb2VmZlRvU3RyaW5nKG4uYyksIGUsICcwJyk7XHJcbiAgICAgICAgfSBlbHNlIGlmIChiID09PSAxMCkge1xyXG4gICAgICAgICAgbiA9IHJvdW5kKG5ldyBCaWdOdW1iZXIobiksIERFQ0lNQUxfUExBQ0VTICsgZSArIDEsIFJPVU5ESU5HX01PREUpO1xyXG4gICAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgbi5lLCAnMCcpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcbiAgICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpLCAxMCwgYiwgcywgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocyA8IDAgJiYgbi5jWzBdKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBzdHI7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICAvKlxyXG4gICAgICogUmV0dXJuIGFzIHRvU3RyaW5nLCBidXQgZG8gbm90IGFjY2VwdCBhIGJhc2UgYXJndW1lbnQsIGFuZCBpbmNsdWRlIHRoZSBtaW51cyBzaWduIGZvclxyXG4gICAgICogbmVnYXRpdmUgemVyby5cclxuICAgICAqL1xyXG4gICAgUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgIHJldHVybiB2YWx1ZU9mKHRoaXMpO1xyXG4gICAgfTtcclxuXHJcblxyXG4gICAgUC5faXNCaWdOdW1iZXIgPSB0cnVlO1xyXG5cclxuICAgIGlmIChjb25maWdPYmplY3QgIT0gbnVsbCkgQmlnTnVtYmVyLnNldChjb25maWdPYmplY3QpO1xyXG5cclxuICAgIHJldHVybiBCaWdOdW1iZXI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBIRUxQRVIgRlVOQ1RJT05TXHJcblxyXG4gIC8vIFRoZXNlIGZ1bmN0aW9ucyBkb24ndCBuZWVkIGFjY2VzcyB0byB2YXJpYWJsZXMsXHJcbiAgLy8gZS5nLiBERUNJTUFMX1BMQUNFUywgaW4gdGhlIHNjb3BlIG9mIHRoZSBgY2xvbmVgIGZ1bmN0aW9uIGFib3ZlLlxyXG5cclxuXHJcbiAgZnVuY3Rpb24gYml0Rmxvb3Iobikge1xyXG4gICAgdmFyIGkgPSBuIHwgMDtcclxuICAgIHJldHVybiBuID4gMCB8fCBuID09PSBpID8gaSA6IGkgLSAxO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFJldHVybiBhIGNvZWZmaWNpZW50IGFycmF5IGFzIGEgc3RyaW5nIG9mIGJhc2UgMTAgZGlnaXRzLlxyXG4gIGZ1bmN0aW9uIGNvZWZmVG9TdHJpbmcoYSkge1xyXG4gICAgdmFyIHMsIHosXHJcbiAgICAgIGkgPSAxLFxyXG4gICAgICBqID0gYS5sZW5ndGgsXHJcbiAgICAgIHIgPSBhWzBdICsgJyc7XHJcblxyXG4gICAgZm9yICg7IGkgPCBqOykge1xyXG4gICAgICBzID0gYVtpKytdICsgJyc7XHJcbiAgICAgIHogPSBMT0dfQkFTRSAtIHMubGVuZ3RoO1xyXG4gICAgICBmb3IgKDsgei0tOyBzID0gJzAnICsgcyk7XHJcbiAgICAgIHIgKz0gcztcclxuICAgIH1cclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKGogPSByLmxlbmd0aDsgci5jaGFyQ29kZUF0KC0taikgPT09IDQ4Oyk7XHJcblxyXG4gICAgcmV0dXJuIHIuc2xpY2UoMCwgaiArIDEgfHwgMSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ29tcGFyZSB0aGUgdmFsdWUgb2YgQmlnTnVtYmVycyB4IGFuZCB5LlxyXG4gIGZ1bmN0aW9uIGNvbXBhcmUoeCwgeSkge1xyXG4gICAgdmFyIGEsIGIsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYyxcclxuICAgICAgaSA9IHgucyxcclxuICAgICAgaiA9IHkucyxcclxuICAgICAgayA9IHguZSxcclxuICAgICAgbCA9IHkuZTtcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFpIHx8ICFqKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBhID0geGMgJiYgIXhjWzBdO1xyXG4gICAgYiA9IHljICYmICF5Y1swXTtcclxuXHJcbiAgICAvLyBFaXRoZXIgemVybz9cclxuICAgIGlmIChhIHx8IGIpIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gICAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gICAgaWYgKGkgIT0gaikgcmV0dXJuIGk7XHJcblxyXG4gICAgYSA9IGkgPCAwO1xyXG4gICAgYiA9IGsgPT0gbDtcclxuXHJcbiAgICAvLyBFaXRoZXIgSW5maW5pdHk/XHJcbiAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICAvLyBDb21wYXJlIGV4cG9uZW50cy5cclxuICAgIGlmICghYikgcmV0dXJuIGsgPiBsIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBkaWdpdCBieSBkaWdpdC5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIGlmICh4Y1tpXSAhPSB5Y1tpXSkgcmV0dXJuIHhjW2ldID4geWNbaV0gXiBhID8gMSA6IC0xO1xyXG5cclxuICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgIHJldHVybiBrID09IGwgPyAwIDogayA+IGwgXiBhID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ2hlY2sgdGhhdCBuIGlzIGEgcHJpbWl0aXZlIG51bWJlciwgYW4gaW50ZWdlciwgYW5kIGluIHJhbmdlLCBvdGhlcndpc2UgdGhyb3cuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaW50Q2hlY2sobiwgbWluLCBtYXgsIG5hbWUpIHtcclxuICAgIGlmIChuIDwgbWluIHx8IG4gPiBtYXggfHwgbiAhPT0gbWF0aGZsb29yKG4pKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAobmFtZSB8fCAnQXJndW1lbnQnKSArICh0eXBlb2YgbiA9PSAnbnVtYmVyJ1xyXG4gICAgICAgICA/IG4gPCBtaW4gfHwgbiA+IG1heCA/ICcgb3V0IG9mIHJhbmdlOiAnIDogJyBub3QgYW4gaW50ZWdlcjogJ1xyXG4gICAgICAgICA6ICcgbm90IGEgcHJpbWl0aXZlIG51bWJlcjogJykgKyBTdHJpbmcobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIEFzc3VtZXMgZmluaXRlIG4uXHJcbiAgZnVuY3Rpb24gaXNPZGQobikge1xyXG4gICAgdmFyIGsgPSBuLmMubGVuZ3RoIC0gMTtcclxuICAgIHJldHVybiBiaXRGbG9vcihuLmUgLyBMT0dfQkFTRSkgPT0gayAmJiBuLmNba10gJSAyICE9IDA7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gdG9FeHBvbmVudGlhbChzdHIsIGUpIHtcclxuICAgIHJldHVybiAoc3RyLmxlbmd0aCA+IDEgPyBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpIDogc3RyKSArXHJcbiAgICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIHRvRml4ZWRQb2ludChzdHIsIGUsIHopIHtcclxuICAgIHZhciBsZW4sIHpzO1xyXG5cclxuICAgIC8vIE5lZ2F0aXZlIGV4cG9uZW50P1xyXG4gICAgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgICBmb3IgKHpzID0geiArICcuJzsgKytlOyB6cyArPSB6KTtcclxuICAgICAgc3RyID0genMgKyBzdHI7XHJcblxyXG4gICAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICAgIGlmICgrK2UgPiBsZW4pIHtcclxuICAgICAgICBmb3IgKHpzID0geiwgZSAtPSBsZW47IC0tZTsgenMgKz0geik7XHJcbiAgICAgICAgc3RyICs9IHpzO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCBsZW4pIHtcclxuICAgICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgZSkgKyAnLicgKyBzdHIuc2xpY2UoZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEVYUE9SVFxyXG5cclxuXHJcbiAgQmlnTnVtYmVyID0gY2xvbmUoKTtcclxuICBCaWdOdW1iZXJbJ2RlZmF1bHQnXSA9IEJpZ051bWJlci5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEFNRC5cclxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcclxuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7IHJldHVybiBCaWdOdW1iZXI7IH0pO1xyXG5cclxuICAvLyBOb2RlLmpzIGFuZCBvdGhlciBlbnZpcm9ubWVudHMgdGhhdCBzdXBwb3J0IG1vZHVsZS5leHBvcnRzLlxyXG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xyXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCaWdOdW1iZXI7XHJcblxyXG4gIC8vIEJyb3dzZXIuXHJcbiAgfSBlbHNlIHtcclxuICAgIGlmICghZ2xvYmFsT2JqZWN0KSB7XHJcbiAgICAgIGdsb2JhbE9iamVjdCA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYgPyBzZWxmIDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGdsb2JhbE9iamVjdC5CaWdOdW1iZXIgPSBCaWdOdW1iZXI7XHJcbiAgfVxyXG59KSh0aGlzKTtcclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bignumber.js/bignumber.js\n");

/***/ }),

/***/ "./node_modules/bnc-onboard/dist/esm/onboard-584c044d.js":
/*!***************************************************************!*\
  !*** ./node_modules/bnc-onboard/dist/esm/onboard-584c044d.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"B\": function() { return /* binding */ Button; },\n/* harmony export */   \"M\": function() { return /* binding */ Modal; },\n/* harmony export */   \"a\": function() { return /* binding */ app; },\n/* harmony export */   \"b\": function() { return /* binding */ noop; },\n/* harmony export */   \"c\": function() { return /* binding */ insert; },\n/* harmony export */   \"d\": function() { return /* binding */ detach; },\n/* harmony export */   \"e\": function() { return /* binding */ connectIcon; },\n/* harmony export */   \"f\": function() { return /* binding */ networkIcon; },\n/* harmony export */   \"g\": function() { return /* binding */ get_store_value; },\n/* harmony export */   \"h\": function() { return /* binding */ balanceIcon; },\n/* harmony export */   \"i\": function() { return /* binding */ init$1; },\n/* harmony export */   \"n\": function() { return /* binding */ networkName; },\n/* harmony export */   \"o\": function() { return /* binding */ openLink; }\n/* harmony export */ });\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bignumber.js */ \"./node_modules/bignumber.js/bignumber.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bignumber_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bnc_sdk__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bnc-sdk */ \"./node_modules/bnc-sdk/dist/esm/index.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bowser */ \"./node_modules/bowser/es5.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(bowser__WEBPACK_IMPORTED_MODULE_3__);\nvar _excluded = [\"dappId\", \"networkId\", \"networkName\", \"subscriptions\", \"walletSelect\", \"walletCheck\", \"darkMode\", \"apiUrl\", \"hideBranding\", \"blockPollingInterval\"],\n    _excluded2 = [\"address\", \"network\", \"balance\", \"wallet\"],\n    _excluded3 = [\"heading\", \"description\", \"explanation\", \"wallets\", \"agreement\"],\n    _excluded4 = [\"name\", \"iconSrc\", \"iconSrcSet\", \"svg\", \"wallet\", \"link\", \"installMessage\", \"preferred\", \"desktop\", \"mobile\", \"type\", \"osExclusions\"],\n    _excluded5 = [\"checkName\", \"heading\", \"description\", \"minimumBalance\", \"html\", \"icon\", \"button\"],\n    _excluded6 = [\"darkMode\", \"networkId\"],\n    _excluded7 = [\"heading\", \"description\", \"button\", \"eventCode\", \"action\", \"icon\", \"html\"],\n    _excluded8 = [\"onclick\", \"text\"],\n    _excluded9 = [\"name\", \"connect\", \"disconnect\", \"address\", \"network\", \"balance\"],\n    _excluded10 = [\"walletName\", \"preferred\", \"label\", \"iconSrc\", \"svg\"],\n    _excluded11 = [\"walletName\"],\n    _excluded12 = [\"checkName\"];\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr && (typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]); if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\n\n\n\nfunction noop() {}\n\nvar identity = function identity(x) {\n  return x;\n};\n\nfunction assign(tar, src) {\n  // @ts-ignore\n  for (var k in src) {\n    tar[k] = src[k];\n  }\n\n  return tar;\n}\n\nfunction run(fn) {\n  return fn();\n}\n\nfunction blank_object() {\n  return Object.create(null);\n}\n\nfunction run_all(fns) {\n  fns.forEach(run);\n}\n\nfunction is_function(thing) {\n  return typeof thing === 'function';\n}\n\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || a && _typeof(a) === 'object' || typeof a === 'function';\n}\n\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\n\nfunction subscribe(store) {\n  if (store == null) {\n    return noop;\n  }\n\n  for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    callbacks[_key - 1] = arguments[_key];\n  }\n\n  var unsub = store.subscribe.apply(store, callbacks);\n  return unsub.unsubscribe ? function () {\n    return unsub.unsubscribe();\n  } : unsub;\n}\n\nfunction get_store_value(store) {\n  var value;\n  subscribe(store, function (_) {\n    return value = _;\n  })();\n  return value;\n}\n\nfunction component_subscribe(component, store, callback) {\n  component.$$.on_destroy.push(subscribe(store, callback));\n}\n\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    var slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\n\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\n\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    var lets = definition[2](fn(dirty));\n\n    if ($$scope.dirty === undefined) {\n      return lets;\n    }\n\n    if (_typeof(lets) === 'object') {\n      var merged = [];\n      var len = Math.max($$scope.dirty.length, lets.length);\n\n      for (var i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n\n      return merged;\n    }\n\n    return $$scope.dirty | lets;\n  }\n\n  return $$scope.dirty;\n}\n\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n  var slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n\n  if (slot_changes) {\n    var slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\n\nvar is_client = typeof window !== 'undefined';\nvar now = is_client ? function () {\n  return window.performance.now();\n} : function () {\n  return Date.now();\n};\nvar raf = is_client ? function (cb) {\n  return requestAnimationFrame(cb);\n} : noop;\nvar tasks = new Set();\n\nfunction run_tasks(now) {\n  tasks.forEach(function (task) {\n    if (!task.c(now)) {\n      tasks[\"delete\"](task);\n      task.f();\n    }\n  });\n  if (tasks.size !== 0) raf(run_tasks);\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\n\n\nfunction loop(callback) {\n  var task;\n  if (tasks.size === 0) raf(run_tasks);\n  return {\n    promise: new Promise(function (fulfill) {\n      tasks.add(task = {\n        c: callback,\n        f: fulfill\n      });\n    }),\n    abort: function abort() {\n      tasks[\"delete\"](task);\n    }\n  };\n}\n\nfunction append(target, node) {\n  target.appendChild(node);\n}\n\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\n\nfunction detach(node) {\n  node.parentNode.removeChild(node);\n}\n\nfunction element(name) {\n  return document.createElement(name);\n}\n\nfunction svg_element(name) {\n  return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\n\nfunction text(data) {\n  return document.createTextNode(data);\n}\n\nfunction space() {\n  return text(' ');\n}\n\nfunction empty() {\n  return text('');\n}\n\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return function () {\n    return node.removeEventListener(event, handler, options);\n  };\n}\n\nfunction attr(node, attribute, value) {\n  if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);\n}\n\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\n\nfunction set_data(text, data) {\n  data = '' + data;\n  if (text.wholeText !== data) text.data = data;\n}\n\nfunction set_style(node, key, value, important) {\n  node.style.setProperty(key, value, important ? 'important' : '');\n}\n\nfunction toggle_class(element, name, toggle) {\n  element.classList[toggle ? 'add' : 'remove'](name);\n}\n\nfunction custom_event(type, detail) {\n  var e = document.createEvent('CustomEvent');\n  e.initCustomEvent(type, false, false, detail);\n  return e;\n}\n\nvar HtmlTag = /*#__PURE__*/function () {\n  function HtmlTag() {\n    var anchor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, HtmlTag);\n\n    this.a = anchor;\n    this.e = this.n = null;\n  }\n\n  _createClass(HtmlTag, [{\n    key: \"m\",\n    value: function m(html, target) {\n      var anchor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n      if (!this.e) {\n        this.e = element(target.nodeName);\n        this.t = target;\n        this.h(html);\n      }\n\n      this.i(anchor);\n    }\n  }, {\n    key: \"h\",\n    value: function h(html) {\n      this.e.innerHTML = html;\n      this.n = Array.from(this.e.childNodes);\n    }\n  }, {\n    key: \"i\",\n    value: function i(anchor) {\n      for (var i = 0; i < this.n.length; i += 1) {\n        insert(this.t, this.n[i], anchor);\n      }\n    }\n  }, {\n    key: \"p\",\n    value: function p(html) {\n      this.d();\n      this.h(html);\n      this.i(this.a);\n    }\n  }, {\n    key: \"d\",\n    value: function d() {\n      this.n.forEach(detach);\n    }\n  }]);\n\n  return HtmlTag;\n}();\n\nvar active_docs = new Set();\nvar active = 0; // https://github.com/darkskyapp/string-hash/blob/master/index.js\n\nfunction hash(str) {\n  var hash = 5381;\n  var i = str.length;\n\n  while (i--) {\n    hash = (hash << 5) - hash ^ str.charCodeAt(i);\n  }\n\n  return hash >>> 0;\n}\n\nfunction create_rule(node, a, b, duration, delay, ease, fn) {\n  var uid = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;\n  var step = 16.666 / duration;\n  var keyframes = '{\\n';\n\n  for (var p = 0; p <= 1; p += step) {\n    var t = a + (b - a) * ease(p);\n    keyframes += p * 100 + \"%{\".concat(fn(t, 1 - t), \"}\\n\");\n  }\n\n  var rule = keyframes + \"100% {\".concat(fn(b, 1 - b), \"}\\n}\");\n  var name = \"__svelte_\".concat(hash(rule), \"_\").concat(uid);\n  var doc = node.ownerDocument;\n  active_docs.add(doc);\n  var stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);\n  var current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n\n  if (!current_rules[name]) {\n    current_rules[name] = true;\n    stylesheet.insertRule(\"@keyframes \".concat(name, \" \").concat(rule), stylesheet.cssRules.length);\n  }\n\n  var animation = node.style.animation || '';\n  node.style.animation = \"\".concat(animation ? \"\".concat(animation, \", \") : '').concat(name, \" \").concat(duration, \"ms linear \").concat(delay, \"ms 1 both\");\n  active += 1;\n  return name;\n}\n\nfunction delete_rule(node, name) {\n  var previous = (node.style.animation || '').split(', ');\n  var next = previous.filter(name ? function (anim) {\n    return anim.indexOf(name) < 0;\n  } // remove specific animation\n  : function (anim) {\n    return anim.indexOf('__svelte') === -1;\n  } // remove all Svelte animations\n  );\n  var deleted = previous.length - next.length;\n\n  if (deleted) {\n    node.style.animation = next.join(', ');\n    active -= deleted;\n    if (!active) clear_rules();\n  }\n}\n\nfunction clear_rules() {\n  raf(function () {\n    if (active) return;\n    active_docs.forEach(function (doc) {\n      var stylesheet = doc.__svelte_stylesheet;\n      var i = stylesheet.cssRules.length;\n\n      while (i--) {\n        stylesheet.deleteRule(i);\n      }\n\n      doc.__svelte_rules = {};\n    });\n    active_docs.clear();\n  });\n}\n\nvar current_component;\n\nfunction set_current_component(component) {\n  current_component = component;\n}\n\nfunction get_current_component() {\n  if (!current_component) throw new Error('Function called outside component initialization');\n  return current_component;\n}\n\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\n\nfunction onDestroy(fn) {\n  get_current_component().$$.on_destroy.push(fn);\n}\n\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = Promise.resolve();\nvar update_scheduled = false;\n\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\n\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\n\nvar flushing = false;\nvar seen_callbacks = new Set();\n\nfunction flush() {\n  if (flushing) return;\n  flushing = true;\n\n  do {\n    // first, call beforeUpdate functions\n    // and update components\n    for (var i = 0; i < dirty_components.length; i += 1) {\n      var component = dirty_components[i];\n      set_current_component(component);\n      update(component.$$);\n    }\n\n    set_current_component(null);\n    dirty_components.length = 0;\n\n    while (binding_callbacks.length) {\n      binding_callbacks.pop()();\n    } // then, once components are updated, call\n    // afterUpdate functions. This may cause\n    // subsequent updates...\n\n\n    for (var _i = 0; _i < render_callbacks.length; _i += 1) {\n      var callback = render_callbacks[_i];\n\n      if (!seen_callbacks.has(callback)) {\n        // ...so guard against infinite loops\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n\n  update_scheduled = false;\n  flushing = false;\n  seen_callbacks.clear();\n}\n\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    var dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\n\nvar promise;\n\nfunction wait() {\n  if (!promise) {\n    promise = Promise.resolve();\n    promise.then(function () {\n      promise = null;\n    });\n  }\n\n  return promise;\n}\n\nfunction dispatch(node, direction, kind) {\n  node.dispatchEvent(custom_event(\"\".concat(direction ? 'intro' : 'outro').concat(kind)));\n}\n\nvar outroing = new Set();\nvar outros;\n\nfunction group_outros() {\n  outros = {\n    r: 0,\n    c: [],\n    p: outros // parent group\n\n  };\n}\n\nfunction check_outros() {\n  if (!outros.r) {\n    run_all(outros.c);\n  }\n\n  outros = outros.p;\n}\n\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing[\"delete\"](block);\n    block.i(local);\n  }\n}\n\nfunction transition_out(block, local, detach, callback) {\n  if (block && block.o) {\n    if (outroing.has(block)) return;\n    outroing.add(block);\n    outros.c.push(function () {\n      outroing[\"delete\"](block);\n\n      if (callback) {\n        if (detach) block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  }\n}\n\nvar null_transition = {\n  duration: 0\n};\n\nfunction create_in_transition(node, fn, params) {\n  var config = fn(node, params);\n  var running = false;\n  var animation_name;\n  var task;\n  var uid = 0;\n\n  function cleanup() {\n    if (animation_name) delete_rule(node, animation_name);\n  }\n\n  function go() {\n    var _ref = config || null_transition,\n        _ref$delay = _ref.delay,\n        delay = _ref$delay === void 0 ? 0 : _ref$delay,\n        _ref$duration = _ref.duration,\n        duration = _ref$duration === void 0 ? 300 : _ref$duration,\n        _ref$easing = _ref.easing,\n        easing = _ref$easing === void 0 ? identity : _ref$easing,\n        _ref$tick = _ref.tick,\n        tick = _ref$tick === void 0 ? noop : _ref$tick,\n        css = _ref.css;\n\n    if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n    tick(0, 1);\n    var start_time = now() + delay;\n    var end_time = start_time + duration;\n    if (task) task.abort();\n    running = true;\n    add_render_callback(function () {\n      return dispatch(node, true, 'start');\n    });\n    task = loop(function (now) {\n      if (running) {\n        if (now >= end_time) {\n          tick(1, 0);\n          dispatch(node, true, 'end');\n          cleanup();\n          return running = false;\n        }\n\n        if (now >= start_time) {\n          var t = easing((now - start_time) / duration);\n          tick(t, 1 - t);\n        }\n      }\n\n      return running;\n    });\n  }\n\n  var started = false;\n  return {\n    start: function start() {\n      if (started) return;\n      delete_rule(node);\n\n      if (is_function(config)) {\n        config = config();\n        wait().then(go);\n      } else {\n        go();\n      }\n    },\n    invalidate: function invalidate() {\n      started = false;\n    },\n    end: function end() {\n      if (running) {\n        cleanup();\n        running = false;\n      }\n    }\n  };\n}\n\nfunction create_bidirectional_transition(node, fn, params, intro) {\n  var config = fn(node, params);\n  var t = intro ? 0 : 1;\n  var running_program = null;\n  var pending_program = null;\n  var animation_name = null;\n\n  function clear_animation() {\n    if (animation_name) delete_rule(node, animation_name);\n  }\n\n  function init(program, duration) {\n    var d = program.b - t;\n    duration *= Math.abs(d);\n    return {\n      a: t,\n      b: program.b,\n      d: d,\n      duration: duration,\n      start: program.start,\n      end: program.start + duration,\n      group: program.group\n    };\n  }\n\n  function go(b) {\n    var _ref2 = config || null_transition,\n        _ref2$delay = _ref2.delay,\n        delay = _ref2$delay === void 0 ? 0 : _ref2$delay,\n        _ref2$duration = _ref2.duration,\n        duration = _ref2$duration === void 0 ? 300 : _ref2$duration,\n        _ref2$easing = _ref2.easing,\n        easing = _ref2$easing === void 0 ? identity : _ref2$easing,\n        _ref2$tick = _ref2.tick,\n        tick = _ref2$tick === void 0 ? noop : _ref2$tick,\n        css = _ref2.css;\n\n    var program = {\n      start: now() + delay,\n      b: b\n    };\n\n    if (!b) {\n      // @ts-ignore todo: improve typings\n      program.group = outros;\n      outros.r += 1;\n    }\n\n    if (running_program || pending_program) {\n      pending_program = program;\n    } else {\n      // if this is an intro, and there's a delay, we need to do\n      // an initial tick and/or apply CSS animation immediately\n      if (css) {\n        clear_animation();\n        animation_name = create_rule(node, t, b, duration, delay, easing, css);\n      }\n\n      if (b) tick(0, 1);\n      running_program = init(program, duration);\n      add_render_callback(function () {\n        return dispatch(node, b, 'start');\n      });\n      loop(function (now) {\n        if (pending_program && now > pending_program.start) {\n          running_program = init(pending_program, duration);\n          pending_program = null;\n          dispatch(node, running_program.b, 'start');\n\n          if (css) {\n            clear_animation();\n            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n          }\n        }\n\n        if (running_program) {\n          if (now >= running_program.end) {\n            tick(t = running_program.b, 1 - t);\n            dispatch(node, running_program.b, 'end');\n\n            if (!pending_program) {\n              // we're done\n              if (running_program.b) {\n                // intro — we can tidy up immediately\n                clear_animation();\n              } else {\n                // outro — needs to be coordinated\n                if (! --running_program.group.r) run_all(running_program.group.c);\n              }\n            }\n\n            running_program = null;\n          } else if (now >= running_program.start) {\n            var p = now - running_program.start;\n            t = running_program.a + running_program.d * easing(p / running_program.duration);\n            tick(t, 1 - t);\n          }\n        }\n\n        return !!(running_program || pending_program);\n      });\n    }\n  }\n\n  return {\n    run: function run(b) {\n      if (is_function(config)) {\n        wait().then(function () {\n          // @ts-ignore\n          config = config();\n          go(b);\n        });\n      } else {\n        go(b);\n      }\n    },\n    end: function end() {\n      clear_animation();\n      running_program = pending_program = null;\n    }\n  };\n}\n\nfunction outro_and_destroy_block(block, lookup) {\n  transition_out(block, 1, 1, function () {\n    lookup[\"delete\"](block.key);\n  });\n}\n\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n  var o = old_blocks.length;\n  var n = list.length;\n  var i = o;\n  var old_indexes = {};\n\n  while (i--) {\n    old_indexes[old_blocks[i].key] = i;\n  }\n\n  var new_blocks = [];\n  var new_lookup = new Map();\n  var deltas = new Map();\n  i = n;\n\n  while (i--) {\n    var child_ctx = get_context(ctx, list, i);\n    var key = get_key(child_ctx);\n    var block = lookup.get(key);\n\n    if (!block) {\n      block = create_each_block(key, child_ctx);\n      block.c();\n    } else if (dynamic) {\n      block.p(child_ctx, dirty);\n    }\n\n    new_lookup.set(key, new_blocks[i] = block);\n    if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));\n  }\n\n  var will_move = new Set();\n  var did_move = new Set();\n\n  function insert(block) {\n    transition_in(block, 1);\n    block.m(node, next);\n    lookup.set(block.key, block);\n    next = block.first;\n    n--;\n  }\n\n  while (o && n) {\n    var new_block = new_blocks[n - 1];\n    var old_block = old_blocks[o - 1];\n    var new_key = new_block.key;\n    var old_key = old_block.key;\n\n    if (new_block === old_block) {\n      // do nothing\n      next = new_block.first;\n      o--;\n      n--;\n    } else if (!new_lookup.has(old_key)) {\n      // remove old block\n      destroy(old_block, lookup);\n      o--;\n    } else if (!lookup.has(new_key) || will_move.has(new_key)) {\n      insert(new_block);\n    } else if (did_move.has(old_key)) {\n      o--;\n    } else if (deltas.get(new_key) > deltas.get(old_key)) {\n      did_move.add(new_key);\n      insert(new_block);\n    } else {\n      will_move.add(old_key);\n      o--;\n    }\n  }\n\n  while (o--) {\n    var _old_block = old_blocks[o];\n    if (!new_lookup.has(_old_block.key)) destroy(_old_block, lookup);\n  }\n\n  while (n) {\n    insert(new_blocks[n - 1]);\n  }\n\n  return new_blocks;\n}\n\nfunction create_component(block) {\n  block && block.c();\n}\n\nfunction mount_component(component, target, anchor, customElement) {\n  var _component$$$ = component.$$,\n      fragment = _component$$$.fragment,\n      on_mount = _component$$$.on_mount,\n      on_destroy = _component$$$.on_destroy,\n      after_update = _component$$$.after_update;\n  fragment && fragment.m(target, anchor);\n\n  if (!customElement) {\n    // onMount happens before the initial afterUpdate\n    add_render_callback(function () {\n      var new_on_destroy = on_mount.map(run).filter(is_function);\n\n      if (on_destroy) {\n        on_destroy.push.apply(on_destroy, _toConsumableArray(new_on_destroy));\n      } else {\n        // Edge case - component was destroyed immediately,\n        // most likely as a result of a binding initialising\n        run_all(new_on_destroy);\n      }\n\n      component.$$.on_mount = [];\n    });\n  }\n\n  after_update.forEach(add_render_callback);\n}\n\nfunction destroy_component(component, detaching) {\n  var $$ = component.$$;\n\n  if ($$.fragment !== null) {\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to\n    // preserve final state?)\n\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\n\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\n\nfunction init(component, options, instance, create_fragment, not_equal, props) {\n  var dirty = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [-1];\n  var parent_component = current_component;\n  set_current_component(component);\n  var $$ = component.$$ = {\n    fragment: null,\n    ctx: null,\n    // state\n    props: props,\n    update: noop,\n    not_equal: not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(parent_component ? parent_component.$$.context : options.context || []),\n    // everything else\n    callbacks: blank_object(),\n    dirty: dirty,\n    skip_bound: false\n  };\n  var ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, function (i, ret) {\n    var value = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : ret;\n\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);\n      if (ready) make_dirty(component, i);\n    }\n\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update); // `false` as a special case of no DOM component\n\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n\n  if (options.target) {\n    if (options.hydrate) {\n      var nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      $$.fragment && $$.fragment.c();\n    }\n\n    if (options.intro) transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    flush();\n  }\n\n  set_current_component(parent_component);\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\n\n\nvar SvelteComponent = /*#__PURE__*/function () {\n  function SvelteComponent() {\n    _classCallCheck(this, SvelteComponent);\n  }\n\n  _createClass(SvelteComponent, [{\n    key: \"$destroy\",\n    value: function $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n  }, {\n    key: \"$on\",\n    value: function $on(type, callback) {\n      var callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return function () {\n        var index = callbacks.indexOf(callback);\n        if (index !== -1) callbacks.splice(index, 1);\n      };\n    }\n  }, {\n    key: \"$set\",\n    value: function $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  }]);\n\n  return SvelteComponent;\n}();\n\nvar subscriber_queue = [];\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\n\nfunction readable(value, start) {\n  return {\n    subscribe: writable(value, start).subscribe\n  };\n}\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\n\n\nfunction writable(value) {\n  var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n  var stop;\n  var subscribers = [];\n\n  function set(new_value) {\n    if (safe_not_equal(value, new_value)) {\n      value = new_value;\n\n      if (stop) {\n        // store is ready\n        var run_queue = !subscriber_queue.length;\n\n        for (var i = 0; i < subscribers.length; i += 1) {\n          var s = subscribers[i];\n          s[1]();\n          subscriber_queue.push(s, value);\n        }\n\n        if (run_queue) {\n          for (var _i2 = 0; _i2 < subscriber_queue.length; _i2 += 2) {\n            subscriber_queue[_i2][0](subscriber_queue[_i2 + 1]);\n          }\n\n          subscriber_queue.length = 0;\n        }\n      }\n    }\n  }\n\n  function update(fn) {\n    set(fn(value));\n  }\n\n  function subscribe(run) {\n    var invalidate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop;\n    var subscriber = [run, invalidate];\n    subscribers.push(subscriber);\n\n    if (subscribers.length === 1) {\n      stop = start(set) || noop;\n    }\n\n    run(value);\n    return function () {\n      var index = subscribers.indexOf(subscriber);\n\n      if (index !== -1) {\n        subscribers.splice(index, 1);\n      }\n\n      if (subscribers.length === 0) {\n        stop();\n        stop = null;\n      }\n    };\n  }\n\n  return {\n    set: set,\n    update: update,\n    subscribe: subscribe\n  };\n}\n\nfunction derived(stores, fn, initial_value) {\n  var single = !Array.isArray(stores);\n  var stores_array = single ? [stores] : stores;\n  var auto = fn.length < 2;\n  return readable(initial_value, function (set) {\n    var inited = false;\n    var values = [];\n    var pending = 0;\n    var cleanup = noop;\n\n    var sync = function sync() {\n      if (pending) {\n        return;\n      }\n\n      cleanup();\n      var result = fn(single ? values[0] : values, set);\n\n      if (auto) {\n        set(result);\n      } else {\n        cleanup = is_function(result) ? result : noop;\n      }\n    };\n\n    var unsubscribers = stores_array.map(function (store, i) {\n      return subscribe(store, function (value) {\n        values[i] = value;\n        pending &= ~(1 << i);\n\n        if (inited) {\n          sync();\n        }\n      }, function () {\n        pending |= 1 << i;\n      });\n    });\n    inited = true;\n    sync();\n    return function stop() {\n      run_all(unsubscribers);\n      cleanup();\n    };\n  });\n}\n\nfunction fade(node) {\n  var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref3$delay = _ref3.delay,\n      delay = _ref3$delay === void 0 ? 0 : _ref3$delay,\n      _ref3$duration = _ref3.duration,\n      duration = _ref3$duration === void 0 ? 400 : _ref3$duration,\n      _ref3$easing = _ref3.easing,\n      easing = _ref3$easing === void 0 ? identity : _ref3$easing;\n\n  var o = +getComputedStyle(node).opacity;\n  return {\n    delay: delay,\n    duration: duration,\n    easing: easing,\n    css: function css(t) {\n      return \"opacity: \".concat(t * o);\n    }\n  };\n}\n\nvar version = \"1.30.0\";\nvar blocknative;\n\nfunction initializeBlocknative(dappId, networkId, apiUrl) {\n  blocknative = new bnc_sdk__WEBPACK_IMPORTED_MODULE_2__.default({\n    dappId: dappId,\n    networkId: networkId,\n    name: 'Onboard',\n    appVersion: version,\n    apiUrl: apiUrl\n  });\n  return blocknative;\n}\n\nfunction getBlocknative() {\n  if (!blocknative) {\n    var _get_store_value = get_store_value(app),\n        dappId = _get_store_value.dappId,\n        networkId = _get_store_value.networkId,\n        apiUrl = _get_store_value.apiUrl; // init only if dappId\n\n\n    dappId && initializeBlocknative(dappId, networkId, apiUrl);\n  }\n\n  return blocknative;\n}\n\nfunction closeSocketConnection() {\n  var _blocknative;\n\n  (_blocknative = blocknative) === null || _blocknative === void 0 ? void 0 : _blocknative.destroy();\n}\n\nfunction getNetwork(provider) {\n  return new Promise(function (resolve, reject) {\n    var options = {\n      jsonrpc: '2.0',\n      method: 'net_version',\n      params: [],\n      id: 42\n    }; // use MetaMask parameter if there\n\n    if (provider.chainId) {\n      return resolve(Number(provider.chainId));\n    }\n\n    var callback = function callback(e, res) {\n      e && reject(e);\n      var result = res && res.result;\n      resolve(result && Number(result));\n    };\n\n    if (typeof provider.sendAsync === 'function') {\n      provider.sendAsync(options, callback);\n    } else if (typeof provider.send === 'function') {\n      provider.send(options, callback);\n    } else {\n      resolve(null);\n    }\n  });\n}\n\nfunction getAddress(provider) {\n  return new Promise(function (resolve, reject) {\n    var options = {\n      jsonrpc: '2.0',\n      method: 'eth_accounts',\n      params: [],\n      id: 42\n    }; // use MetaMask request method if there\n\n    if (provider.request) {\n      return provider.request(options).then(function (res) {\n        return resolve(res[0]);\n      });\n    }\n\n    var callback = function callback(e, res) {\n      e && reject(e);\n      var result = res && res.result && res.result[0];\n      resolve(result);\n    };\n\n    if (typeof provider.sendAsync === 'function') {\n      provider.sendAsync(options, callback);\n    } else if (typeof provider.send === 'function') {\n      provider.send(options, callback);\n    } else {\n      resolve(null);\n    }\n  });\n}\n\nfunction getBalance(provider, address) {\n  return new Promise( /*#__PURE__*/function () {\n    var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(resolve, reject) {\n      var currentAddress, options, callback;\n      return regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.t0 = address;\n\n              if (_context.t0) {\n                _context.next = 5;\n                break;\n              }\n\n              _context.next = 4;\n              return getAddress(provider);\n\n            case 4:\n              _context.t0 = _context.sent;\n\n            case 5:\n              currentAddress = _context.t0;\n\n              if (currentAddress) {\n                _context.next = 9;\n                break;\n              }\n\n              resolve(null);\n              return _context.abrupt(\"return\");\n\n            case 9:\n              options = {\n                jsonrpc: '2.0',\n                method: 'eth_getBalance',\n                params: [currentAddress, 'latest'],\n                id: 42\n              }; // use MetaMask request method if there\n\n              if (!provider.request) {\n                _context.next = 12;\n                break;\n              }\n\n              return _context.abrupt(\"return\", provider.request(options).then(function (res) {\n                return res ? new (bignumber_js__WEBPACK_IMPORTED_MODULE_1___default())(res).toString(10) : null;\n              }).then(resolve));\n\n            case 12:\n              callback = function callback(e, res) {\n                e && reject(e);\n                var result = res && res.result;\n                resolve(result && new (bignumber_js__WEBPACK_IMPORTED_MODULE_1___default())(result).toString(10));\n              };\n\n              if (typeof provider.sendAsync === 'function') {\n                provider.sendAsync(options, callback);\n              } else if (typeof provider.send === 'function') {\n                provider.send(options, callback);\n              } else {\n                resolve(null);\n              }\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x, _x2) {\n      return _ref4.apply(this, arguments);\n    };\n  }());\n}\n\nfunction createModernProviderInterface(provider) {\n  provider.autoRefreshOnNetworkChange = false;\n  var onFuncExists = typeof provider.on === 'function';\n  return {\n    address: onFuncExists ? {\n      onChange: function onChange(func) {\n        // get the initial value\n        getAddress(provider).then(func);\n        provider.on('accountsChanged', function (accounts) {\n          return func(accounts && accounts[0]);\n        });\n      }\n    } : {\n      get: function get() {\n        return getAddress(provider);\n      }\n    },\n    network: onFuncExists ? {\n      onChange: function onChange(func) {\n        // get initial value\n        getNetwork(provider).then(func); // networkChanged event is deprecated in MM, keep for wallets that may not have updated\n\n        provider.on('networkChanged', function (netId) {\n          return func(netId && Number(netId));\n        }); // use new chainChanged event for network change\n\n        provider.on('chainChanged', function (netId) {\n          return func(netId && Number(netId));\n        });\n      }\n    } : {\n      get: function get() {\n        return getNetwork(provider);\n      }\n    },\n    balance: {\n      get: function get() {\n        return getBalance(provider);\n      }\n    },\n    connect: function () {\n      var _connect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {\n        var result, _result;\n\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n\n                if (!provider.request) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                _context2.next = 4;\n                return provider.request({\n                  method: 'eth_requestAccounts'\n                });\n\n              case 4:\n                result = _context2.sent;\n                return _context2.abrupt(\"return\", result);\n\n              case 8:\n                _context2.next = 10;\n                return provider.enable();\n\n              case 10:\n                _result = _context2.sent;\n                return _context2.abrupt(\"return\", _result);\n\n              case 12:\n                _context2.next = 17;\n                break;\n\n              case 14:\n                _context2.prev = 14;\n                _context2.t0 = _context2[\"catch\"](0);\n                throw {\n                  message: 'This dapp requires access to your account information.'\n                };\n\n              case 17:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, null, [[0, 14]]);\n      }));\n\n      function connect() {\n        return _connect.apply(this, arguments);\n      }\n\n      return connect;\n    }(),\n    name: getProviderName(provider)\n  };\n}\n\nfunction createLegacyProviderInterface(provider) {\n  return {\n    address: {\n      get: function get() {\n        return getAddress(provider);\n      }\n    },\n    network: {\n      get: function get() {\n        return getNetwork(provider);\n      }\n    },\n    balance: {\n      get: function get() {\n        return getBalance(provider);\n      }\n    },\n    name: getProviderName(provider)\n  };\n}\n\nfunction getProviderName(provider) {\n  if (!provider) return;\n\n  if (provider.isWalletIO) {\n    return 'wallet.io';\n  }\n\n  if (provider.isDcentWallet) {\n    return \"D'CENT\";\n  }\n\n  if (provider.isTokenPocket) {\n    return 'TokenPocket';\n  }\n\n  if (provider.isOwnbit) {\n    return 'Ownbit';\n  }\n\n  if (provider.wallet === 'MEETONE') {\n    return 'MEETONE';\n  }\n\n  if (provider.isTorus) {\n    return 'Torus';\n  }\n\n  if (provider.isImToken) {\n    return 'imToken';\n  }\n\n  if (provider.isDapper) {\n    return 'Dapper';\n  }\n\n  if (provider.isWalletConnect) {\n    return 'WalletConnect';\n  }\n\n  if (provider.isTrust) {\n    return 'Trust';\n  }\n\n  if (provider.isCoinbaseWallet) {\n    return 'Coinbase';\n  }\n\n  if (provider.isToshi) {\n    return 'Toshi';\n  }\n\n  if (provider.isCipher) {\n    return 'Cipher';\n  }\n\n  if (provider.isOpera) {\n    return 'Opera';\n  }\n\n  if (provider.isStatus) {\n    return 'Status';\n  }\n\n  if (provider.isXDEFI) {\n    return 'XDEFI';\n  }\n\n  if (provider.isFrame) {\n    return 'Frame';\n  }\n\n  if (provider.isMYKEY) {\n    return 'MYKEY';\n  }\n\n  if (provider.isHbWallet) {\n    return 'huobiwallet';\n  }\n\n  if (provider.isHyperPay) {\n    return 'HyperPay';\n  }\n\n  if (provider.isAToken) {\n    return 'AToken';\n  }\n\n  if (provider.isLiquality) {\n    return 'Liquality';\n  }\n\n  if (provider.isAlphaWallet) {\n    return 'AlphaWallet';\n  }\n\n  if (provider.isBitpie) {\n    return 'Bitpie';\n  } // =====================================\n  // When adding new wallet place above this metamask check as some providers\n  // have an isMetaMask property in addition to the wallet's own `is[WalletName]`\n\n\n  if (provider.isMetaMask && provider._metamask) {\n    return 'MetaMask';\n  }\n\n  if (provider.host && provider.host.indexOf('localhost') !== -1) {\n    return 'localhost';\n  }\n}\n\nfunction getDeviceInfo() {\n  var parsed = bowser__WEBPACK_IMPORTED_MODULE_3___default().getParser(window.navigator.userAgent);\n  var os = parsed.getOS();\n  var browser = parsed.getBrowser();\n\n  var _parsed$getPlatform = parsed.getPlatform(),\n      type = _parsed$getPlatform.type;\n\n  return {\n    isMobile: type ? type !== 'desktop' : window.innerWidth < 600,\n    os: os,\n    browser: browser\n  };\n}\n\nfunction networkName(id) {\n  switch (id) {\n    case 1:\n      return 'mainnet';\n\n    case 3:\n      return 'ropsten';\n\n    case 4:\n      return 'rinkeby';\n\n    case 5:\n      return 'goerli';\n\n    case 42:\n      return 'kovan';\n\n    case 100:\n      return 'xdai';\n\n    case 56:\n      return 'bsc';\n\n    default:\n      var _get_store_value2 = get_store_value(app),\n          networkId = _get_store_value2.networkId,\n          _networkName = _get_store_value2.networkName;\n\n      return networkId === id && _networkName || 'unknown';\n  }\n}\n\nfunction wait$1(time) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, time);\n  });\n}\n\nfunction makeCancelable(promise) {\n  var rejectFn;\n  var wrappedPromise = new Promise(function (resolve, reject) {\n    rejectFn = reject;\n    promise.then(resolve)[\"catch\"](reject);\n  });\n\n  wrappedPromise.cancel = function () {\n    rejectFn('canceled');\n  };\n\n  return wrappedPromise;\n}\n\nfunction isPromise(val) {\n  if (val instanceof Promise) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction createInterval(func, interval) {\n  var id = setInterval(func, interval);\n  var status = {\n    active: true\n  };\n  return {\n    status: status,\n    clear: function clear() {\n      clearInterval(id);\n      status.active = false;\n    }\n  };\n}\n\nfunction openLink(url) {\n  window.open(url);\n}\n\nvar validSubscriptionKeys = ['address', 'network', 'balance', 'wallet'];\n\nfunction validateType(options) {\n  var name = options.name,\n      value = options.value,\n      type = options.type,\n      optional = options.optional;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(\"\\\"\".concat(name, \"\\\" is required\"));\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : _typeof(value) !== type)) {\n    throw new Error(\"\\\"\".concat(name, \"\\\" must be of type: \").concat(type, \", received type: \").concat(_typeof(value), \" from value: \").concat(value));\n  }\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  var keys = Object.keys(params);\n  keys.forEach(function (key) {\n    if (!validParams.includes(key)) {\n      throw new Error(\"\".concat(key, \" is not a valid parameter for \").concat(functionName, \", must be one of the following valid parameters: \").concat(validParams.join(', ')));\n    }\n  });\n}\n\nfunction validateInit(init) {\n  validateType({\n    name: 'init',\n    value: init,\n    type: 'object'\n  });\n\n  var dappId = init.dappId,\n      networkId = init.networkId,\n      networkName = init.networkName,\n      subscriptions = init.subscriptions,\n      walletSelect = init.walletSelect,\n      walletCheck = init.walletCheck,\n      darkMode = init.darkMode,\n      apiUrl = init.apiUrl,\n      hideBranding = init.hideBranding,\n      blockPollingInterval = init.blockPollingInterval,\n      otherParams = _objectWithoutProperties(init, _excluded);\n\n  invalidParams(otherParams, ['dappId', 'networkId', 'networkName', 'subscriptions', 'walletSelect', 'walletCheck', 'darkMode', 'apiUrl', 'hideBranding', 'blockPollingInterval', 'agreement'], 'init');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n  validateType({\n    name: 'networkName',\n    value: networkName,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'darkMode',\n    value: darkMode,\n    type: 'boolean',\n    optional: true\n  });\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'hideBranding',\n    value: hideBranding,\n    type: 'boolean',\n    optional: true\n  });\n  validateType({\n    name: 'blockPollingInterval',\n    value: blockPollingInterval,\n    type: 'number',\n    optional: true\n  });\n  validateType({\n    name: 'subscriptions',\n    value: subscriptions,\n    type: 'object',\n    optional: true\n  });\n\n  if (subscriptions) {\n    validateSubscriptions(subscriptions);\n  }\n\n  validateType({\n    name: 'walletSelect',\n    value: walletSelect,\n    type: 'object',\n    optional: true\n  });\n\n  if (walletSelect) {\n    validateWalletSelect(walletSelect);\n  }\n\n  validateType({\n    name: 'walletCheck',\n    value: walletCheck,\n    type: 'object',\n    optional: true\n  });\n\n  if (walletCheck) {\n    validateWalletCheck(walletCheck);\n  }\n}\n\nfunction validateSubscriptions(subscriptions) {\n  var address = subscriptions.address,\n      network = subscriptions.network,\n      balance = subscriptions.balance,\n      wallet = subscriptions.wallet,\n      otherParams = _objectWithoutProperties(subscriptions, _excluded2);\n\n  invalidParams(otherParams, validSubscriptionKeys, 'subscriptions');\n  validateType({\n    name: 'subscriptions.address',\n    value: address,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'subscriptions.network',\n    value: network,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'subscriptions.balance',\n    value: balance,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'subscriptions.wallet',\n    value: wallet,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validateWalletSelect(walletSelect) {\n  validateType({\n    name: 'walletSelect',\n    value: walletSelect,\n    type: 'object'\n  });\n\n  var heading = walletSelect.heading,\n      description = walletSelect.description,\n      explanation = walletSelect.explanation,\n      wallets = walletSelect.wallets,\n      agreement = walletSelect.agreement,\n      otherParams = _objectWithoutProperties(walletSelect, _excluded3);\n\n  invalidParams(otherParams, ['heading', 'description', 'explanation', 'wallets', 'agreement'], 'walletSelect');\n  validateType({\n    name: 'heading',\n    value: heading,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'description',\n    value: description,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'explanation',\n    value: explanation,\n    type: 'string',\n    optional: true\n  });\n\n  if (Array.isArray(wallets)) {\n    wallets.forEach(validateWallet);\n  }\n\n  validateType({\n    name: 'agreement',\n    value: agreement,\n    type: 'object',\n    optional: true\n  });\n\n  if (agreement) {\n    validateAgreement(agreement);\n  }\n}\n\nvar validateAgreement = function validateAgreement(agreement) {\n  var version = agreement.version,\n      termsUrl = agreement.termsUrl,\n      privacyUrl = agreement.privacyUrl;\n  validateType({\n    name: 'version',\n    value: version,\n    type: 'string',\n    optional: false\n  });\n  validateType({\n    name: 'termsUrl',\n    value: termsUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'privacyUrl',\n    value: privacyUrl,\n    type: 'string',\n    optional: true\n  });\n};\n\nfunction isWalletModule(obj) {\n  return obj.wallet !== undefined;\n}\n\nfunction isWalletInit(obj) {\n  return obj.walletName !== undefined;\n}\n\nfunction validateWallet(obj) {\n  validateType({\n    name: 'selectWallet.wallets item',\n    value: obj,\n    type: 'object'\n  });\n\n  if (isWalletModule(obj)) {\n    var name = obj.name,\n        iconSrc = obj.iconSrc,\n        iconSrcSet = obj.iconSrcSet,\n        svg = obj.svg,\n        _wallet = obj.wallet,\n        link = obj.link,\n        installMessage = obj.installMessage,\n        preferred = obj.preferred,\n        desktop = obj.desktop,\n        mobile = obj.mobile,\n        type = obj.type,\n        osExclusions = obj.osExclusions,\n        otherParams = _objectWithoutProperties(obj, _excluded4);\n\n    invalidParams(otherParams, ['name', 'iconSrc', 'iconSrcSet', 'svg', 'wallet', 'type', 'link', 'installMessage', 'preferred', 'desktop', 'mobile', 'osExclusions'], 'selectWallets.wallets item');\n    validateType({\n      name: 'name',\n      value: name,\n      type: 'string'\n    });\n    validateType({\n      name: 'wallet',\n      value: _wallet,\n      type: 'function'\n    });\n    validateType({\n      name: 'iconSrc',\n      value: iconSrc,\n      type: 'string',\n      optional: true\n    });\n    validateType({\n      name: 'iconSrcSet',\n      value: iconSrcSet,\n      type: 'string',\n      optional: true\n    });\n    validateType({\n      name: 'svg',\n      value: svg,\n      type: 'string',\n      optional: true\n    });\n    validateType({\n      name: 'link',\n      value: link,\n      type: 'string',\n      optional: true\n    });\n    validateType({\n      name: 'installMessage',\n      value: installMessage,\n      type: 'function',\n      optional: true\n    });\n    validateType({\n      name: 'preferred',\n      value: preferred,\n      type: 'boolean',\n      optional: true\n    });\n    validateType({\n      name: 'desktop',\n      value: desktop,\n      type: 'boolean',\n      optional: true\n    });\n    validateType({\n      name: 'mobile',\n      value: mobile,\n      type: 'boolean',\n      optional: true\n    });\n    validateType({\n      name: 'type',\n      value: type,\n      type: 'string',\n      optional: true\n    });\n    validateType({\n      name: 'osExclusions',\n      value: osExclusions,\n      type: 'array',\n      optional: true\n    });\n    return;\n  }\n\n  validateWalletInit(obj);\n}\n\nfunction isWalletCheckModule(obj) {\n  return typeof obj === 'function';\n}\n\nfunction validateWalletCheck(walletCheck) {\n  validateType({\n    name: 'walletCheck',\n    value: walletCheck,\n    type: 'array'\n  });\n  walletCheck.forEach(function (check) {\n    if (isWalletCheckModule(check)) {\n      validateWalletCheckModule(check);\n    } else {\n      validateType({\n        name: 'walletCheck item',\n        value: check,\n        type: 'object'\n      });\n\n      var checkName = check.checkName,\n          heading = check.heading,\n          description = check.description,\n          minimumBalance = check.minimumBalance,\n          html = check.html,\n          icon = check.icon,\n          button = check.button,\n          otherParams = _objectWithoutProperties(check, _excluded5);\n\n      invalidParams(otherParams, ['checkName', 'heading', 'description', 'html', 'icon', 'button', 'minimumBalance'], 'walletCheck item');\n      validateType({\n        name: 'checkName',\n        value: checkName,\n        type: 'string'\n      });\n      validateType({\n        name: 'heading',\n        value: heading,\n        type: 'string',\n        optional: true\n      });\n      validateType({\n        name: 'description',\n        value: description,\n        type: 'string',\n        optional: true\n      });\n      validateType({\n        name: 'html',\n        value: html,\n        type: 'string',\n        optional: true\n      });\n      validateType({\n        name: 'icon',\n        value: icon,\n        type: 'string',\n        optional: true\n      });\n      validateType({\n        name: 'button',\n        value: button,\n        type: 'object',\n        optional: true\n      });\n      validateType({\n        name: 'minimumBalance',\n        value: minimumBalance,\n        type: 'string',\n        optional: true\n      });\n    }\n  });\n}\n\nfunction validateWalletCheckModule(module) {\n  validateType({\n    name: 'walletCheck module',\n    value: module,\n    type: 'function'\n  });\n}\n\nfunction validateConfig(configuration) {\n  validateType({\n    name: 'configuration',\n    value: configuration,\n    type: 'object'\n  });\n\n  var darkMode = configuration.darkMode,\n      networkId = configuration.networkId,\n      otherParams = _objectWithoutProperties(configuration, _excluded6);\n\n  invalidParams(otherParams, ['darkMode', 'networkId'], 'configuration');\n  validateType({\n    name: 'darkMode',\n    value: darkMode,\n    type: 'boolean',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number',\n    optional: true\n  });\n}\n\nfunction validateModal(modal) {\n  validateType({\n    name: 'modal',\n    value: modal,\n    type: 'object'\n  });\n\n  var heading = modal.heading,\n      description = modal.description,\n      button = modal.button,\n      eventCode = modal.eventCode,\n      action = modal.action,\n      icon = modal.icon,\n      html = modal.html,\n      otherParams = _objectWithoutProperties(modal, _excluded7);\n\n  invalidParams(otherParams, ['heading', 'description', 'button', 'eventCode', 'action', 'icon', 'html'], 'modal');\n  validateType({\n    name: 'heading',\n    value: heading,\n    type: 'string'\n  });\n  validateType({\n    name: 'description',\n    value: description,\n    type: 'string'\n  });\n  validateType({\n    name: 'eventCode',\n    value: eventCode,\n    type: 'string'\n  });\n  validateType({\n    name: 'action',\n    value: action,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'button',\n    value: button,\n    type: 'object',\n    optional: true\n  });\n  validateType({\n    name: 'html',\n    value: html,\n    type: 'string',\n    optional: true\n  });\n\n  if (button) {\n    var onclick = button.onclick,\n        _text = button.text,\n        restParams = _objectWithoutProperties(button, _excluded8);\n\n    invalidParams(restParams, ['onclick', 'text'], 'button');\n    validateType({\n      name: 'onclick',\n      value: onclick,\n      type: 'function'\n    });\n    validateType({\n      name: 'text',\n      value: _text,\n      type: 'string'\n    });\n  }\n\n  validateType({\n    name: 'icon',\n    value: icon,\n    type: 'string',\n    optional: true\n  });\n}\n\nfunction validateWalletInterface(walletInterface) {\n  validateType({\n    name: 'walletInterface',\n    value: walletInterface,\n    type: 'object'\n  });\n\n  var name = walletInterface.name,\n      connect = walletInterface.connect,\n      disconnect = walletInterface.disconnect,\n      address = walletInterface.address,\n      network = walletInterface.network,\n      balance = walletInterface.balance,\n      otherParams = _objectWithoutProperties(walletInterface, _excluded9);\n\n  invalidParams(otherParams, ['name', 'connect', 'disconnect', 'address', 'network', 'balance'], 'walletInterface');\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string'\n  });\n  validateType({\n    name: 'connect',\n    value: connect,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'disconnect',\n    value: disconnect,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'address',\n    value: address,\n    type: 'object'\n  });\n  validateType({\n    name: 'address.get',\n    value: address.get,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'address.onChange',\n    value: address.onChange,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'network',\n    value: network,\n    type: 'object'\n  });\n  validateType({\n    name: 'network.get',\n    value: network.get,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'network.onChange',\n    value: network.onChange,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'balance',\n    value: balance,\n    type: 'object'\n  });\n  validateType({\n    name: 'balance.get',\n    value: balance.get,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'balance.onChange',\n    value: balance.onChange,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validateWalletInit(walletInit) {\n  validateType({\n    name: 'walletInit',\n    value: walletInit,\n    type: 'object'\n  });\n\n  var walletName = walletInit.walletName,\n      preferred = walletInit.preferred,\n      label = walletInit.label,\n      iconSrc = walletInit.iconSrc,\n      svg = walletInit.svg,\n      otherParams = _objectWithoutProperties(walletInit, _excluded10);\n\n  invalidParams(otherParams, ['walletName', 'apiKey', 'networkId', 'infuraKey', 'rpc', 'bridge', 'preferred', 'label', 'iconSrc', 'svg', 'appUrl', 'email', 'rpcUrl', 'LedgerTransport', 'buildEnv', 'buttonPosition', 'enableLogging', 'loginMethod', 'loginConfig', 'showTorusButton', 'modalZindex', 'integrity', 'whiteLabel', 'appName', 'appLogoUrl', 'enabledVerifiers', 'disableNotifications', 'rpcUri', 'webUri', 'xsUri', 'blockedPopupRedirect'], 'walletInitObject');\n  validateType({\n    name: 'walletInit.walletName',\n    value: walletName,\n    type: 'string'\n  });\n  validateType({\n    name: 'walletInit.preferred',\n    value: preferred,\n    type: 'boolean',\n    optional: true\n  });\n  validateType({\n    name: 'walletInit.label',\n    value: label,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'walletInit.iconSrc',\n    value: iconSrc,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'walletInit.svg',\n    value: svg,\n    type: 'string',\n    optional: true\n  });\n}\n\nvar app = writable({\n  dappId: '',\n  apiUrl: '',\n  networkId: 1,\n  networkName: '',\n  version: '',\n  mobileDevice: false,\n  os: '',\n  darkMode: false,\n  walletSelectInProgress: false,\n  walletSelectCompleted: false,\n  walletCheckInProgress: false,\n  walletCheckCompleted: false,\n  switchingWallets: false,\n  accountSelectInProgress: false,\n  autoSelectWallet: '',\n  checkModules: [],\n  walletSelectDisplayedUI: false,\n  walletCheckDisplayedUI: false,\n  displayBranding: false,\n  blockPollingInterval: 4000,\n  agreement: {}\n});\nvar stateSyncStatus = {\n  balance: null,\n  address: null,\n  network: null\n};\nvar address;\nvar network;\nvar balance;\nvar wallet;\nvar state;\nvar walletInterface;\nvar currentSyncerIntervals;\n\nfunction initializeStores() {\n  address = createWalletStateSliceStore({\n    parameter: 'address',\n    initialState: null\n  });\n  network = createWalletStateSliceStore({\n    parameter: 'network',\n    initialState: null\n  });\n  balance = get_store_value(app).dappId ? createBalanceStore(null) : createWalletStateSliceStore({\n    parameter: 'balance',\n    initialState: null,\n    intervalSetting: 1000\n  });\n  wallet = writable({\n    name: null,\n    provider: null,\n    connect: null,\n    instance: null,\n    dashboard: null,\n    type: null,\n    icons: null\n  });\n  state = derived([address, network, balance, wallet, app], function (_ref5) {\n    var _ref6 = _slicedToArray(_ref5, 5),\n        $address = _ref6[0],\n        $network = _ref6[1],\n        $balance = _ref6[2],\n        $wallet = _ref6[3],\n        $app = _ref6[4];\n\n    return {\n      address: $address,\n      network: $network,\n      balance: $balance,\n      wallet: $wallet,\n      mobileDevice: $app.mobileDevice,\n      appNetworkId: $app.networkId\n    };\n  });\n  currentSyncerIntervals = [];\n  walletInterface = createWalletInterfaceStore(null);\n  walletInterface.subscribe(function (walletInterface) {\n    // make sure that stores have been initialized\n    if (state) {\n      // clear all current intervals if they exist\n      currentSyncerIntervals.forEach(function (interval) {\n        return interval && interval.clear();\n      });\n      var currentState = get_store_value(state); // reset state\n\n      currentState.balance && balance.reset();\n      currentState.address && address.reset();\n      currentState.network && network.reset();\n\n      if (walletInterface) {\n        // start syncing state and save intervals\n        currentSyncerIntervals = [address.setStateSyncer(walletInterface.address), network.setStateSyncer(walletInterface.network), balance.setStateSyncer(walletInterface.balance)];\n      }\n\n      resetCheckModules();\n    }\n  });\n}\n\nfunction resetWalletState(options) {\n  walletInterface.update(function (currentInterface) {\n    // no interface then don't do anything\n    if (!currentInterface) {\n      return currentInterface;\n    } // no options object, so do a full reset by disconnecting and setting interface to null\n\n\n    if (!options) {\n      wallet.update(function () {\n        return {\n          name: undefined,\n          provider: undefined,\n          connect: undefined,\n          instance: undefined,\n          dashboard: undefined,\n          type: undefined\n        };\n      });\n      currentInterface.disconnect && currentInterface.disconnect();\n      return null;\n    }\n\n    var walletName = options.walletName,\n        disconnected = options.disconnected; // if walletName is the same as the current interface name then do a full reset (checking if to do a disconnect)\n\n    if (currentInterface.name === walletName) {\n      wallet.update(function () {\n        return {\n          name: undefined,\n          provider: undefined,\n          connect: undefined,\n          instance: undefined,\n          dashboard: undefined\n        };\n      });\n      !disconnected && currentInterface.disconnect && currentInterface.disconnect();\n      return null;\n    }\n\n    return currentInterface;\n  });\n  resetCheckModules();\n  app.update(function (store) {\n    return _objectSpread(_objectSpread({}, store), {}, {\n      walletSelectInProgress: false,\n      walletSelectCompleted: false\n    });\n  });\n}\n\nfunction resetCheckModules() {\n  var _get_store_value3 = get_store_value(app),\n      checkModules = _get_store_value3.checkModules;\n\n  if (Array.isArray(checkModules)) {\n    checkModules.forEach(function (m) {\n      return m.reset && m.reset();\n    });\n  }\n}\n\nfunction createWalletInterfaceStore(initialState) {\n  var _writable = writable(initialState),\n      subscribe = _writable.subscribe,\n      _set = _writable.set,\n      update = _writable.update;\n\n  return {\n    subscribe: subscribe,\n    update: update,\n    set: function set(walletInterface) {\n      if (walletInterface) {\n        validateWalletInterface(walletInterface);\n      }\n\n      _set(walletInterface);\n    }\n  };\n}\n\nfunction createWalletStateSliceStore(options) {\n  var parameter = options.parameter,\n      initialState = options.initialState,\n      intervalSetting = options.intervalSetting;\n\n  var _writable2 = writable(initialState),\n      subscribe = _writable2.subscribe,\n      set = _writable2.set;\n\n  var currentState;\n  subscribe(function (store) {\n    currentState = store;\n  });\n  return {\n    subscribe: subscribe,\n    reset: function reset() {\n      set(undefined);\n    },\n    get: function get() {\n      return currentState;\n    },\n    setStateSyncer: function setStateSyncer(stateSyncer) {\n      validateType({\n        name: 'stateSyncer',\n        value: stateSyncer,\n        type: 'object'\n      });\n      var get = stateSyncer.get,\n          onChange = stateSyncer.onChange;\n      validateType({\n        name: \"\".concat(parameter, \".get\"),\n        value: get,\n        type: 'function',\n        optional: true\n      });\n      validateType({\n        name: \"\".concat(parameter, \".onChange\"),\n        value: onChange,\n        type: 'function',\n        optional: true\n      });\n\n      if (onChange) {\n        stateSyncStatus[parameter] = new Promise(function (resolve) {\n          onChange(function (newVal) {\n            resolve(undefined);\n\n            if (newVal || currentState !== initialState) {\n              set(newVal);\n            }\n          });\n        });\n        return;\n      }\n\n      if (get) {\n        var interval = createInterval(function () {\n          stateSyncStatus[parameter] = get().then(function (newVal) {\n            stateSyncStatus[parameter] = null;\n\n            if (newVal || currentState !== initialState) {\n              interval.status.active && set(newVal);\n            }\n          })[\"catch\"](function (err) {\n            console.warn(\"Error getting \".concat(parameter, \" from state syncer: \").concat(err));\n            stateSyncStatus[parameter] = null;\n          });\n        }, intervalSetting || 200);\n        return interval;\n      }\n    }\n  };\n}\n\nfunction createBalanceStore(initialState) {\n  var stateSyncer;\n  var emitter;\n  var emitterAddress;\n\n  var cancel = function cancel() {};\n\n  var _derived = derived([address, network], function (_ref7, set) {\n    var _ref8 = _slicedToArray(_ref7, 2),\n        $address = _ref8[0],\n        $network = _ref8[1];\n\n    if (stateSyncer && !stateSyncer.onChange) {\n      if ($address && $network && stateSyncer.get && set) {\n        cancel = syncStateWithTimeout({\n          getState: stateSyncer.get,\n          setState: set,\n          timeout: 2000,\n          currentBalance: get_store_value(balance)\n        });\n\n        if (emitterAddress !== $address) {\n          var _blocknative2 = getBlocknative(); // unsubscribe from previous address\n\n\n          // unsubscribe from previous address\n          if (emitterAddress) {\n            _blocknative2.unsubscribe(emitterAddress);\n          } // subscribe to new address and filter to just confirmed status\n\n\n          // subscribe to new address and filter to just confirmed status\n          _blocknative2.configuration({\n            scope: $address,\n            filters: [{\n              status: 'confirmed'\n            }],\n            watchAddress: true\n          }).then(function (result) {\n            emitter = result.emitter;\n            emitter.on('txConfirmed', function () {\n              if (stateSyncer.get) {\n                cancel = syncStateWithTimeout({\n                  getState: stateSyncer.get,\n                  setState: set,\n                  timeout: 2000,\n                  currentBalance: get_store_value(balance),\n                  pollStart: Date.now()\n                });\n              }\n\n              return false;\n            });\n            emitterAddress = $address;\n          }) // swallow possible timeout error for sending configuration\n          [\"catch\"](function () {});\n        }\n      } else if (emitterAddress && !$address) {\n        var _blocknative3 = getBlocknative(); // unsubscribe from previous address\n\n\n        // unsubscribe from previous address\n        _blocknative3.unsubscribe(emitterAddress); // no address, so set balance to undefined\n\n\n        // no address, so set balance to undefined\n        set && set(undefined);\n        emitterAddress = undefined;\n      }\n    }\n\n    set(initialState);\n  }),\n      subscribe = _derived.subscribe;\n\n  var currentState;\n  subscribe(function (store) {\n    currentState = store;\n  });\n  return {\n    subscribe: subscribe,\n    get: function get() {\n      return currentState;\n    },\n    setStateSyncer: function setStateSyncer(syncer) {\n      validateType({\n        name: 'syncer',\n        value: syncer,\n        type: 'object'\n      });\n      var get = syncer.get,\n          onChange = syncer.onChange;\n      validateType({\n        name: 'balance.get',\n        value: get,\n        type: 'function',\n        optional: true\n      });\n      validateType({\n        name: 'balance.onChange',\n        value: onChange,\n        type: 'function',\n        optional: true\n      });\n      stateSyncer = syncer;\n      return undefined;\n    },\n    reset: cancel\n  };\n}\n\nfunction syncStateWithTimeout(options) {\n  var getState = options.getState,\n      setState = options.setState,\n      timeout = options.timeout,\n      currentBalance = options.currentBalance,\n      pollStart = options.pollStart;\n\n  if (pollStart && Date.now() - pollStart > 25000) {\n    return function () {};\n  }\n\n  var prom = makeCancelable(getState());\n  stateSyncStatus.balance = prom;\n  prom.then( /*#__PURE__*/function () {\n    var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(result) {\n      return regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(result === currentBalance && pollStart)) {\n                _context3.next = 6;\n                break;\n              }\n\n              _context3.next = 3;\n              return wait$1(350);\n\n            case 3:\n              syncStateWithTimeout(options);\n              _context3.next = 8;\n              break;\n\n            case 6:\n              stateSyncStatus.balance = null;\n              setState(result);\n\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n\n    return function (_x3) {\n      return _ref9.apply(this, arguments);\n    };\n  }())[\"catch\"](function () {\n    stateSyncStatus.balance = null;\n  });\n  var timedOut = wait$1(timeout);\n  timedOut.then(function () {\n    prom.cancel();\n  });\n  return function () {\n    return prom.cancel();\n  };\n}\n/* src/elements/Branding.svelte generated by Svelte v3.38.2 */\n\n\nfunction add_css() {\n  var style = element(\"style\");\n  style.id = \"svelte-15m9up6-style\";\n  style.textContent = \".bn-branding.svelte-15m9up6{font-size:0.75rem;font-family:inherit;margin:0.4rem;display:flex;justify-content:center;width:100%;align-items:center}span.svelte-15m9up6{opacity:0.3}a.svelte-15m9up6{color:inherit;display:flex;margin-left:0.25rem;align-items:center}.bn-logo.svelte-15m9up6{height:1.1rem;margin-left:0.25rem;margin-bottom:0.1rem}svg.svelte-15m9up6{height:100%;width:auto}\";\n  append(document.head, style);\n} // (81:6) {:else}\n\n\nfunction create_else_block(ctx) {\n  var svg;\n  var g;\n  var path0;\n  var path1;\n  return {\n    c: function c() {\n      svg = svg_element(\"svg\");\n      g = svg_element(\"g\");\n      path0 = svg_element(\"path\");\n      path1 = svg_element(\"path\");\n      attr(path0, \"d\", \"m1.35473654 25.2695268\\n              41.68515786-24.21771792c.5647044-.32807482 1.2619836-.32807795\\n              1.8266909-.00000821l19.9275013\\n              11.57698923c.5635938.3274228.9088026.9314826.9048094\\n              1.5832707l-.1501112 24.5017756 20.8472716\\n              12.1113348c.5601525.3254236.9048434.9243111.9048434\\n              1.5721317v48.4560123c0 .647825-.3446953 1.246715-.9048537\\n              1.572138l-41.6835092\\n              24.215895c-.5655731.328567-1.2640448.328023-1.8291052-.001426l-41.5311197-24.21401c-.5587764-.325785-.90240476-.923899-.90240476-1.570712v-49.505258-24.5082917c0-.6478147.34468473-1.2466978.9048293-1.5721235z\");\n      attr(path1, \"d\", \"m22.0428451 114.442824v-25.2731141l-21.59284788-12.5449388\\n              42.75014288 24.6551909c.5648507.325765 1.260898.324109\\n              1.8241926-.004339l42.2766571-24.6508519-21.5955473\\n              12.6370084v-24.2248276c0-.6488012-.3457266-1.2484405-.9072187-1.5735092l-20.9222804-12.1126883\\n              21.6729314-12.6370084-42.4525958\\n              24.4763352c-.5545159.3197099-1.236865.3218902-1.7934127.0057303l-20.85286908-11.8459598\");\n      set_style(g, \"stroke\", \"#000\");\n      set_style(g, \"stroke-width\", \"2.70793\");\n      set_style(g, \"fill\", \"none\");\n      set_style(g, \"fill-rule\", \"evenodd\");\n      set_style(g, \"stroke-linecap\", \"round\");\n      set_style(g, \"stroke-linejoin\", \"round\");\n      attr(g, \"transform\", \"translate(1.818182 .909091)\");\n      attr(svg, \"height\", \"130\");\n      attr(svg, \"viewBox\", \"0 0 91 130\");\n      attr(svg, \"width\", \"91\");\n      attr(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      attr(svg, \"class\", \"svelte-15m9up6\");\n    },\n    m: function m(target, anchor) {\n      insert(target, svg, anchor);\n      append(svg, g);\n      append(g, path0);\n      append(g, path1);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(svg);\n    }\n  };\n} // (49:6) {#if darkMode}\n\n\nfunction create_if_block(ctx) {\n  var svg;\n  var g;\n  var path0;\n  var path1;\n  return {\n    c: function c() {\n      svg = svg_element(\"svg\");\n      g = svg_element(\"g\");\n      path0 = svg_element(\"path\");\n      path1 = svg_element(\"path\");\n      attr(path0, \"d\", \"m1.35473654 25.2695268\\n              41.68515786-24.21771792c.5647044-.32807482 1.2619836-.32807795\\n              1.8266909-.00000821l19.9275013\\n              11.57698923c.5635938.3274228.9088026.9314826.9048094\\n              1.5832707l-.1501112 24.5017756 20.8472716\\n              12.1113348c.5601525.3254236.9048434.9243111.9048434\\n              1.5721317v48.4560123c0 .647825-.3446953 1.246715-.9048537\\n              1.572138l-41.6835092\\n              24.215895c-.5655731.328567-1.2640448.328023-1.8291052-.001426l-41.5311197-24.21401c-.5587764-.325785-.90240476-.923899-.90240476-1.570712v-49.505258-24.5082917c0-.6478147.34468473-1.2466978.9048293-1.5721235z\");\n      attr(path1, \"d\", \"m22.0428451 114.442824v-25.2731141l-21.59284788-12.5449388\\n              42.75014288 24.6551909c.5648507.325765 1.260898.324109\\n              1.8241926-.004339l42.2766571-24.6508519-21.5955473\\n              12.6370084v-24.2248276c0-.6488012-.3457266-1.2484405-.9072187-1.5735092l-20.9222804-12.1126883\\n              21.6729314-12.6370084-42.4525958\\n              24.4763352c-.5545159.3197099-1.236865.3218902-1.7934127.0057303l-20.85286908-11.8459598\");\n      set_style(g, \"stroke\", \"#fff\");\n      set_style(g, \"stroke-width\", \"2.70793\");\n      set_style(g, \"fill\", \"none\");\n      set_style(g, \"fill-rule\", \"evenodd\");\n      set_style(g, \"stroke-linecap\", \"round\");\n      set_style(g, \"stroke-linejoin\", \"round\");\n      attr(g, \"transform\", \"translate(1.818182 .909091)\");\n      attr(svg, \"height\", \"130\");\n      attr(svg, \"viewBox\", \"0 0 91 130\");\n      attr(svg, \"width\", \"91\");\n      attr(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      attr(svg, \"class\", \"svelte-15m9up6\");\n    },\n    m: function m(target, anchor) {\n      insert(target, svg, anchor);\n      append(svg, g);\n      append(g, path0);\n      append(g, path1);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(svg);\n    }\n  };\n}\n\nfunction create_fragment(ctx) {\n  var div1;\n  var span0;\n  var t1;\n  var a;\n  var span1;\n  var t3;\n  var div0;\n\n  function select_block_type(ctx, dirty) {\n    if (\n    /*darkMode*/\n    ctx[0]) return create_if_block;\n    return create_else_block;\n  }\n\n  var current_block_type = select_block_type(ctx);\n  var if_block = current_block_type(ctx);\n  return {\n    c: function c() {\n      div1 = element(\"div\");\n      span0 = element(\"span\");\n      span0.textContent = \"Powered by\";\n      t1 = space();\n      a = element(\"a\");\n      span1 = element(\"span\");\n      span1.textContent = \"Blocknative\";\n      t3 = space();\n      div0 = element(\"div\");\n      if_block.c();\n      attr(span0, \"class\", \"svelte-15m9up6\");\n      attr(span1, \"class\", \"svelte-15m9up6\");\n      attr(div0, \"class\", \"bn-logo svelte-15m9up6\");\n      attr(a, \"href\", \"https://hubs.ly/H0qh2g10\");\n      attr(a, \"class\", \"bn-onboard-clickable svelte-15m9up6\");\n      attr(a, \"target\", \"_blank\");\n      attr(a, \"rel\", \"noopener noreferrer\");\n      attr(div1, \"class\", \"bn-branding svelte-15m9up6\");\n    },\n    m: function m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, span0);\n      append(div1, t1);\n      append(div1, a);\n      append(a, span1);\n      append(a, t3);\n      append(a, div0);\n      if_block.m(div0, null);\n    },\n    p: function p(ctx, _ref10) {\n      var _ref11 = _slicedToArray(_ref10, 1),\n          dirty = _ref11[0];\n\n      if (current_block_type !== (current_block_type = select_block_type(ctx))) {\n        if_block.d(1);\n        if_block = current_block_type(ctx);\n\n        if (if_block) {\n          if_block.c();\n          if_block.m(div0, null);\n        }\n      }\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(div1);\n      if_block.d();\n    }\n  };\n}\n\nfunction instance($$self, $$props, $$invalidate) {\n  var darkMode = $$props.darkMode;\n\n  $$self.$$set = function ($$props) {\n    if (\"darkMode\" in $$props) $$invalidate(0, darkMode = $$props.darkMode);\n  };\n\n  return [darkMode];\n}\n\nvar Branding = /*#__PURE__*/function (_SvelteComponent) {\n  _inherits(Branding, _SvelteComponent);\n\n  var _super = _createSuper(Branding);\n\n  function Branding(options) {\n    var _this;\n\n    _classCallCheck(this, Branding);\n\n    _this = _super.call(this);\n    if (!document.getElementById(\"svelte-15m9up6-style\")) add_css();\n    init(_assertThisInitialized(_this), options, instance, create_fragment, safe_not_equal, {\n      darkMode: 0\n    });\n    return _this;\n  }\n\n  return Branding;\n}(SvelteComponent);\n/* src/components/Modal.svelte generated by Svelte v3.38.2 */\n\n\nfunction add_css$1() {\n  var style = element(\"style\");\n  style.id = \"svelte-rntogh-style\";\n  style.textContent = \"aside.svelte-rntogh{display:flex;font-family:'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;justify-content:center;align-items:center;position:fixed;font-size:16px;top:0;left:0;width:100vw;height:100vh;background:rgba(0, 0, 0, 0.3)}@media screen and (max-width: 420px){aside.svelte-rntogh{font-size:14px}}section.svelte-rntogh{display:block;box-sizing:content-box;background:#ffffff;border-radius:10px;box-shadow:0 1px 5px 0 rgba(0, 0, 0, 0.1);font-family:inherit;font-size:inherit;padding:1.33em;position:relative;overflow:hidden;max-width:37em;color:#4a4a4a}div.svelte-rntogh{height:0.66em;position:absolute;padding:0.25em;top:1.33em;right:1.33em;font-size:inherit;font-family:inherit;border-radius:5px;transition:background 200ms ease-in-out;display:flex;justify-content:center;align-items:center}div.svelte-rntogh:hover{cursor:pointer;background:#eeeeee}svg.svelte-rntogh{width:10px;height:10px}.bn-onboard-dark-mode-close-background.svelte-rntogh:hover{background:#00222c}.no-padding-branding.svelte-rntogh{padding-bottom:0}\";\n  append(document.head, style);\n} // (97:4) {#if $app.displayBranding}\n\n\nfunction create_if_block_1(ctx) {\n  var branding;\n  var current;\n  branding = new Branding({\n    props: {\n      darkMode:\n      /*$app*/\n      ctx[3].darkMode\n    }\n  });\n  return {\n    c: function c() {\n      create_component(branding.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(branding, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var branding_changes = {};\n      if (dirty &\n      /*$app*/\n      8) branding_changes.darkMode =\n      /*$app*/\n      ctx[3].darkMode;\n      branding.$set(branding_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(branding.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(branding.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(branding, detaching);\n    }\n  };\n} // (100:4) {#if closeable}\n\n\nfunction create_if_block$1(ctx) {\n  var div;\n  var svg;\n  var g0;\n  var path;\n  var g1;\n  var g2;\n  var g3;\n  var g4;\n  var g5;\n  var g6;\n  var g7;\n  var g8;\n  var g9;\n  var g10;\n  var g11;\n  var g12;\n  var g13;\n  var g14;\n  var g15;\n  var svg_fill_value;\n  var mounted;\n  var dispose;\n  return {\n    c: function c() {\n      div = element(\"div\");\n      svg = svg_element(\"svg\");\n      g0 = svg_element(\"g\");\n      path = svg_element(\"path\");\n      g1 = svg_element(\"g\");\n      g2 = svg_element(\"g\");\n      g3 = svg_element(\"g\");\n      g4 = svg_element(\"g\");\n      g5 = svg_element(\"g\");\n      g6 = svg_element(\"g\");\n      g7 = svg_element(\"g\");\n      g8 = svg_element(\"g\");\n      g9 = svg_element(\"g\");\n      g10 = svg_element(\"g\");\n      g11 = svg_element(\"g\");\n      g12 = svg_element(\"g\");\n      g13 = svg_element(\"g\");\n      g14 = svg_element(\"g\");\n      g15 = svg_element(\"g\");\n      attr(path, \"d\", \"M28.228,23.986L47.092,5.122c1.172-1.171,1.172-3.071,0-4.242c-1.172-1.172-3.07-1.172-4.242,0L23.986,19.744L5.121,0.88\\n              c-1.172-1.172-3.07-1.172-4.242,0c-1.172,1.171-1.172,3.071,0,4.242l18.865,18.864L0.879,42.85c-1.172,1.171-1.172,3.071,0,4.242\\n              C1.465,47.677,2.233,47.97,3,47.97s1.535-0.293,2.121-0.879l18.865-18.864L42.85,47.091c0.586,0.586,1.354,0.879,2.121,0.879\\n              s1.535-0.293,2.121-0.879c1.172-1.171,1.172-3.071,0-4.242L28.228,23.986z\");\n      attr(svg, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      attr(svg, \"xmlns:xlink\", \"http://www.w3.org/1999/xlink\");\n      attr(svg, \"x\", \"0px\");\n      attr(svg, \"y\", \"0px\");\n      attr(svg, \"viewBox\", \"0 0 47.971 47.971\");\n      set_style(svg, \"enable-background\", \"new 0 0 47.971 47.971\");\n      set_style(svg, \"transition\", \"fill 150ms\\n          ease-in-out\");\n      attr(svg, \"fill\", svg_fill_value =\n      /*closeHovered*/\n      ctx[2] ?\n      /*$app*/\n      ctx[3].darkMode ? \"#ffffff\" : \"#4a4a4a\" : \"#9B9B9B\");\n      attr(svg, \"xml:space\", \"preserve\");\n      attr(svg, \"class\", \"svelte-rntogh\");\n      attr(div, \"class\", \"bn-onboard-custom bn-onboard-modal-content-close svelte-rntogh\");\n      toggle_class(div, \"bn-onboard-dark-mode-close-background\",\n      /*$app*/\n      ctx[3].darkMode);\n    },\n    m: function m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, svg);\n      append(svg, g0);\n      append(g0, path);\n      append(svg, g1);\n      append(svg, g2);\n      append(svg, g3);\n      append(svg, g4);\n      append(svg, g5);\n      append(svg, g6);\n      append(svg, g7);\n      append(svg, g8);\n      append(svg, g9);\n      append(svg, g10);\n      append(svg, g11);\n      append(svg, g12);\n      append(svg, g13);\n      append(svg, g14);\n      append(svg, g15);\n\n      if (!mounted) {\n        dispose = [listen(div, \"click\", function () {\n          if (is_function(\n          /*closeModal*/\n          ctx[0]))\n            /*closeModal*/\n            ctx[0].apply(this, arguments);\n        }), listen(div, \"mouseenter\",\n        /*mouseenter_handler*/\n        ctx[6]), listen(div, \"mouseleave\",\n        /*mouseleave_handler*/\n        ctx[7])];\n        mounted = true;\n      }\n    },\n    p: function p(new_ctx, dirty) {\n      ctx = new_ctx;\n\n      if (dirty &\n      /*closeHovered, $app*/\n      12 && svg_fill_value !== (svg_fill_value =\n      /*closeHovered*/\n      ctx[2] ?\n      /*$app*/\n      ctx[3].darkMode ? \"#ffffff\" : \"#4a4a4a\" : \"#9B9B9B\")) {\n        attr(svg, \"fill\", svg_fill_value);\n      }\n\n      if (dirty &\n      /*$app*/\n      8) {\n        toggle_class(div, \"bn-onboard-dark-mode-close-background\",\n        /*$app*/\n        ctx[3].darkMode);\n      }\n    },\n    d: function d(detaching) {\n      if (detaching) detach(div);\n      mounted = false;\n      run_all(dispose);\n    }\n  };\n}\n\nfunction create_fragment$1(ctx) {\n  var aside;\n  var section;\n  var t0;\n  var t1;\n  var aside_transition;\n  var current;\n  var mounted;\n  var dispose;\n  var default_slot_template =\n  /*#slots*/\n  ctx[5][\"default\"];\n  var default_slot = create_slot(default_slot_template, ctx,\n  /*$$scope*/\n  ctx[4], null);\n  var if_block0 =\n  /*$app*/\n  ctx[3].displayBranding && create_if_block_1(ctx);\n  var if_block1 =\n  /*closeable*/\n  ctx[1] && create_if_block$1(ctx);\n  return {\n    c: function c() {\n      aside = element(\"aside\");\n      section = element(\"section\");\n      if (default_slot) default_slot.c();\n      t0 = space();\n      if (if_block0) if_block0.c();\n      t1 = space();\n      if (if_block1) if_block1.c();\n      attr(section, \"class\", \"bn-onboard-custom bn-onboard-modal-content svelte-rntogh\");\n      toggle_class(section, \"bn-onboard-dark-mode\",\n      /*$app*/\n      ctx[3].darkMode);\n      toggle_class(section, \"no-padding-branding\",\n      /*$app*/\n      ctx[3].displayBranding);\n      attr(aside, \"class\", \"bn-onboard-custom bn-onboard-modal svelte-rntogh\");\n    },\n    m: function m(target, anchor) {\n      insert(target, aside, anchor);\n      append(aside, section);\n\n      if (default_slot) {\n        default_slot.m(section, null);\n      }\n\n      append(section, t0);\n      if (if_block0) if_block0.m(section, null);\n      append(section, t1);\n      if (if_block1) if_block1.m(section, null);\n      current = true;\n\n      if (!mounted) {\n        dispose = [listen(section, \"click\", click_handler), listen(aside, \"click\", function () {\n          if (is_function(\n          /*closeModal*/\n          ctx[0]))\n            /*closeModal*/\n            ctx[0].apply(this, arguments);\n        })];\n        mounted = true;\n      }\n    },\n    p: function p(new_ctx, _ref12) {\n      var _ref13 = _slicedToArray(_ref12, 1),\n          dirty = _ref13[0];\n\n      ctx = new_ctx;\n\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty &\n        /*$$scope*/\n        16)) {\n          update_slot(default_slot, default_slot_template, ctx,\n          /*$$scope*/\n          ctx[4], dirty, null, null);\n        }\n      }\n\n      if (\n      /*$app*/\n      ctx[3].displayBranding) {\n        if (if_block0) {\n          if_block0.p(ctx, dirty);\n\n          if (dirty &\n          /*$app*/\n          8) {\n            transition_in(if_block0, 1);\n          }\n        } else {\n          if_block0 = create_if_block_1(ctx);\n          if_block0.c();\n          transition_in(if_block0, 1);\n          if_block0.m(section, t1);\n        }\n      } else if (if_block0) {\n        group_outros();\n        transition_out(if_block0, 1, 1, function () {\n          if_block0 = null;\n        });\n        check_outros();\n      }\n\n      if (\n      /*closeable*/\n      ctx[1]) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n        } else {\n          if_block1 = create_if_block$1(ctx);\n          if_block1.c();\n          if_block1.m(section, null);\n        }\n      } else if (if_block1) {\n        if_block1.d(1);\n        if_block1 = null;\n      }\n\n      if (dirty &\n      /*$app*/\n      8) {\n        toggle_class(section, \"bn-onboard-dark-mode\",\n        /*$app*/\n        ctx[3].darkMode);\n      }\n\n      if (dirty &\n      /*$app*/\n      8) {\n        toggle_class(section, \"no-padding-branding\",\n        /*$app*/\n        ctx[3].displayBranding);\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      transition_in(if_block0);\n      add_render_callback(function () {\n        if (!aside_transition) aside_transition = create_bidirectional_transition(aside, fade, {}, true);\n        aside_transition.run(1);\n      });\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(default_slot, local);\n      transition_out(if_block0);\n      if (!aside_transition) aside_transition = create_bidirectional_transition(aside, fade, {}, false);\n      aside_transition.run(0);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(aside);\n      if (default_slot) default_slot.d(detaching);\n      if (if_block0) if_block0.d();\n      if (if_block1) if_block1.d();\n      if (detaching && aside_transition) aside_transition.end();\n      mounted = false;\n      run_all(dispose);\n    }\n  };\n}\n\nvar click_handler = function click_handler(e) {\n  return e.stopPropagation();\n};\n\nfunction instance$1($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(3, $app = $$value);\n  });\n  var _$$props$$$slots = $$props.$$slots,\n      slots = _$$props$$$slots === void 0 ? {} : _$$props$$$slots,\n      $$scope = $$props.$$scope;\n  var _$$props$closeModal = $$props.closeModal,\n      closeModal = _$$props$closeModal === void 0 ? function () {} : _$$props$closeModal;\n  var _$$props$closeable = $$props.closeable,\n      closeable = _$$props$closeable === void 0 ? true : _$$props$closeable;\n  var closeHovered;\n\n  var mouseenter_handler = function mouseenter_handler() {\n    return $$invalidate(2, closeHovered = true);\n  };\n\n  var mouseleave_handler = function mouseleave_handler() {\n    return $$invalidate(2, closeHovered = false);\n  };\n\n  $$self.$$set = function ($$props) {\n    if (\"closeModal\" in $$props) $$invalidate(0, closeModal = $$props.closeModal);\n    if (\"closeable\" in $$props) $$invalidate(1, closeable = $$props.closeable);\n    if (\"$$scope\" in $$props) $$invalidate(4, $$scope = $$props.$$scope);\n  };\n\n  return [closeModal, closeable, closeHovered, $app, $$scope, slots, mouseenter_handler, mouseleave_handler];\n}\n\nvar Modal = /*#__PURE__*/function (_SvelteComponent2) {\n  _inherits(Modal, _SvelteComponent2);\n\n  var _super2 = _createSuper(Modal);\n\n  function Modal(options) {\n    var _this2;\n\n    _classCallCheck(this, Modal);\n\n    _this2 = _super2.call(this);\n    if (!document.getElementById(\"svelte-rntogh-style\")) add_css$1();\n    init(_assertThisInitialized(_this2), options, instance$1, create_fragment$1, safe_not_equal, {\n      closeModal: 0,\n      closeable: 1\n    });\n    return _this2;\n  }\n\n  return Modal;\n}(SvelteComponent);\n/* src/components/ModalHeader.svelte generated by Svelte v3.38.2 */\n\n\nfunction add_css$2() {\n  var style = element(\"style\");\n  style.id = \"svelte-8i8o6j-style\";\n  style.textContent = \"header.svelte-8i8o6j{display:flex;align-items:center;font-size:inherit;font-family:inherit;margin-bottom:1em}div.svelte-8i8o6j{display:flex;justify-content:center;align-items:center;font-size:inherit;font-family:inherit;padding:0.6em;border-radius:30px;background:#eeeeee}h3.svelte-8i8o6j{font-weight:bold;font-size:1.33em;font-family:inherit;margin:0 0 0 0.5em}\";\n  append(document.head, style);\n}\n\nfunction create_fragment$2(ctx) {\n  var header;\n  var div;\n  var t0;\n  var h3;\n  var t1;\n  return {\n    c: function c() {\n      header = element(\"header\");\n      div = element(\"div\");\n      t0 = space();\n      h3 = element(\"h3\");\n      t1 = text(\n      /*heading*/\n      ctx[0]);\n      attr(div, \"class\", \"bn-onboard-custom bn-onboard-modal-content-header-icon svelte-8i8o6j\");\n      toggle_class(div, \"bn-onboard-dark-mode-background\",\n      /*$app*/\n      ctx[2].darkMode);\n      attr(h3, \"class\", \"bn-onboard-custom bn-onboard-modal-content-header-heading svelte-8i8o6j\");\n      attr(header, \"class\", \"bn-onboard-custom bn-onboard-modal-content-header svelte-8i8o6j\");\n    },\n    m: function m(target, anchor) {\n      insert(target, header, anchor);\n      append(header, div);\n      div.innerHTML =\n      /*icon*/\n      ctx[1];\n      append(header, t0);\n      append(header, h3);\n      append(h3, t1);\n    },\n    p: function p(ctx, _ref14) {\n      var _ref15 = _slicedToArray(_ref14, 1),\n          dirty = _ref15[0];\n\n      if (dirty &\n      /*icon*/\n      2) div.innerHTML =\n      /*icon*/\n      ctx[1];\n\n      if (dirty &\n      /*$app*/\n      4) {\n        toggle_class(div, \"bn-onboard-dark-mode-background\",\n        /*$app*/\n        ctx[2].darkMode);\n      }\n\n      if (dirty &\n      /*heading*/\n      1) set_data(t1,\n      /*heading*/\n      ctx[0]);\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(header);\n    }\n  };\n}\n\nfunction instance$2($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(2, $app = $$value);\n  });\n  var heading = $$props.heading;\n  var icon = $$props.icon;\n\n  $$self.$$set = function ($$props) {\n    if (\"heading\" in $$props) $$invalidate(0, heading = $$props.heading);\n    if (\"icon\" in $$props) $$invalidate(1, icon = $$props.icon);\n  };\n\n  return [heading, icon, $app];\n}\n\nvar ModalHeader = /*#__PURE__*/function (_SvelteComponent3) {\n  _inherits(ModalHeader, _SvelteComponent3);\n\n  var _super3 = _createSuper(ModalHeader);\n\n  function ModalHeader(options) {\n    var _this3;\n\n    _classCallCheck(this, ModalHeader);\n\n    _this3 = _super3.call(this);\n    if (!document.getElementById(\"svelte-8i8o6j-style\")) add_css$2();\n    init(_assertThisInitialized(_this3), options, instance$2, create_fragment$2, safe_not_equal, {\n      heading: 0,\n      icon: 1\n    });\n    return _this3;\n  }\n\n  return ModalHeader;\n}(SvelteComponent);\n/* src/elements/Button.svelte generated by Svelte v3.38.2 */\n\n\nfunction add_css$3() {\n  var style = element(\"style\");\n  style.id = \"svelte-fnc3e1-style\";\n  style.textContent = \"button.svelte-fnc3e1{border:none;background:inherit;font-size:0.889em;font-family:inherit;padding:0.55em 1.4em;cursor:pointer;color:#4a90e2;font-family:inherit;transition:background 150ms ease-in-out;line-height:1.15;opacity:1;transition:opacity 200ms}button.svelte-fnc3e1:focus{outline:none}.bn-onboard-prepare-button-right.svelte-fnc3e1{position:absolute;right:0}.bn-onboard-prepare-button-left.svelte-fnc3e1{position:absolute;left:0}.disabled.svelte-fnc3e1{cursor:inherit;pointer-events:none;opacity:0.4}.cta.svelte-fnc3e1{border:1px solid #4a90e2;border-radius:40px}.cta.svelte-fnc3e1:hover{background:#ecf3fc}\";\n  append(document.head, style);\n}\n\nfunction create_fragment$3(ctx) {\n  var button;\n  var current;\n  var mounted;\n  var dispose;\n  var default_slot_template =\n  /*#slots*/\n  ctx[6][\"default\"];\n  var default_slot = create_slot(default_slot_template, ctx,\n  /*$$scope*/\n  ctx[5], null);\n  return {\n    c: function c() {\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      button.disabled =\n      /*disabled*/\n      ctx[2];\n      attr(button, \"class\", \"bn-onboard-custom bn-onboard-prepare-button svelte-fnc3e1\");\n      toggle_class(button, \"disabled\",\n      /*disabled*/\n      ctx[2]);\n      toggle_class(button, \"cta\",\n      /*cta*/\n      ctx[3]);\n      toggle_class(button, \"bn-onboard-prepare-button-right\",\n      /*position*/\n      ctx[1] === \"right\");\n      toggle_class(button, \"bn-onboard-prepare-button-left\",\n      /*position*/\n      ctx[1] === \"left\");\n      toggle_class(button, \"bn-onboard-prepare-button-center\",\n      /*position*/\n      ctx[1] !== \"left\" &&\n      /*position*/\n      ctx[1] !== \"right\");\n      toggle_class(button, \"bn-onboard-dark-mode-link\",\n      /*$app*/\n      ctx[4].darkMode);\n      toggle_class(button, \"bn-onboard-dark-mode-background-hover\",\n      /*$app*/\n      ctx[4].darkMode);\n    },\n    m: function m(target, anchor) {\n      insert(target, button, anchor);\n\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n\n      current = true;\n\n      if (!mounted) {\n        dispose = listen(button, \"click\", function () {\n          if (is_function(\n          /*onclick*/\n          ctx[0]))\n            /*onclick*/\n            ctx[0].apply(this, arguments);\n        });\n        mounted = true;\n      }\n    },\n    p: function p(new_ctx, _ref16) {\n      var _ref17 = _slicedToArray(_ref16, 1),\n          dirty = _ref17[0];\n\n      ctx = new_ctx;\n\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty &\n        /*$$scope*/\n        32)) {\n          update_slot(default_slot, default_slot_template, ctx,\n          /*$$scope*/\n          ctx[5], dirty, null, null);\n        }\n      }\n\n      if (!current || dirty &\n      /*disabled*/\n      4) {\n        button.disabled =\n        /*disabled*/\n        ctx[2];\n      }\n\n      if (dirty &\n      /*disabled*/\n      4) {\n        toggle_class(button, \"disabled\",\n        /*disabled*/\n        ctx[2]);\n      }\n\n      if (dirty &\n      /*cta*/\n      8) {\n        toggle_class(button, \"cta\",\n        /*cta*/\n        ctx[3]);\n      }\n\n      if (dirty &\n      /*position*/\n      2) {\n        toggle_class(button, \"bn-onboard-prepare-button-right\",\n        /*position*/\n        ctx[1] === \"right\");\n      }\n\n      if (dirty &\n      /*position*/\n      2) {\n        toggle_class(button, \"bn-onboard-prepare-button-left\",\n        /*position*/\n        ctx[1] === \"left\");\n      }\n\n      if (dirty &\n      /*position*/\n      2) {\n        toggle_class(button, \"bn-onboard-prepare-button-center\",\n        /*position*/\n        ctx[1] !== \"left\" &&\n        /*position*/\n        ctx[1] !== \"right\");\n      }\n\n      if (dirty &\n      /*$app*/\n      16) {\n        toggle_class(button, \"bn-onboard-dark-mode-link\",\n        /*$app*/\n        ctx[4].darkMode);\n      }\n\n      if (dirty &\n      /*$app*/\n      16) {\n        toggle_class(button, \"bn-onboard-dark-mode-background-hover\",\n        /*$app*/\n        ctx[4].darkMode);\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(button);\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\n\nfunction instance$3($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(4, $app = $$value);\n  });\n  var _$$props$$$slots2 = $$props.$$slots,\n      slots = _$$props$$$slots2 === void 0 ? {} : _$$props$$$slots2,\n      $$scope = $$props.$$scope;\n  var _$$props$onclick = $$props.onclick,\n      onclick = _$$props$onclick === void 0 ? function () {} : _$$props$onclick;\n  var _$$props$position = $$props.position,\n      position = _$$props$position === void 0 ? \"\" : _$$props$position;\n  var _$$props$disabled = $$props.disabled,\n      disabled = _$$props$disabled === void 0 ? false : _$$props$disabled;\n  var _$$props$cta = $$props.cta,\n      cta = _$$props$cta === void 0 ? true : _$$props$cta;\n\n  $$self.$$set = function ($$props) {\n    if (\"onclick\" in $$props) $$invalidate(0, onclick = $$props.onclick);\n    if (\"position\" in $$props) $$invalidate(1, position = $$props.position);\n    if (\"disabled\" in $$props) $$invalidate(2, disabled = $$props.disabled);\n    if (\"cta\" in $$props) $$invalidate(3, cta = $$props.cta);\n    if (\"$$scope\" in $$props) $$invalidate(5, $$scope = $$props.$$scope);\n  };\n\n  return [onclick, position, disabled, cta, $app, $$scope, slots];\n}\n\nvar Button = /*#__PURE__*/function (_SvelteComponent4) {\n  _inherits(Button, _SvelteComponent4);\n\n  var _super4 = _createSuper(Button);\n\n  function Button(options) {\n    var _this4;\n\n    _classCallCheck(this, Button);\n\n    _this4 = _super4.call(this);\n    if (!document.getElementById(\"svelte-fnc3e1-style\")) add_css$3();\n    init(_assertThisInitialized(_this4), options, instance$3, create_fragment$3, safe_not_equal, {\n      onclick: 0,\n      position: 1,\n      disabled: 2,\n      cta: 3\n    });\n    return _this4;\n  }\n\n  return Button;\n}(SvelteComponent);\n/* src/elements/Spinner.svelte generated by Svelte v3.38.2 */\n\n\nfunction add_css$4() {\n  var style = element(\"style\");\n  style.id = \"svelte-16ghk2h-style\";\n  style.textContent = \".bn-onboard-loading-container.svelte-16ghk2h{display:flex;flex-direction:column;align-items:center;justify-content:center;font-family:inherit;font-size:inherit;color:inherit}span.svelte-16ghk2h{font-family:inherit;font-size:0.889em;margin-top:1rem}.bn-onboard-loading{display:inline-block;position:relative;width:2em;height:2em}.bn-onboard-loading div{box-sizing:border-box;font-size:inherit;display:block;position:absolute;width:2em;height:2em;border:3px solid;border-radius:50%;animation:bn-onboard-loading 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;border-color:currentColor transparent transparent transparent}.bn-onboard-loading .bn-onboard-loading-first{animation-delay:-0.45s}.bn-onboard-loading .bn-onboard-loading-second{animation-delay:-0.3s}.bn-onboard-loading .bn-onboard-loading-third{animation-delay:-0.15s}@keyframes bn-onboard-loading{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}\";\n  append(document.head, style);\n} // (64:2) {#if description}\n\n\nfunction create_if_block$2(ctx) {\n  var span;\n  var t;\n  return {\n    c: function c() {\n      span = element(\"span\");\n      t = text(\n      /*description*/\n      ctx[0]);\n      attr(span, \"class\", \"svelte-16ghk2h\");\n    },\n    m: function m(target, anchor) {\n      insert(target, span, anchor);\n      append(span, t);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*description*/\n      1) set_data(t,\n      /*description*/\n      ctx[0]);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(span);\n    }\n  };\n}\n\nfunction create_fragment$4(ctx) {\n  var div4;\n  var div3;\n  var t2;\n  var if_block =\n  /*description*/\n  ctx[0] && create_if_block$2(ctx);\n  return {\n    c: function c() {\n      div4 = element(\"div\");\n      div3 = element(\"div\");\n      div3.innerHTML = \"<div class=\\\"bn-onboard-loading-first\\\"></div> \\n    <div class=\\\"bn-onboard-loading-second\\\"></div> \\n    <div class=\\\"bn-onboard-loading-third\\\"></div>\";\n      t2 = space();\n      if (if_block) if_block.c();\n      attr(div3, \"class\", \"bn-onboard-custom bn-onboard-loading\");\n      attr(div4, \"class\", \"bn-onboard-loading-container svelte-16ghk2h\");\n    },\n    m: function m(target, anchor) {\n      insert(target, div4, anchor);\n      append(div4, div3);\n      append(div4, t2);\n      if (if_block) if_block.m(div4, null);\n    },\n    p: function p(ctx, _ref18) {\n      var _ref19 = _slicedToArray(_ref18, 1),\n          dirty = _ref19[0];\n\n      if (\n      /*description*/\n      ctx[0]) {\n        if (if_block) {\n          if_block.p(ctx, dirty);\n        } else {\n          if_block = create_if_block$2(ctx);\n          if_block.c();\n          if_block.m(div4, null);\n        }\n      } else if (if_block) {\n        if_block.d(1);\n        if_block = null;\n      }\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(div4);\n      if (if_block) if_block.d();\n    }\n  };\n}\n\nfunction instance$4($$self, $$props, $$invalidate) {\n  var _$$props$description = $$props.description,\n      description = _$$props$description === void 0 ? \"\" : _$$props$description;\n\n  $$self.$$set = function ($$props) {\n    if (\"description\" in $$props) $$invalidate(0, description = $$props.description);\n  };\n\n  return [description];\n}\n\nvar Spinner = /*#__PURE__*/function (_SvelteComponent5) {\n  _inherits(Spinner, _SvelteComponent5);\n\n  var _super5 = _createSuper(Spinner);\n\n  function Spinner(options) {\n    var _this5;\n\n    _classCallCheck(this, Spinner);\n\n    _this5 = _super5.call(this);\n    if (!document.getElementById(\"svelte-16ghk2h-style\")) add_css$4();\n    init(_assertThisInitialized(_this5), options, instance$4, create_fragment$4, safe_not_equal, {\n      description: 0\n    });\n    return _this5;\n  }\n\n  return Spinner;\n}(SvelteComponent);\n/* src/elements/IconButton.svelte generated by Svelte v3.38.2 */\n\n\nfunction add_css$5() {\n  var style = element(\"style\");\n  style.id = \"svelte-1799bj2-style\";\n  style.textContent = \"button.svelte-1799bj2{display:flex;align-items:center;border:none;margin:0.33em 0;background:inherit;font-size:inherit;width:18em;padding:0.625em 1.25em;transition:box-shadow 150ms ease-in-out, background 200ms ease-in-out;border-radius:40px;cursor:pointer;color:inherit;line-height:1.15;font-family:inherit;opacity:1;transition:opacity 200ms}.disabled.svelte-1799bj2{cursor:inherit;pointer-events:none;opacity:0.4}button.svelte-1799bj2:hover{box-shadow:0 2px 10px 0 rgba(0, 0, 0, 0.1)}button.svelte-1799bj2:focus{outline:none}div.svelte-1799bj2{display:flex;justify-content:center;align-items:center;text-align:center;height:40px;width:40px;line-height:40px;font-family:inherit}img.svelte-1799bj2{max-height:100%;max-width:100%;vertical-align:middle}span.svelte-1799bj2{width:100%;display:flex;justify-content:space-between;align-items:center;font-size:inherit;margin-left:0.66em;font-weight:bold;text-align:left;font-family:inherit}i.svelte-1799bj2{font-size:0.8rem;font-weight:lighter;color:inherit;text-decoration:underline}@media only screen and (max-width: 450px){button.svelte-1799bj2{width:100%}}.bn-onboard-selected-wallet.svelte-1799bj2{background:#c3c3c3}\";\n  append(document.head, style);\n} // (108:4) {:else}\n\n\nfunction create_else_block$1(ctx) {\n  var img;\n  var img_src_value;\n  return {\n    c: function c() {\n      img = element(\"img\");\n      if (img.src !== (img_src_value =\n      /*iconSrc*/\n      ctx[0])) attr(img, \"src\", img_src_value);\n      attr(img, \"srcset\",\n      /*iconSrcSet*/\n      ctx[1]);\n      attr(img, \"alt\",\n      /*text*/\n      ctx[4]);\n      attr(img, \"class\", \"svelte-1799bj2\");\n    },\n    m: function m(target, anchor) {\n      insert(target, img, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*iconSrc*/\n      1 && img.src !== (img_src_value =\n      /*iconSrc*/\n      ctx[0])) {\n        attr(img, \"src\", img_src_value);\n      }\n\n      if (dirty &\n      /*iconSrcSet*/\n      2) {\n        attr(img, \"srcset\",\n        /*iconSrcSet*/\n        ctx[1]);\n      }\n\n      if (dirty &\n      /*text*/\n      16) {\n        attr(img, \"alt\",\n        /*text*/\n        ctx[4]);\n      }\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(img);\n    }\n  };\n} // (106:18) \n\n\nfunction create_if_block_2(ctx) {\n  var html_tag;\n  var html_anchor;\n  return {\n    c: function c() {\n      html_anchor = empty();\n      html_tag = new HtmlTag(html_anchor);\n    },\n    m: function m(target, anchor) {\n      html_tag.m(\n      /*svg*/\n      ctx[2], target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*svg*/\n      4) html_tag.p(\n      /*svg*/\n      ctx[2]);\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(html_anchor);\n      if (detaching) html_tag.d();\n    }\n  };\n} // (104:4) {#if loadingWallet === text}\n\n\nfunction create_if_block_1$1(ctx) {\n  var spinner;\n  var current;\n  spinner = new Spinner({});\n  return {\n    c: function c() {\n      create_component(spinner.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(spinner, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i: function i(local) {\n      if (current) return;\n      transition_in(spinner.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(spinner.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(spinner, detaching);\n    }\n  };\n} // (114:4) {#if currentlySelected}\n\n\nfunction create_if_block$3(ctx) {\n  var i;\n  return {\n    c: function c() {\n      i = element(\"i\");\n      i.textContent = \"selected\";\n      attr(i, \"class\", \"svelte-1799bj2\");\n    },\n    m: function m(target, anchor) {\n      insert(target, i, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(i);\n    }\n  };\n}\n\nfunction create_fragment$5(ctx) {\n  var button;\n  var div;\n  var current_block_type_index;\n  var if_block0;\n  var t0;\n  var span;\n  var t1;\n  var t2;\n  var current;\n  var mounted;\n  var dispose;\n  var if_block_creators = [create_if_block_1$1, create_if_block_2, create_else_block$1];\n  var if_blocks = [];\n\n  function select_block_type(ctx, dirty) {\n    if (\n    /*loadingWallet*/\n    ctx[5] ===\n    /*text*/\n    ctx[4]) return 0;\n    if (\n    /*svg*/\n    ctx[2]) return 1;\n    return 2;\n  }\n\n  current_block_type_index = select_block_type(ctx);\n  if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n  var if_block1 =\n  /*currentlySelected*/\n  ctx[6] && create_if_block$3();\n  return {\n    c: function c() {\n      button = element(\"button\");\n      div = element(\"div\");\n      if_block0.c();\n      t0 = space();\n      span = element(\"span\");\n      t1 = text(\n      /*text*/\n      ctx[4]);\n      t2 = space();\n      if (if_block1) if_block1.c();\n      attr(div, \"class\", \"svelte-1799bj2\");\n      attr(span, \"class\", \"svelte-1799bj2\");\n      button.disabled =\n      /*disabled*/\n      ctx[7];\n      attr(button, \"class\", \"bn-onboard-custom bn-onboard-icon-button svelte-1799bj2\");\n      toggle_class(button, \"disabled\",\n      /*disabled*/\n      ctx[7]);\n      toggle_class(button, \"bn-onboard-dark-mode-background-hover\",\n      /*$app*/\n      ctx[8].darkMode);\n      toggle_class(button, \"bn-onboard-selected-wallet\",\n      /*currentlySelected*/\n      ctx[6]);\n    },\n    m: function m(target, anchor) {\n      insert(target, button, anchor);\n      append(button, div);\n      if_blocks[current_block_type_index].m(div, null);\n      append(button, t0);\n      append(button, span);\n      append(span, t1);\n      append(span, t2);\n      if (if_block1) if_block1.m(span, null);\n      current = true;\n\n      if (!mounted) {\n        dispose = listen(button, \"click\", function () {\n          if (is_function(\n          /*onclick*/\n          ctx[3]))\n            /*onclick*/\n            ctx[3].apply(this, arguments);\n        });\n        mounted = true;\n      }\n    },\n    p: function p(new_ctx, _ref20) {\n      var _ref21 = _slicedToArray(_ref20, 1),\n          dirty = _ref21[0];\n\n      ctx = new_ctx;\n      var previous_block_index = current_block_type_index;\n      current_block_type_index = select_block_type(ctx);\n\n      if (current_block_type_index === previous_block_index) {\n        if_blocks[current_block_type_index].p(ctx, dirty);\n      } else {\n        group_outros();\n        transition_out(if_blocks[previous_block_index], 1, 1, function () {\n          if_blocks[previous_block_index] = null;\n        });\n        check_outros();\n        if_block0 = if_blocks[current_block_type_index];\n\n        if (!if_block0) {\n          if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n          if_block0.c();\n        } else {\n          if_block0.p(ctx, dirty);\n        }\n\n        transition_in(if_block0, 1);\n        if_block0.m(div, null);\n      }\n\n      if (!current || dirty &\n      /*text*/\n      16) set_data(t1,\n      /*text*/\n      ctx[4]);\n\n      if (\n      /*currentlySelected*/\n      ctx[6]) {\n        if (if_block1) ;else {\n          if_block1 = create_if_block$3();\n          if_block1.c();\n          if_block1.m(span, null);\n        }\n      } else if (if_block1) {\n        if_block1.d(1);\n        if_block1 = null;\n      }\n\n      if (!current || dirty &\n      /*disabled*/\n      128) {\n        button.disabled =\n        /*disabled*/\n        ctx[7];\n      }\n\n      if (dirty &\n      /*disabled*/\n      128) {\n        toggle_class(button, \"disabled\",\n        /*disabled*/\n        ctx[7]);\n      }\n\n      if (dirty &\n      /*$app*/\n      256) {\n        toggle_class(button, \"bn-onboard-dark-mode-background-hover\",\n        /*$app*/\n        ctx[8].darkMode);\n      }\n\n      if (dirty &\n      /*currentlySelected*/\n      64) {\n        toggle_class(button, \"bn-onboard-selected-wallet\",\n        /*currentlySelected*/\n        ctx[6]);\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(if_block0);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(if_block0);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(button);\n      if_blocks[current_block_type_index].d();\n      if (if_block1) if_block1.d();\n      mounted = false;\n      dispose();\n    }\n  };\n}\n\nfunction instance$5($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(8, $app = $$value);\n  });\n  var iconSrc = $$props.iconSrc;\n  var iconSrcSet = $$props.iconSrcSet;\n  var svg = $$props.svg;\n  var _$$props$onclick2 = $$props.onclick,\n      onclick = _$$props$onclick2 === void 0 ? function () {} : _$$props$onclick2;\n  var text = $$props.text;\n  var loadingWallet = $$props.loadingWallet;\n  var _$$props$currentlySel = $$props.currentlySelected,\n      currentlySelected = _$$props$currentlySel === void 0 ? false : _$$props$currentlySel;\n  var _$$props$disabled2 = $$props.disabled,\n      disabled = _$$props$disabled2 === void 0 ? false : _$$props$disabled2;\n\n  $$self.$$set = function ($$props) {\n    if (\"iconSrc\" in $$props) $$invalidate(0, iconSrc = $$props.iconSrc);\n    if (\"iconSrcSet\" in $$props) $$invalidate(1, iconSrcSet = $$props.iconSrcSet);\n    if (\"svg\" in $$props) $$invalidate(2, svg = $$props.svg);\n    if (\"onclick\" in $$props) $$invalidate(3, onclick = $$props.onclick);\n    if (\"text\" in $$props) $$invalidate(4, text = $$props.text);\n    if (\"loadingWallet\" in $$props) $$invalidate(5, loadingWallet = $$props.loadingWallet);\n    if (\"currentlySelected\" in $$props) $$invalidate(6, currentlySelected = $$props.currentlySelected);\n    if (\"disabled\" in $$props) $$invalidate(7, disabled = $$props.disabled);\n  };\n\n  return [iconSrc, iconSrcSet, svg, onclick, text, loadingWallet, currentlySelected, disabled, $app];\n}\n\nvar IconButton = /*#__PURE__*/function (_SvelteComponent6) {\n  _inherits(IconButton, _SvelteComponent6);\n\n  var _super6 = _createSuper(IconButton);\n\n  function IconButton(options) {\n    var _this6;\n\n    _classCallCheck(this, IconButton);\n\n    _this6 = _super6.call(this);\n    if (!document.getElementById(\"svelte-1799bj2-style\")) add_css$5();\n    init(_assertThisInitialized(_this6), options, instance$5, create_fragment$5, safe_not_equal, {\n      iconSrc: 0,\n      iconSrcSet: 1,\n      svg: 2,\n      onclick: 3,\n      text: 4,\n      loadingWallet: 5,\n      currentlySelected: 6,\n      disabled: 7\n    });\n    return _this6;\n  }\n\n  return IconButton;\n}(SvelteComponent);\n/* src/components/Wallets.svelte generated by Svelte v3.38.2 */\n\n\nfunction add_css$6() {\n  var style = element(\"style\");\n  style.id = \"svelte-q1527-style\";\n  style.textContent = \"ul.svelte-q1527.svelte-q1527{display:flex;flex-flow:row wrap;align-items:center;list-style-type:none;margin:1.25em 0;padding:0;font-family:inherit;font-size:inherit;line-height:1.15;box-sizing:border-box}ul.svelte-q1527 li.svelte-q1527{padding:0 0.25em}div.svelte-q1527.svelte-q1527{width:100%;display:flex;font-size:inherit;font-family:inherit;justify-content:center;margin-top:1.25em}.svelte-q1527.svelte-q1527::-webkit-scrollbar{display:none}@media only screen and (max-width: 450px){ul.svelte-q1527 li.svelte-q1527{width:100%}ul.svelte-q1527.svelte-q1527{max-height:66vh;overflow-y:scroll}}\";\n  append(document.head, style);\n}\n\nfunction get_each_context(ctx, list, i) {\n  var child_ctx = ctx.slice();\n  child_ctx[10] = list[i];\n  child_ctx[12] = i;\n  return child_ctx;\n}\n\nfunction get_each_context_1(ctx, list, i) {\n  var child_ctx = ctx.slice();\n  child_ctx[10] = list[i];\n  child_ctx[12] = i;\n  return child_ctx;\n} // (62:2) {#each modalData.primaryWallets as wallet, i (wallet.name)}\n\n\nfunction create_each_block_1(key_1, ctx) {\n  var li;\n  var iconbutton;\n  var current;\n\n  function func() {\n    return (\n      /*func*/\n      ctx[7](\n      /*wallet*/\n      ctx[10])\n    );\n  }\n\n  iconbutton = new IconButton({\n    props: {\n      disabled:\n      /*walletsDisabled*/\n      ctx[5],\n      onclick: func,\n      iconSrc:\n      /*wallet*/\n      ctx[10].iconSrc,\n      iconSrcSet:\n      /*wallet*/\n      ctx[10].iconSrcSet,\n      svg:\n      /*wallet*/\n      ctx[10].svg,\n      text:\n      /*wallet*/\n      ctx[10].name,\n      currentlySelected:\n      /*wallet*/\n      ctx[10].name ===\n      /*selectedWallet*/\n      ctx[6].name,\n      loadingWallet:\n      /*loadingWallet*/\n      ctx[2]\n    }\n  });\n  return {\n    key: key_1,\n    first: null,\n    c: function c() {\n      li = element(\"li\");\n      create_component(iconbutton.$$.fragment);\n      attr(li, \"class\", \"svelte-q1527\");\n      this.first = li;\n    },\n    m: function m(target, anchor) {\n      insert(target, li, anchor);\n      mount_component(iconbutton, li, null);\n      current = true;\n    },\n    p: function p(new_ctx, dirty) {\n      ctx = new_ctx;\n      var iconbutton_changes = {};\n      if (dirty &\n      /*walletsDisabled*/\n      32) iconbutton_changes.disabled =\n      /*walletsDisabled*/\n      ctx[5];\n      if (dirty &\n      /*handleWalletSelect, modalData*/\n      3) iconbutton_changes.onclick = func;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.iconSrc =\n      /*wallet*/\n      ctx[10].iconSrc;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.iconSrcSet =\n      /*wallet*/\n      ctx[10].iconSrcSet;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.svg =\n      /*wallet*/\n      ctx[10].svg;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.text =\n      /*wallet*/\n      ctx[10].name;\n      if (dirty &\n      /*modalData, selectedWallet*/\n      65) iconbutton_changes.currentlySelected =\n      /*wallet*/\n      ctx[10].name ===\n      /*selectedWallet*/\n      ctx[6].name;\n      if (dirty &\n      /*loadingWallet*/\n      4) iconbutton_changes.loadingWallet =\n      /*loadingWallet*/\n      ctx[2];\n      iconbutton.$set(iconbutton_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(iconbutton.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(iconbutton.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(li);\n      destroy_component(iconbutton);\n    }\n  };\n} // (77:2) {#if modalData.secondaryWallets && modalData.secondaryWallets.length && !showingAllWalletModules}\n\n\nfunction create_if_block_1$2(ctx) {\n  var div;\n  var button;\n  var current;\n  button = new Button({\n    props: {\n      disabled:\n      /*walletsDisabled*/\n      ctx[5],\n      onclick:\n      /*showAllWallets*/\n      ctx[4],\n      $$slots: {\n        \"default\": [create_default_slot]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      div = element(\"div\");\n      create_component(button.$$.fragment);\n      attr(div, \"class\", \"svelte-q1527\");\n    },\n    m: function m(target, anchor) {\n      insert(target, div, anchor);\n      mount_component(button, div, null);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var button_changes = {};\n      if (dirty &\n      /*walletsDisabled*/\n      32) button_changes.disabled =\n      /*walletsDisabled*/\n      ctx[5];\n      if (dirty &\n      /*showAllWallets*/\n      16) button_changes.onclick =\n      /*showAllWallets*/\n      ctx[4];\n\n      if (dirty &\n      /*$$scope*/\n      16384) {\n        button_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button.$set(button_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(button.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(button.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(div);\n      destroy_component(button);\n    }\n  };\n} // (79:6) <Button disabled={walletsDisabled} onclick={showAllWallets}         >\n\n\nfunction create_default_slot(ctx) {\n  var t;\n  return {\n    c: function c() {\n      t = text(\"Show More\");\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n} // (85:2) {#if showingAllWalletModules}\n\n\nfunction create_if_block$4(ctx) {\n  var each_blocks = [];\n  var each_1_lookup = new Map();\n  var each_1_anchor;\n  var current;\n  var each_value =\n  /*modalData*/\n  ctx[0].secondaryWallets;\n\n  var get_key = function get_key(ctx) {\n    return (\n      /*wallet*/\n      ctx[10].name\n    );\n  };\n\n  for (var i = 0; i < each_value.length; i += 1) {\n    var child_ctx = get_each_context(ctx, each_value, i);\n    var key = get_key(child_ctx);\n    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));\n  }\n\n  return {\n    c: function c() {\n      for (var _i3 = 0; _i3 < each_blocks.length; _i3 += 1) {\n        each_blocks[_i3].c();\n      }\n\n      each_1_anchor = empty();\n    },\n    m: function m(target, anchor) {\n      for (var _i4 = 0; _i4 < each_blocks.length; _i4 += 1) {\n        each_blocks[_i4].m(target, anchor);\n      }\n\n      insert(target, each_1_anchor, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*walletsDisabled, handleWalletSelect, modalData, selectedWallet, loadingWallet*/\n      103) {\n        each_value =\n        /*modalData*/\n        ctx[0].secondaryWallets;\n        group_outros();\n        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);\n        check_outros();\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n\n      for (var _i5 = 0; _i5 < each_value.length; _i5 += 1) {\n        transition_in(each_blocks[_i5]);\n      }\n\n      current = true;\n    },\n    o: function o(local) {\n      for (var _i6 = 0; _i6 < each_blocks.length; _i6 += 1) {\n        transition_out(each_blocks[_i6]);\n      }\n\n      current = false;\n    },\n    d: function d(detaching) {\n      for (var _i7 = 0; _i7 < each_blocks.length; _i7 += 1) {\n        each_blocks[_i7].d(detaching);\n      }\n\n      if (detaching) detach(each_1_anchor);\n    }\n  };\n} // (86:4) {#each modalData.secondaryWallets as wallet, i (wallet.name)}\n\n\nfunction create_each_block(key_1, ctx) {\n  var li;\n  var iconbutton;\n  var t;\n  var current;\n\n  function func_1() {\n    return (\n      /*func_1*/\n      ctx[8](\n      /*wallet*/\n      ctx[10])\n    );\n  }\n\n  iconbutton = new IconButton({\n    props: {\n      disabled:\n      /*walletsDisabled*/\n      ctx[5],\n      onclick: func_1,\n      iconSrc:\n      /*wallet*/\n      ctx[10].iconSrc,\n      iconSrcSet:\n      /*wallet*/\n      ctx[10].iconSrcSet,\n      svg:\n      /*wallet*/\n      ctx[10].svg,\n      text:\n      /*wallet*/\n      ctx[10].name,\n      currentlySelected:\n      /*wallet*/\n      ctx[10].name ===\n      /*selectedWallet*/\n      ctx[6].name,\n      loadingWallet:\n      /*loadingWallet*/\n      ctx[2]\n    }\n  });\n  return {\n    key: key_1,\n    first: null,\n    c: function c() {\n      li = element(\"li\");\n      create_component(iconbutton.$$.fragment);\n      t = space();\n      attr(li, \"class\", \"svelte-q1527\");\n      this.first = li;\n    },\n    m: function m(target, anchor) {\n      insert(target, li, anchor);\n      mount_component(iconbutton, li, null);\n      append(li, t);\n      current = true;\n    },\n    p: function p(new_ctx, dirty) {\n      ctx = new_ctx;\n      var iconbutton_changes = {};\n      if (dirty &\n      /*walletsDisabled*/\n      32) iconbutton_changes.disabled =\n      /*walletsDisabled*/\n      ctx[5];\n      if (dirty &\n      /*handleWalletSelect, modalData*/\n      3) iconbutton_changes.onclick = func_1;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.iconSrc =\n      /*wallet*/\n      ctx[10].iconSrc;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.iconSrcSet =\n      /*wallet*/\n      ctx[10].iconSrcSet;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.svg =\n      /*wallet*/\n      ctx[10].svg;\n      if (dirty &\n      /*modalData*/\n      1) iconbutton_changes.text =\n      /*wallet*/\n      ctx[10].name;\n      if (dirty &\n      /*modalData, selectedWallet*/\n      65) iconbutton_changes.currentlySelected =\n      /*wallet*/\n      ctx[10].name ===\n      /*selectedWallet*/\n      ctx[6].name;\n      if (dirty &\n      /*loadingWallet*/\n      4) iconbutton_changes.loadingWallet =\n      /*loadingWallet*/\n      ctx[2];\n      iconbutton.$set(iconbutton_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(iconbutton.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(iconbutton.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(li);\n      destroy_component(iconbutton);\n    }\n  };\n}\n\nfunction create_fragment$6(ctx) {\n  var ul;\n  var each_blocks = [];\n  var each_1_lookup = new Map();\n  var t0;\n  var t1;\n  var current;\n  var each_value_1 =\n  /*modalData*/\n  ctx[0].primaryWallets;\n\n  var get_key = function get_key(ctx) {\n    return (\n      /*wallet*/\n      ctx[10].name\n    );\n  };\n\n  for (var i = 0; i < each_value_1.length; i += 1) {\n    var child_ctx = get_each_context_1(ctx, each_value_1, i);\n    var key = get_key(child_ctx);\n    each_1_lookup.set(key, each_blocks[i] = create_each_block_1(key, child_ctx));\n  }\n\n  var if_block0 =\n  /*modalData*/\n  ctx[0].secondaryWallets &&\n  /*modalData*/\n  ctx[0].secondaryWallets.length && !\n  /*showingAllWalletModules*/\n  ctx[3] && create_if_block_1$2(ctx);\n  var if_block1 =\n  /*showingAllWalletModules*/\n  ctx[3] && create_if_block$4(ctx);\n  return {\n    c: function c() {\n      ul = element(\"ul\");\n\n      for (var _i8 = 0; _i8 < each_blocks.length; _i8 += 1) {\n        each_blocks[_i8].c();\n      }\n\n      t0 = space();\n      if (if_block0) if_block0.c();\n      t1 = space();\n      if (if_block1) if_block1.c();\n      attr(ul, \"class\", \"bn-onboard-custom bn-onboard-modal-select-wallets svelte-q1527\");\n    },\n    m: function m(target, anchor) {\n      insert(target, ul, anchor);\n\n      for (var _i9 = 0; _i9 < each_blocks.length; _i9 += 1) {\n        each_blocks[_i9].m(ul, null);\n      }\n\n      append(ul, t0);\n      if (if_block0) if_block0.m(ul, null);\n      append(ul, t1);\n      if (if_block1) if_block1.m(ul, null);\n      current = true;\n    },\n    p: function p(ctx, _ref22) {\n      var _ref23 = _slicedToArray(_ref22, 1),\n          dirty = _ref23[0];\n\n      if (dirty &\n      /*walletsDisabled, handleWalletSelect, modalData, selectedWallet, loadingWallet*/\n      103) {\n        each_value_1 =\n        /*modalData*/\n        ctx[0].primaryWallets;\n        group_outros();\n        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, outro_and_destroy_block, create_each_block_1, t0, get_each_context_1);\n        check_outros();\n      }\n\n      if (\n      /*modalData*/\n      ctx[0].secondaryWallets &&\n      /*modalData*/\n      ctx[0].secondaryWallets.length && !\n      /*showingAllWalletModules*/\n      ctx[3]) {\n        if (if_block0) {\n          if_block0.p(ctx, dirty);\n\n          if (dirty &\n          /*modalData, showingAllWalletModules*/\n          9) {\n            transition_in(if_block0, 1);\n          }\n        } else {\n          if_block0 = create_if_block_1$2(ctx);\n          if_block0.c();\n          transition_in(if_block0, 1);\n          if_block0.m(ul, t1);\n        }\n      } else if (if_block0) {\n        group_outros();\n        transition_out(if_block0, 1, 1, function () {\n          if_block0 = null;\n        });\n        check_outros();\n      }\n\n      if (\n      /*showingAllWalletModules*/\n      ctx[3]) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n\n          if (dirty &\n          /*showingAllWalletModules*/\n          8) {\n            transition_in(if_block1, 1);\n          }\n        } else {\n          if_block1 = create_if_block$4(ctx);\n          if_block1.c();\n          transition_in(if_block1, 1);\n          if_block1.m(ul, null);\n        }\n      } else if (if_block1) {\n        group_outros();\n        transition_out(if_block1, 1, 1, function () {\n          if_block1 = null;\n        });\n        check_outros();\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n\n      for (var _i10 = 0; _i10 < each_value_1.length; _i10 += 1) {\n        transition_in(each_blocks[_i10]);\n      }\n\n      transition_in(if_block0);\n      transition_in(if_block1);\n      current = true;\n    },\n    o: function o(local) {\n      for (var _i11 = 0; _i11 < each_blocks.length; _i11 += 1) {\n        transition_out(each_blocks[_i11]);\n      }\n\n      transition_out(if_block0);\n      transition_out(if_block1);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(ul);\n\n      for (var _i12 = 0; _i12 < each_blocks.length; _i12 += 1) {\n        each_blocks[_i12].d();\n      }\n\n      if (if_block0) if_block0.d();\n      if (if_block1) if_block1.d();\n    }\n  };\n}\n\nfunction instance$6($$self, $$props, $$invalidate) {\n  var modalData = $$props.modalData;\n  var handleWalletSelect = $$props.handleWalletSelect;\n  var loadingWallet = $$props.loadingWallet;\n  var _$$props$showingAllWa = $$props.showingAllWalletModules,\n      showingAllWalletModules = _$$props$showingAllWa === void 0 ? false : _$$props$showingAllWa;\n  var showAllWallets = $$props.showAllWallets;\n  var _$$props$walletsDisab = $$props.walletsDisabled,\n      walletsDisabled = _$$props$walletsDisab === void 0 ? false : _$$props$walletsDisab;\n  var selectedWallet;\n  var unsubscribe = wallet.subscribe(function (wallet) {\n    return $$invalidate(6, selectedWallet = wallet);\n  });\n  onDestroy(function () {\n    return unsubscribe();\n  });\n\n  var func = function func(wallet) {\n    return handleWalletSelect(wallet);\n  };\n\n  var func_1 = function func_1(wallet) {\n    return handleWalletSelect(wallet);\n  };\n\n  $$self.$$set = function ($$props) {\n    if (\"modalData\" in $$props) $$invalidate(0, modalData = $$props.modalData);\n    if (\"handleWalletSelect\" in $$props) $$invalidate(1, handleWalletSelect = $$props.handleWalletSelect);\n    if (\"loadingWallet\" in $$props) $$invalidate(2, loadingWallet = $$props.loadingWallet);\n    if (\"showingAllWalletModules\" in $$props) $$invalidate(3, showingAllWalletModules = $$props.showingAllWalletModules);\n    if (\"showAllWallets\" in $$props) $$invalidate(4, showAllWallets = $$props.showAllWallets);\n    if (\"walletsDisabled\" in $$props) $$invalidate(5, walletsDisabled = $$props.walletsDisabled);\n  };\n\n  return [modalData, handleWalletSelect, loadingWallet, showingAllWalletModules, showAllWallets, walletsDisabled, selectedWallet, func, func_1];\n}\n\nvar Wallets = /*#__PURE__*/function (_SvelteComponent7) {\n  _inherits(Wallets, _SvelteComponent7);\n\n  var _super7 = _createSuper(Wallets);\n\n  function Wallets(options) {\n    var _this7;\n\n    _classCallCheck(this, Wallets);\n\n    _this7 = _super7.call(this);\n    if (!document.getElementById(\"svelte-q1527-style\")) add_css$6();\n    init(_assertThisInitialized(_this7), options, instance$6, create_fragment$6, safe_not_equal, {\n      modalData: 0,\n      handleWalletSelect: 1,\n      loadingWallet: 2,\n      showingAllWalletModules: 3,\n      showAllWallets: 4,\n      walletsDisabled: 5\n    });\n    return _this7;\n  }\n\n  return Wallets;\n}(SvelteComponent);\n/* src/elements/IconDisplay.svelte generated by Svelte v3.38.2 */\n\n\nfunction add_css$7() {\n  var style = element(\"style\");\n  style.id = \"svelte-18zts4b-style\";\n  style.textContent = \"div.svelte-18zts4b{display:flex;align-items:center;border:none;margin:0;font-size:inherit;font-family:inherit;background:inherit;padding:0;width:18em;border-radius:40px;color:inherit}img.svelte-18zts4b{width:auto;height:3em}span.svelte-18zts4b{margin-left:0.66em;font-weight:bold;font-size:inherit;font-family:inherit;opacity:0.7;text-align:left}\";\n  append(document.head, style);\n} // (41:2) {:else}\n\n\nfunction create_else_block$2(ctx) {\n  var img;\n  var img_src_value;\n  return {\n    c: function c() {\n      img = element(\"img\");\n      if (img.src !== (img_src_value =\n      /*iconSrc*/\n      ctx[0])) attr(img, \"src\", img_src_value);\n      attr(img, \"srcset\",\n      /*iconSrcSet*/\n      ctx[1]);\n      attr(img, \"alt\",\n      /*text*/\n      ctx[2]);\n      attr(img, \"class\", \"svelte-18zts4b\");\n    },\n    m: function m(target, anchor) {\n      insert(target, img, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*iconSrc*/\n      1 && img.src !== (img_src_value =\n      /*iconSrc*/\n      ctx[0])) {\n        attr(img, \"src\", img_src_value);\n      }\n\n      if (dirty &\n      /*iconSrcSet*/\n      2) {\n        attr(img, \"srcset\",\n        /*iconSrcSet*/\n        ctx[1]);\n      }\n\n      if (dirty &\n      /*text*/\n      4) {\n        attr(img, \"alt\",\n        /*text*/\n        ctx[2]);\n      }\n    },\n    d: function d(detaching) {\n      if (detaching) detach(img);\n    }\n  };\n} // (39:2) {#if svg}\n\n\nfunction create_if_block$5(ctx) {\n  var html_tag;\n  var html_anchor;\n  return {\n    c: function c() {\n      html_anchor = empty();\n      html_tag = new HtmlTag(html_anchor);\n    },\n    m: function m(target, anchor) {\n      html_tag.m(\n      /*svg*/\n      ctx[3], target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*svg*/\n      8) html_tag.p(\n      /*svg*/\n      ctx[3]);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(html_anchor);\n      if (detaching) html_tag.d();\n    }\n  };\n}\n\nfunction create_fragment$7(ctx) {\n  var div;\n  var t0;\n  var span;\n  var t1;\n\n  function select_block_type(ctx, dirty) {\n    if (\n    /*svg*/\n    ctx[3]) return create_if_block$5;\n    return create_else_block$2;\n  }\n\n  var current_block_type = select_block_type(ctx);\n  var if_block = current_block_type(ctx);\n  return {\n    c: function c() {\n      div = element(\"div\");\n      if_block.c();\n      t0 = space();\n      span = element(\"span\");\n      t1 = text(\n      /*text*/\n      ctx[2]);\n      attr(span, \"class\", \"svelte-18zts4b\");\n      attr(div, \"class\", \"bn-onboard-custom bn-onboard-icon-display svelte-18zts4b\");\n    },\n    m: function m(target, anchor) {\n      insert(target, div, anchor);\n      if_block.m(div, null);\n      append(div, t0);\n      append(div, span);\n      append(span, t1);\n    },\n    p: function p(ctx, _ref24) {\n      var _ref25 = _slicedToArray(_ref24, 1),\n          dirty = _ref25[0];\n\n      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {\n        if_block.p(ctx, dirty);\n      } else {\n        if_block.d(1);\n        if_block = current_block_type(ctx);\n\n        if (if_block) {\n          if_block.c();\n          if_block.m(div, t0);\n        }\n      }\n\n      if (dirty &\n      /*text*/\n      4) set_data(t1,\n      /*text*/\n      ctx[2]);\n    },\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(div);\n      if_block.d();\n    }\n  };\n}\n\nfunction instance$7($$self, $$props, $$invalidate) {\n  var iconSrc = $$props.iconSrc;\n  var iconSrcSet = $$props.iconSrcSet;\n  var text = $$props.text;\n  var svg = $$props.svg;\n\n  $$self.$$set = function ($$props) {\n    if (\"iconSrc\" in $$props) $$invalidate(0, iconSrc = $$props.iconSrc);\n    if (\"iconSrcSet\" in $$props) $$invalidate(1, iconSrcSet = $$props.iconSrcSet);\n    if (\"text\" in $$props) $$invalidate(2, text = $$props.text);\n    if (\"svg\" in $$props) $$invalidate(3, svg = $$props.svg);\n  };\n\n  return [iconSrc, iconSrcSet, text, svg];\n}\n\nvar IconDisplay = /*#__PURE__*/function (_SvelteComponent8) {\n  _inherits(IconDisplay, _SvelteComponent8);\n\n  var _super8 = _createSuper(IconDisplay);\n\n  function IconDisplay(options) {\n    var _this8;\n\n    _classCallCheck(this, IconDisplay);\n\n    _this8 = _super8.call(this);\n    if (!document.getElementById(\"svelte-18zts4b-style\")) add_css$7();\n    init(_assertThisInitialized(_this8), options, instance$7, create_fragment$7, safe_not_equal, {\n      iconSrc: 0,\n      iconSrcSet: 1,\n      text: 2,\n      svg: 3\n    });\n    return _this8;\n  }\n\n  return IconDisplay;\n}(SvelteComponent);\n/* src/components/SelectedWallet.svelte generated by Svelte v3.38.2 */\n\n\nfunction add_css$8() {\n  var style = element(\"style\");\n  style.id = \"svelte-mi6ahc-style\";\n  style.textContent = \"section.svelte-mi6ahc{color:inherit;font-size:inherit;font-family:inherit;display:block}footer.svelte-mi6ahc{display:flex;font-size:inherit;font-family:inherit;justify-content:space-between}\";\n  append(document.head, style);\n} // (34:2) {#if installMessage}\n\n\nfunction create_if_block$6(ctx) {\n  var html_tag;\n  var html_anchor;\n  return {\n    c: function c() {\n      html_anchor = empty();\n      html_tag = new HtmlTag(html_anchor);\n    },\n    m: function m(target, anchor) {\n      html_tag.m(\n      /*installMessage*/\n      ctx[2], target, anchor);\n      insert(target, html_anchor, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*installMessage*/\n      4) html_tag.p(\n      /*installMessage*/\n      ctx[2]);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(html_anchor);\n      if (detaching) html_tag.d();\n    }\n  };\n} // (39:4) <Button cta={false} onclick={onBack}>\n\n\nfunction create_default_slot_1(ctx) {\n  var t;\n  return {\n    c: function c() {\n      t = text(\"Back\");\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n} // (45:6) <Button>\n\n\nfunction create_default_slot$1(ctx) {\n  var t0;\n  var t1_value =\n  /*selectedWalletModule*/\n  ctx[0].name + \"\";\n  var t1;\n  return {\n    c: function c() {\n      t0 = text(\"Open \");\n      t1 = text(t1_value);\n    },\n    m: function m(target, anchor) {\n      insert(target, t0, anchor);\n      insert(target, t1, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*selectedWalletModule*/\n      1 && t1_value !== (t1_value =\n      /*selectedWalletModule*/\n      ctx[0].name + \"\")) set_data(t1, t1_value);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t0);\n      if (detaching) detach(t1);\n    }\n  };\n}\n\nfunction create_fragment$8(ctx) {\n  var section;\n  var icondisplay;\n  var t0;\n  var t1;\n  var footer;\n  var button0;\n  var t2;\n  var a;\n  var button1;\n  var a_href_value;\n  var section_intro;\n  var current;\n  icondisplay = new IconDisplay({\n    props: {\n      iconSrc:\n      /*selectedWalletModule*/\n      ctx[0].iconSrc,\n      iconSrcSet:\n      /*selectedWalletModule*/\n      ctx[0].iconSrcSet,\n      svg:\n      /*selectedWalletModule*/\n      ctx[0].svg,\n      text:\n      /*selectedWalletModule*/\n      ctx[0].name\n    }\n  });\n  var if_block =\n  /*installMessage*/\n  ctx[2] && create_if_block$6(ctx);\n  button0 = new Button({\n    props: {\n      cta: false,\n      onclick:\n      /*onBack*/\n      ctx[1],\n      $$slots: {\n        \"default\": [create_default_slot_1]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  button1 = new Button({\n    props: {\n      $$slots: {\n        \"default\": [create_default_slot$1]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      section = element(\"section\");\n      create_component(icondisplay.$$.fragment);\n      t0 = space();\n      if (if_block) if_block.c();\n      t1 = space();\n      footer = element(\"footer\");\n      create_component(button0.$$.fragment);\n      t2 = space();\n      a = element(\"a\");\n      create_component(button1.$$.fragment);\n      attr(a, \"href\", a_href_value =\n      /*selectedWalletModule*/\n      ctx[0].link);\n      attr(a, \"rel\", \"noreferrer noopener\");\n      attr(a, \"target\", \"_blank\");\n      attr(footer, \"class\", \"bn-onboard-custom bn-onboard-modal-selected-wallet-footer svelte-mi6ahc\");\n      attr(section, \"class\", \"bn-onboard-custom bn-onboard-modal-selected-wallet svelte-mi6ahc\");\n    },\n    m: function m(target, anchor) {\n      insert(target, section, anchor);\n      mount_component(icondisplay, section, null);\n      append(section, t0);\n      if (if_block) if_block.m(section, null);\n      append(section, t1);\n      append(section, footer);\n      mount_component(button0, footer, null);\n      append(footer, t2);\n      append(footer, a);\n      mount_component(button1, a, null);\n      current = true;\n    },\n    p: function p(ctx, _ref26) {\n      var _ref27 = _slicedToArray(_ref26, 1),\n          dirty = _ref27[0];\n\n      var icondisplay_changes = {};\n      if (dirty &\n      /*selectedWalletModule*/\n      1) icondisplay_changes.iconSrc =\n      /*selectedWalletModule*/\n      ctx[0].iconSrc;\n      if (dirty &\n      /*selectedWalletModule*/\n      1) icondisplay_changes.iconSrcSet =\n      /*selectedWalletModule*/\n      ctx[0].iconSrcSet;\n      if (dirty &\n      /*selectedWalletModule*/\n      1) icondisplay_changes.svg =\n      /*selectedWalletModule*/\n      ctx[0].svg;\n      if (dirty &\n      /*selectedWalletModule*/\n      1) icondisplay_changes.text =\n      /*selectedWalletModule*/\n      ctx[0].name;\n      icondisplay.$set(icondisplay_changes);\n\n      if (\n      /*installMessage*/\n      ctx[2]) {\n        if (if_block) {\n          if_block.p(ctx, dirty);\n        } else {\n          if_block = create_if_block$6(ctx);\n          if_block.c();\n          if_block.m(section, t1);\n        }\n      } else if (if_block) {\n        if_block.d(1);\n        if_block = null;\n      }\n\n      var button0_changes = {};\n      if (dirty &\n      /*onBack*/\n      2) button0_changes.onclick =\n      /*onBack*/\n      ctx[1];\n\n      if (dirty &\n      /*$$scope*/\n      8) {\n        button0_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button0.$set(button0_changes);\n      var button1_changes = {};\n\n      if (dirty &\n      /*$$scope, selectedWalletModule*/\n      9) {\n        button1_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button1.$set(button1_changes);\n\n      if (!current || dirty &\n      /*selectedWalletModule*/\n      1 && a_href_value !== (a_href_value =\n      /*selectedWalletModule*/\n      ctx[0].link)) {\n        attr(a, \"href\", a_href_value);\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(icondisplay.$$.fragment, local);\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n\n      if (!section_intro) {\n        add_render_callback(function () {\n          section_intro = create_in_transition(section, fade, {});\n          section_intro.start();\n        });\n      }\n\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(icondisplay.$$.fragment, local);\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(section);\n      destroy_component(icondisplay);\n      if (if_block) if_block.d();\n      destroy_component(button0);\n      destroy_component(button1);\n    }\n  };\n}\n\nfunction instance$8($$self, $$props, $$invalidate) {\n  var selectedWalletModule = $$props.selectedWalletModule;\n  var onBack = $$props.onBack;\n  var installMessage = $$props.installMessage;\n\n  $$self.$$set = function ($$props) {\n    if (\"selectedWalletModule\" in $$props) $$invalidate(0, selectedWalletModule = $$props.selectedWalletModule);\n    if (\"onBack\" in $$props) $$invalidate(1, onBack = $$props.onBack);\n    if (\"installMessage\" in $$props) $$invalidate(2, installMessage = $$props.installMessage);\n  };\n\n  return [selectedWalletModule, onBack, installMessage];\n}\n\nvar SelectedWallet = /*#__PURE__*/function (_SvelteComponent9) {\n  _inherits(SelectedWallet, _SvelteComponent9);\n\n  var _super9 = _createSuper(SelectedWallet);\n\n  function SelectedWallet(options) {\n    var _this9;\n\n    _classCallCheck(this, SelectedWallet);\n\n    _this9 = _super9.call(this);\n    if (!document.getElementById(\"svelte-mi6ahc-style\")) add_css$8();\n    init(_assertThisInitialized(_this9), options, instance$8, create_fragment$8, safe_not_equal, {\n      selectedWalletModule: 0,\n      onBack: 1,\n      installMessage: 2\n    });\n    return _this9;\n  }\n\n  return SelectedWallet;\n}(SvelteComponent);\n\nvar walletIcon = \"\\n<svg\\nheight=\\\"18\\\"\\nviewBox=\\\"0 0 19 18\\\"\\nwidth=\\\"19\\\"\\nxmlns=\\\"http://www.w3.org/2000/svg\\\">\\n<g fill=\\\"currentColor\\\" fill-rule=\\\"evenodd\\\">\\n\\t<path\\n\\t\\td=\\\"m15.7721618.00006623h-13.27469839c-.86762065\\n\\t\\t0-1.48592681.3078086-1.89741046.76113193-.40615823.44745064-.60839063\\n\\t\\t1.04661988-.59978974\\n\\t\\t1.64464107.00029187.005124.00040335.01025653.00033423.01538822v3.66899811c.06682404-.11685776.14162507-.22938827.22533894-.33628895.36778845-.46959466.90812952-.82116145\\n\\t\\t1.61866132-.95623339v-.59093422c0-.55214353.17649657-1.05790163.47278173-1.43388645.29630745-.37596275.72292065-.62513272\\n\\t\\t1.19969088-.62513272h11.23546239c.4765474 0 .9032497.24850764\\n\\t\\t1.199624.62424961.2963743.37574196.4728709.88161045.4728709\\n\\t\\t1.43476956v.4652895c.5235626-.11047728.9266682-.35445897\\n\\t\\t1.2246022-.6733727.4116397-.44060653.6210469-1.03392515.6210469-1.63015804s-.2094072-1.18955151-.6210469-1.63018011c-.4116396-.44060653-1.0238627-.73834765-1.877468-.73834765z\\\" />\\n\\t<path\\n\\t\\td=\\\"m14.6096047 2.57151734h-11.21914267c-.32073002\\n\\t\\t0-.6185428.16561433-.84722564.45769739s-.37782286.70763901-.37782286\\n\\t\\t1.16808814v.53953924c.06265527-.0036172.12640078-.00570319.19125878-.00616921.00518482-.00032924.01037961-.00047727.01557482-.00044383h.01326084\\n\\t\\t13.24215593c.0706652 0\\n\\t\\t.1395281-.00228571.2069226-.00630235v-.52671262c0-.46164746-.1491623-.87711464-.3777561-1.16884264-.2286161-.29175019-.5263622-.45694289-.8473147-.45694289z\\\" />\\n\\t<path\\n\\t\\td=\\\"m18.2706767\\n\\t\\t3.92481203c-.0857195.13278047-.1837832.25906993-.2945478.376829-.495466.52680184-1.2439236.87400468-2.2045296.87400468h-13.26144765c-.93286471\\n\\t\\t0-1.53628777.33766369-1.93268731.8403655s-.57746434\\n\\t\\t1.18877443-.57746434\\n\\t\\t1.87212785v.41252951c.13725808.14817467.29229732.20450824.50016754.23211693.21170276.02811305.46814809.01403459.74212947.02170977h5.25979191c.94146564\\n\\t\\t0 1.67588548.36084271 2.15878435.90341155.48289887.54259078.7188669\\n\\t\\t1.25649138.7188669 1.96738768s-.23596803 1.4247969-.7188669\\n\\t\\t1.9673877c-.48289887.5425689-1.21731871.9033896-2.15878435.9033896h-5.25979191c-.25038458\\n\\t\\t0-.55749953-.0171046-.84908381-.0866198-.13520812-.0322576-.27003744-.0756114-.3932132-.1380653v1.5302318c0\\n\\t\\t1.3201295 1.09561358 2.3983815 2.43697706\\n\\t\\t2.3983815h13.39672254c1.3413635 0 2.4369771-1.078252\\n\\t\\t2.4369771-2.3983815z\\\" />\\n\\t<path\\n\\t\\td=\\\"m0\\n\\t\\t8.79699248c.14260628.06959022.29864665.11050376.44557501.1299645.2753208.03649163.54484912.01335327.79368049.02057717.002302.00003506.00460441.00003506.00690641\\n\\t\\t0h5.25640383c.82827939 0 1.4220972.30156492\\n\\t\\t1.8240727.75248941.40199777.45094634.60569239 1.06221954.60569239\\n\\t\\t1.67601014 0 .6137467-.20369462 1.2250637-.60569239\\n\\t\\t1.6759882-.4019755.4509463-.99579331.7524894-1.8240727.7524894h-5.25640383c-.22831264\\n\\t\\t0-.50846792-.0188259-.74493458-.075238-.23646666-.0563245-.41416197-.1517676-.48734767-.2599728-.00440013-.0047203-.00900883-.0092487-.01387966-.0135722v-4.65860448zm6.42601595\\n\\t\\t1.42288912c-.62979799 0-1.14873693.5024111-1.14873693 1.1218933 0\\n\\t\\t.6211677.51893894 1.128745 1.14873693 1.128745.62984256 0\\n\\t\\t1.14178597-.5082122 1.14178597-1.128745\\n\\t\\t0-.6188692-.51194341-1.1218933-1.14178597-1.1218933z\\\" />\\n</g>\\n</svg>\\n\\t\";\nvar STORAGE_KEYS = {\n  TERMS_AGREEMENT: 'onboard.js:agreement'\n};\n/* src/views/WalletSelect.svelte generated by Svelte v3.38.2 */\n\nfunction add_css$9() {\n  var style = element(\"style\");\n  style.id = \"svelte-w9ftfy-style\";\n  style.textContent = \"p.svelte-w9ftfy.svelte-w9ftfy{font-size:0.889em;margin:1.6em 0 0 0;font-family:inherit}div.svelte-w9ftfy.svelte-w9ftfy{display:flex;font-size:inherit;font-family:inherit;justify-content:space-between}div.svelte-w9ftfy span.svelte-w9ftfy{color:#4a90e2;font-size:inherit;font-family:inherit;margin-top:0.66em;cursor:pointer}.bn-onboard-modal-terms-of-service.svelte-w9ftfy.svelte-w9ftfy{display:flex;align-items:center}.bn-onboard-modal-terms-of-service-check-box.svelte-w9ftfy.svelte-w9ftfy{margin-right:7px}\";\n  append(document.head, style);\n} // (213:0) {#if modalData}\n\n\nfunction create_if_block$7(ctx) {\n  var modal;\n  var current;\n  modal = new Modal({\n    props: {\n      closeModal:\n      /*func_2*/\n      ctx[21],\n      $$slots: {\n        \"default\": [create_default_slot$2]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(modal.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(modal, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var modal_changes = {};\n\n      if (dirty[0] &\n      /*modalData, showWalletDefinition, loadingWallet, showingAllWalletModules, walletsDisabled, selectedWalletModule, walletAlreadyInstalled, installMessage, agreed*/\n      511 | dirty[1] &\n      /*$$scope*/\n      32) {\n        modal_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      modal.$set(modal_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(modal.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(modal.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(modal, detaching);\n    }\n  };\n} // (216:4) {#if showTermsOfService}\n\n\nfunction create_if_block_4(ctx) {\n  var p;\n  var label;\n  var input;\n  var t0;\n  var span;\n  var t1;\n  var t2;\n  var mounted;\n  var dispose;\n  var if_block0 =\n  /*termsUrl*/\n  ctx[10] && create_if_block_6(ctx);\n  var if_block1 =\n  /*privacyUrl*/\n  ctx[11] && create_if_block_5(ctx);\n  return {\n    c: function c() {\n      p = element(\"p\");\n      label = element(\"label\");\n      input = element(\"input\");\n      t0 = space();\n      span = element(\"span\");\n      t1 = text(\"I agree to the\\n            \");\n      if (if_block0) if_block0.c();\n      t2 = space();\n      if (if_block1) if_block1.c();\n      attr(input, \"class\", \"bn-onboard-custom bn-onboard-modal-terms-of-service-check-box svelte-w9ftfy\");\n      attr(input, \"type\", \"checkbox\");\n      attr(label, \"class\", \"bn-onboard-custom bn-onboard-modal-terms-of-service svelte-w9ftfy\");\n      attr(p, \"class\", \"svelte-w9ftfy\");\n    },\n    m: function m(target, anchor) {\n      insert(target, p, anchor);\n      append(p, label);\n      append(label, input);\n      input.checked =\n      /*agreed*/\n      ctx[0];\n      append(label, t0);\n      append(label, span);\n      append(span, t1);\n      if (if_block0) if_block0.m(span, null);\n      append(span, t2);\n      if (if_block1) if_block1.m(span, null);\n\n      if (!mounted) {\n        dispose = listen(input, \"change\",\n        /*input_change_handler*/\n        ctx[17]);\n        mounted = true;\n      }\n    },\n    p: function p(ctx, dirty) {\n      if (dirty[0] &\n      /*agreed*/\n      1) {\n        input.checked =\n        /*agreed*/\n        ctx[0];\n      }\n\n      if (\n      /*termsUrl*/\n      ctx[10]) if_block0.p(ctx, dirty);\n      if (\n      /*privacyUrl*/\n      ctx[11]) if_block1.p(ctx, dirty);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(p);\n      if (if_block0) if_block0.d();\n      if (if_block1) if_block1.d();\n      mounted = false;\n      dispose();\n    }\n  };\n} // (226:12) {#if termsUrl}\n\n\nfunction create_if_block_6(ctx) {\n  var a;\n  var t0;\n  var t1_value = (\n  /*privacyUrl*/\n  ctx[11] ? \" and\" : \".\") + \"\";\n  var t1;\n  return {\n    c: function c() {\n      a = element(\"a\");\n      t0 = text(\"Terms & Conditions\");\n      t1 = text(t1_value);\n      attr(a, \"href\",\n      /*termsUrl*/\n      ctx[10]);\n      attr(a, \"target\", \"_blank\");\n    },\n    m: function m(target, anchor) {\n      insert(target, a, anchor);\n      append(a, t0);\n      insert(target, t1, anchor);\n    },\n    p: noop,\n    d: function d(detaching) {\n      if (detaching) detach(a);\n      if (detaching) detach(t1);\n    }\n  };\n} // (230:12) {#if privacyUrl}\n\n\nfunction create_if_block_5(ctx) {\n  var a;\n  var t0;\n  var t1;\n  return {\n    c: function c() {\n      a = element(\"a\");\n      t0 = text(\"Privacy Policy\");\n      t1 = text(\".\");\n      attr(a, \"href\",\n      /*privacyUrl*/\n      ctx[11]);\n      attr(a, \"target\", \"_blank\");\n    },\n    m: function m(target, anchor) {\n      insert(target, a, anchor);\n      append(a, t0);\n      insert(target, t1, anchor);\n    },\n    p: noop,\n    d: function d(detaching) {\n      if (detaching) detach(a);\n      if (detaching) detach(t1);\n    }\n  };\n} // (270:4) {:else}\n\n\nfunction create_else_block$3(ctx) {\n  var selectedwallet;\n  var current;\n  selectedwallet = new SelectedWallet({\n    props: {\n      selectedWalletModule:\n      /*selectedWalletModule*/\n      ctx[5],\n      onBack:\n      /*func_1*/\n      ctx[20],\n      installMessage:\n      /*installMessage*/\n      ctx[4]\n    }\n  });\n  return {\n    c: function c() {\n      create_component(selectedwallet.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(selectedwallet, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var selectedwallet_changes = {};\n      if (dirty[0] &\n      /*selectedWalletModule*/\n      32) selectedwallet_changes.selectedWalletModule =\n      /*selectedWalletModule*/\n      ctx[5];\n      if (dirty[0] &\n      /*selectedWalletModule, walletAlreadyInstalled*/\n      40) selectedwallet_changes.onBack =\n      /*func_1*/\n      ctx[20];\n      if (dirty[0] &\n      /*installMessage*/\n      16) selectedwallet_changes.installMessage =\n      /*installMessage*/\n      ctx[4];\n      selectedwallet.$set(selectedwallet_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(selectedwallet.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(selectedwallet.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(selectedwallet, detaching);\n    }\n  };\n} // (237:4) {#if !selectedWalletModule}\n\n\nfunction create_if_block_1$3(ctx) {\n  var _p;\n\n  var raw_value =\n  /*modalData*/\n  ctx[1].description + \"\";\n  var t0;\n  var wallets_1;\n  var t1;\n  var div;\n  var span;\n  var t3;\n  var t4;\n  var if_block1_anchor;\n  var current;\n  var mounted;\n  var dispose;\n  wallets_1 = new Wallets({\n    props: {\n      modalData:\n      /*modalData*/\n      ctx[1],\n      handleWalletSelect:\n      /*handleWalletSelect*/\n      ctx[14],\n      loadingWallet:\n      /*loadingWallet*/\n      ctx[7],\n      showingAllWalletModules:\n      /*showingAllWalletModules*/\n      ctx[8],\n      showAllWallets:\n      /*showAllWallets*/\n      ctx[13],\n      walletsDisabled:\n      /*walletsDisabled*/\n      ctx[6]\n    }\n  });\n  var if_block0 =\n  /*mobileDevice*/\n  ctx[9] && create_if_block_3(ctx);\n  var if_block1 =\n  /*showWalletDefinition*/\n  ctx[2] && create_if_block_2$1(ctx);\n  return {\n    c: function c() {\n      _p = element(\"p\");\n      t0 = space();\n      create_component(wallets_1.$$.fragment);\n      t1 = space();\n      div = element(\"div\");\n      span = element(\"span\");\n      span.textContent = \"What is a wallet?\";\n      t3 = space();\n      if (if_block0) if_block0.c();\n      t4 = space();\n      if (if_block1) if_block1.c();\n      if_block1_anchor = empty();\n      attr(_p, \"class\", \"bn-onboard-custom bn-onboard-select-description svelte-w9ftfy\");\n      attr(span, \"class\", \"bn-onboard-custom bn-onboard-select-wallet-info svelte-w9ftfy\");\n      attr(div, \"class\", \"bn-onboard-custom bn-onboard-select-info-container svelte-w9ftfy\");\n    },\n    m: function m(target, anchor) {\n      insert(target, _p, anchor);\n      _p.innerHTML = raw_value;\n      insert(target, t0, anchor);\n      mount_component(wallets_1, target, anchor);\n      insert(target, t1, anchor);\n      insert(target, div, anchor);\n      append(div, span);\n      append(div, t3);\n      if (if_block0) if_block0.m(div, null);\n      insert(target, t4, anchor);\n      if (if_block1) if_block1.m(target, anchor);\n      insert(target, if_block1_anchor, anchor);\n      current = true;\n\n      if (!mounted) {\n        dispose = listen(span, \"click\",\n        /*click_handler*/\n        ctx[18]);\n        mounted = true;\n      }\n    },\n    p: function p(ctx, dirty) {\n      if ((!current || dirty[0] &\n      /*modalData*/\n      2) && raw_value !== (raw_value =\n      /*modalData*/\n      ctx[1].description + \"\")) _p.innerHTML = raw_value;\n      var wallets_1_changes = {};\n      if (dirty[0] &\n      /*modalData*/\n      2) wallets_1_changes.modalData =\n      /*modalData*/\n      ctx[1];\n      if (dirty[0] &\n      /*loadingWallet*/\n      128) wallets_1_changes.loadingWallet =\n      /*loadingWallet*/\n      ctx[7];\n      if (dirty[0] &\n      /*showingAllWalletModules*/\n      256) wallets_1_changes.showingAllWalletModules =\n      /*showingAllWalletModules*/\n      ctx[8];\n      if (dirty[0] &\n      /*walletsDisabled*/\n      64) wallets_1_changes.walletsDisabled =\n      /*walletsDisabled*/\n      ctx[6];\n      wallets_1.$set(wallets_1_changes);\n      if (\n      /*mobileDevice*/\n      ctx[9]) if_block0.p(ctx, dirty);\n\n      if (\n      /*showWalletDefinition*/\n      ctx[2]) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n\n          if (dirty[0] &\n          /*showWalletDefinition*/\n          4) {\n            transition_in(if_block1, 1);\n          }\n        } else {\n          if_block1 = create_if_block_2$1(ctx);\n          if_block1.c();\n          transition_in(if_block1, 1);\n          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);\n        }\n      } else if (if_block1) {\n        if_block1.d(1);\n        if_block1 = null;\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(wallets_1.$$.fragment, local);\n      transition_in(if_block0);\n      transition_in(if_block1);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(wallets_1.$$.fragment, local);\n      transition_out(if_block0);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(_p);\n      if (detaching) detach(t0);\n      destroy_component(wallets_1, detaching);\n      if (detaching) detach(t1);\n      if (detaching) detach(div);\n      if (if_block0) if_block0.d();\n      if (detaching) detach(t4);\n      if (if_block1) if_block1.d(detaching);\n      if (detaching) detach(if_block1_anchor);\n      mounted = false;\n      dispose();\n    }\n  };\n} // (256:8) {#if mobileDevice}\n\n\nfunction create_if_block_3(ctx) {\n  var button;\n  var current;\n  button = new Button({\n    props: {\n      cta: false,\n      onclick:\n      /*func*/\n      ctx[19],\n      $$slots: {\n        \"default\": [create_default_slot_1$1]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(button.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(button, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var button_changes = {};\n\n      if (dirty[1] &\n      /*$$scope*/\n      32) {\n        button_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button.$set(button_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(button.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(button.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(button, detaching);\n    }\n  };\n} // (257:10) <Button cta={false} onclick={() => finish({ completed: false })}             >\n\n\nfunction create_default_slot_1$1(ctx) {\n  var t;\n  return {\n    c: function c() {\n      t = text(\"Dismiss\");\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n} // (262:6) {#if showWalletDefinition}\n\n\nfunction create_if_block_2$1(ctx) {\n  var _p2;\n\n  var raw_value =\n  /*modalData*/\n  ctx[1].explanation + \"\";\n  var p_intro;\n  return {\n    c: function c() {\n      _p2 = element(\"p\");\n      attr(_p2, \"class\", \"bn-onboard-custom bn-onboard-select-wallet-definition svelte-w9ftfy\");\n    },\n    m: function m(target, anchor) {\n      insert(target, _p2, anchor);\n      _p2.innerHTML = raw_value;\n    },\n    p: function p(ctx, dirty) {\n      if (dirty[0] &\n      /*modalData*/\n      2 && raw_value !== (raw_value =\n      /*modalData*/\n      ctx[1].explanation + \"\")) _p2.innerHTML = raw_value;\n    },\n    i: function i(local) {\n      if (!p_intro) {\n        add_render_callback(function () {\n          p_intro = create_in_transition(_p2, fade, {});\n          p_intro.start();\n        });\n      }\n    },\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(_p2);\n    }\n  };\n} // (214:2) <Modal closeModal={() => finish({ completed: false })}>\n\n\nfunction create_default_slot$2(ctx) {\n  var modalheader;\n  var t0;\n  var t1;\n  var current_block_type_index;\n  var if_block1;\n  var if_block1_anchor;\n  var current;\n  modalheader = new ModalHeader({\n    props: {\n      icon: walletIcon,\n      heading:\n      /*modalData*/\n      ctx[1].heading\n    }\n  });\n  var if_block0 =\n  /*showTermsOfService*/\n  ctx[12] && create_if_block_4(ctx);\n  var if_block_creators = [create_if_block_1$3, create_else_block$3];\n  var if_blocks = [];\n\n  function select_block_type(ctx, dirty) {\n    if (!\n    /*selectedWalletModule*/\n    ctx[5]) return 0;\n    return 1;\n  }\n\n  current_block_type_index = select_block_type(ctx);\n  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n  return {\n    c: function c() {\n      create_component(modalheader.$$.fragment);\n      t0 = space();\n      if (if_block0) if_block0.c();\n      t1 = space();\n      if_block1.c();\n      if_block1_anchor = empty();\n    },\n    m: function m(target, anchor) {\n      mount_component(modalheader, target, anchor);\n      insert(target, t0, anchor);\n      if (if_block0) if_block0.m(target, anchor);\n      insert(target, t1, anchor);\n      if_blocks[current_block_type_index].m(target, anchor);\n      insert(target, if_block1_anchor, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var modalheader_changes = {};\n      if (dirty[0] &\n      /*modalData*/\n      2) modalheader_changes.heading =\n      /*modalData*/\n      ctx[1].heading;\n      modalheader.$set(modalheader_changes);\n      if (\n      /*showTermsOfService*/\n      ctx[12]) if_block0.p(ctx, dirty);\n      var previous_block_index = current_block_type_index;\n      current_block_type_index = select_block_type(ctx);\n\n      if (current_block_type_index === previous_block_index) {\n        if_blocks[current_block_type_index].p(ctx, dirty);\n      } else {\n        group_outros();\n        transition_out(if_blocks[previous_block_index], 1, 1, function () {\n          if_blocks[previous_block_index] = null;\n        });\n        check_outros();\n        if_block1 = if_blocks[current_block_type_index];\n\n        if (!if_block1) {\n          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n          if_block1.c();\n        } else {\n          if_block1.p(ctx, dirty);\n        }\n\n        transition_in(if_block1, 1);\n        if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(modalheader.$$.fragment, local);\n      transition_in(if_block1);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(modalheader.$$.fragment, local);\n      transition_out(if_block1);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(modalheader, detaching);\n      if (detaching) detach(t0);\n      if (if_block0) if_block0.d(detaching);\n      if (detaching) detach(t1);\n      if_blocks[current_block_type_index].d(detaching);\n      if (detaching) detach(if_block1_anchor);\n    }\n  };\n}\n\nfunction create_fragment$9(ctx) {\n  var if_block_anchor;\n  var current;\n  var if_block =\n  /*modalData*/\n  ctx[1] && create_if_block$7(ctx);\n  return {\n    c: function c() {\n      if (if_block) if_block.c();\n      if_block_anchor = empty();\n    },\n    m: function m(target, anchor) {\n      if (if_block) if_block.m(target, anchor);\n      insert(target, if_block_anchor, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      if (\n      /*modalData*/\n      ctx[1]) {\n        if (if_block) {\n          if_block.p(ctx, dirty);\n\n          if (dirty[0] &\n          /*modalData*/\n          2) {\n            transition_in(if_block, 1);\n          }\n        } else {\n          if_block = create_if_block$7(ctx);\n          if_block.c();\n          transition_in(if_block, 1);\n          if_block.m(if_block_anchor.parentNode, if_block_anchor);\n        }\n      } else if (if_block) {\n        group_outros();\n        transition_out(if_block, 1, 1, function () {\n          if_block = null;\n        });\n        check_outros();\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(if_block);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(if_block);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (if_block) if_block.d(detaching);\n      if (detaching) detach(if_block_anchor);\n    }\n  };\n}\n\nfunction lockScroll() {\n  window.scrollTo(0, 0);\n}\n\nfunction instance$9($$self, $$props, $$invalidate) {\n  var _$$props$module = $$props.module,\n      module = _$$props$module === void 0 ? {\n    heading: \"\",\n    description: \"\",\n    wallets: [],\n    agreement: undefined\n  } : _$$props$module;\n  var modalData;\n  var showWalletDefinition;\n  var walletAlreadyInstalled;\n  var installMessage;\n  var selectedWalletModule;\n\n  var _get_store_value4 = get_store_value(app),\n      mobileDevice = _get_store_value4.mobileDevice,\n      os = _get_store_value4.os;\n\n  var _module = module,\n      heading = _module.heading,\n      description = _module.description,\n      explanation = _module.explanation,\n      wallets = _module.wallets,\n      agreement = _module.agreement;\n\n  var _ref28 = agreement || {},\n      termsUrl = _ref28.termsUrl,\n      privacyUrl = _ref28.privacyUrl,\n      version = _ref28.version;\n\n  var _JSON$parse = JSON.parse(localStorage.getItem(STORAGE_KEYS.TERMS_AGREEMENT) || \"{}\"),\n      termsAgreed = _JSON$parse.terms,\n      privacyAgreed = _JSON$parse.privacy,\n      versionAgreed = _JSON$parse.version;\n\n  var showTermsOfService = !!(termsUrl && !termsAgreed || privacyUrl && !privacyAgreed || version && version !== versionAgreed);\n  var walletsDisabled = showTermsOfService;\n  var agreed = undefined;\n  var primaryWallets;\n  var secondaryWallets;\n  var loadingWallet = undefined;\n  var showingAllWalletModules = false;\n\n  var showAllWallets = function showAllWallets() {\n    return $$invalidate(8, showingAllWalletModules = true);\n  };\n\n  var originalOverflowValue;\n  onMount(function () {\n    originalOverflowValue = window.document.body.style.overflow;\n    window.document.body.style.overflow = \"hidden\";\n    window.addEventListener(\"scroll\", lockScroll);\n  });\n  onDestroy(function () {\n    window.removeEventListener(\"scroll\", lockScroll);\n    window.document.body.style.overflow = originalOverflowValue;\n  });\n  renderWalletSelect();\n\n  function renderWalletSelect() {\n    return _renderWalletSelect.apply(this, arguments);\n  }\n\n  function _renderWalletSelect() {\n    _renderWalletSelect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {\n      var appState, deviceWallets, _module2;\n\n      return regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              appState = get_store_value(app);\n              _context4.next = 3;\n              return wallets;\n\n            case 3:\n              wallets = _context4.sent;\n              deviceWallets = wallets.filter(function (wallet) {\n                return wallet[mobileDevice ? \"mobile\" : \"desktop\"];\n              }).filter(function (wallet) {\n                var _wallet$osExclusions = wallet.osExclusions,\n                    osExclusions = _wallet$osExclusions === void 0 ? [] : _wallet$osExclusions;\n                return !osExclusions.includes(os.name);\n              });\n\n              if (deviceWallets.find(function (wallet) {\n                return wallet.preferred;\n              })) {\n                // if preferred wallets, then split in to preferred and not preferred\n                primaryWallets = deviceWallets.filter(function (wallet) {\n                  return wallet.preferred;\n                });\n                secondaryWallets = deviceWallets.filter(function (wallet) {\n                  return !wallet.preferred;\n                });\n              } else {\n                // otherwise make the first 4 wallets preferred\n                primaryWallets = deviceWallets.slice(0, 4);\n                secondaryWallets = deviceWallets.length > 4 ? deviceWallets.slice(4) : undefined;\n              }\n\n              if (!appState.autoSelectWallet) {\n                _context4.next = 12;\n                break;\n              }\n\n              _module2 = deviceWallets.find(function (m) {\n                return m.name === appState.autoSelectWallet;\n              });\n              app.update(function (store) {\n                return _objectSpread(_objectSpread({}, store), {}, {\n                  autoSelectWallet: \"\"\n                });\n              });\n\n              if (!_module2) {\n                _context4.next = 12;\n                break;\n              }\n\n              handleWalletSelect(_module2, true);\n              return _context4.abrupt(\"return\");\n\n            case 12:\n              $$invalidate(1, modalData = {\n                heading: heading,\n                description: description,\n                explanation: explanation,\n                primaryWallets: primaryWallets,\n                secondaryWallets: secondaryWallets\n              });\n              app.update(function (store) {\n                return _objectSpread(_objectSpread({}, store), {}, {\n                  walletSelectDisplayedUI: true\n                });\n              });\n\n            case 14:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return _renderWalletSelect.apply(this, arguments);\n  }\n\n  function handleWalletSelect(_x4, _x5) {\n    return _handleWalletSelect.apply(this, arguments);\n  }\n\n  function _handleWalletSelect() {\n    _handleWalletSelect = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5(module, autoSelected) {\n      var currentWalletInterface, _get_store_value5, browser, os, _yield$module$wallet, provider, selectedWalletInterface, instance, name, type, svg, iconSrc, iconSrcSet;\n\n      return regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              currentWalletInterface = get_store_value(walletInterface);\n              _get_store_value5 = get_store_value(app), browser = _get_store_value5.browser, os = _get_store_value5.os;\n\n              if (!(currentWalletInterface && currentWalletInterface.name === module.name)) {\n                _context5.next = 5;\n                break;\n              }\n\n              finish({\n                completed: true\n              });\n              return _context5.abrupt(\"return\");\n\n            case 5:\n              $$invalidate(7, loadingWallet = module.name);\n              _context5.next = 8;\n              return module.wallet({\n                getProviderName: getProviderName,\n                createLegacyProviderInterface: createLegacyProviderInterface,\n                createModernProviderInterface: createModernProviderInterface,\n                BigNumber: (bignumber_js__WEBPACK_IMPORTED_MODULE_1___default()),\n                getNetwork: getNetwork,\n                getAddress: getAddress,\n                getBalance: getBalance,\n                resetWalletState: resetWalletState,\n                networkName: networkName,\n                browser: browser,\n                os: os\n              });\n\n            case 8:\n              _yield$module$wallet = _context5.sent;\n              provider = _yield$module$wallet.provider;\n              selectedWalletInterface = _yield$module$wallet[\"interface\"];\n              instance = _yield$module$wallet.instance;\n              $$invalidate(7, loadingWallet = undefined); // if no interface then the user does not have the wallet they selected installed or available\n\n              if (selectedWalletInterface) {\n                _context5.next = 19;\n                break;\n              }\n\n              $$invalidate(5, selectedWalletModule = module);\n              $$invalidate(3, walletAlreadyInstalled = provider && getProviderName(provider));\n              $$invalidate(4, installMessage = module.installMessage ? module.installMessage({\n                currentWallet: walletAlreadyInstalled,\n                selectedWallet: selectedWalletModule.name\n              }) : \"\"); // if it was autoSelected then we need to add modalData to show the modal\n\n              if (autoSelected) {\n                $$invalidate(1, modalData = {\n                  heading: heading,\n                  description: description,\n                  explanation: explanation,\n                  primaryWallets: primaryWallets,\n                  secondaryWallets: secondaryWallets\n                });\n                app.update(function (store) {\n                  return _objectSpread(_objectSpread({}, store), {}, {\n                    walletSelectDisplayedUI: true\n                  });\n                });\n              }\n\n              return _context5.abrupt(\"return\");\n\n            case 19:\n              walletInterface.update(function (currentInterface) {\n                if (currentInterface && currentInterface.disconnect) {\n                  currentInterface.disconnect();\n                }\n\n                return selectedWalletInterface;\n              });\n              name = module.name, type = module.type, svg = module.svg, iconSrc = module.iconSrc, iconSrcSet = module.iconSrcSet;\n              wallet.set({\n                provider: provider,\n                instance: instance,\n                dashboard: selectedWalletInterface.dashboard,\n                name: name,\n                connect: selectedWalletInterface.connect,\n                type: type,\n                icons: {\n                  svg: svg,\n                  iconSrc: iconSrc,\n                  iconSrcSet: iconSrcSet\n                }\n              });\n              finish({\n                completed: true\n              });\n\n            case 23:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n    return _handleWalletSelect.apply(this, arguments);\n  }\n\n  function finish(options) {\n    $$invalidate(1, modalData = null);\n    app.update(function (store) {\n      return _objectSpread(_objectSpread({}, store), {}, {\n        walletSelectInProgress: false,\n        walletSelectCompleted: options.completed\n      });\n    });\n  }\n\n  function input_change_handler() {\n    agreed = this.checked;\n    $$invalidate(0, agreed);\n  }\n\n  var click_handler = function click_handler() {\n    return $$invalidate(2, showWalletDefinition = !showWalletDefinition);\n  };\n\n  var func = function func() {\n    return finish({\n      completed: false\n    });\n  };\n\n  var func_1 = function func_1() {\n    $$invalidate(5, selectedWalletModule = null);\n    $$invalidate(3, walletAlreadyInstalled = undefined);\n  };\n\n  var func_2 = function func_2() {\n    return finish({\n      completed: false\n    });\n  };\n\n  $$self.$$set = function ($$props) {\n    if (\"module\" in $$props) $$invalidate(16, module = $$props.module);\n  };\n\n  $$self.$$.update = function () {\n    if ($$self.$$.dirty[0] &\n    /*agreed*/\n    1) {\n      if (agreed) {\n        localStorage.setItem(STORAGE_KEYS.TERMS_AGREEMENT, JSON.stringify({\n          version: version,\n          terms: !!termsUrl,\n          privacy: !!privacyUrl\n        }));\n        $$invalidate(6, walletsDisabled = false);\n      } else if (agreed === false) {\n        localStorage.removeItem(STORAGE_KEYS.TERMS_AGREEMENT);\n        $$invalidate(6, walletsDisabled = true);\n      }\n    }\n  };\n\n  return [agreed, modalData, showWalletDefinition, walletAlreadyInstalled, installMessage, selectedWalletModule, walletsDisabled, loadingWallet, showingAllWalletModules, mobileDevice, termsUrl, privacyUrl, showTermsOfService, showAllWallets, handleWalletSelect, finish, module, input_change_handler, click_handler, func, func_1, func_2];\n}\n\nvar WalletSelect = /*#__PURE__*/function (_SvelteComponent10) {\n  _inherits(WalletSelect, _SvelteComponent10);\n\n  var _super10 = _createSuper(WalletSelect);\n\n  function WalletSelect(options) {\n    var _this10;\n\n    _classCallCheck(this, WalletSelect);\n\n    _this10 = _super10.call(this);\n    if (!document.getElementById(\"svelte-w9ftfy-style\")) add_css$9();\n    init(_assertThisInitialized(_this10), options, instance$9, create_fragment$9, safe_not_equal, {\n      module: 16\n    }, [-1, -1]);\n    return _this10;\n  }\n\n  return WalletSelect;\n}(SvelteComponent);\n/* src/views/WalletCheck.svelte generated by Svelte v3.38.2 */\n\n\nfunction add_css$a() {\n  var style = element(\"style\");\n  style.id = \"svelte-zrvscw-style\";\n  style.textContent = \"p.svelte-zrvscw{font-size:0.889em;font-family:inherit;margin:1em 0}span.svelte-zrvscw{color:#e2504a;font-size:0.889em;font-family:inherit;display:block;margin-bottom:0.75em;padding:0.5em;border:1px solid #e2504a;border-radius:5px}div.svelte-zrvscw{display:flex;justify-content:center;align-items:center;min-height:2.5rem;position:relative}section.svelte-zrvscw{display:flex;justify-content:center;flex-direction:column;align-items:center;margin-bottom:1rem}\";\n  append(document.head, style);\n} // (242:0) {#if loadingModal}\n\n\nfunction create_if_block_6$1(ctx) {\n  var modal;\n  var current;\n  modal = new Modal({\n    props: {\n      closeable: false,\n      $$slots: {\n        \"default\": [create_default_slot_4]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(modal.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(modal, target, anchor);\n      current = true;\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(modal.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(modal.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(modal, detaching);\n    }\n  };\n} // (243:2) <Modal closeable={false}>\n\n\nfunction create_default_slot_4(ctx) {\n  var spinner;\n  var current;\n  spinner = new Spinner({\n    props: {\n      description: \"Checking wallet\"\n    }\n  });\n  return {\n    c: function c() {\n      create_component(spinner.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(spinner, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i: function i(local) {\n      if (current) return;\n      transition_in(spinner.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(spinner.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(spinner, detaching);\n    }\n  };\n} // (248:0) {#if activeModal}\n\n\nfunction create_if_block$8(ctx) {\n  var modal;\n  var current;\n  modal = new Modal({\n    props: {\n      closeModal:\n      /*func_1*/\n      ctx[12],\n      $$slots: {\n        \"default\": [create_default_slot$3]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(modal.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(modal, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var modal_changes = {};\n\n      if (dirty &\n      /*$$scope, loading, activeModal, errorMsg, $app*/\n      33554455) {\n        modal_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      modal.$set(modal_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(modal.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(modal.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(modal, detaching);\n    }\n  };\n} // (254:4) {#if errorMsg}\n\n\nfunction create_if_block_5$1(ctx) {\n  var span;\n  var t;\n  var span_intro;\n  return {\n    c: function c() {\n      span = element(\"span\");\n      t = text(\n      /*errorMsg*/\n      ctx[1]);\n      attr(span, \"class\", \"bn-onboard-custom bn-onboard-prepare-error svelte-zrvscw\");\n      toggle_class(span, \"bn-onboard-dark-mode-background\",\n      /*$app*/\n      ctx[4].darkMode);\n    },\n    m: function m(target, anchor) {\n      insert(target, span, anchor);\n      append(span, t);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*errorMsg*/\n      2) set_data(t,\n      /*errorMsg*/\n      ctx[1]);\n\n      if (dirty &\n      /*$app*/\n      16) {\n        toggle_class(span, \"bn-onboard-dark-mode-background\",\n        /*$app*/\n        ctx[4].darkMode);\n      }\n    },\n    i: function i(local) {\n      if (!span_intro) {\n        add_render_callback(function () {\n          span_intro = create_in_transition(span, fade, {});\n          span_intro.start();\n        });\n      }\n    },\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(span);\n    }\n  };\n} // (264:4) {#if activeModal.html}\n\n\nfunction create_if_block_4$1(ctx) {\n  var section;\n  var raw_value =\n  /*activeModal*/\n  ctx[0].html + \"\";\n  return {\n    c: function c() {\n      section = element(\"section\");\n      attr(section, \"class\", \"bn-onboard-custom bn-onboard-wallet-check-section svelte-zrvscw\");\n    },\n    m: function m(target, anchor) {\n      insert(target, section, anchor);\n      section.innerHTML = raw_value;\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*activeModal*/\n      1 && raw_value !== (raw_value =\n      /*activeModal*/\n      ctx[0].html + \"\")) section.innerHTML = raw_value;\n    },\n    d: function d(detaching) {\n      if (detaching) detach(section);\n    }\n  };\n} // (271:6) {#if activeModal.button}\n\n\nfunction create_if_block_3$1(ctx) {\n  var button;\n  var current;\n  button = new Button({\n    props: {\n      position: \"right\",\n      onclick:\n      /*activeModal*/\n      ctx[0].button.onclick,\n      $$slots: {\n        \"default\": [create_default_slot_3]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(button.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(button, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var button_changes = {};\n      if (dirty &\n      /*activeModal*/\n      1) button_changes.onclick =\n      /*activeModal*/\n      ctx[0].button.onclick;\n\n      if (dirty &\n      /*$$scope, activeModal*/\n      33554433) {\n        button_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button.$set(button_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(button.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(button.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(button, detaching);\n    }\n  };\n} // (272:8) <Button position=\"right\" onclick={activeModal.button.onclick}>\n\n\nfunction create_default_slot_3(ctx) {\n  var t_value =\n  /*activeModal*/\n  ctx[0].button.text + \"\";\n  var t;\n  return {\n    c: function c() {\n      t = text(t_value);\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    p: function p(ctx, dirty) {\n      if (dirty &\n      /*activeModal*/\n      1 && t_value !== (t_value =\n      /*activeModal*/\n      ctx[0].button.text + \"\")) set_data(t, t_value);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n} // (283:6) {:else}\n\n\nfunction create_else_block$4(ctx) {\n  var div;\n  return {\n    c: function c() {\n      div = element(\"div\");\n      attr(div, \"class\", \"svelte-zrvscw\");\n    },\n    m: function m(target, anchor) {\n      insert(target, div, anchor);\n    },\n    p: noop,\n    i: noop,\n    o: noop,\n    d: function d(detaching) {\n      if (detaching) detach(div);\n    }\n  };\n} // (276:6) {#if errorMsg}\n\n\nfunction create_if_block_2$2(ctx) {\n  var button;\n  var current;\n  button = new Button({\n    props: {\n      position: !\n      /*activeModal*/\n      ctx[0].button ? \"right\" : \"\",\n      onclick:\n      /*doAction*/\n      ctx[5],\n      $$slots: {\n        \"default\": [create_default_slot_2]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(button.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(button, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var button_changes = {};\n      if (dirty &\n      /*activeModal*/\n      1) button_changes.position = !\n      /*activeModal*/\n      ctx[0].button ? \"right\" : \"\";\n\n      if (dirty &\n      /*$$scope*/\n      33554432) {\n        button_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button.$set(button_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(button.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(button.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(button, detaching);\n    }\n  };\n} // (277:8) <Button           position={!activeModal.button ? 'right' : ''}           onclick={doAction}         >\n\n\nfunction create_default_slot_2(ctx) {\n  var t;\n  return {\n    c: function c() {\n      t = text(\"Try Again\");\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n} // (286:6) {#if loading}\n\n\nfunction create_if_block_1$4(ctx) {\n  var spinner;\n  var current;\n  spinner = new Spinner({});\n  return {\n    c: function c() {\n      create_component(spinner.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(spinner, target, anchor);\n      current = true;\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(spinner.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(spinner.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(spinner, detaching);\n    }\n  };\n} // (289:6) <Button position=\"left\" onclick={() => handleExit(false)} cta={false}         >\n\n\nfunction create_default_slot_1$2(ctx) {\n  var t;\n  return {\n    c: function c() {\n      t = text(\"Dismiss\");\n    },\n    m: function m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d: function d(detaching) {\n      if (detaching) detach(t);\n    }\n  };\n} // (249:2) <Modal closeModal={() => handleExit()}>\n\n\nfunction create_default_slot$3(ctx) {\n  var modalheader;\n  var t0;\n\n  var _p3;\n\n  var raw_value =\n  /*activeModal*/\n  ctx[0].description + \"\";\n  var t1;\n  var t2;\n  var t3;\n  var div;\n  var t4;\n  var current_block_type_index;\n  var if_block3;\n  var t5;\n  var t6;\n  var button;\n  var current;\n  modalheader = new ModalHeader({\n    props: {\n      icon:\n      /*activeModal*/\n      ctx[0].icon || \"\",\n      heading:\n      /*activeModal*/\n      ctx[0].heading\n    }\n  });\n  var if_block0 =\n  /*errorMsg*/\n  ctx[1] && create_if_block_5$1(ctx);\n  var if_block1 =\n  /*activeModal*/\n  ctx[0].html && create_if_block_4$1(ctx);\n  var if_block2 =\n  /*activeModal*/\n  ctx[0].button && create_if_block_3$1(ctx);\n  var if_block_creators = [create_if_block_2$2, create_else_block$4];\n  var if_blocks = [];\n\n  function select_block_type(ctx, dirty) {\n    if (\n    /*errorMsg*/\n    ctx[1]) return 0;\n    return 1;\n  }\n\n  current_block_type_index = select_block_type(ctx);\n  if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n  var if_block4 =\n  /*loading*/\n  ctx[2] && create_if_block_1$4();\n  button = new Button({\n    props: {\n      position: \"left\",\n      onclick:\n      /*func*/\n      ctx[11],\n      cta: false,\n      $$slots: {\n        \"default\": [create_default_slot_1$2]\n      },\n      $$scope: {\n        ctx: ctx\n      }\n    }\n  });\n  return {\n    c: function c() {\n      create_component(modalheader.$$.fragment);\n      t0 = space();\n      _p3 = element(\"p\");\n      t1 = space();\n      if (if_block0) if_block0.c();\n      t2 = space();\n      if (if_block1) if_block1.c();\n      t3 = space();\n      div = element(\"div\");\n      if (if_block2) if_block2.c();\n      t4 = space();\n      if_block3.c();\n      t5 = space();\n      if (if_block4) if_block4.c();\n      t6 = space();\n      create_component(button.$$.fragment);\n      attr(_p3, \"class\", \"bn-onboard-custom bn-onboard-prepare-description svelte-zrvscw\");\n      attr(div, \"class\", \"bn-onboard-custom bn-onboard-prepare-button-container svelte-zrvscw\");\n    },\n    m: function m(target, anchor) {\n      mount_component(modalheader, target, anchor);\n      insert(target, t0, anchor);\n      insert(target, _p3, anchor);\n      _p3.innerHTML = raw_value;\n      insert(target, t1, anchor);\n      if (if_block0) if_block0.m(target, anchor);\n      insert(target, t2, anchor);\n      if (if_block1) if_block1.m(target, anchor);\n      insert(target, t3, anchor);\n      insert(target, div, anchor);\n      if (if_block2) if_block2.m(div, null);\n      append(div, t4);\n      if_blocks[current_block_type_index].m(div, null);\n      append(div, t5);\n      if (if_block4) if_block4.m(div, null);\n      append(div, t6);\n      mount_component(button, div, null);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var modalheader_changes = {};\n      if (dirty &\n      /*activeModal*/\n      1) modalheader_changes.icon =\n      /*activeModal*/\n      ctx[0].icon || \"\";\n      if (dirty &\n      /*activeModal*/\n      1) modalheader_changes.heading =\n      /*activeModal*/\n      ctx[0].heading;\n      modalheader.$set(modalheader_changes);\n      if ((!current || dirty &\n      /*activeModal*/\n      1) && raw_value !== (raw_value =\n      /*activeModal*/\n      ctx[0].description + \"\")) _p3.innerHTML = raw_value;\n\n      if (\n      /*errorMsg*/\n      ctx[1]) {\n        if (if_block0) {\n          if_block0.p(ctx, dirty);\n\n          if (dirty &\n          /*errorMsg*/\n          2) {\n            transition_in(if_block0, 1);\n          }\n        } else {\n          if_block0 = create_if_block_5$1(ctx);\n          if_block0.c();\n          transition_in(if_block0, 1);\n          if_block0.m(t2.parentNode, t2);\n        }\n      } else if (if_block0) {\n        if_block0.d(1);\n        if_block0 = null;\n      }\n\n      if (\n      /*activeModal*/\n      ctx[0].html) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n        } else {\n          if_block1 = create_if_block_4$1(ctx);\n          if_block1.c();\n          if_block1.m(t3.parentNode, t3);\n        }\n      } else if (if_block1) {\n        if_block1.d(1);\n        if_block1 = null;\n      }\n\n      if (\n      /*activeModal*/\n      ctx[0].button) {\n        if (if_block2) {\n          if_block2.p(ctx, dirty);\n\n          if (dirty &\n          /*activeModal*/\n          1) {\n            transition_in(if_block2, 1);\n          }\n        } else {\n          if_block2 = create_if_block_3$1(ctx);\n          if_block2.c();\n          transition_in(if_block2, 1);\n          if_block2.m(div, t4);\n        }\n      } else if (if_block2) {\n        group_outros();\n        transition_out(if_block2, 1, 1, function () {\n          if_block2 = null;\n        });\n        check_outros();\n      }\n\n      var previous_block_index = current_block_type_index;\n      current_block_type_index = select_block_type(ctx);\n\n      if (current_block_type_index === previous_block_index) {\n        if_blocks[current_block_type_index].p(ctx, dirty);\n      } else {\n        group_outros();\n        transition_out(if_blocks[previous_block_index], 1, 1, function () {\n          if_blocks[previous_block_index] = null;\n        });\n        check_outros();\n        if_block3 = if_blocks[current_block_type_index];\n\n        if (!if_block3) {\n          if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);\n          if_block3.c();\n        } else {\n          if_block3.p(ctx, dirty);\n        }\n\n        transition_in(if_block3, 1);\n        if_block3.m(div, t5);\n      }\n\n      if (\n      /*loading*/\n      ctx[2]) {\n        if (if_block4) {\n          if (dirty &\n          /*loading*/\n          4) {\n            transition_in(if_block4, 1);\n          }\n        } else {\n          if_block4 = create_if_block_1$4();\n          if_block4.c();\n          transition_in(if_block4, 1);\n          if_block4.m(div, t6);\n        }\n      } else if (if_block4) {\n        group_outros();\n        transition_out(if_block4, 1, 1, function () {\n          if_block4 = null;\n        });\n        check_outros();\n      }\n\n      var button_changes = {};\n\n      if (dirty &\n      /*$$scope*/\n      33554432) {\n        button_changes.$$scope = {\n          dirty: dirty,\n          ctx: ctx\n        };\n      }\n\n      button.$set(button_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(modalheader.$$.fragment, local);\n      transition_in(if_block0);\n      transition_in(if_block2);\n      transition_in(if_block3);\n      transition_in(if_block4);\n      transition_in(button.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(modalheader.$$.fragment, local);\n      transition_out(if_block2);\n      transition_out(if_block3);\n      transition_out(if_block4);\n      transition_out(button.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(modalheader, detaching);\n      if (detaching) detach(t0);\n      if (detaching) detach(_p3);\n      if (detaching) detach(t1);\n      if (if_block0) if_block0.d(detaching);\n      if (detaching) detach(t2);\n      if (if_block1) if_block1.d(detaching);\n      if (detaching) detach(t3);\n      if (detaching) detach(div);\n      if (if_block2) if_block2.d();\n      if_blocks[current_block_type_index].d();\n      if (if_block4) if_block4.d();\n      destroy_component(button);\n    }\n  };\n}\n\nfunction create_fragment$a(ctx) {\n  var t;\n  var if_block1_anchor;\n  var current;\n  var if_block0 =\n  /*loadingModal*/\n  ctx[3] && create_if_block_6$1(ctx);\n  var if_block1 =\n  /*activeModal*/\n  ctx[0] && create_if_block$8(ctx);\n  return {\n    c: function c() {\n      if (if_block0) if_block0.c();\n      t = space();\n      if (if_block1) if_block1.c();\n      if_block1_anchor = empty();\n    },\n    m: function m(target, anchor) {\n      if (if_block0) if_block0.m(target, anchor);\n      insert(target, t, anchor);\n      if (if_block1) if_block1.m(target, anchor);\n      insert(target, if_block1_anchor, anchor);\n      current = true;\n    },\n    p: function p(ctx, _ref29) {\n      var _ref30 = _slicedToArray(_ref29, 1),\n          dirty = _ref30[0];\n\n      if (\n      /*loadingModal*/\n      ctx[3]) {\n        if (if_block0) {\n          if (dirty &\n          /*loadingModal*/\n          8) {\n            transition_in(if_block0, 1);\n          }\n        } else {\n          if_block0 = create_if_block_6$1(ctx);\n          if_block0.c();\n          transition_in(if_block0, 1);\n          if_block0.m(t.parentNode, t);\n        }\n      } else if (if_block0) {\n        group_outros();\n        transition_out(if_block0, 1, 1, function () {\n          if_block0 = null;\n        });\n        check_outros();\n      }\n\n      if (\n      /*activeModal*/\n      ctx[0]) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n\n          if (dirty &\n          /*activeModal*/\n          1) {\n            transition_in(if_block1, 1);\n          }\n        } else {\n          if_block1 = create_if_block$8(ctx);\n          if_block1.c();\n          transition_in(if_block1, 1);\n          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);\n        }\n      } else if (if_block1) {\n        group_outros();\n        transition_out(if_block1, 1, 1, function () {\n          if_block1 = null;\n        });\n        check_outros();\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(if_block0);\n      transition_in(if_block1);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(if_block0);\n      transition_out(if_block1);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (if_block0) if_block0.d(detaching);\n      if (detaching) detach(t);\n      if (if_block1) if_block1.d(detaching);\n      if (detaching) detach(if_block1_anchor);\n    }\n  };\n}\n\nfunction lockScroll$1() {\n  window.scrollTo(0, 0);\n}\n\nfunction isCheckModal(val) {\n  return val.heading !== undefined;\n}\n\nfunction instance$a($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(4, $app = $$value);\n  });\n  var walletCheck = $$props.walletCheck;\n  var walletSelect = $$props.walletSelect;\n  var modules = $$props.modules;\n  var blocknative = getBlocknative();\n  var currentState;\n  var activeModal = undefined;\n  var currentModule = undefined;\n  var errorMsg;\n  var pollingInterval;\n  var checkingModule = false;\n  var actionResolved = undefined;\n  var loading = false;\n  var loadingModal = false;\n  var unsubscribe = walletInterface.subscribe(function (currentInterface) {\n    if (currentInterface === null) {\n      handleExit();\n      unsubscribe();\n    }\n  });\n  var originalOverflowValue;\n  var unsubscribeCurrentState = state.subscribe(function (store) {\n    return currentState = store;\n  });\n  onMount(function () {\n    originalOverflowValue = window.document.body.style.overflow;\n    window.document.body.style.overflow = \"hidden\";\n    window.addEventListener(\"scroll\", lockScroll$1);\n  });\n  onDestroy(function () {\n    unsubscribeCurrentState();\n    window.removeEventListener(\"scroll\", lockScroll$1);\n    window.document.body.style.overflow = originalOverflowValue;\n  });\n\n  function renderModule() {\n    return _renderModule.apply(this, arguments);\n  }\n\n  function _renderModule() {\n    _renderModule = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {\n      var checkModules, currentWallet;\n      return regeneratorRuntime.wrap(function _callee8$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              $$invalidate(10, checkingModule = true);\n              checkModules = modules || get_store_value(app).checkModules;\n\n              if (!isPromise(checkModules)) {\n                _context8.next = 8;\n                break;\n              }\n\n              _context8.next = 5;\n              return checkModules;\n\n            case 5:\n              checkModules = _context8.sent;\n              checkModules.forEach(validateWalletCheckModule);\n              app.update(function (store) {\n                return _objectSpread(_objectSpread({}, store), {}, {\n                  checkModules: checkModules\n                });\n              });\n\n            case 8:\n              currentWallet = get_store_value(wallet).name; // loop through and run each module to check if a modal needs to be shown\n\n              runModules(checkModules).then(function (result) {\n                // no result then user has passed all conditions\n                if (!result.modal) {\n                  blocknative && blocknative.event({\n                    categoryCode: \"onboard\",\n                    eventCode: \"onboardingCompleted\"\n                  });\n                  handleExit(true);\n                  return;\n                } // set that UI has been displayed, so that timeouts can be added for UI transitions\n\n\n                app.update(function (store) {\n                  return _objectSpread(_objectSpread({}, store), {}, {\n                    walletCheckDisplayedUI: true\n                  });\n                });\n                $$invalidate(0, activeModal = result.modal);\n                currentModule = result.module; // log the event code for this module\n\n                blocknative && blocknative.event({\n                  eventCode: activeModal.eventCode,\n                  categoryCode: \"onboard\"\n                }); // run any actions that module require as part of this step\n\n                if (activeModal.action) {\n                  doAction();\n                } // poll to automatically to check if condition has been met\n\n\n                pollingInterval = setInterval( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {\n                  var _result2;\n\n                  return regeneratorRuntime.wrap(function _callee7$(_context7) {\n                    while (1) {\n                      switch (_context7.prev = _context7.next) {\n                        case 0:\n                          if (!currentModule) {\n                            _context7.next = 5;\n                            break;\n                          }\n\n                          _context7.next = 3;\n                          return invalidState(currentModule, get_store_value(state));\n\n                        case 3:\n                          _result2 = _context7.sent;\n\n                          if (!_result2 && actionResolved !== false) {\n                            resetState(); // delayed for animations\n\n                            setTimeout(function () {\n                              $$invalidate(10, checkingModule = false);\n                            }, 250);\n                          } else {\n                            $$invalidate(0, activeModal = _result2 && _result2.modal ? _result2.modal : activeModal);\n                          }\n\n                        case 5:\n                        case \"end\":\n                          return _context7.stop();\n                      }\n                    }\n                  }, _callee7);\n                })), 100);\n              });\n\n            case 10:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, _callee8);\n    }));\n    return _renderModule.apply(this, arguments);\n  }\n\n  function doAction() {\n    actionResolved = false;\n    $$invalidate(2, loading = true);\n    activeModal && activeModal.action && activeModal.action().then(function () {\n      actionResolved = true;\n      $$invalidate(2, loading = false);\n    })[\"catch\"](function (err) {\n      $$invalidate(1, errorMsg = err.message);\n      $$invalidate(2, loading = false);\n    });\n  }\n\n  function handleExit() {\n    var completed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    var _ref31 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        switchingWallets = _ref31.switchingWallets;\n\n    resetState();\n    app.update(function (store) {\n      return _objectSpread(_objectSpread({}, store), {}, {\n        switchingWallets: switchingWallets,\n        walletCheckInProgress: false,\n        walletCheckCompleted: completed,\n        accountSelectInProgress: false\n      });\n    });\n  }\n\n  function resetState() {\n    clearInterval(pollingInterval);\n    $$invalidate(1, errorMsg = \"\");\n    actionResolved = undefined;\n    $$invalidate(0, activeModal = undefined);\n    currentModule = undefined;\n  }\n\n  function runModules(modules) {\n    return new Promise( /*#__PURE__*/function () {\n      var _ref32 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(resolve) {\n        var _iterator, _step, module, result;\n\n        return regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _iterator = _createForOfIteratorHelper(modules);\n                _context6.prev = 1;\n\n                _iterator.s();\n\n              case 3:\n                if ((_step = _iterator.n()).done) {\n                  _context6.next = 12;\n                  break;\n                }\n\n                module = _step.value;\n                _context6.next = 7;\n                return invalidState(module, currentState);\n\n              case 7:\n                result = _context6.sent;\n\n                if (!result) {\n                  _context6.next = 10;\n                  break;\n                }\n\n                return _context6.abrupt(\"return\", resolve(result));\n\n              case 10:\n                _context6.next = 3;\n                break;\n\n              case 12:\n                _context6.next = 17;\n                break;\n\n              case 14:\n                _context6.prev = 14;\n                _context6.t0 = _context6[\"catch\"](1);\n\n                _iterator.e(_context6.t0);\n\n              case 17:\n                _context6.prev = 17;\n\n                _iterator.f();\n\n                return _context6.finish(17);\n\n              case 20:\n                return _context6.abrupt(\"return\", resolve({\n                  modal: undefined,\n                  module: undefined\n                }));\n\n              case 21:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[1, 14, 17, 20]]);\n      }));\n\n      return function (_x6) {\n        return _ref32.apply(this, arguments);\n      };\n    }());\n  }\n\n  function invalidState(_x7, _x8) {\n    return _invalidState.apply(this, arguments);\n  }\n\n  function _invalidState() {\n    _invalidState = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9(module, state) {\n      var result, modal;\n      return regeneratorRuntime.wrap(function _callee9$(_context9) {\n        while (1) {\n          switch (_context9.prev = _context9.next) {\n            case 0:\n              result = module(_objectSpread(_objectSpread({}, state), {}, {\n                BigNumber: (bignumber_js__WEBPACK_IMPORTED_MODULE_1___default()),\n                walletSelect: walletSelect,\n                walletCheck: walletCheck,\n                exit: handleExit,\n                wallet: get_store_value(wallet),\n                stateSyncStatus: stateSyncStatus,\n                stateStore: {\n                  address: address,\n                  network: network,\n                  balance: balance\n                }\n              }));\n\n              if (!result) {\n                _context9.next = 12;\n                break;\n              }\n\n              if (!isCheckModal(result)) {\n                _context9.next = 7;\n                break;\n              }\n\n              validateModal(result);\n              return _context9.abrupt(\"return\", {\n                module: module,\n                modal: result\n              });\n\n            case 7:\n              _context9.next = 9;\n              return new Promise(function (resolve) {\n                var completed = false;\n                result.then(function (res) {\n                  $$invalidate(3, loadingModal = false);\n                  completed = true;\n                  modal = res;\n                  resolve(undefined);\n                });\n                setTimeout(function () {\n                  if (!completed) {\n                    $$invalidate(3, loadingModal = true);\n                  }\n                }, 650);\n              });\n\n            case 9:\n              if (!modal) {\n                _context9.next = 12;\n                break;\n              }\n\n              validateModal(modal);\n              return _context9.abrupt(\"return\", {\n                module: module,\n                modal: modal\n              });\n\n            case 12:\n            case \"end\":\n              return _context9.stop();\n          }\n        }\n      }, _callee9);\n    }));\n    return _invalidState.apply(this, arguments);\n  }\n\n  var func = function func() {\n    return handleExit(false);\n  };\n\n  var func_1 = function func_1() {\n    return handleExit();\n  };\n\n  $$self.$$set = function ($$props) {\n    if (\"walletCheck\" in $$props) $$invalidate(7, walletCheck = $$props.walletCheck);\n    if (\"walletSelect\" in $$props) $$invalidate(8, walletSelect = $$props.walletSelect);\n    if (\"modules\" in $$props) $$invalidate(9, modules = $$props.modules);\n  };\n\n  $$self.$$.update = function () {\n    if ($$self.$$.dirty &\n    /*activeModal, checkingModule*/\n    1025) {\n      // recheck modules if below conditions\n      if (!activeModal && !checkingModule) {\n        renderModule();\n      }\n    }\n  };\n\n  return [activeModal, errorMsg, loading, loadingModal, $app, doAction, handleExit, walletCheck, walletSelect, modules, checkingModule, func, func_1];\n}\n\nvar WalletCheck_1 = /*#__PURE__*/function (_SvelteComponent11) {\n  _inherits(WalletCheck_1, _SvelteComponent11);\n\n  var _super11 = _createSuper(WalletCheck_1);\n\n  function WalletCheck_1(options) {\n    var _this11;\n\n    _classCallCheck(this, WalletCheck_1);\n\n    _this11 = _super11.call(this);\n    if (!document.getElementById(\"svelte-zrvscw-style\")) add_css$a();\n    init(_assertThisInitialized(_this11), options, instance$a, create_fragment$a, safe_not_equal, {\n      walletCheck: 7,\n      walletSelect: 8,\n      modules: 9\n    });\n    return _this11;\n  }\n\n  return WalletCheck_1;\n}(SvelteComponent);\n\nvar usbIcon = \"\\n\\t<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" xmlns:xlink=\\\"http://www.w3.org/1999/xlink\\\" x=\\\"0px\\\" y=\\\"0px\\\" viewBox=\\\"0 0 512 512\\\" style=\\\"enable-background:new 0 0 512 512;\\\" xml:space=\\\"preserve\\\" width=\\\"18px\\\" height=\\\"18px\\\">\\n\\t<g>\\n\\t<g>\\n\\t<path fill=\\\"currentColor\\\" d=\\\"M314.468,157.197v103.942h31.553v2.312c0,9.888-4.815,19.205-12.881,24.924l-56.652,40.171V109.939h44.546L257.634,0\\n\\t\\tl-66.527,109.939h45.404V358.25l-56.652-40.171c-8.066-5.719-12.881-15.037-12.881-24.924v-8.489\\n\\t\\tc20.19-7.815,34.552-27.427,34.552-50.342c0-29.759-24.211-53.97-53.97-53.97c-29.76,0-53.97,24.211-53.97,53.97\\n\\t\\tc0,22.482,13.821,41.789,33.41,49.891v8.94c0,22.824,11.116,44.333,29.735,57.536l66.895,47.434\\n\\t\\tc4.255,3.016,7.593,7.04,9.809,11.615c-17.713,8.862-29.909,27.173-29.909,48.29c0,29.76,24.211,53.97,53.97,53.97\\n\\t\\tc29.759,0,53.97-24.211,53.97-53.97c0-23.078-14.564-42.81-34.981-50.511v-14.174c0-9.888,4.815-19.205,12.881-24.924\\n\\t\\tl66.895-47.434c18.619-13.202,29.735-34.711,29.735-57.536v-2.312h32.411V157.197H314.468z M147.56,248.316\\n\\t\\tc-7.716,0-13.992-6.277-13.992-13.992c0-7.716,6.276-13.992,13.992-13.992c7.716,0,13.992,6.276,13.992,13.992\\n\\t\\tC161.552,242.04,155.276,248.316,147.56,248.316z M257.499,472.022c-7.716,0-13.992-6.276-13.992-13.992\\n\\t\\tc0-7.716,6.277-13.992,13.992-13.992c7.716,0,13.992,6.276,13.992,13.992C271.491,465.746,265.215,472.022,257.499,472.022z\\n\\t\\tM378.432,221.161h-23.987v-23.987h23.987V221.161z\\\"/>\\n\\t</g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t<g>\\n\\t</g>\\n\\t</svg>\\t  \\n\";\nvar networkIcon = \"\\n\\t<svg height=\\\"18\\\" viewBox=\\\"0 0 18 18\\\" width=\\\"18\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\\t\\t<path d=\\\"m13.375 28c-1.86075 0-3.375-1.51425-3.375-3.375s1.51425-3.375 3.375-3.375 3.375 1.51425 3.375 3.375-1.51425 3.375-3.375 3.375zm0-4.5c-.619875 0-1.125.504-1.125 1.125s.505125 1.125 1.125 1.125 1.125-.504 1.125-1.125-.505125-1.125-1.125-1.125zm0-6.75c-1.86075 0-3.375-1.51425-3.375-3.375s1.51425-3.375 3.375-3.375 3.375 1.51425 3.375 3.375-1.51425 3.375-3.375 3.375zm0-4.5c-.619875 0-1.125.505125-1.125 1.125s.505125 1.125 1.125 1.125 1.125-.505125 1.125-1.125-.505125-1.125-1.125-1.125zm11.25 4.5c-1.86075 0-3.375-1.51425-3.375-3.375s1.51425-3.375 3.375-3.375 3.375 1.51425 3.375 3.375-1.51425 3.375-3.375 3.375zm0-4.5c-.621 0-1.125.505125-1.125 1.125s.504 1.125 1.125 1.125 1.125-.505125 1.125-1.125-.504-1.125-1.125-1.125zm-11.25 10.117125h-.014625c-.615375-.007875-1.110375-.50175-1.110375-1.117125 0-1.35675.898875-3.375 3.375-3.375h6.75c.50625-.0135 1.125-.219375 1.125-1.125v-1.125c0-.621.502875-1.125 1.125-1.125s1.125.504 1.125 1.125v1.125c0 2.476125-2.01825 3.375-3.375 3.375h-6.75c-.905625 0-1.1115.61875-1.125 1.1385-.01575.610875-.51525 1.103625-1.125 1.103625zm0 1.132875c-.621 0-1.125-.502875-1.125-1.125v-6.75c0-.621.504-1.125 1.125-1.125s1.125.504 1.125 1.125v6.75c0 .622125-.504 1.125-1.125 1.125z\\\" fill=\\\"currentColor\\\" transform=\\\"translate(-10 -10)\\\"/>\\n\\t</svg>\\n\";\nvar connectIcon = \"\\n\\t<svg height=\\\"14\\\" viewBox=\\\"0 0 18 14\\\" width=\\\"18\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\\t\\t<g fill=\\\"currentColor\\\">\\n\\t\\t\\t<path d=\\\"m10.29375 4.05351563c0-.04921875 0-.09140625 0-.13007813 0-1.0546875 0-2.109375 0-3.1640625 0-.43945312.3480469-.76992188.7804688-.7453125.2003906.01054688.3585937.10546875.4992187.24609375.5800781.58359375 1.1566406 1.16367188 1.7367187 1.74023438 1.4695313 1.46953125 2.9390625 2.93906249 4.4050782 4.40859375.1335937.13359375.2425781.27421875.2707031.46757812.0351562.20742188-.0246094.421875-.1652344.58007813-.0246094.028125-.0492187.05273437-.0738281.08085937-2.0601563 2.06367188-4.1203125 4.1238281-6.1804688 6.1875-.2109375.2109375-.4570312.3023438-.7453125.2179688-.2707031-.0808594-.4464843-.2707032-.5132812-.5484375-.0140625-.0738282-.0175781-.1441407-.0140625-.2179688 0-1.0335937 0-2.0707031 0-3.1042969 0-.0386719 0-.08085935 0-.13359372h-5.06953125c-.49570313 0-.80507813-.309375-.80507813-.80859375 0-1.42382813 0-2.84414063 0-4.26796875 0-.49570313.30585938-.8015625.8015625-.8015625h4.93593748z\\\"/>\\n\\t\\t\\t<path d=\\\"m5.69882812 13.978125h-4.01132812c-.928125 0-1.6875-.8753906-1.6875-1.9511719v-10.06171872c0-1.07578125.75585938-1.95117188 1.6875-1.95117188h4.01132812c.34101563 0 .61523438.31992188.61523438.71015625 0 .39023438-.27421875.71015625-.61523438.71015625h-4.01132812c-.253125 0-.45703125.23554688-.45703125.52734375v10.06171875c0 .2917969.20390625.5273437.45703125.5273437h4.01132812c.34101563 0 .61523438.3199219.61523438.7101563s-.27773438.7171875-.61523438.7171875z\\\"/>\\n\\t\\t</g>\\n\\t</svg>\\n\";\nvar balanceIcon = \"\\n\\t<svg height=\\\"18\\\" viewBox=\\\"0 0 429 695\\\" width=\\\"18\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\">\\n\\t\\t<g fill=\\\"currentColor\\\" fill-rule=\\\"evenodd\\\">\\n\\t\\t\\t<path d=\\\"m0 394 213 126.228516 214-126.228516-214 301z\\\"/>\\n\\t\\t\\t<path d=\\\"m0 353.962264 213.5-353.962264 213.5 353.962264-213.5 126.037736z\\\"/>\\n\\t\\t</g>\\n\\t</svg>\\n\";\nvar msgStyles = \"\\n  display: block;\\n  font-size: 0.889em;\\n  font-family: inherit;\\n  color: inherit;\\n  margin-top: 0.5rem;\\n\";\n\nfunction accountSelect() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var heading = options.heading,\n      description = options.description,\n      icon = options.icon;\n  var completed = false;\n  var loadingAccounts = false;\n  var accountsAndBalances = [];\n\n  function checkModule(_x9) {\n    return _checkModule.apply(this, arguments);\n  }\n\n  function _checkModule() {\n    _checkModule = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee11(stateAndHelpers) {\n      var wallet, BigNumber, provider, type, _accounts, deleteWindowProperties, loadMoreAccounts, _accountSelect;\n\n      return regeneratorRuntime.wrap(function _callee11$(_context11) {\n        while (1) {\n          switch (_context11.prev = _context11.next) {\n            case 0:\n              wallet = stateAndHelpers.wallet, BigNumber = stateAndHelpers.BigNumber;\n              provider = wallet.provider, type = wallet.type;\n\n              if (!(type === 'hardware' && !completed && !provider.isCustomPath())) {\n                _context11.next = 18;\n                break;\n              }\n\n              if (!(accountsAndBalances.length === 0)) {\n                _context11.next = 12;\n                break;\n              }\n\n              loadingAccounts = true;\n              _context11.next = 7;\n              return provider.enable();\n\n            case 7:\n              _accounts = _context11.sent;\n              _context11.next = 10;\n              return provider.getBalances(_accounts);\n\n            case 10:\n              accountsAndBalances = _context11.sent;\n              loadingAccounts = false;\n\n            case 12:\n              deleteWindowProperties = function deleteWindowProperties() {\n                delete window.accountSelect;\n                delete window.loadMoreAccounts;\n              };\n\n              loadMoreAccounts = /*#__PURE__*/function () {\n                var _ref34 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10() {\n                  return regeneratorRuntime.wrap(function _callee10$(_context10) {\n                    while (1) {\n                      switch (_context10.prev = _context10.next) {\n                        case 0:\n                          loadingAccounts = true;\n                          _context10.next = 3;\n                          return provider.getMoreAccounts();\n\n                        case 3:\n                          accountsAndBalances = _context10.sent;\n                          loadingAccounts = false;\n\n                        case 5:\n                        case \"end\":\n                          return _context10.stop();\n                      }\n                    }\n                  }, _callee10);\n                }));\n\n                return function loadMoreAccounts() {\n                  return _ref34.apply(this, arguments);\n                };\n              }();\n\n              _accountSelect = function _accountSelect() {\n                var accountIndex = document.getElementById('account-select').selectedIndex;\n                provider.setPrimaryAccount(accountsAndBalances[accountIndex].address);\n              };\n\n              window.accountSelect = _accountSelect;\n              window.loadMoreAccounts = loadMoreAccounts;\n              return _context11.abrupt(\"return\", {\n                heading: heading || 'Select Account',\n                description: description || \"Please select which account you would like to use with this Dapp:\",\n                eventCode: 'accountSelect',\n                html: loadingAccounts ? \"<div class=\\\"bn-onboard-custom bn-onboard-loading\\\">\\n              <div class=\\\"bn-onboard-loading-first\\\"></div>\\n              <div class=\\\"bn-onboard-loading-second\\\"></div>\\n              <div class=\\\"bn-onboard-loading-third\\\"></div>\\n            </div>\\n            <span style=\\\"\".concat(msgStyles, \"\\\">Loading More Accounts...</span>\\n            \") : \"\\n          <div style=\\\"display: flex; align-items: center;\\\">\\n            <select id=\\\"account-select\\\" onchange=\\\"window.accountSelect();\\\" class=\\\"bn-onboard-custom bn-onboard-account-select\\\">\\n              \".concat(accountsAndBalances.map(function (account) {\n                  return \"<option>\".concat(account.address, \" --- \").concat(account.balance != null ? new BigNumber(account.balance).div('1000000000000000000').toFixed(3) : '0', \" ETH</option>\");\n                }), \"\\n            </select>\\n            <button style=\\\"display: flex; align-items: center; text-align: center; height: 1.5rem; background: transparent; margin: 0 0.25rem; padding: 0 0.5rem; border-radius: 40px; cursor: pointer; color: inherit; border-color: inherit; border-width: 1px; border-style: solid;\\\" onclick=\\\"window.loadMoreAccounts()\\\">Load More</button>\\n          </div>\\n        \"),\n                button: {\n                  onclick: function onclick() {\n                    deleteWindowProperties();\n                    completed = true;\n                  },\n                  text: 'Done'\n                },\n                icon: icon || usbIcon\n              });\n\n            case 18:\n            case \"end\":\n              return _context11.stop();\n          }\n        }\n      }, _callee11);\n    }));\n    return _checkModule.apply(this, arguments);\n  }\n\n  checkModule.reset = function () {\n    completed = false;\n    accountsAndBalances = [];\n    loadingAccounts = false;\n  };\n\n  return checkModule;\n}\n\nvar accounts = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  'default': accountSelect\n});\nvar derivationPaths = {\n  Ledger: [{\n    path: \"m/44'/60'/0'\",\n    label: 'Ethereum'\n  }, {\n    path: \"m/44'/60'\",\n    label: 'Ethereum Ledger Live'\n  }],\n  Trezor: [{\n    path: \"m/44'/60'/0'/0\",\n    label: 'Ethereum'\n  }],\n  Lattice: [{\n    path: \"m/44'/60'/0'/0\",\n    label: 'Ethereum'\n  }],\n  KeepKey: [{\n    path: \"m/44'/60'/0'/0/0\",\n    label: 'Ethereum'\n  }]\n};\nvar styles = \"\\n  display: flex;\\n  flex-direction: column;\\n  align-items: center;\\n  justify-content: center;\\n\";\nvar baseStyles = \"\\n  background: inherit;\\n  font-size: 0.889em;\\n  font-family: inherit;\\n  border-width: 1px;\\n  border-style: solid;\\n  border-color: inherit;\\n  border-radius: 40px;\\n  margin-top: 0.5rem;\\n  padding: 0.55em 1.4em;\\n  text-align: center;\\n  color: inherit;\\n  font-family: inherit;\\n  transition: background 150ms ease-in-out;\\n  line-height: 1.15;\\n\";\nvar buttonStyles = \"\\n  cursor: pointer;\\n\";\nvar selectedStyles = \"\\n  border: 1px solid #4a90e2;\\n\";\nvar errorStyles = \"\\n  border: 1px solid #e2504a;\\n\";\nvar msgStyles$1 = \"\\n  display: block;\\n  font-size: 0.889em;\\n  font-family: inherit;\\n  color: inherit;\\n  margin-top: 0.5rem;\\n\";\nvar errorMsgStyles = \"\\n  color: #e2504a;\\n\";\n\nfunction derivationPath() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var heading = options.heading,\n      description = options.description,\n      icon = options.icon;\n  var state = {\n    completed: false,\n    showCustomInput: false,\n    dPath: '',\n    loading: false,\n    error: ''\n  };\n\n  var customInputHtmlString = function customInputHtmlString(error) {\n    return \"\\n      <input \\n        id=\\\"custom-derivation-input\\\" \\n        style=\\\"\".concat(baseStyles + selectedStyles + (error ? errorStyles : ''), \"\\\" \\n        type=\\\"text\\\" \\n        value=\\\"\").concat(state.dPath, \"\\\"\\n        placeholder=\\\"custom derivation path\\\" \\n        onchange=\\\"window.handleCustomInput(this.value)\\\" />\\n      \");\n  };\n\n  function derivationSelectHtmlString(walletName) {\n    return \"\\n      <div id=\\\"derivation-select\\\" style=\\\"\".concat(styles, \"\\\">\\n        \").concat(derivationPaths[walletName].map(function (derivation) {\n      var path = derivation.path,\n          label = derivation.label;\n      return \"\\n              <button style=\\\"\".concat(baseStyles + buttonStyles + (state.dPath === path && !state.showCustomInput ? selectedStyles : ''), \"\\\" onclick=\\\"window.handleDerivationClick(this)\\\" data-path=\\\"\").concat(path, \"\\\">\\n                \").concat(label, \" - \").concat(path, \"\\n              </button>\\n            \");\n    }).join(' '), \"\\n        \").concat(state.showCustomInput ? customInputHtmlString(state.error) : \"<button style=\\\"\".concat(baseStyles + buttonStyles, \"\\\" onclick=\\\"window.handleDerivationClick(this)\\\" data-path=\\\"custom\\\">Custom Path</button>\"), \"\\n        \").concat(state.loading ? \"<div class=\\\"bn-onboard-custom bn-onboard-loading\\\" style=\\\"margin-top: 1rem;\\\">\\n                <div class=\\\"bn-onboard-loading-first\\\"></div>\\n                <div class=\\\"bn-onboard-loading-second\\\"></div>\\n                <div class=\\\"bn-onboard-loading-third\\\"></div>\\n              </div>\\n              <span style=\\\"\".concat(msgStyles$1, \"\\\">Loading Accounts...</span>\\n              \") : state.error ? \"<span style=\\\"\".concat(msgStyles$1 + errorMsgStyles, \"\\\">\").concat(state.error, \"</span>\") : '', \"\\n      </div>\\n    \");\n  }\n\n  function resetState() {\n    state.completed = false;\n    state.showCustomInput = false;\n    state.dPath = '';\n    state.loading = false;\n    state.error = '';\n  }\n\n  function checkModule(stateAndHelpers) {\n    var wallet = stateAndHelpers.wallet;\n\n    if (wallet && wallet.type === 'hardware' && !state.completed) {\n      var handleCustomInput = function handleCustomInput() {\n        var input = document.getElementById('custom-derivation-input');\n        state.dPath = input && input.value;\n        state.error = '';\n      };\n\n      var handleDerivationClick = function handleDerivationClick(button) {\n        var selectedPath = button.dataset.path;\n\n        if (selectedPath === 'custom') {\n          state.showCustomInput = true;\n          setTimeout(function () {\n            var input = document.getElementById('custom-derivation-input');\n            input && input.focus();\n          }, 100);\n        } else {\n          state.error = '';\n          state.showCustomInput = false;\n          state.dPath = selectedPath;\n        }\n      };\n\n      var deleteWindowProperties = function deleteWindowProperties() {\n        delete window.handleCustomInput;\n        delete window.handleDerivationSelect;\n      };\n\n      window.handleCustomInput = handleCustomInput;\n      window.handleDerivationClick = handleDerivationClick;\n      return derivationPaths[wallet.name] && {\n        heading: heading || 'Hardware Wallet Connect',\n        description: description || \"Make sure your \".concat(wallet.name, \" is plugged in, \").concat(wallet.name === 'Ledger' ? 'and the Ethereum app is open, ' : '', \"then select a derivation path to connect your accounts:\"),\n        eventCode: 'derivationPath',\n        html: derivationSelectHtmlString(wallet.name),\n        button: {\n          text: 'Connect',\n          onclick: function () {\n            var _onclick = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee12() {\n              var path, validPath;\n              return regeneratorRuntime.wrap(function _callee12$(_context12) {\n                while (1) {\n                  switch (_context12.prev = _context12.next) {\n                    case 0:\n                      state.loading = true;\n                      path = state.dPath || derivationPaths[wallet.name][0].path;\n                      _context12.prev = 2;\n                      _context12.next = 5;\n                      return wallet.provider.setPath(path, state.showCustomInput);\n\n                    case 5:\n                      validPath = _context12.sent;\n\n                      if (validPath) {\n                        _context12.next = 10;\n                        break;\n                      }\n\n                      state.error = \"\".concat(path, \" is not a valid derivation path\");\n                      state.loading = false;\n                      return _context12.abrupt(\"return\");\n\n                    case 10:\n                      _context12.next = 17;\n                      break;\n\n                    case 12:\n                      _context12.prev = 12;\n                      _context12.t0 = _context12[\"catch\"](2);\n                      state.error = _context12.t0;\n                      state.loading = false;\n                      return _context12.abrupt(\"return\");\n\n                    case 17:\n                      state.error = '';\n\n                      if (wallet.connect) {\n                        wallet.connect().then(function () {\n                          deleteWindowProperties();\n                          state.loading = false;\n                          state.completed = true;\n                        })[\"catch\"](function (error) {\n                          state.error = error.message;\n                          state.loading = false;\n                        });\n                      }\n\n                    case 19:\n                    case \"end\":\n                      return _context12.stop();\n                  }\n                }\n              }, _callee12, null, [[2, 12]]);\n            }));\n\n            function onclick() {\n              return _onclick.apply(this, arguments);\n            }\n\n            return onclick;\n          }()\n        },\n        icon: icon || usbIcon\n      };\n    }\n  }\n\n  checkModule.reset = resetState;\n  return checkModule;\n}\n\nvar derivationPath$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  'default': derivationPath\n});\n/* src/views/Onboard.svelte generated by Svelte v3.38.2 */\n\nfunction add_css$b() {\n  var style = element(\"style\");\n  style.id = \"svelte-1yxy612-style\";\n  style.textContent = \".bn-onboard-custom.bn-onboard-dark-mode{background:#283944;color:#ffffff}.bn-onboard-custom.bn-onboard-dark-mode-background-hover:hover, .bn-onboard-custom.bn-onboard-dark-mode-background{background:#0e212a}.bn-onboard-clickable{text-decoration:none}.bn-onboard-clickable:hover{cursor:pointer;text-decoration:underline}.bn-onboard-custom.bn-onboard-dark-mode-link{color:#91bced;border-color:#91bced}.bn-onboard-wallet-check-section select{padding:0.5rem}\";\n  append(document.head, style);\n} // (41:0) {#if $app.walletSelectInProgress}\n\n\nfunction create_if_block_2$3(ctx) {\n  var walletselect;\n  var current;\n  walletselect = new WalletSelect({\n    props: {\n      module:\n      /*walletSelectModule*/\n      ctx[0]\n    }\n  });\n  return {\n    c: function c() {\n      create_component(walletselect.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(walletselect, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var walletselect_changes = {};\n      if (dirty &\n      /*walletSelectModule*/\n      1) walletselect_changes.module =\n      /*walletSelectModule*/\n      ctx[0];\n      walletselect.$set(walletselect_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(walletselect.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(walletselect.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(walletselect, detaching);\n    }\n  };\n} // (45:0) {#if $app.walletCheckInProgress}\n\n\nfunction create_if_block_1$5(ctx) {\n  var walletcheck;\n  var current;\n  walletcheck = new WalletCheck_1({\n    props: {\n      modules: undefined,\n      walletSelect:\n      /*walletSelect*/\n      ctx[1],\n      walletCheck:\n      /*walletCheck*/\n      ctx[2]\n    }\n  });\n  return {\n    c: function c() {\n      create_component(walletcheck.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(walletcheck, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var walletcheck_changes = {};\n      if (dirty &\n      /*walletSelect*/\n      2) walletcheck_changes.walletSelect =\n      /*walletSelect*/\n      ctx[1];\n      if (dirty &\n      /*walletCheck*/\n      4) walletcheck_changes.walletCheck =\n      /*walletCheck*/\n      ctx[2];\n      walletcheck.$set(walletcheck_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(walletcheck.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(walletcheck.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(walletcheck, detaching);\n    }\n  };\n} // (49:0) {#if $app.accountSelectInProgress}\n\n\nfunction create_if_block$9(ctx) {\n  var walletcheck;\n  var current;\n  walletcheck = new WalletCheck_1({\n    props: {\n      modules: [derivationPath(), accountSelect()],\n      walletSelect:\n      /*walletSelect*/\n      ctx[1],\n      walletCheck:\n      /*walletCheck*/\n      ctx[2]\n    }\n  });\n  return {\n    c: function c() {\n      create_component(walletcheck.$$.fragment);\n    },\n    m: function m(target, anchor) {\n      mount_component(walletcheck, target, anchor);\n      current = true;\n    },\n    p: function p(ctx, dirty) {\n      var walletcheck_changes = {};\n      if (dirty &\n      /*walletSelect*/\n      2) walletcheck_changes.walletSelect =\n      /*walletSelect*/\n      ctx[1];\n      if (dirty &\n      /*walletCheck*/\n      4) walletcheck_changes.walletCheck =\n      /*walletCheck*/\n      ctx[2];\n      walletcheck.$set(walletcheck_changes);\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(walletcheck.$$.fragment, local);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(walletcheck.$$.fragment, local);\n      current = false;\n    },\n    d: function d(detaching) {\n      destroy_component(walletcheck, detaching);\n    }\n  };\n}\n\nfunction create_fragment$b(ctx) {\n  var t0;\n  var t1;\n  var if_block2_anchor;\n  var current;\n  var if_block0 =\n  /*$app*/\n  ctx[3].walletSelectInProgress && create_if_block_2$3(ctx);\n  var if_block1 =\n  /*$app*/\n  ctx[3].walletCheckInProgress && create_if_block_1$5(ctx);\n  var if_block2 =\n  /*$app*/\n  ctx[3].accountSelectInProgress && create_if_block$9(ctx);\n  return {\n    c: function c() {\n      if (if_block0) if_block0.c();\n      t0 = space();\n      if (if_block1) if_block1.c();\n      t1 = space();\n      if (if_block2) if_block2.c();\n      if_block2_anchor = empty();\n    },\n    m: function m(target, anchor) {\n      if (if_block0) if_block0.m(target, anchor);\n      insert(target, t0, anchor);\n      if (if_block1) if_block1.m(target, anchor);\n      insert(target, t1, anchor);\n      if (if_block2) if_block2.m(target, anchor);\n      insert(target, if_block2_anchor, anchor);\n      current = true;\n    },\n    p: function p(ctx, _ref35) {\n      var _ref36 = _slicedToArray(_ref35, 1),\n          dirty = _ref36[0];\n\n      if (\n      /*$app*/\n      ctx[3].walletSelectInProgress) {\n        if (if_block0) {\n          if_block0.p(ctx, dirty);\n\n          if (dirty &\n          /*$app*/\n          8) {\n            transition_in(if_block0, 1);\n          }\n        } else {\n          if_block0 = create_if_block_2$3(ctx);\n          if_block0.c();\n          transition_in(if_block0, 1);\n          if_block0.m(t0.parentNode, t0);\n        }\n      } else if (if_block0) {\n        group_outros();\n        transition_out(if_block0, 1, 1, function () {\n          if_block0 = null;\n        });\n        check_outros();\n      }\n\n      if (\n      /*$app*/\n      ctx[3].walletCheckInProgress) {\n        if (if_block1) {\n          if_block1.p(ctx, dirty);\n\n          if (dirty &\n          /*$app*/\n          8) {\n            transition_in(if_block1, 1);\n          }\n        } else {\n          if_block1 = create_if_block_1$5(ctx);\n          if_block1.c();\n          transition_in(if_block1, 1);\n          if_block1.m(t1.parentNode, t1);\n        }\n      } else if (if_block1) {\n        group_outros();\n        transition_out(if_block1, 1, 1, function () {\n          if_block1 = null;\n        });\n        check_outros();\n      }\n\n      if (\n      /*$app*/\n      ctx[3].accountSelectInProgress) {\n        if (if_block2) {\n          if_block2.p(ctx, dirty);\n\n          if (dirty &\n          /*$app*/\n          8) {\n            transition_in(if_block2, 1);\n          }\n        } else {\n          if_block2 = create_if_block$9(ctx);\n          if_block2.c();\n          transition_in(if_block2, 1);\n          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);\n        }\n      } else if (if_block2) {\n        group_outros();\n        transition_out(if_block2, 1, 1, function () {\n          if_block2 = null;\n        });\n        check_outros();\n      }\n    },\n    i: function i(local) {\n      if (current) return;\n      transition_in(if_block0);\n      transition_in(if_block1);\n      transition_in(if_block2);\n      current = true;\n    },\n    o: function o(local) {\n      transition_out(if_block0);\n      transition_out(if_block1);\n      transition_out(if_block2);\n      current = false;\n    },\n    d: function d(detaching) {\n      if (if_block0) if_block0.d(detaching);\n      if (detaching) detach(t0);\n      if (if_block1) if_block1.d(detaching);\n      if (detaching) detach(t1);\n      if (if_block2) if_block2.d(detaching);\n      if (detaching) detach(if_block2_anchor);\n    }\n  };\n}\n\nfunction instance$b($$self, $$props, $$invalidate) {\n  var $app;\n  component_subscribe($$self, app, function ($$value) {\n    return $$invalidate(3, $app = $$value);\n  });\n  var walletSelectModule = $$props.walletSelectModule;\n  var walletSelect = $$props.walletSelect;\n  var walletCheck = $$props.walletCheck;\n\n  $$self.$$set = function ($$props) {\n    if (\"walletSelectModule\" in $$props) $$invalidate(0, walletSelectModule = $$props.walletSelectModule);\n    if (\"walletSelect\" in $$props) $$invalidate(1, walletSelect = $$props.walletSelect);\n    if (\"walletCheck\" in $$props) $$invalidate(2, walletCheck = $$props.walletCheck);\n  };\n\n  return [walletSelectModule, walletSelect, walletCheck, $app];\n}\n\nvar Onboard = /*#__PURE__*/function (_SvelteComponent12) {\n  _inherits(Onboard, _SvelteComponent12);\n\n  var _super12 = _createSuper(Onboard);\n\n  function Onboard(options) {\n    var _this12;\n\n    _classCallCheck(this, Onboard);\n\n    _this12 = _super12.call(this);\n    if (!document.getElementById(\"svelte-1yxy612-style\")) add_css$b();\n    init(_assertThisInitialized(_this12), options, instance$b, create_fragment$b, safe_not_equal, {\n      walletSelectModule: 0,\n      walletSelect: 1,\n      walletCheck: 2\n    });\n    return _this12;\n  }\n\n  return Onboard;\n}(SvelteComponent); // wallets that qualify for default wallets need to have no\n// init parameters that are required for full functionality\n\n\nvar desktopDefaultWalletNames = ['detectedwallet', 'metamask', 'frame', 'torus', 'opera', 'liquality'];\nvar mobileDefaultWalletNames = ['detectedwallet', 'metamask', 'coinbase', 'trust', 'torus', 'opera', 'operaTouch', 'status', 'hyperpay', 'tokenpocket', 'dcent', 'atoken', 'liquality', 'alphawallet', 'ownbit', 'bitpie', 'authereum'];\n\nvar injectedWalletDetected = function injectedWalletDetected() {\n  return window.ethereum && getProviderName(window.ethereum) === undefined;\n};\n\nfunction select(wallets, networkId, isMobile) {\n  var defaultWalletNames = isMobile ? mobileDefaultWalletNames : desktopDefaultWalletNames;\n\n  if (wallets) {\n    return Promise.all(wallets // only include a detected wallet if it's not already one of the provided options\n    .filter(function (wallet) {\n      return isWalletInit(wallet) && (wallet.walletName !== 'detectedwallet' || injectedWalletDetected());\n    }).map(function (wallet) {\n      var walletName = wallet.walletName,\n          initParams = _objectWithoutProperties(wallet, _excluded11);\n\n      try {\n        return getModule(walletName).then(function (m) {\n          return m[\"default\"](_objectSpread(_objectSpread({}, initParams), {}, {\n            networkId: networkId,\n            isMobile: isMobile\n          }));\n        });\n      } catch (error) {\n        if (error.name === 'DeprecatedWalletError') {\n          console.warn(error.message);\n        } else {\n          throw error;\n        }\n      }\n\n      return Promise.resolve(wallet);\n    }));\n  }\n\n  return Promise.all(defaultWalletNames // only include a detected wallet if it's not already one of the provided options\n  .filter(function (walletName) {\n    return walletName !== 'detectedwallet' || injectedWalletDetected();\n  }).map(function (walletName) {\n    return getModule(walletName).then(function (m) {\n      return m[\"default\"]({\n        networkId: networkId\n      });\n    });\n  }));\n}\n\nfunction getModule(name) {\n  switch (name) {\n    // Deprecated wallets\n    case 'dapper':\n    case 'squarelink':\n    case 'unilogin':\n      throw {\n        name: 'DeprecatedWalletError',\n        message: \"\".concat(name, \" wallet has been deprecated\")\n      };\n\n    case 'meetone':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_meetone-10714292_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./meetone-10714292.js */ \"./node_modules/bnc-onboard/dist/esm/meetone-10714292.js\"));\n\n    case 'metamask':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_metamask-61289acd_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./metamask-61289acd.js */ \"./node_modules/bnc-onboard/dist/esm/metamask-61289acd.js\"));\n\n    case 'portis':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_portis-20da3305_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./portis-20da3305.js */ \"./node_modules/bnc-onboard/dist/esm/portis-20da3305.js\"));\n\n    case 'fortmatic':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_fortmatic-4fe9359d_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./fortmatic-4fe9359d.js */ \"./node_modules/bnc-onboard/dist/esm/fortmatic-4fe9359d.js\"));\n\n    case 'authereum':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_authereum-d17fd2eb_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./authereum-d17fd2eb.js */ \"./node_modules/bnc-onboard/dist/esm/authereum-d17fd2eb.js\"));\n\n    case 'trust':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_trust-366bacfe_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./trust-366bacfe.js */ \"./node_modules/bnc-onboard/dist/esm/trust-366bacfe.js\"));\n\n    case 'coinbase':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_coinbase-ff2019aa_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./coinbase-ff2019aa.js */ \"./node_modules/bnc-onboard/dist/esm/coinbase-ff2019aa.js\"));\n\n    case 'walletConnect':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_wallet-connect-b01cbd9e_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./wallet-connect-b01cbd9e.js */ \"./node_modules/bnc-onboard/dist/esm/wallet-connect-b01cbd9e.js\"));\n\n    case 'opera':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_opera-b328ed05_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./opera-b328ed05.js */ \"./node_modules/bnc-onboard/dist/esm/opera-b328ed05.js\"));\n\n    case 'operaTouch':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_opera-touch-269c38a9_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./opera-touch-269c38a9.js */ \"./node_modules/bnc-onboard/dist/esm/opera-touch-269c38a9.js\"));\n\n    case 'torus':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_torus-a3ead2fc_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./torus-a3ead2fc.js */ \"./node_modules/bnc-onboard/dist/esm/torus-a3ead2fc.js\"));\n\n    case 'status':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_status-b68b10b3_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./status-b68b10b3.js */ \"./node_modules/bnc-onboard/dist/esm/status-b68b10b3.js\"));\n\n    case 'trezor':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_trezor-79b1a639_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./trezor-79b1a639.js */ \"./node_modules/bnc-onboard/dist/esm/trezor-79b1a639.js\"));\n\n    case 'lattice':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_lattice-a9225c21_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./lattice-a9225c21.js */ \"./node_modules/bnc-onboard/dist/esm/lattice-a9225c21.js\"));\n\n    case 'cobovault':\n      return Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_buffer_index_js\"), __webpack_require__.e(\"vendors-node_modules_events_events_js\"), __webpack_require__.e(\"vendors-node_modules_create-hash_browser_js-node_modules_elliptic_lib_elliptic_js-node_module-ad4815\"), __webpack_require__.e(\"vendors-node_modules_assert_build_assert_js-node_modules_assert_build_internal_assert_asserti-d1eadf\"), __webpack_require__.e(\"vendors-node_modules_crypto-browserify_index_js\"), __webpack_require__.e(\"vendors-node_modules_rxjs__esm5_index_js\"), __webpack_require__.e(\"vendors-node_modules_hdkey_lib_hdkey_js\"), __webpack_require__.e(\"vendors-node_modules_bnc-onboard_dist_esm_cobovault-28f5eab2_js\"), __webpack_require__.e(\"_045f-_3fc0-_f9d4-_7a28-_cad2-_593c-_802b-_1e44-_3e83-_19e6\")]).then(__webpack_require__.bind(__webpack_require__, /*! ./cobovault-28f5eab2.js */ \"./node_modules/bnc-onboard/dist/esm/cobovault-28f5eab2.js\"));\n\n    case 'ledger':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_ledger-e33a98e5_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./ledger-e33a98e5.js */ \"./node_modules/bnc-onboard/dist/esm/ledger-e33a98e5.js\"));\n\n    case 'walletLink':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_wallet-link-b78ddc0e_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./wallet-link-b78ddc0e.js */ \"./node_modules/bnc-onboard/dist/esm/wallet-link-b78ddc0e.js\"));\n\n    case 'imToken':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_imtoken-cc5e15c9_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./imtoken-cc5e15c9.js */ \"./node_modules/bnc-onboard/dist/esm/imtoken-cc5e15c9.js\"));\n\n    case 'mykey':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_mykey-d08cad20_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./mykey-d08cad20.js */ \"./node_modules/bnc-onboard/dist/esm/mykey-d08cad20.js\"));\n\n    case 'huobiwallet':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_huobiwallet-0348988e_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./huobiwallet-0348988e.js */ \"./node_modules/bnc-onboard/dist/esm/huobiwallet-0348988e.js\"));\n\n    case 'wallet.io':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_wallet-io-4db3dbea_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./wallet-io-4db3dbea.js */ \"./node_modules/bnc-onboard/dist/esm/wallet-io-4db3dbea.js\"));\n\n    case 'hyperpay':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_hyperpay-cb53c487_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./hyperpay-cb53c487.js */ \"./node_modules/bnc-onboard/dist/esm/hyperpay-cb53c487.js\"));\n\n    case 'tokenpocket':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_tokenpocket-3b49fdba_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./tokenpocket-3b49fdba.js */ \"./node_modules/bnc-onboard/dist/esm/tokenpocket-3b49fdba.js\"));\n\n    case 'dcent':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_dcent-aad7ab41_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./dcent-aad7ab41.js */ \"./node_modules/bnc-onboard/dist/esm/dcent-aad7ab41.js\"));\n\n    case 'atoken':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_atoken-68fc48b8_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./atoken-68fc48b8.js */ \"./node_modules/bnc-onboard/dist/esm/atoken-68fc48b8.js\"));\n\n    case 'liquality':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_liquality-0adca826_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./liquality-0adca826.js */ \"./node_modules/bnc-onboard/dist/esm/liquality-0adca826.js\"));\n\n    case 'frame':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_frame-a3f4e5a5_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./frame-a3f4e5a5.js */ \"./node_modules/bnc-onboard/dist/esm/frame-a3f4e5a5.js\"));\n\n    case 'xdefi':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_xdefi-041b1a64_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./xdefi-041b1a64.js */ \"./node_modules/bnc-onboard/dist/esm/xdefi-041b1a64.js\"));\n\n    case 'alphawallet':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_alphawallet-48de70ca_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./alphawallet-48de70ca.js */ \"./node_modules/bnc-onboard/dist/esm/alphawallet-48de70ca.js\"));\n\n    case 'ownbit':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_ownbit-b933af7e_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./ownbit-b933af7e.js */ \"./node_modules/bnc-onboard/dist/esm/ownbit-b933af7e.js\"));\n\n    case 'keepkey':\n      return __webpack_require__.e(/*! import() */ \"vendors-node_modules_bnc-onboard_dist_esm_index-4a48b5ea_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./index-4a48b5ea.js */ \"./node_modules/bnc-onboard/dist/esm/index-4a48b5ea.js\"));\n\n    case 'bitpie':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_bitpie-a7acfe0e_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./bitpie-a7acfe0e.js */ \"./node_modules/bnc-onboard/dist/esm/bitpie-a7acfe0e.js\"));\n\n    case 'gnosis':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_gnosis-19b90e57_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./gnosis-19b90e57.js */ \"./node_modules/bnc-onboard/dist/esm/gnosis-19b90e57.js\"));\n\n    case 'detectedwallet':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_detectedwallet-be2637be_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./detectedwallet-be2637be.js */ \"./node_modules/bnc-onboard/dist/esm/detectedwallet-be2637be.js\"));\n\n    default:\n      throw new Error(\"\".concat(name, \" is not a valid walletName.\"));\n  }\n}\n\nvar defaultChecks = ['connect', 'network'];\n\nfunction check(_x10, _x11) {\n  return _check.apply(this, arguments);\n}\n\nfunction _check() {\n  _check = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee13(walletChecks, networkId) {\n    var checks;\n    return regeneratorRuntime.wrap(function _callee13$(_context13) {\n      while (1) {\n        switch (_context13.prev = _context13.next) {\n          case 0:\n            if (!walletChecks) {\n              _context13.next = 3;\n              break;\n            }\n\n            checks = walletChecks.map(function (checkOrModule) {\n              if (!isWalletCheckModule(checkOrModule)) {\n                var checkName = checkOrModule.checkName,\n                    otherParams = _objectWithoutProperties(checkOrModule, _excluded12);\n\n                var module = getModule$1(checkName);\n                return module && module.then(function (m) {\n                  return m[\"default\"](_objectSpread(_objectSpread({}, otherParams), {}, {\n                    networkId: networkId\n                  }));\n                });\n              }\n\n              return Promise.resolve(checkOrModule);\n            });\n            return _context13.abrupt(\"return\", Promise.all(checks));\n\n          case 3:\n            return _context13.abrupt(\"return\", Promise.all(defaultChecks.map(function (checkName) {\n              var module = getModule$1(checkName);\n              return module && module.then(function (m) {\n                return m[\"default\"]({\n                  networkId: networkId\n                });\n              });\n            })));\n\n          case 4:\n          case \"end\":\n            return _context13.stop();\n        }\n      }\n    }, _callee13);\n  }));\n  return _check.apply(this, arguments);\n}\n\nfunction getModule$1(name) {\n  switch (name) {\n    case 'connect':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_connect-945daaba_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./connect-945daaba.js */ \"./node_modules/bnc-onboard/dist/esm/connect-945daaba.js\"));\n\n    case 'network':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_network-d7fdf0ca_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./network-d7fdf0ca.js */ \"./node_modules/bnc-onboard/dist/esm/network-d7fdf0ca.js\"));\n\n    case 'balance':\n      return __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_balance-55ba2eda_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./balance-55ba2eda.js */ \"./node_modules/bnc-onboard/dist/esm/balance-55ba2eda.js\"));\n\n    case 'accounts':\n      return Promise.resolve().then(function () {\n        return accounts;\n      });\n\n    case 'derivationPath':\n      return Promise.resolve().then(function () {\n        return derivationPath$1;\n      });\n\n    default:\n      throw new Error(\"invalid module name: \".concat(name));\n  }\n}\n\nvar defaultHeading = 'Select a Wallet';\nvar defaultDescription = 'Please select a wallet to connect to this dapp:';\nvar defaultWalletExplanation = \"Wallets are used to send, receive, and store digital assets like Ether. Wallets come in many forms. They are either built into your browser, an extension added to your browser, a piece of hardware plugged into your computer or even an app on your phone. For more information about wallets, see <a style=\\\"color: #4a90e2; font-size: 0.889rem; font-family: inherit;\\\" class=\\\"bn-onboard-clickable\\\" href=\\\"https://docs.ethhub.io/using-ethereum/wallets/intro-to-ethereum-wallets/\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">this explanation</a>.\";\n\nfunction initializeModules(networkId, walletSelectOptions, walletCheck, isMobile) {\n  var wallets = select(walletSelectOptions && walletSelectOptions.wallets, networkId, isMobile);\n\n  var _ref37 = walletSelectOptions || {},\n      _ref37$heading = _ref37.heading,\n      heading = _ref37$heading === void 0 ? defaultHeading : _ref37$heading,\n      _ref37$description = _ref37.description,\n      description = _ref37$description === void 0 ? defaultDescription : _ref37$description,\n      _ref37$explanation = _ref37.explanation,\n      explanation = _ref37$explanation === void 0 ? defaultWalletExplanation : _ref37$explanation,\n      _ref37$agreement = _ref37.agreement,\n      agreement = _ref37$agreement === void 0 ? {} : _ref37$agreement;\n\n  return {\n    walletSelect: {\n      heading: heading,\n      description: description,\n      wallets: wallets,\n      explanation: explanation,\n      agreement: agreement\n    },\n    walletCheck: check(walletCheck, networkId)\n  };\n}\n\nvar onboard;\n\nfunction init$1(initialization) {\n  var _initialization$walle2, _initialization$walle3;\n\n  if (typeof window === 'undefined') {\n    console.warn('Onboard.js must be run in a browser environment. If you are utilizing server side rendering you can ignore this warning.');\n    var stubbedAPI = {\n      walletSelect: function walletSelect() {\n        return Promise.resolve(false);\n      },\n      walletCheck: function walletCheck() {\n        return Promise.resolve(false);\n      },\n      walletReset: function walletReset() {},\n      config: function config() {},\n      getState: function getState() {\n        return get_store_value(state);\n      },\n      accountSelect: function accountSelect() {\n        return Promise.resolve(false);\n      }\n    };\n    return stubbedAPI;\n  }\n\n  if (onboard) {\n    console.warn('Initializing Onboard and destroying previously initialized instance.'); // close WebSocket connection\n\n    closeSocketConnection(); // reset the wallet state\n\n    resetWalletState(); // destroy svelte instance and remove from DOM\n\n    onboard.$destroy();\n  }\n\n  validateInit(initialization);\n  var subscriptions = initialization.subscriptions,\n      dappId = initialization.dappId,\n      networkId = initialization.networkId,\n      networkName = initialization.networkName,\n      darkMode = initialization.darkMode,\n      apiUrl = initialization.apiUrl,\n      hideBranding = initialization.hideBranding,\n      _initialization$block = initialization.blockPollingInterval,\n      blockPollingInterval = _initialization$block === void 0 ? 4000 : _initialization$block;\n\n  var _getDeviceInfo = getDeviceInfo(),\n      os = _getDeviceInfo.os,\n      browser = _getDeviceInfo.browser,\n      isMobile = _getDeviceInfo.isMobile;\n\n  var initializedModules = initializeModules(networkId, initialization.walletSelect, initialization.walletCheck, isMobile);\n  var displayBranding;\n\n  if (dappId) {\n    if (hideBranding !== false) {\n      displayBranding = false;\n    } else {\n      displayBranding = true;\n    }\n  } else {\n    if (hideBranding !== true) {\n      displayBranding = true;\n    } else {\n      displayBranding = false;\n    }\n  }\n\n  app.update(function (store) {\n    var _initialization$walle;\n\n    return _objectSpread(_objectSpread({}, store), {}, {\n      dappId: dappId,\n      apiUrl: apiUrl,\n      networkId: networkId,\n      networkName: networkName,\n      version: version,\n      mobileDevice: isMobile,\n      os: os,\n      browser: browser,\n      darkMode: darkMode,\n      displayBranding: displayBranding,\n      checkModules: initializedModules.walletCheck,\n      blockPollingInterval: blockPollingInterval,\n      agreement: ((_initialization$walle = initialization.walletSelect) === null || _initialization$walle === void 0 ? void 0 : _initialization$walle.agreement) || null\n    });\n  });\n  initializeStores();\n  onboard = new Onboard({\n    target: document.body,\n    props: {\n      walletSelectModule: initializedModules.walletSelect,\n      walletSelect: walletSelect,\n      walletCheck: walletCheck\n    }\n  }); // register subscriptions\n\n  if (subscriptions) {\n    if (subscriptions.address) {\n      address.subscribe(function (address) {\n        if (address !== null) {\n          subscriptions.address && subscriptions.address(address);\n        }\n      });\n    }\n\n    if (subscriptions.network) {\n      network.subscribe(function (networkId) {\n        if (networkId !== null) {\n          subscriptions.network && subscriptions.network(networkId);\n        }\n      });\n    }\n\n    if (subscriptions.balance) {\n      balance.subscribe(function (balance) {\n        if (balance !== null) {\n          subscriptions.balance && subscriptions.balance(balance);\n        }\n      });\n    }\n\n    if (subscriptions.wallet) {\n      wallet.subscribe(function (wallet) {\n        if (wallet.provider !== null) {\n          subscriptions.wallet && subscriptions.wallet(wallet);\n        }\n      });\n    }\n  }\n\n  function walletSelect(autoSelectWallet) {\n    return new Promise(function (resolve) {\n      app.update(function (store) {\n        return _objectSpread(_objectSpread({}, store), {}, {\n          walletSelectInProgress: true,\n          autoSelectWallet: typeof autoSelectWallet === 'string' && autoSelectWallet\n        });\n      });\n      var appUnsubscribe = app.subscribe(function (store) {\n        var walletSelectInProgress = store.walletSelectInProgress,\n            walletSelectCompleted = store.walletSelectCompleted,\n            walletSelectDisplayedUI = store.walletSelectDisplayedUI;\n\n        if (walletSelectInProgress === false) {\n          appUnsubscribe(); // timeout for UI transitions if it was displayed\n\n          walletSelectDisplayedUI ? setTimeout(function () {\n            resolve(walletSelectCompleted);\n            app.update(function (store) {\n              return _objectSpread(_objectSpread({}, store), {}, {\n                displayedUI: false\n              });\n            });\n          }, 500) : resolve(walletSelectCompleted);\n        }\n      });\n    });\n  }\n\n  function walletCheck() {\n    return new Promise(function (resolve) {\n      if (!get_store_value(walletInterface)) {\n        throw new Error('walletSelect must be called before walletCheck');\n      }\n\n      app.update(function (store) {\n        return _objectSpread(_objectSpread({}, store), {}, {\n          walletCheckInProgress: true\n        });\n      });\n      var appUnsubscribe = app.subscribe(function (store) {\n        var walletCheckInProgress = store.walletCheckInProgress,\n            walletCheckCompleted = store.walletCheckCompleted,\n            walletCheckDisplayedUI = store.walletCheckDisplayedUI,\n            switchingWallets = store.switchingWallets;\n\n        if (!switchingWallets && walletCheckInProgress === false) {\n          appUnsubscribe();\n          walletCheckDisplayedUI ? setTimeout(function () {\n            resolve(walletCheckCompleted);\n            app.update(function (store) {\n              return _objectSpread(_objectSpread({}, store), {}, {\n                displayedUI: false\n              });\n            });\n          }, 500) : resolve(walletCheckCompleted);\n        }\n      });\n    });\n  }\n\n  function walletReset() {\n    resetWalletState();\n  }\n\n  function accountSelect() {\n    return new Promise(function (resolve) {\n      var _get_store_value6 = get_store_value(wallet),\n          type = _get_store_value6.type;\n\n      if (type !== 'hardware') {\n        resolve(false);\n      }\n\n      app.update(function (store) {\n        return _objectSpread(_objectSpread({}, store), {}, {\n          accountSelectInProgress: true\n        });\n      });\n      var appUnsubscribe = app.subscribe(function (store) {\n        var accountSelectInProgress = store.accountSelectInProgress,\n            walletSelectDisplayedUI = store.walletSelectDisplayedUI;\n\n        if (accountSelectInProgress === false) {\n          appUnsubscribe();\n          walletSelectDisplayedUI ? setTimeout(function () {\n            resolve(true);\n            app.update(function (store) {\n              return _objectSpread(_objectSpread({}, store), {}, {\n                displayedUI: false\n              });\n            });\n          }, 500) : resolve(true);\n        }\n      });\n    });\n  }\n\n  function config(options) {\n    validateConfig(options);\n    app.update(function (store) {\n      return _objectSpread(_objectSpread({}, store), options);\n    });\n  }\n\n  function getState() {\n    return get_store_value(state);\n  } // Find the Gnosis wallet from the wallet init options. Ignore it\n  // if it is a wallet module. We need to get the wallet init first\n  // in order to determine the wallet name: `walletName` or `label`.\n\n\n  var _ref38 = ((_initialization$walle2 = initialization.walletSelect) === null || _initialization$walle2 === void 0 ? void 0 : (_initialization$walle3 = _initialization$walle2.wallets) === null || _initialization$walle3 === void 0 ? void 0 : _initialization$walle3.find(function (wallet) {\n    return isWalletInit(wallet) && wallet.walletName === 'gnosis';\n  })) || {},\n      _ref38$label = _ref38.label,\n      gnosisWalletName = _ref38$label === void 0 ? 'Gnosis Safe' : _ref38$label;\n\n  if (gnosisWalletName) {\n    __webpack_require__.e(/*! import() */ \"node_modules_bnc-onboard_dist_esm_gnosis-19b90e57_js\").then(__webpack_require__.bind(__webpack_require__, /*! ./gnosis-19b90e57.js */ \"./node_modules/bnc-onboard/dist/esm/gnosis-19b90e57.js\")).then(function (_ref39) {\n      var checkGnosisSafeContext = _ref39.checkGnosisSafeContext;\n      return checkGnosisSafeContext(function () {\n        return walletSelect(gnosisWalletName);\n      });\n    });\n  }\n\n  return {\n    walletSelect: walletSelect,\n    walletCheck: walletCheck,\n    walletReset: walletReset,\n    config: config,\n    getState: getState,\n    accountSelect: accountSelect\n  };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JuYy1vbmJvYXJkL2Rpc3QvZXNtL29uYm9hcmQtNTg0YzA0NGQuanM/Y2FjOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3REFBd0QsaUZBQWlGLFdBQVcsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLDhCQUE4QixFQUFFLHNCQUFzQixXQUFXLEVBQUUsU0FBUyxFQUFFLDhKQUE4SixFQUFFLGtEQUFrRCxTQUFTLGtCQUFrQixpQkFBaUIsRUFBRSxtQkFBbUIsc0JBQXNCLDhCQUE4QixhQUFhLEVBQUUsc0JBQXNCLGVBQWUsV0FBVyxFQUFFLG1CQUFtQixNQUFNLCtEQUErRCxFQUFFLFVBQVUsdUJBQXVCLEVBQUUsRUFBRSxHQUFHOztBQUU1K0IsMENBQTBDLCtEQUErRCwyRUFBMkUsRUFBRSx5RUFBeUUsZUFBZSxzREFBc0QsRUFBRSxFQUFFLHVEQUF1RDs7QUFFL1gsZ0NBQWdDLDRFQUE0RSxpQkFBaUIsVUFBVSxHQUFHLDhCQUE4Qjs7QUFFeEssZ0NBQWdDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQseURBQXlELEVBQUUsT0FBTyx1Q0FBdUMsRUFBRSxpREFBaUQsR0FBRzs7QUFFdmEsaURBQWlELDBFQUEwRSxhQUFhLEVBQUUscUNBQXFDOztBQUUvSyx1Q0FBdUMsdUJBQXVCLHVGQUF1RixFQUFFLGFBQWE7O0FBRXBLLHNDQUFzQyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDZFQUE2RSxHQUFHLGFBQWEsRUFBRSxZQUFZLGNBQWMsRUFBRTs7QUFFdlUsNkJBQTZCLGdHQUFnRyxnREFBZ0QsR0FBRywyQkFBMkI7O0FBRTNNLDBDQUEwQyxnQ0FBZ0Msb0NBQW9D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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLDhCQUE4Qix5QkFBeUI7QUFDdkQ7O0FBRUEsZ0NBQWdDLHlCQUF5QixHQUFHO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FOztBQUVwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQSxvQkFBb0IsOEJBQThCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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LEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSx1REFBZ0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztB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QUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxrRUFB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7OztBQUdkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLHlCQUF5QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCLG1CQUFtQixvQkFBb0IsZ0NBQWdDLGFBQWEsa0JBQWtCLG9CQUFvQiw4QkFBOEIscUNBQXFDLGNBQWMsa0JBQWtCLG9CQUFvQixrQkFBa0IsZUFBZSwrREFBK0QsYUFBYSxtQkFBbUIseUVBQXlFLGlCQUFpQjtBQUNsaEI7QUFDQSxDQUFDLGFBQWE7OztBQUdkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7OztBQUdkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxjQUFjOzs7QUFHZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGNBQWM7OztBQUdmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTs7O0FBR2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMEJBQTBCLE1BQU0sVUFBVSxjQUFjLG1CQUFtQixFQUFFOzs7QUFHOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOzs7QUFHZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCLGNBQWMsbUJBQW1CLEVBQUU7OztBQUduRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FB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Q0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QixNQUFNOzs7QUFHckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGFBQWE7OztBQUdkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QywyQkFBMkI7OztBQUcxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxhQUFhOzs7QUFHZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0NBQXdDLG1DQUFtQyxvQkFBb0IsU0FBUzs7O0FBR3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsYUFBYTs7O0FBR2Q7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2Q0FBNkMsd0JBQXdCLE1BQU0sTUFBTTs7O0FBR2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsK0JBQStCLG1CQUFtQjs7O0FBR25EO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxH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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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LEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm5jLW9uYm9hcmQvZGlzdC9lc20vb25ib2FyZC01ODRjMDQ0ZC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBfZXhjbHVkZWQgPSBbXCJkYXBwSWRcIiwgXCJuZXR3b3JrSWRcIiwgXCJuZXR3b3JrTmFtZVwiLCBcInN1YnNjcmlwdGlvbnNcIiwgXCJ3YWxsZXRTZWxlY3RcIiwgXCJ3YWxsZXRDaGVja1wiLCBcImRhcmtNb2RlXCIsIFwiYXBpVXJsXCIsIFwiaGlkZUJyYW5kaW5nXCIsIFwiYmxvY2tQb2xsaW5nSW50ZXJ2YWxcIl0sXG4gICAgX2V4Y2x1ZGVkMiA9IFtcImFkZHJlc3NcIiwgXCJuZXR3b3JrXCIsIFwiYmFsYW5jZVwiLCBcIndhbGxldFwiXSxcbiAgICBfZXhjbHVkZWQzID0gW1wiaGVhZGluZ1wiLCBcImRlc2NyaXB0aW9uXCIsIFwiZXhwbGFuYXRpb25cIiwgXCJ3YWxsZXRzXCIsIFwiYWdyZWVtZW50XCJdLFxuICAgIF9leGNsdWRlZDQgPSBbXCJuYW1lXCIsIFwiaWNvblNyY1wiLCBcImljb25TcmNTZXRcIiwgXCJzdmdcIiwgXCJ3YWxsZXRcIiwgXCJsaW5rXCIsIFwiaW5zdGFsbE1lc3NhZ2VcIiwgXCJwcmVmZXJyZWRcIiwgXCJkZXNrdG9wXCIsIFwibW9iaWxlXCIsIFwidHlwZVwiLCBcIm9zRXhjbHVzaW9uc1wiXSxcbiAgICBfZXhjbHVkZWQ1ID0gW1wiY2hlY2tOYW1lXCIsIFwiaGVhZGluZ1wiLCBcImRlc2NyaXB0aW9uXCIsIFwibWluaW11bUJhbGFuY2VcIiwgXCJodG1sXCIsIFwiaWNvblwiLCBcImJ1dHRvblwiXSxcbiAgICBfZXhjbHVkZWQ2ID0gW1wiZGFya01vZGVcIiwgXCJuZXR3b3JrSWRcIl0sXG4gICAgX2V4Y2x1ZGVkNyA9IFtcImhlYWRpbmdcIiwgXCJkZXNjcmlwdGlvblwiLCBcImJ1dHRvblwiLCBcImV2ZW50Q29kZVwiLCBcImFjdGlvblwiLCBcImljb25cIiwgXCJodG1sXCJdLFxuICAgIF9leGNsdWRlZDggPSBbXCJvbmNsaWNrXCIsIFwidGV4dFwiXSxcbiAgICBfZXhjbHVkZWQ5ID0gW1wibmFtZVwiLCBcImNvbm5lY3RcIiwgXCJkaXNjb25uZWN0XCIsIFwiYWRkcmVzc1wiLCBcIm5ldHdvcmtcIiwgXCJiYWxhbmNlXCJdLFxuICAgIF9leGNsdWRlZDEwID0gW1wid2FsbGV0TmFtZVwiLCBcInByZWZlcnJlZFwiLCBcImxhYmVsXCIsIFwiaWNvblNyY1wiLCBcInN2Z1wiXSxcbiAgICBfZXhjbHVkZWQxMSA9IFtcIndhbGxldE5hbWVcIl0sXG4gICAgX2V4Y2x1ZGVkMTIgPSBbXCJjaGVja05hbWVcIl07XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IHRocm93IF9lMjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMykgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTM7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IHZhciBfaSA9IGFyciAmJiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdKTsgaWYgKF9pID09IG51bGwpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfcywgX2U7IHRyeSB7IGZvciAoX2kgPSBfaS5jYWxsKGFycik7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1wicmV0dXJuXCJdICE9IG51bGwpIF9pW1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTsgdmFyIGtleSwgaTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7IGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7IGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07IGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHsgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307IHZhciB0YXJnZXQgPSB7fTsgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpOyB2YXIga2V5LCBpOyBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykgeyBrZXkgPSBzb3VyY2VLZXlzW2ldOyBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlOyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuaW1wb3J0ICdyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUnO1xuaW1wb3J0IEJpZ051bWJlciBmcm9tICdiaWdudW1iZXIuanMnO1xuaW1wb3J0IEJsb2NrbmF0aXZlQXBpIGZyb20gJ2JuYy1zZGsnO1xuaW1wb3J0IGJvd3NlciBmcm9tICdib3dzZXInO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gaWRlbnRpdHkoeCkge1xuICByZXR1cm4geDtcbn07XG5cbmZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuICAvLyBAdHMtaWdub3JlXG4gIGZvciAodmFyIGsgaW4gc3JjKSB7XG4gICAgdGFyW2tdID0gc3JjW2tdO1xuICB9XG5cbiAgcmV0dXJuIHRhcjtcbn1cblxuZnVuY3Rpb24gcnVuKGZuKSB7XG4gIHJldHVybiBmbigpO1xufVxuXG5mdW5jdGlvbiBibGFua19vYmplY3QoKSB7XG4gIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuXG5mdW5jdGlvbiBydW5fYWxsKGZucykge1xuICBmbnMuZm9yRWFjaChydW4pO1xufVxuXG5mdW5jdGlvbiBpc19mdW5jdGlvbih0aGluZykge1xuICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBzYWZlX25vdF9lcXVhbChhLCBiKSB7XG4gIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8IGEgJiYgX3R5cGVvZihhKSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGEgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzX2VtcHR5KG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZShzdG9yZSkge1xuICBpZiAoc3RvcmUgPT0gbnVsbCkge1xuICAgIHJldHVybiBub29wO1xuICB9XG5cbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGNhbGxiYWNrcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgY2FsbGJhY2tzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciB1bnN1YiA9IHN0b3JlLnN1YnNjcmliZS5hcHBseShzdG9yZSwgY2FsbGJhY2tzKTtcbiAgcmV0dXJuIHVuc3ViLnVuc3Vic2NyaWJlID8gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB1bnN1Yi51bnN1YnNjcmliZSgpO1xuICB9IDogdW5zdWI7XG59XG5cbmZ1bmN0aW9uIGdldF9zdG9yZV92YWx1ZShzdG9yZSkge1xuICB2YXIgdmFsdWU7XG4gIHN1YnNjcmliZShzdG9yZSwgZnVuY3Rpb24gKF8pIHtcbiAgICByZXR1cm4gdmFsdWUgPSBfO1xuICB9KSgpO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGNvbXBvbmVudF9zdWJzY3JpYmUoY29tcG9uZW50LCBzdG9yZSwgY2FsbGJhY2spIHtcbiAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9zbG90KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgaWYgKGRlZmluaXRpb24pIHtcbiAgICB2YXIgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuICAgIHJldHVybiBkZWZpbml0aW9uWzBdKHNsb3RfY3R4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pIHtcbiAgcmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm4gPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSkgOiAkJHNjb3BlLmN0eDtcbn1cblxuZnVuY3Rpb24gZ2V0X3Nsb3RfY2hhbmdlcyhkZWZpbml0aW9uLCAkJHNjb3BlLCBkaXJ0eSwgZm4pIHtcbiAgaWYgKGRlZmluaXRpb25bMl0gJiYgZm4pIHtcbiAgICB2YXIgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcblxuICAgIGlmICgkJHNjb3BlLmRpcnR5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBsZXRzO1xuICAgIH1cblxuICAgIGlmIChfdHlwZW9mKGxldHMpID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIG1lcmdlZCA9IFtdO1xuICAgICAgdmFyIGxlbiA9IE1hdGgubWF4KCQkc2NvcGUuZGlydHkubGVuZ3RoLCBsZXRzLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgbWVyZ2VkW2ldID0gJCRzY29wZS5kaXJ0eVtpXSB8IGxldHNbaV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICQkc2NvcGUuZGlydHkgfCBsZXRzO1xuICB9XG5cbiAgcmV0dXJuICQkc2NvcGUuZGlydHk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZV9zbG90KHNsb3QsIHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBkaXJ0eSwgZ2V0X3Nsb3RfY2hhbmdlc19mbiwgZ2V0X3Nsb3RfY29udGV4dF9mbikge1xuICB2YXIgc2xvdF9jaGFuZ2VzID0gZ2V0X3Nsb3RfY2hhbmdlcyhzbG90X2RlZmluaXRpb24sICQkc2NvcGUsIGRpcnR5LCBnZXRfc2xvdF9jaGFuZ2VzX2ZuKTtcblxuICBpZiAoc2xvdF9jaGFuZ2VzKSB7XG4gICAgdmFyIHNsb3RfY29udGV4dCA9IGdldF9zbG90X2NvbnRleHQoc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGdldF9zbG90X2NvbnRleHRfZm4pO1xuICAgIHNsb3QucChzbG90X2NvbnRleHQsIHNsb3RfY2hhbmdlcyk7XG4gIH1cbn1cblxudmFyIGlzX2NsaWVudCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xudmFyIG5vdyA9IGlzX2NsaWVudCA/IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcbn0gOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBEYXRlLm5vdygpO1xufTtcbnZhciByYWYgPSBpc19jbGllbnQgPyBmdW5jdGlvbiAoY2IpIHtcbiAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShjYik7XG59IDogbm9vcDtcbnZhciB0YXNrcyA9IG5ldyBTZXQoKTtcblxuZnVuY3Rpb24gcnVuX3Rhc2tzKG5vdykge1xuICB0YXNrcy5mb3JFYWNoKGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgaWYgKCF0YXNrLmMobm93KSkge1xuICAgICAgdGFza3NbXCJkZWxldGVcIl0odGFzayk7XG4gICAgICB0YXNrLmYoKTtcbiAgICB9XG4gIH0pO1xuICBpZiAodGFza3Muc2l6ZSAhPT0gMCkgcmFmKHJ1bl90YXNrcyk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGFzayB0aGF0IHJ1bnMgb24gZWFjaCByYWYgZnJhbWVcbiAqIHVudGlsIGl0IHJldHVybnMgYSBmYWxzeSB2YWx1ZSBvciBpcyBhYm9ydGVkXG4gKi9cblxuXG5mdW5jdGlvbiBsb29wKGNhbGxiYWNrKSB7XG4gIHZhciB0YXNrO1xuICBpZiAodGFza3Muc2l6ZSA9PT0gMCkgcmFmKHJ1bl90YXNrcyk7XG4gIHJldHVybiB7XG4gICAgcHJvbWlzZTogbmV3IFByb21pc2UoZnVuY3Rpb24gKGZ1bGZpbGwpIHtcbiAgICAgIHRhc2tzLmFkZCh0YXNrID0ge1xuICAgICAgICBjOiBjYWxsYmFjayxcbiAgICAgICAgZjogZnVsZmlsbFxuICAgICAgfSk7XG4gICAgfSksXG4gICAgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgdGFza3NbXCJkZWxldGVcIl0odGFzayk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBhcHBlbmQodGFyZ2V0LCBub2RlKSB7XG4gIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gIHRhcmdldC5pbnNlcnRCZWZvcmUobm9kZSwgYW5jaG9yIHx8IG51bGwpO1xufVxuXG5mdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnQobmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cblxuZnVuY3Rpb24gc3ZnX2VsZW1lbnQobmFtZSkge1xuICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuXG5mdW5jdGlvbiB0ZXh0KGRhdGEpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuXG5mdW5jdGlvbiBzcGFjZSgpIHtcbiAgcmV0dXJuIHRleHQoJyAnKTtcbn1cblxuZnVuY3Rpb24gZW1wdHkoKSB7XG4gIHJldHVybiB0ZXh0KCcnKTtcbn1cblxuZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgb3B0aW9ucyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSkgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGNoaWxkcmVuKGVsZW1lbnQpIHtcbiAgcmV0dXJuIEFycmF5LmZyb20oZWxlbWVudC5jaGlsZE5vZGVzKTtcbn1cblxuZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuICBkYXRhID0gJycgKyBkYXRhO1xuICBpZiAodGV4dC53aG9sZVRleHQgIT09IGRhdGEpIHRleHQuZGF0YSA9IGRhdGE7XG59XG5cbmZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcbiAgbm9kZS5zdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlLCBpbXBvcnRhbnQgPyAnaW1wb3J0YW50JyA6ICcnKTtcbn1cblxuZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuICBlbGVtZW50LmNsYXNzTGlzdFt0b2dnbGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbn1cblxuZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCkge1xuICB2YXIgZSA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpO1xuICBlLmluaXRDdXN0b21FdmVudCh0eXBlLCBmYWxzZSwgZmFsc2UsIGRldGFpbCk7XG4gIHJldHVybiBlO1xufVxuXG52YXIgSHRtbFRhZyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEh0bWxUYWcoKSB7XG4gICAgdmFyIGFuY2hvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIdG1sVGFnKTtcblxuICAgIHRoaXMuYSA9IGFuY2hvcjtcbiAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEh0bWxUYWcsIFt7XG4gICAga2V5OiBcIm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbShodG1sLCB0YXJnZXQpIHtcbiAgICAgIHZhciBhbmNob3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgICAgIGlmICghdGhpcy5lKSB7XG4gICAgICAgIHRoaXMuZSA9IGVsZW1lbnQodGFyZ2V0Lm5vZGVOYW1lKTtcbiAgICAgICAgdGhpcy50ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmgoaHRtbCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuaShhbmNob3IpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGgoaHRtbCkge1xuICAgICAgdGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICB0aGlzLm4gPSBBcnJheS5mcm9tKHRoaXMuZS5jaGlsZE5vZGVzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpKGFuY2hvcikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaW5zZXJ0KHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHAoaHRtbCkge1xuICAgICAgdGhpcy5kKCk7XG4gICAgICB0aGlzLmgoaHRtbCk7XG4gICAgICB0aGlzLmkodGhpcy5hKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkKCkge1xuICAgICAgdGhpcy5uLmZvckVhY2goZGV0YWNoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSHRtbFRhZztcbn0oKTtcblxudmFyIGFjdGl2ZV9kb2NzID0gbmV3IFNldCgpO1xudmFyIGFjdGl2ZSA9IDA7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kYXJrc2t5YXBwL3N0cmluZy1oYXNoL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG5cbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gIHZhciBoYXNoID0gNTM4MTtcbiAgdmFyIGkgPSBzdHIubGVuZ3RoO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoIF4gc3RyLmNoYXJDb2RlQXQoaSk7XG4gIH1cblxuICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX3J1bGUobm9kZSwgYSwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNlLCBmbikge1xuICB2YXIgdWlkID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiAwO1xuICB2YXIgc3RlcCA9IDE2LjY2NiAvIGR1cmF0aW9uO1xuICB2YXIga2V5ZnJhbWVzID0gJ3tcXG4nO1xuXG4gIGZvciAodmFyIHAgPSAwOyBwIDw9IDE7IHAgKz0gc3RlcCkge1xuICAgIHZhciB0ID0gYSArIChiIC0gYSkgKiBlYXNlKHApO1xuICAgIGtleWZyYW1lcyArPSBwICogMTAwICsgXCIle1wiLmNvbmNhdChmbih0LCAxIC0gdCksIFwifVxcblwiKTtcbiAgfVxuXG4gIHZhciBydWxlID0ga2V5ZnJhbWVzICsgXCIxMDAlIHtcIi5jb25jYXQoZm4oYiwgMSAtIGIpLCBcIn1cXG59XCIpO1xuICB2YXIgbmFtZSA9IFwiX19zdmVsdGVfXCIuY29uY2F0KGhhc2gocnVsZSksIFwiX1wiKS5jb25jYXQodWlkKTtcbiAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgYWN0aXZlX2RvY3MuYWRkKGRvYyk7XG4gIHZhciBzdHlsZXNoZWV0ID0gZG9jLl9fc3ZlbHRlX3N0eWxlc2hlZXQgfHwgKGRvYy5fX3N2ZWx0ZV9zdHlsZXNoZWV0ID0gZG9jLmhlYWQuYXBwZW5kQ2hpbGQoZWxlbWVudCgnc3R5bGUnKSkuc2hlZXQpO1xuICB2YXIgY3VycmVudF9ydWxlcyA9IGRvYy5fX3N2ZWx0ZV9ydWxlcyB8fCAoZG9jLl9fc3ZlbHRlX3J1bGVzID0ge30pO1xuXG4gIGlmICghY3VycmVudF9ydWxlc1tuYW1lXSkge1xuICAgIGN1cnJlbnRfcnVsZXNbbmFtZV0gPSB0cnVlO1xuICAgIHN0eWxlc2hlZXQuaW5zZXJ0UnVsZShcIkBrZXlmcmFtZXMgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQocnVsZSksIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBhbmltYXRpb24gPSBub2RlLnN0eWxlLmFuaW1hdGlvbiB8fCAnJztcbiAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBcIlwiLmNvbmNhdChhbmltYXRpb24gPyBcIlwiLmNvbmNhdChhbmltYXRpb24sIFwiLCBcIikgOiAnJykuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZHVyYXRpb24sIFwibXMgbGluZWFyIFwiKS5jb25jYXQoZGVsYXksIFwibXMgMSBib3RoXCIpO1xuICBhY3RpdmUgKz0gMTtcbiAgcmV0dXJuIG5hbWU7XG59XG5cbmZ1bmN0aW9uIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpIHtcbiAgdmFyIHByZXZpb3VzID0gKG5vZGUuc3R5bGUuYW5pbWF0aW9uIHx8ICcnKS5zcGxpdCgnLCAnKTtcbiAgdmFyIG5leHQgPSBwcmV2aW91cy5maWx0ZXIobmFtZSA/IGZ1bmN0aW9uIChhbmltKSB7XG4gICAgcmV0dXJuIGFuaW0uaW5kZXhPZihuYW1lKSA8IDA7XG4gIH0gLy8gcmVtb3ZlIHNwZWNpZmljIGFuaW1hdGlvblxuICA6IGZ1bmN0aW9uIChhbmltKSB7XG4gICAgcmV0dXJuIGFuaW0uaW5kZXhPZignX19zdmVsdGUnKSA9PT0gLTE7XG4gIH0gLy8gcmVtb3ZlIGFsbCBTdmVsdGUgYW5pbWF0aW9uc1xuICApO1xuICB2YXIgZGVsZXRlZCA9IHByZXZpb3VzLmxlbmd0aCAtIG5leHQubGVuZ3RoO1xuXG4gIGlmIChkZWxldGVkKSB7XG4gICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBuZXh0LmpvaW4oJywgJyk7XG4gICAgYWN0aXZlIC09IGRlbGV0ZWQ7XG4gICAgaWYgKCFhY3RpdmUpIGNsZWFyX3J1bGVzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYXJfcnVsZXMoKSB7XG4gIHJhZihmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGFjdGl2ZSkgcmV0dXJuO1xuICAgIGFjdGl2ZV9kb2NzLmZvckVhY2goZnVuY3Rpb24gKGRvYykge1xuICAgICAgdmFyIHN0eWxlc2hlZXQgPSBkb2MuX19zdmVsdGVfc3R5bGVzaGVldDtcbiAgICAgIHZhciBpID0gc3R5bGVzaGVldC5jc3NSdWxlcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgc3R5bGVzaGVldC5kZWxldGVSdWxlKGkpO1xuICAgICAgfVxuXG4gICAgICBkb2MuX19zdmVsdGVfcnVsZXMgPSB7fTtcbiAgICB9KTtcbiAgICBhY3RpdmVfZG9jcy5jbGVhcigpO1xuICB9KTtcbn1cblxudmFyIGN1cnJlbnRfY29tcG9uZW50O1xuXG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gIGN1cnJlbnRfY29tcG9uZW50ID0gY29tcG9uZW50O1xufVxuXG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gIGlmICghY3VycmVudF9jb21wb25lbnQpIHRocm93IG5ldyBFcnJvcignRnVuY3Rpb24gY2FsbGVkIG91dHNpZGUgY29tcG9uZW50IGluaXRpYWxpemF0aW9uJyk7XG4gIHJldHVybiBjdXJyZW50X2NvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gb25Nb3VudChmbikge1xuICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cblxuZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG4gIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLm9uX2Rlc3Ryb3kucHVzaChmbik7XG59XG5cbnZhciBkaXJ0eV9jb21wb25lbnRzID0gW107XG52YXIgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcbnZhciByZW5kZXJfY2FsbGJhY2tzID0gW107XG52YXIgZmx1c2hfY2FsbGJhY2tzID0gW107XG52YXIgcmVzb2x2ZWRfcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xudmFyIHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gc2NoZWR1bGVfdXBkYXRlKCkge1xuICBpZiAoIXVwZGF0ZV9zY2hlZHVsZWQpIHtcbiAgICB1cGRhdGVfc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICByZXNvbHZlZF9wcm9taXNlLnRoZW4oZmx1c2gpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZF9yZW5kZXJfY2FsbGJhY2soZm4pIHtcbiAgcmVuZGVyX2NhbGxiYWNrcy5wdXNoKGZuKTtcbn1cblxudmFyIGZsdXNoaW5nID0gZmFsc2U7XG52YXIgc2Vlbl9jYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5cbmZ1bmN0aW9uIGZsdXNoKCkge1xuICBpZiAoZmx1c2hpbmcpIHJldHVybjtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuXG4gIGRvIHtcbiAgICAvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG4gICAgLy8gYW5kIHVwZGF0ZSBjb21wb25lbnRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgY29tcG9uZW50ID0gZGlydHlfY29tcG9uZW50c1tpXTtcbiAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgdXBkYXRlKGNvbXBvbmVudC4kJCk7XG4gICAgfVxuXG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KG51bGwpO1xuICAgIGRpcnR5X2NvbXBvbmVudHMubGVuZ3RoID0gMDtcblxuICAgIHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgIGJpbmRpbmdfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgfSAvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcbiAgICAvLyBhZnRlclVwZGF0ZSBmdW5jdGlvbnMuIFRoaXMgbWF5IGNhdXNlXG4gICAgLy8gc3Vic2VxdWVudCB1cGRhdGVzLi4uXG5cblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgX2kgKz0gMSkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gcmVuZGVyX2NhbGxiYWNrc1tfaV07XG5cbiAgICAgIGlmICghc2Vlbl9jYWxsYmFja3MuaGFzKGNhbGxiYWNrKSkge1xuICAgICAgICAvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG4gICAgICAgIHNlZW5fY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVuZGVyX2NhbGxiYWNrcy5sZW5ndGggPSAwO1xuICB9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG5cbiAgd2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICBmbHVzaF9jYWxsYmFja3MucG9wKCkoKTtcbiAgfVxuXG4gIHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgZmx1c2hpbmcgPSBmYWxzZTtcbiAgc2Vlbl9jYWxsYmFja3MuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG4gIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICQkLnVwZGF0ZSgpO1xuICAgIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7XG4gICAgdmFyIGRpcnR5ID0gJCQuZGlydHk7XG4gICAgJCQuZGlydHkgPSBbLTFdO1xuICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG4gICAgJCQuYWZ0ZXJfdXBkYXRlLmZvckVhY2goYWRkX3JlbmRlcl9jYWxsYmFjayk7XG4gIH1cbn1cblxudmFyIHByb21pc2U7XG5cbmZ1bmN0aW9uIHdhaXQoKSB7XG4gIGlmICghcHJvbWlzZSkge1xuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZSA9IG51bGw7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG4gIG5vZGUuZGlzcGF0Y2hFdmVudChjdXN0b21fZXZlbnQoXCJcIi5jb25jYXQoZGlyZWN0aW9uID8gJ2ludHJvJyA6ICdvdXRybycpLmNvbmNhdChraW5kKSkpO1xufVxuXG52YXIgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG52YXIgb3V0cm9zO1xuXG5mdW5jdGlvbiBncm91cF9vdXRyb3MoKSB7XG4gIG91dHJvcyA9IHtcbiAgICByOiAwLFxuICAgIGM6IFtdLFxuICAgIHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcblxuICB9O1xufVxuXG5mdW5jdGlvbiBjaGVja19vdXRyb3MoKSB7XG4gIGlmICghb3V0cm9zLnIpIHtcbiAgICBydW5fYWxsKG91dHJvcy5jKTtcbiAgfVxuXG4gIG91dHJvcyA9IG91dHJvcy5wO1xufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX2luKGJsb2NrLCBsb2NhbCkge1xuICBpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuICAgIG91dHJvaW5nW1wiZGVsZXRlXCJdKGJsb2NrKTtcbiAgICBibG9jay5pKGxvY2FsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcbiAgaWYgKGJsb2NrICYmIGJsb2NrLm8pIHtcbiAgICBpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSkgcmV0dXJuO1xuICAgIG91dHJvaW5nLmFkZChibG9jayk7XG4gICAgb3V0cm9zLmMucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICBvdXRyb2luZ1tcImRlbGV0ZVwiXShibG9jayk7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoZGV0YWNoKSBibG9jay5kKDEpO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGJsb2NrLm8obG9jYWwpO1xuICB9XG59XG5cbnZhciBudWxsX3RyYW5zaXRpb24gPSB7XG4gIGR1cmF0aW9uOiAwXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVfaW5fdHJhbnNpdGlvbihub2RlLCBmbiwgcGFyYW1zKSB7XG4gIHZhciBjb25maWcgPSBmbihub2RlLCBwYXJhbXMpO1xuICB2YXIgcnVubmluZyA9IGZhbHNlO1xuICB2YXIgYW5pbWF0aW9uX25hbWU7XG4gIHZhciB0YXNrO1xuICB2YXIgdWlkID0gMDtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGlmIChhbmltYXRpb25fbmFtZSkgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ28oKSB7XG4gICAgdmFyIF9yZWYgPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uLFxuICAgICAgICBfcmVmJGRlbGF5ID0gX3JlZi5kZWxheSxcbiAgICAgICAgZGVsYXkgPSBfcmVmJGRlbGF5ID09PSB2b2lkIDAgPyAwIDogX3JlZiRkZWxheSxcbiAgICAgICAgX3JlZiRkdXJhdGlvbiA9IF9yZWYuZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uID0gX3JlZiRkdXJhdGlvbiA9PT0gdm9pZCAwID8gMzAwIDogX3JlZiRkdXJhdGlvbixcbiAgICAgICAgX3JlZiRlYXNpbmcgPSBfcmVmLmVhc2luZyxcbiAgICAgICAgZWFzaW5nID0gX3JlZiRlYXNpbmcgPT09IHZvaWQgMCA/IGlkZW50aXR5IDogX3JlZiRlYXNpbmcsXG4gICAgICAgIF9yZWYkdGljayA9IF9yZWYudGljayxcbiAgICAgICAgdGljayA9IF9yZWYkdGljayA9PT0gdm9pZCAwID8gbm9vcCA6IF9yZWYkdGljayxcbiAgICAgICAgY3NzID0gX3JlZi5jc3M7XG5cbiAgICBpZiAoY3NzKSBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcbiAgICB0aWNrKDAsIDEpO1xuICAgIHZhciBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICB2YXIgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgaWYgKHRhc2spIHRhc2suYWJvcnQoKTtcbiAgICBydW5uaW5nID0gdHJ1ZTtcbiAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaChub2RlLCB0cnVlLCAnc3RhcnQnKTtcbiAgICB9KTtcbiAgICB0YXNrID0gbG9vcChmdW5jdGlvbiAobm93KSB7XG4gICAgICBpZiAocnVubmluZykge1xuICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgdGljaygxLCAwKTtcbiAgICAgICAgICBkaXNwYXRjaChub2RlLCB0cnVlLCAnZW5kJyk7XG4gICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgIHJldHVybiBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICB2YXIgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJ1bm5pbmc7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICAgIGlmIChzdGFydGVkKSByZXR1cm47XG4gICAgICBkZWxldGVfcnVsZShub2RlKTtcblxuICAgICAgaWYgKGlzX2Z1bmN0aW9uKGNvbmZpZykpIHtcbiAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgIHdhaXQoKS50aGVuKGdvKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdvKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpbnZhbGlkYXRlOiBmdW5jdGlvbiBpbnZhbGlkYXRlKCkge1xuICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZW5kOiBmdW5jdGlvbiBlbmQoKSB7XG4gICAgICBpZiAocnVubmluZykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIHJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcbiAgdmFyIGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcyk7XG4gIHZhciB0ID0gaW50cm8gPyAwIDogMTtcbiAgdmFyIHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gIHZhciBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICB2YXIgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcbiAgICBpZiAoYW5pbWF0aW9uX25hbWUpIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXQocHJvZ3JhbSwgZHVyYXRpb24pIHtcbiAgICB2YXIgZCA9IHByb2dyYW0uYiAtIHQ7XG4gICAgZHVyYXRpb24gKj0gTWF0aC5hYnMoZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IHQsXG4gICAgICBiOiBwcm9ncmFtLmIsXG4gICAgICBkOiBkLFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgc3RhcnQ6IHByb2dyYW0uc3RhcnQsXG4gICAgICBlbmQ6IHByb2dyYW0uc3RhcnQgKyBkdXJhdGlvbixcbiAgICAgIGdyb3VwOiBwcm9ncmFtLmdyb3VwXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdvKGIpIHtcbiAgICB2YXIgX3JlZjIgPSBjb25maWcgfHwgbnVsbF90cmFuc2l0aW9uLFxuICAgICAgICBfcmVmMiRkZWxheSA9IF9yZWYyLmRlbGF5LFxuICAgICAgICBkZWxheSA9IF9yZWYyJGRlbGF5ID09PSB2b2lkIDAgPyAwIDogX3JlZjIkZGVsYXksXG4gICAgICAgIF9yZWYyJGR1cmF0aW9uID0gX3JlZjIuZHVyYXRpb24sXG4gICAgICAgIGR1cmF0aW9uID0gX3JlZjIkZHVyYXRpb24gPT09IHZvaWQgMCA/IDMwMCA6IF9yZWYyJGR1cmF0aW9uLFxuICAgICAgICBfcmVmMiRlYXNpbmcgPSBfcmVmMi5lYXNpbmcsXG4gICAgICAgIGVhc2luZyA9IF9yZWYyJGVhc2luZyA9PT0gdm9pZCAwID8gaWRlbnRpdHkgOiBfcmVmMiRlYXNpbmcsXG4gICAgICAgIF9yZWYyJHRpY2sgPSBfcmVmMi50aWNrLFxuICAgICAgICB0aWNrID0gX3JlZjIkdGljayA9PT0gdm9pZCAwID8gbm9vcCA6IF9yZWYyJHRpY2ssXG4gICAgICAgIGNzcyA9IF9yZWYyLmNzcztcblxuICAgIHZhciBwcm9ncmFtID0ge1xuICAgICAgc3RhcnQ6IG5vdygpICsgZGVsYXksXG4gICAgICBiOiBiXG4gICAgfTtcblxuICAgIGlmICghYikge1xuICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgIHByb2dyYW0uZ3JvdXAgPSBvdXRyb3M7XG4gICAgICBvdXRyb3MuciArPSAxO1xuICAgIH1cblxuICAgIGlmIChydW5uaW5nX3Byb2dyYW0gfHwgcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICBwZW5kaW5nX3Byb2dyYW0gPSBwcm9ncmFtO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG4gICAgICAvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgYiwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChiKSB0aWNrKDAsIDEpO1xuICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwcm9ncmFtLCBkdXJhdGlvbik7XG4gICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoKG5vZGUsIGIsICdzdGFydCcpO1xuICAgICAgfSk7XG4gICAgICBsb29wKGZ1bmN0aW9uIChub3cpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBpbml0KHBlbmRpbmdfcHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuXG4gICAgICAgICAgaWYgKGNzcykge1xuICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIHJ1bm5pbmdfcHJvZ3JhbS5iLCBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24sIDAsIGVhc2luZywgY29uZmlnLmNzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSkge1xuICAgICAgICAgIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuICAgICAgICAgICAgdGljayh0ID0gcnVubmluZ19wcm9ncmFtLmIsIDEgLSB0KTtcbiAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG5cbiAgICAgICAgICAgIGlmICghcGVuZGluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbS5iKSB7XG4gICAgICAgICAgICAgICAgLy8gaW50cm8g4oCUIHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gb3V0cm8g4oCUIG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG4gICAgICAgICAgICAgICAgaWYgKCEgLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucikgcnVuX2FsbChydW5uaW5nX3Byb2dyYW0uZ3JvdXAuYyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vdyA+PSBydW5uaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gbm93IC0gcnVubmluZ19wcm9ncmFtLnN0YXJ0O1xuICAgICAgICAgICAgdCA9IHJ1bm5pbmdfcHJvZ3JhbS5hICsgcnVubmluZ19wcm9ncmFtLmQgKiBlYXNpbmcocCAvIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbik7XG4gICAgICAgICAgICB0aWNrKHQsIDEgLSB0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEocnVubmluZ19wcm9ncmFtIHx8IHBlbmRpbmdfcHJvZ3JhbSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJ1bjogZnVuY3Rpb24gcnVuKGIpIHtcbiAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgIHdhaXQoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uZmlnID0gY29uZmlnKCk7XG4gICAgICAgICAgZ28oYik7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ28oYik7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCgpIHtcbiAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgcnVubmluZ19wcm9ncmFtID0gcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgdHJhbnNpdGlvbl9vdXQoYmxvY2ssIDEsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICBsb29rdXBbXCJkZWxldGVcIl0oYmxvY2sua2V5KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZV9rZXllZF9lYWNoKG9sZF9ibG9ja3MsIGRpcnR5LCBnZXRfa2V5LCBkeW5hbWljLCBjdHgsIGxpc3QsIGxvb2t1cCwgbm9kZSwgZGVzdHJveSwgY3JlYXRlX2VhY2hfYmxvY2ssIG5leHQsIGdldF9jb250ZXh0KSB7XG4gIHZhciBvID0gb2xkX2Jsb2Nrcy5sZW5ndGg7XG4gIHZhciBuID0gbGlzdC5sZW5ndGg7XG4gIHZhciBpID0gbztcbiAgdmFyIG9sZF9pbmRleGVzID0ge307XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIG9sZF9pbmRleGVzW29sZF9ibG9ja3NbaV0ua2V5XSA9IGk7XG4gIH1cblxuICB2YXIgbmV3X2Jsb2NrcyA9IFtdO1xuICB2YXIgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgdmFyIGRlbHRhcyA9IG5ldyBNYXAoKTtcbiAgaSA9IG47XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBjaGlsZF9jdHggPSBnZXRfY29udGV4dChjdHgsIGxpc3QsIGkpO1xuICAgIHZhciBrZXkgPSBnZXRfa2V5KGNoaWxkX2N0eCk7XG4gICAgdmFyIGJsb2NrID0gbG9va3VwLmdldChrZXkpO1xuXG4gICAgaWYgKCFibG9jaykge1xuICAgICAgYmxvY2sgPSBjcmVhdGVfZWFjaF9ibG9jayhrZXksIGNoaWxkX2N0eCk7XG4gICAgICBibG9jay5jKCk7XG4gICAgfSBlbHNlIGlmIChkeW5hbWljKSB7XG4gICAgICBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xuICAgIH1cblxuICAgIG5ld19sb29rdXAuc2V0KGtleSwgbmV3X2Jsb2Nrc1tpXSA9IGJsb2NrKTtcbiAgICBpZiAoa2V5IGluIG9sZF9pbmRleGVzKSBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcbiAgfVxuXG4gIHZhciB3aWxsX21vdmUgPSBuZXcgU2V0KCk7XG4gIHZhciBkaWRfbW92ZSA9IG5ldyBTZXQoKTtcblxuICBmdW5jdGlvbiBpbnNlcnQoYmxvY2spIHtcbiAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICBibG9jay5tKG5vZGUsIG5leHQpO1xuICAgIGxvb2t1cC5zZXQoYmxvY2sua2V5LCBibG9jayk7XG4gICAgbmV4dCA9IGJsb2NrLmZpcnN0O1xuICAgIG4tLTtcbiAgfVxuXG4gIHdoaWxlIChvICYmIG4pIHtcbiAgICB2YXIgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG4gICAgdmFyIG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuICAgIHZhciBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcbiAgICB2YXIgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG5cbiAgICBpZiAobmV3X2Jsb2NrID09PSBvbGRfYmxvY2spIHtcbiAgICAgIC8vIGRvIG5vdGhpbmdcbiAgICAgIG5leHQgPSBuZXdfYmxvY2suZmlyc3Q7XG4gICAgICBvLS07XG4gICAgICBuLS07XG4gICAgfSBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcbiAgICAgIC8vIHJlbW92ZSBvbGQgYmxvY2tcbiAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgICAgby0tO1xuICAgIH0gZWxzZSBpZiAoIWxvb2t1cC5oYXMobmV3X2tleSkgfHwgd2lsbF9tb3ZlLmhhcyhuZXdfa2V5KSkge1xuICAgICAgaW5zZXJ0KG5ld19ibG9jayk7XG4gICAgfSBlbHNlIGlmIChkaWRfbW92ZS5oYXMob2xkX2tleSkpIHtcbiAgICAgIG8tLTtcbiAgICB9IGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG4gICAgICBkaWRfbW92ZS5hZGQobmV3X2tleSk7XG4gICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lsbF9tb3ZlLmFkZChvbGRfa2V5KTtcbiAgICAgIG8tLTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAoby0tKSB7XG4gICAgdmFyIF9vbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuICAgIGlmICghbmV3X2xvb2t1cC5oYXMoX29sZF9ibG9jay5rZXkpKSBkZXN0cm95KF9vbGRfYmxvY2ssIGxvb2t1cCk7XG4gIH1cblxuICB3aGlsZSAobikge1xuICAgIGluc2VydChuZXdfYmxvY2tzW24gLSAxXSk7XG4gIH1cblxuICByZXR1cm4gbmV3X2Jsb2Nrcztcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2NvbXBvbmVudChibG9jaykge1xuICBibG9jayAmJiBibG9jay5jKCk7XG59XG5cbmZ1bmN0aW9uIG1vdW50X2NvbXBvbmVudChjb21wb25lbnQsIHRhcmdldCwgYW5jaG9yLCBjdXN0b21FbGVtZW50KSB7XG4gIHZhciBfY29tcG9uZW50JCQkID0gY29tcG9uZW50LiQkLFxuICAgICAgZnJhZ21lbnQgPSBfY29tcG9uZW50JCQkLmZyYWdtZW50LFxuICAgICAgb25fbW91bnQgPSBfY29tcG9uZW50JCQkLm9uX21vdW50LFxuICAgICAgb25fZGVzdHJveSA9IF9jb21wb25lbnQkJCQub25fZGVzdHJveSxcbiAgICAgIGFmdGVyX3VwZGF0ZSA9IF9jb21wb25lbnQkJCQuYWZ0ZXJfdXBkYXRlO1xuICBmcmFnbWVudCAmJiBmcmFnbWVudC5tKHRhcmdldCwgYW5jaG9yKTtcblxuICBpZiAoIWN1c3RvbUVsZW1lbnQpIHtcbiAgICAvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG4gICAgYWRkX3JlbmRlcl9jYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgbmV3X29uX2Rlc3Ryb3kgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuXG4gICAgICBpZiAob25fZGVzdHJveSkge1xuICAgICAgICBvbl9kZXN0cm95LnB1c2guYXBwbHkob25fZGVzdHJveSwgX3RvQ29uc3VtYWJsZUFycmF5KG5ld19vbl9kZXN0cm95KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcbiAgICAgICAgLy8gbW9zdCBsaWtlbHkgYXMgYSByZXN1bHQgb2YgYSBiaW5kaW5nIGluaXRpYWxpc2luZ1xuICAgICAgICBydW5fYWxsKG5ld19vbl9kZXN0cm95KTtcbiAgICAgIH1cblxuICAgICAgY29tcG9uZW50LiQkLm9uX21vdW50ID0gW107XG4gICAgfSk7XG4gIH1cblxuICBhZnRlcl91cGRhdGUuZm9yRWFjaChhZGRfcmVuZGVyX2NhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcbiAgdmFyICQkID0gY29tcG9uZW50LiQkO1xuXG4gIGlmICgkJC5mcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIHJ1bl9hbGwoJCQub25fZGVzdHJveSk7XG4gICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuZChkZXRhY2hpbmcpOyAvLyBUT0RPIG51bGwgb3V0IG90aGVyIHJlZnMsIGluY2x1ZGluZyBjb21wb25lbnQuJCQgKGJ1dCBuZWVkIHRvXG4gICAgLy8gcHJlc2VydmUgZmluYWwgc3RhdGU/KVxuXG4gICAgJCQub25fZGVzdHJveSA9ICQkLmZyYWdtZW50ID0gbnVsbDtcbiAgICAkJC5jdHggPSBbXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSkge1xuICBpZiAoY29tcG9uZW50LiQkLmRpcnR5WzBdID09PSAtMSkge1xuICAgIGRpcnR5X2NvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgIGNvbXBvbmVudC4kJC5kaXJ0eS5maWxsKDApO1xuICB9XG5cbiAgY29tcG9uZW50LiQkLmRpcnR5W2kgLyAzMSB8IDBdIHw9IDEgPDwgaSAlIDMxO1xufVxuXG5mdW5jdGlvbiBpbml0KGNvbXBvbmVudCwgb3B0aW9ucywgaW5zdGFuY2UsIGNyZWF0ZV9mcmFnbWVudCwgbm90X2VxdWFsLCBwcm9wcykge1xuICB2YXIgZGlydHkgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IFstMV07XG4gIHZhciBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICB2YXIgJCQgPSBjb21wb25lbnQuJCQgPSB7XG4gICAgZnJhZ21lbnQ6IG51bGwsXG4gICAgY3R4OiBudWxsLFxuICAgIC8vIHN0YXRlXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIHVwZGF0ZTogbm9vcCxcbiAgICBub3RfZXF1YWw6IG5vdF9lcXVhbCxcbiAgICBib3VuZDogYmxhbmtfb2JqZWN0KCksXG4gICAgLy8gbGlmZWN5Y2xlXG4gICAgb25fbW91bnQ6IFtdLFxuICAgIG9uX2Rlc3Ryb3k6IFtdLFxuICAgIG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgIGFmdGVyX3VwZGF0ZTogW10sXG4gICAgY29udGV4dDogbmV3IE1hcChwYXJlbnRfY29tcG9uZW50ID8gcGFyZW50X2NvbXBvbmVudC4kJC5jb250ZXh0IDogb3B0aW9ucy5jb250ZXh0IHx8IFtdKSxcbiAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICBjYWxsYmFja3M6IGJsYW5rX29iamVjdCgpLFxuICAgIGRpcnR5OiBkaXJ0eSxcbiAgICBza2lwX2JvdW5kOiBmYWxzZVxuICB9O1xuICB2YXIgcmVhZHkgPSBmYWxzZTtcbiAgJCQuY3R4ID0gaW5zdGFuY2UgPyBpbnN0YW5jZShjb21wb25lbnQsIG9wdGlvbnMucHJvcHMgfHwge30sIGZ1bmN0aW9uIChpLCByZXQpIHtcbiAgICB2YXIgdmFsdWUgPSAoYXJndW1lbnRzLmxlbmd0aCA8PSAyID8gMCA6IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA/IGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSA6IHJldDtcblxuICAgIGlmICgkJC5jdHggJiYgbm90X2VxdWFsKCQkLmN0eFtpXSwgJCQuY3R4W2ldID0gdmFsdWUpKSB7XG4gICAgICBpZiAoISQkLnNraXBfYm91bmQgJiYgJCQuYm91bmRbaV0pICQkLmJvdW5kW2ldKHZhbHVlKTtcbiAgICAgIGlmIChyZWFkeSkgbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH0pIDogW107XG4gICQkLnVwZGF0ZSgpO1xuICByZWFkeSA9IHRydWU7XG4gIHJ1bl9hbGwoJCQuYmVmb3JlX3VwZGF0ZSk7IC8vIGBmYWxzZWAgYXMgYSBzcGVjaWFsIGNhc2Ugb2Ygbm8gRE9NIGNvbXBvbmVudFxuXG4gICQkLmZyYWdtZW50ID0gY3JlYXRlX2ZyYWdtZW50ID8gY3JlYXRlX2ZyYWdtZW50KCQkLmN0eCkgOiBmYWxzZTtcblxuICBpZiAob3B0aW9ucy50YXJnZXQpIHtcbiAgICBpZiAob3B0aW9ucy5oeWRyYXRlKSB7XG4gICAgICB2YXIgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG5cbiAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50Lmwobm9kZXMpO1xuICAgICAgbm9kZXMuZm9yRWFjaChkZXRhY2gpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmludHJvKSB0cmFuc2l0aW9uX2luKGNvbXBvbmVudC4kJC5mcmFnbWVudCk7XG4gICAgbW91bnRfY29tcG9uZW50KGNvbXBvbmVudCwgb3B0aW9ucy50YXJnZXQsIG9wdGlvbnMuYW5jaG9yLCBvcHRpb25zLmN1c3RvbUVsZW1lbnQpO1xuICAgIGZsdXNoKCk7XG4gIH1cblxuICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICovXG5cblxudmFyIFN2ZWx0ZUNvbXBvbmVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN2ZWx0ZUNvbXBvbmVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3ZlbHRlQ29tcG9uZW50KTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdmVsdGVDb21wb25lbnQsIFt7XG4gICAga2V5OiBcIiRkZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRkZXN0cm95KCkge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQodGhpcywgMSk7XG4gICAgICB0aGlzLiRkZXN0cm95ID0gbm9vcDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiJG9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKTtcbiAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNhbGxiYWNrcy5pbmRleE9mKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkgY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCIkc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICRzZXQoJCRwcm9wcykge1xuICAgICAgaWYgKHRoaXMuJCRzZXQgJiYgIWlzX2VtcHR5KCQkcHJvcHMpKSB7XG4gICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgIHRoaXMuJCRzZXQoJCRwcm9wcyk7XG4gICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdmVsdGVDb21wb25lbnQ7XG59KCk7XG5cbnZhciBzdWJzY3JpYmVyX3F1ZXVlID0gW107XG4vKipcbiAqIENyZWF0ZXMgYSBgUmVhZGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICogQHBhcmFtIHZhbHVlIGluaXRpYWwgdmFsdWVcbiAqIEBwYXJhbSB7U3RhcnRTdG9wTm90aWZpZXJ9c3RhcnQgc3RhcnQgYW5kIHN0b3Agbm90aWZpY2F0aW9ucyBmb3Igc3Vic2NyaXB0aW9uc1xuICovXG5cbmZ1bmN0aW9uIHJlYWRhYmxlKHZhbHVlLCBzdGFydCkge1xuICByZXR1cm4ge1xuICAgIHN1YnNjcmliZTogd3JpdGFibGUodmFsdWUsIHN0YXJ0KS5zdWJzY3JpYmVcbiAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgYFdyaXRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyBib3RoIHVwZGF0aW5nIGFuZCByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqIEBwYXJhbSB7Kj19dmFsdWUgaW5pdGlhbCB2YWx1ZVxuICogQHBhcmFtIHtTdGFydFN0b3BOb3RpZmllcj19c3RhcnQgc3RhcnQgYW5kIHN0b3Agbm90aWZpY2F0aW9ucyBmb3Igc3Vic2NyaXB0aW9uc1xuICovXG5cblxuZnVuY3Rpb24gd3JpdGFibGUodmFsdWUpIHtcbiAgdmFyIHN0YXJ0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBub29wO1xuICB2YXIgc3RvcDtcbiAgdmFyIHN1YnNjcmliZXJzID0gW107XG5cbiAgZnVuY3Rpb24gc2V0KG5ld192YWx1ZSkge1xuICAgIGlmIChzYWZlX25vdF9lcXVhbCh2YWx1ZSwgbmV3X3ZhbHVlKSkge1xuICAgICAgdmFsdWUgPSBuZXdfdmFsdWU7XG5cbiAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgIC8vIHN0b3JlIGlzIHJlYWR5XG4gICAgICAgIHZhciBydW5fcXVldWUgPSAhc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdWJzY3JpYmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIHZhciBzID0gc3Vic2NyaWJlcnNbaV07XG4gICAgICAgICAgc1sxXSgpO1xuICAgICAgICAgIHN1YnNjcmliZXJfcXVldWUucHVzaChzLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocnVuX3F1ZXVlKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGg7IF9pMiArPSAyKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyX3F1ZXVlW19pMl1bMF0oc3Vic2NyaWJlcl9xdWV1ZVtfaTIgKyAxXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc3Vic2NyaWJlcl9xdWV1ZS5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlKGZuKSB7XG4gICAgc2V0KGZuKHZhbHVlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBzdWJzY3JpYmUocnVuKSB7XG4gICAgdmFyIGludmFsaWRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG5vb3A7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBbcnVuLCBpbnZhbGlkYXRlXTtcbiAgICBzdWJzY3JpYmVycy5wdXNoKHN1YnNjcmliZXIpO1xuXG4gICAgaWYgKHN1YnNjcmliZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgc3RvcCA9IHN0YXJ0KHNldCkgfHwgbm9vcDtcbiAgICB9XG5cbiAgICBydW4odmFsdWUpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKHN1YnNjcmliZXIpO1xuXG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHN1YnNjcmliZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdWJzY3JpYmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc3RvcCgpO1xuICAgICAgICBzdG9wID0gbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzZXQ6IHNldCxcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZVxuICB9O1xufVxuXG5mdW5jdGlvbiBkZXJpdmVkKHN0b3JlcywgZm4sIGluaXRpYWxfdmFsdWUpIHtcbiAgdmFyIHNpbmdsZSA9ICFBcnJheS5pc0FycmF5KHN0b3Jlcyk7XG4gIHZhciBzdG9yZXNfYXJyYXkgPSBzaW5nbGUgPyBbc3RvcmVzXSA6IHN0b3JlcztcbiAgdmFyIGF1dG8gPSBmbi5sZW5ndGggPCAyO1xuICByZXR1cm4gcmVhZGFibGUoaW5pdGlhbF92YWx1ZSwgZnVuY3Rpb24gKHNldCkge1xuICAgIHZhciBpbml0ZWQgPSBmYWxzZTtcbiAgICB2YXIgdmFsdWVzID0gW107XG4gICAgdmFyIHBlbmRpbmcgPSAwO1xuICAgIHZhciBjbGVhbnVwID0gbm9vcDtcblxuICAgIHZhciBzeW5jID0gZnVuY3Rpb24gc3luYygpIHtcbiAgICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2xlYW51cCgpO1xuICAgICAgdmFyIHJlc3VsdCA9IGZuKHNpbmdsZSA/IHZhbHVlc1swXSA6IHZhbHVlcywgc2V0KTtcblxuICAgICAgaWYgKGF1dG8pIHtcbiAgICAgICAgc2V0KHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGVhbnVwID0gaXNfZnVuY3Rpb24ocmVzdWx0KSA/IHJlc3VsdCA6IG5vb3A7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciB1bnN1YnNjcmliZXJzID0gc3RvcmVzX2FycmF5Lm1hcChmdW5jdGlvbiAoc3RvcmUsIGkpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmUoc3RvcmUsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZTtcbiAgICAgICAgcGVuZGluZyAmPSB+KDEgPDwgaSk7XG5cbiAgICAgICAgaWYgKGluaXRlZCkge1xuICAgICAgICAgIHN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBwZW5kaW5nIHw9IDEgPDwgaTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGluaXRlZCA9IHRydWU7XG4gICAgc3luYygpO1xuICAgIHJldHVybiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgcnVuX2FsbCh1bnN1YnNjcmliZXJzKTtcbiAgICAgIGNsZWFudXAoKTtcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZmFkZShub2RlKSB7XG4gIHZhciBfcmVmMyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICBfcmVmMyRkZWxheSA9IF9yZWYzLmRlbGF5LFxuICAgICAgZGVsYXkgPSBfcmVmMyRkZWxheSA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJGRlbGF5LFxuICAgICAgX3JlZjMkZHVyYXRpb24gPSBfcmVmMy5kdXJhdGlvbixcbiAgICAgIGR1cmF0aW9uID0gX3JlZjMkZHVyYXRpb24gPT09IHZvaWQgMCA/IDQwMCA6IF9yZWYzJGR1cmF0aW9uLFxuICAgICAgX3JlZjMkZWFzaW5nID0gX3JlZjMuZWFzaW5nLFxuICAgICAgZWFzaW5nID0gX3JlZjMkZWFzaW5nID09PSB2b2lkIDAgPyBpZGVudGl0eSA6IF9yZWYzJGVhc2luZztcblxuICB2YXIgbyA9ICtnZXRDb21wdXRlZFN0eWxlKG5vZGUpLm9wYWNpdHk7XG4gIHJldHVybiB7XG4gICAgZGVsYXk6IGRlbGF5LFxuICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICBlYXNpbmc6IGVhc2luZyxcbiAgICBjc3M6IGZ1bmN0aW9uIGNzcyh0KSB7XG4gICAgICByZXR1cm4gXCJvcGFjaXR5OiBcIi5jb25jYXQodCAqIG8pO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjEuMzAuMFwiO1xudmFyIGJsb2NrbmF0aXZlO1xuXG5mdW5jdGlvbiBpbml0aWFsaXplQmxvY2tuYXRpdmUoZGFwcElkLCBuZXR3b3JrSWQsIGFwaVVybCkge1xuICBibG9ja25hdGl2ZSA9IG5ldyBCbG9ja25hdGl2ZUFwaSh7XG4gICAgZGFwcElkOiBkYXBwSWQsXG4gICAgbmV0d29ya0lkOiBuZXR3b3JrSWQsXG4gICAgbmFtZTogJ09uYm9hcmQnLFxuICAgIGFwcFZlcnNpb246IHZlcnNpb24sXG4gICAgYXBpVXJsOiBhcGlVcmxcbiAgfSk7XG4gIHJldHVybiBibG9ja25hdGl2ZTtcbn1cblxuZnVuY3Rpb24gZ2V0QmxvY2tuYXRpdmUoKSB7XG4gIGlmICghYmxvY2tuYXRpdmUpIHtcbiAgICB2YXIgX2dldF9zdG9yZV92YWx1ZSA9IGdldF9zdG9yZV92YWx1ZShhcHApLFxuICAgICAgICBkYXBwSWQgPSBfZ2V0X3N0b3JlX3ZhbHVlLmRhcHBJZCxcbiAgICAgICAgbmV0d29ya0lkID0gX2dldF9zdG9yZV92YWx1ZS5uZXR3b3JrSWQsXG4gICAgICAgIGFwaVVybCA9IF9nZXRfc3RvcmVfdmFsdWUuYXBpVXJsOyAvLyBpbml0IG9ubHkgaWYgZGFwcElkXG5cblxuICAgIGRhcHBJZCAmJiBpbml0aWFsaXplQmxvY2tuYXRpdmUoZGFwcElkLCBuZXR3b3JrSWQsIGFwaVVybCk7XG4gIH1cblxuICByZXR1cm4gYmxvY2tuYXRpdmU7XG59XG5cbmZ1bmN0aW9uIGNsb3NlU29ja2V0Q29ubmVjdGlvbigpIHtcbiAgdmFyIF9ibG9ja25hdGl2ZTtcblxuICAoX2Jsb2NrbmF0aXZlID0gYmxvY2tuYXRpdmUpID09PSBudWxsIHx8IF9ibG9ja25hdGl2ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Jsb2NrbmF0aXZlLmRlc3Ryb3koKTtcbn1cblxuZnVuY3Rpb24gZ2V0TmV0d29yayhwcm92aWRlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICBtZXRob2Q6ICduZXRfdmVyc2lvbicsXG4gICAgICBwYXJhbXM6IFtdLFxuICAgICAgaWQ6IDQyXG4gICAgfTsgLy8gdXNlIE1ldGFNYXNrIHBhcmFtZXRlciBpZiB0aGVyZVxuXG4gICAgaWYgKHByb3ZpZGVyLmNoYWluSWQpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKE51bWJlcihwcm92aWRlci5jaGFpbklkKSk7XG4gICAgfVxuXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soZSwgcmVzKSB7XG4gICAgICBlICYmIHJlamVjdChlKTtcbiAgICAgIHZhciByZXN1bHQgPSByZXMgJiYgcmVzLnJlc3VsdDtcbiAgICAgIHJlc29sdmUocmVzdWx0ICYmIE51bWJlcihyZXN1bHQpKTtcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwcm92aWRlci5zZW5kQXN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3ZpZGVyLnNlbmRBc3luYyhvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvdmlkZXIuc2VuZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvdmlkZXIuc2VuZChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc29sdmUobnVsbCk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0QWRkcmVzcyhwcm92aWRlcikge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBvcHRpb25zID0ge1xuICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICBtZXRob2Q6ICdldGhfYWNjb3VudHMnLFxuICAgICAgcGFyYW1zOiBbXSxcbiAgICAgIGlkOiA0MlxuICAgIH07IC8vIHVzZSBNZXRhTWFzayByZXF1ZXN0IG1ldGhvZCBpZiB0aGVyZVxuXG4gICAgaWYgKHByb3ZpZGVyLnJlcXVlc3QpIHtcbiAgICAgIHJldHVybiBwcm92aWRlci5yZXF1ZXN0KG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZShyZXNbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soZSwgcmVzKSB7XG4gICAgICBlICYmIHJlamVjdChlKTtcbiAgICAgIHZhciByZXN1bHQgPSByZXMgJiYgcmVzLnJlc3VsdCAmJiByZXMucmVzdWx0WzBdO1xuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH07XG5cbiAgICBpZiAodHlwZW9mIHByb3ZpZGVyLnNlbmRBc3luYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvdmlkZXIuc2VuZEFzeW5jKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm92aWRlci5zZW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwcm92aWRlci5zZW5kKG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRCYWxhbmNlKHByb3ZpZGVyLCBhZGRyZXNzKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgY3VycmVudEFkZHJlc3MsIG9wdGlvbnMsIGNhbGxiYWNrO1xuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dC50MCA9IGFkZHJlc3M7XG5cbiAgICAgICAgICAgICAgaWYgKF9jb250ZXh0LnQwKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MocHJvdmlkZXIpO1xuXG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHQuc2VudDtcblxuICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICBjdXJyZW50QWRkcmVzcyA9IF9jb250ZXh0LnQwO1xuXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50QWRkcmVzcykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6ICcyLjAnLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ2V0aF9nZXRCYWxhbmNlJyxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IFtjdXJyZW50QWRkcmVzcywgJ2xhdGVzdCddLFxuICAgICAgICAgICAgICAgIGlkOiA0MlxuICAgICAgICAgICAgICB9OyAvLyB1c2UgTWV0YU1hc2sgcmVxdWVzdCBtZXRob2QgaWYgdGhlcmVcblxuICAgICAgICAgICAgICBpZiAoIXByb3ZpZGVyLnJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHByb3ZpZGVyLnJlcXVlc3Qob3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcyA/IG5ldyBCaWdOdW1iZXIocmVzKS50b1N0cmluZygxMCkgOiBudWxsO1xuICAgICAgICAgICAgICB9KS50aGVuKHJlc29sdmUpKTtcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlLCByZXMpIHtcbiAgICAgICAgICAgICAgICBlICYmIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gcmVzICYmIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQgJiYgbmV3IEJpZ051bWJlcihyZXN1bHQpLnRvU3RyaW5nKDEwKSk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlci5zZW5kQXN5bmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwcm92aWRlci5zZW5kQXN5bmMob3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm92aWRlci5zZW5kID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXIuc2VuZChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZSk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyKSB7XG4gICAgICByZXR1cm4gX3JlZjQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNb2Rlcm5Qcm92aWRlckludGVyZmFjZShwcm92aWRlcikge1xuICBwcm92aWRlci5hdXRvUmVmcmVzaE9uTmV0d29ya0NoYW5nZSA9IGZhbHNlO1xuICB2YXIgb25GdW5jRXhpc3RzID0gdHlwZW9mIHByb3ZpZGVyLm9uID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGFkZHJlc3M6IG9uRnVuY0V4aXN0cyA/IHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShmdW5jKSB7XG4gICAgICAgIC8vIGdldCB0aGUgaW5pdGlhbCB2YWx1ZVxuICAgICAgICBnZXRBZGRyZXNzKHByb3ZpZGVyKS50aGVuKGZ1bmMpO1xuICAgICAgICBwcm92aWRlci5vbignYWNjb3VudHNDaGFuZ2VkJywgZnVuY3Rpb24gKGFjY291bnRzKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMoYWNjb3VudHMgJiYgYWNjb3VudHNbMF0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHByb3ZpZGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5ldHdvcms6IG9uRnVuY0V4aXN0cyA/IHtcbiAgICAgIG9uQ2hhbmdlOiBmdW5jdGlvbiBvbkNoYW5nZShmdW5jKSB7XG4gICAgICAgIC8vIGdldCBpbml0aWFsIHZhbHVlXG4gICAgICAgIGdldE5ldHdvcmsocHJvdmlkZXIpLnRoZW4oZnVuYyk7IC8vIG5ldHdvcmtDaGFuZ2VkIGV2ZW50IGlzIGRlcHJlY2F0ZWQgaW4gTU0sIGtlZXAgZm9yIHdhbGxldHMgdGhhdCBtYXkgbm90IGhhdmUgdXBkYXRlZFxuXG4gICAgICAgIHByb3ZpZGVyLm9uKCduZXR3b3JrQ2hhbmdlZCcsIGZ1bmN0aW9uIChuZXRJZCkge1xuICAgICAgICAgIHJldHVybiBmdW5jKG5ldElkICYmIE51bWJlcihuZXRJZCkpO1xuICAgICAgICB9KTsgLy8gdXNlIG5ldyBjaGFpbkNoYW5nZWQgZXZlbnQgZm9yIG5ldHdvcmsgY2hhbmdlXG5cbiAgICAgICAgcHJvdmlkZXIub24oJ2NoYWluQ2hhbmdlZCcsIGZ1bmN0aW9uIChuZXRJZCkge1xuICAgICAgICAgIHJldHVybiBmdW5jKG5ldElkICYmIE51bWJlcihuZXRJZCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IDoge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXROZXR3b3JrKHByb3ZpZGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJhbGFuY2U6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gZ2V0QmFsYW5jZShwcm92aWRlcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2Nvbm5lY3QgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgcmVzdWx0LCBfcmVzdWx0O1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAwO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFwcm92aWRlci5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZXRoX3JlcXVlc3RBY2NvdW50cydcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0KTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZW5hYmxlKCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBfcmVzdWx0ID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX3Jlc3VsdCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDE3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTQ6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAxNDtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIudDAgPSBfY29udGV4dDJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnVGhpcyBkYXBwIHJlcXVpcmVzIGFjY2VzcyB0byB5b3VyIGFjY291bnQgaW5mb3JtYXRpb24uJ1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIG51bGwsIFtbMCwgMTRdXSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfY29ubmVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29ubmVjdDtcbiAgICB9KCksXG4gICAgbmFtZTogZ2V0UHJvdmlkZXJOYW1lKHByb3ZpZGVyKVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMZWdhY3lQcm92aWRlckludGVyZmFjZShwcm92aWRlcikge1xuICByZXR1cm4ge1xuICAgIGFkZHJlc3M6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhwcm92aWRlcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBuZXR3b3JrOiB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIGdldE5ldHdvcmsocHJvdmlkZXIpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYmFsYW5jZToge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBnZXRCYWxhbmNlKHByb3ZpZGVyKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG5hbWU6IGdldFByb3ZpZGVyTmFtZShwcm92aWRlcilcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0UHJvdmlkZXJOYW1lKHByb3ZpZGVyKSB7XG4gIGlmICghcHJvdmlkZXIpIHJldHVybjtcblxuICBpZiAocHJvdmlkZXIuaXNXYWxsZXRJTykge1xuICAgIHJldHVybiAnd2FsbGV0LmlvJztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc0RjZW50V2FsbGV0KSB7XG4gICAgcmV0dXJuIFwiRCdDRU5UXCI7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNUb2tlblBvY2tldCkge1xuICAgIHJldHVybiAnVG9rZW5Qb2NrZXQnO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzT3duYml0KSB7XG4gICAgcmV0dXJuICdPd25iaXQnO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLndhbGxldCA9PT0gJ01FRVRPTkUnKSB7XG4gICAgcmV0dXJuICdNRUVUT05FJztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc1RvcnVzKSB7XG4gICAgcmV0dXJuICdUb3J1cyc7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNJbVRva2VuKSB7XG4gICAgcmV0dXJuICdpbVRva2VuJztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc0RhcHBlcikge1xuICAgIHJldHVybiAnRGFwcGVyJztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc1dhbGxldENvbm5lY3QpIHtcbiAgICByZXR1cm4gJ1dhbGxldENvbm5lY3QnO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzVHJ1c3QpIHtcbiAgICByZXR1cm4gJ1RydXN0JztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc0NvaW5iYXNlV2FsbGV0KSB7XG4gICAgcmV0dXJuICdDb2luYmFzZSc7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNUb3NoaSkge1xuICAgIHJldHVybiAnVG9zaGknO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzQ2lwaGVyKSB7XG4gICAgcmV0dXJuICdDaXBoZXInO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzT3BlcmEpIHtcbiAgICByZXR1cm4gJ09wZXJhJztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc1N0YXR1cykge1xuICAgIHJldHVybiAnU3RhdHVzJztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc1hERUZJKSB7XG4gICAgcmV0dXJuICdYREVGSSc7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNGcmFtZSkge1xuICAgIHJldHVybiAnRnJhbWUnO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzTVlLRVkpIHtcbiAgICByZXR1cm4gJ01ZS0VZJztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc0hiV2FsbGV0KSB7XG4gICAgcmV0dXJuICdodW9iaXdhbGxldCc7XG4gIH1cblxuICBpZiAocHJvdmlkZXIuaXNIeXBlclBheSkge1xuICAgIHJldHVybiAnSHlwZXJQYXknO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzQVRva2VuKSB7XG4gICAgcmV0dXJuICdBVG9rZW4nO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzTGlxdWFsaXR5KSB7XG4gICAgcmV0dXJuICdMaXF1YWxpdHknO1xuICB9XG5cbiAgaWYgKHByb3ZpZGVyLmlzQWxwaGFXYWxsZXQpIHtcbiAgICByZXR1cm4gJ0FscGhhV2FsbGV0JztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5pc0JpdHBpZSkge1xuICAgIHJldHVybiAnQml0cGllJztcbiAgfSAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFdoZW4gYWRkaW5nIG5ldyB3YWxsZXQgcGxhY2UgYWJvdmUgdGhpcyBtZXRhbWFzayBjaGVjayBhcyBzb21lIHByb3ZpZGVyc1xuICAvLyBoYXZlIGFuIGlzTWV0YU1hc2sgcHJvcGVydHkgaW4gYWRkaXRpb24gdG8gdGhlIHdhbGxldCdzIG93biBgaXNbV2FsbGV0TmFtZV1gXG5cblxuICBpZiAocHJvdmlkZXIuaXNNZXRhTWFzayAmJiBwcm92aWRlci5fbWV0YW1hc2spIHtcbiAgICByZXR1cm4gJ01ldGFNYXNrJztcbiAgfVxuXG4gIGlmIChwcm92aWRlci5ob3N0ICYmIHByb3ZpZGVyLmhvc3QuaW5kZXhPZignbG9jYWxob3N0JykgIT09IC0xKSB7XG4gICAgcmV0dXJuICdsb2NhbGhvc3QnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERldmljZUluZm8oKSB7XG4gIHZhciBwYXJzZWQgPSBib3dzZXIuZ2V0UGFyc2VyKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIG9zID0gcGFyc2VkLmdldE9TKCk7XG4gIHZhciBicm93c2VyID0gcGFyc2VkLmdldEJyb3dzZXIoKTtcblxuICB2YXIgX3BhcnNlZCRnZXRQbGF0Zm9ybSA9IHBhcnNlZC5nZXRQbGF0Zm9ybSgpLFxuICAgICAgdHlwZSA9IF9wYXJzZWQkZ2V0UGxhdGZvcm0udHlwZTtcblxuICByZXR1cm4ge1xuICAgIGlzTW9iaWxlOiB0eXBlID8gdHlwZSAhPT0gJ2Rlc2t0b3AnIDogd2luZG93LmlubmVyV2lkdGggPCA2MDAsXG4gICAgb3M6IG9zLFxuICAgIGJyb3dzZXI6IGJyb3dzZXJcbiAgfTtcbn1cblxuZnVuY3Rpb24gbmV0d29ya05hbWUoaWQpIHtcbiAgc3dpdGNoIChpZCkge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiAnbWFpbm5ldCc7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gJ3JvcHN0ZW4nO1xuXG4gICAgY2FzZSA0OlxuICAgICAgcmV0dXJuICdyaW5rZWJ5JztcblxuICAgIGNhc2UgNTpcbiAgICAgIHJldHVybiAnZ29lcmxpJztcblxuICAgIGNhc2UgNDI6XG4gICAgICByZXR1cm4gJ2tvdmFuJztcblxuICAgIGNhc2UgMTAwOlxuICAgICAgcmV0dXJuICd4ZGFpJztcblxuICAgIGNhc2UgNTY6XG4gICAgICByZXR1cm4gJ2JzYyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIF9nZXRfc3RvcmVfdmFsdWUyID0gZ2V0X3N0b3JlX3ZhbHVlKGFwcCksXG4gICAgICAgICAgbmV0d29ya0lkID0gX2dldF9zdG9yZV92YWx1ZTIubmV0d29ya0lkLFxuICAgICAgICAgIF9uZXR3b3JrTmFtZSA9IF9nZXRfc3RvcmVfdmFsdWUyLm5ldHdvcmtOYW1lO1xuXG4gICAgICByZXR1cm4gbmV0d29ya0lkID09PSBpZCAmJiBfbmV0d29ya05hbWUgfHwgJ3Vua25vd24nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhaXQkMSh0aW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWFrZUNhbmNlbGFibGUocHJvbWlzZSkge1xuICB2YXIgcmVqZWN0Rm47XG4gIHZhciB3cmFwcGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZWplY3RGbiA9IHJlamVjdDtcbiAgICBwcm9taXNlLnRoZW4ocmVzb2x2ZSlbXCJjYXRjaFwiXShyZWplY3QpO1xuICB9KTtcblxuICB3cmFwcGVkUHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmVqZWN0Rm4oJ2NhbmNlbGVkJyk7XG4gIH07XG5cbiAgcmV0dXJuIHdyYXBwZWRQcm9taXNlO1xufVxuXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUludGVydmFsKGZ1bmMsIGludGVydmFsKSB7XG4gIHZhciBpZCA9IHNldEludGVydmFsKGZ1bmMsIGludGVydmFsKTtcbiAgdmFyIHN0YXR1cyA9IHtcbiAgICBhY3RpdmU6IHRydWVcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgIHN0YXR1cy5hY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9wZW5MaW5rKHVybCkge1xuICB3aW5kb3cub3Blbih1cmwpO1xufVxuXG52YXIgdmFsaWRTdWJzY3JpcHRpb25LZXlzID0gWydhZGRyZXNzJywgJ25ldHdvcmsnLCAnYmFsYW5jZScsICd3YWxsZXQnXTtcblxuZnVuY3Rpb24gdmFsaWRhdGVUeXBlKG9wdGlvbnMpIHtcbiAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUsXG4gICAgICB2YWx1ZSA9IG9wdGlvbnMudmFsdWUsXG4gICAgICB0eXBlID0gb3B0aW9ucy50eXBlLFxuICAgICAgb3B0aW9uYWwgPSBvcHRpb25zLm9wdGlvbmFsO1xuXG4gIGlmICghb3B0aW9uYWwgJiYgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIGlzIHJlcXVpcmVkXCIpKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmICh0eXBlID09PSAnYXJyYXknID8gQXJyYXkuaXNBcnJheSh0eXBlKSA6IF90eXBlb2YodmFsdWUpICE9PSB0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiIG11c3QgYmUgb2YgdHlwZTogXCIpLmNvbmNhdCh0eXBlLCBcIiwgcmVjZWl2ZWQgdHlwZTogXCIpLmNvbmNhdChfdHlwZW9mKHZhbHVlKSwgXCIgZnJvbSB2YWx1ZTogXCIpLmNvbmNhdCh2YWx1ZSkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGludmFsaWRQYXJhbXMocGFyYW1zLCB2YWxpZFBhcmFtcywgZnVuY3Rpb25OYW1lKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMocGFyYW1zKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIXZhbGlkUGFyYW1zLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChrZXksIFwiIGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlciBmb3IgXCIpLmNvbmNhdChmdW5jdGlvbk5hbWUsIFwiLCBtdXN0IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbGlkIHBhcmFtZXRlcnM6IFwiKS5jb25jYXQodmFsaWRQYXJhbXMuam9pbignLCAnKSkpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW5pdChpbml0KSB7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2luaXQnLFxuICAgIHZhbHVlOiBpbml0LFxuICAgIHR5cGU6ICdvYmplY3QnXG4gIH0pO1xuXG4gIHZhciBkYXBwSWQgPSBpbml0LmRhcHBJZCxcbiAgICAgIG5ldHdvcmtJZCA9IGluaXQubmV0d29ya0lkLFxuICAgICAgbmV0d29ya05hbWUgPSBpbml0Lm5ldHdvcmtOYW1lLFxuICAgICAgc3Vic2NyaXB0aW9ucyA9IGluaXQuc3Vic2NyaXB0aW9ucyxcbiAgICAgIHdhbGxldFNlbGVjdCA9IGluaXQud2FsbGV0U2VsZWN0LFxuICAgICAgd2FsbGV0Q2hlY2sgPSBpbml0LndhbGxldENoZWNrLFxuICAgICAgZGFya01vZGUgPSBpbml0LmRhcmtNb2RlLFxuICAgICAgYXBpVXJsID0gaW5pdC5hcGlVcmwsXG4gICAgICBoaWRlQnJhbmRpbmcgPSBpbml0LmhpZGVCcmFuZGluZyxcbiAgICAgIGJsb2NrUG9sbGluZ0ludGVydmFsID0gaW5pdC5ibG9ja1BvbGxpbmdJbnRlcnZhbCxcbiAgICAgIG90aGVyUGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGluaXQsIF9leGNsdWRlZCk7XG5cbiAgaW52YWxpZFBhcmFtcyhvdGhlclBhcmFtcywgWydkYXBwSWQnLCAnbmV0d29ya0lkJywgJ25ldHdvcmtOYW1lJywgJ3N1YnNjcmlwdGlvbnMnLCAnd2FsbGV0U2VsZWN0JywgJ3dhbGxldENoZWNrJywgJ2RhcmtNb2RlJywgJ2FwaVVybCcsICdoaWRlQnJhbmRpbmcnLCAnYmxvY2tQb2xsaW5nSW50ZXJ2YWwnLCAnYWdyZWVtZW50J10sICdpbml0Jyk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2RhcHBJZCcsXG4gICAgdmFsdWU6IGRhcHBJZCxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnbmV0d29ya0lkJyxcbiAgICB2YWx1ZTogbmV0d29ya0lkLFxuICAgIHR5cGU6ICdudW1iZXInXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICduZXR3b3JrTmFtZScsXG4gICAgdmFsdWU6IG5ldHdvcmtOYW1lLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdkYXJrTW9kZScsXG4gICAgdmFsdWU6IGRhcmtNb2RlLFxuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYXBpVXJsJyxcbiAgICB2YWx1ZTogYXBpVXJsLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdoaWRlQnJhbmRpbmcnLFxuICAgIHZhbHVlOiBoaWRlQnJhbmRpbmcsXG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdibG9ja1BvbGxpbmdJbnRlcnZhbCcsXG4gICAgdmFsdWU6IGJsb2NrUG9sbGluZ0ludGVydmFsLFxuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdzdWJzY3JpcHRpb25zJyxcbiAgICB2YWx1ZTogc3Vic2NyaXB0aW9ucyxcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcblxuICBpZiAoc3Vic2NyaXB0aW9ucykge1xuICAgIHZhbGlkYXRlU3Vic2NyaXB0aW9ucyhzdWJzY3JpcHRpb25zKTtcbiAgfVxuXG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dhbGxldFNlbGVjdCcsXG4gICAgdmFsdWU6IHdhbGxldFNlbGVjdCxcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcblxuICBpZiAod2FsbGV0U2VsZWN0KSB7XG4gICAgdmFsaWRhdGVXYWxsZXRTZWxlY3Qod2FsbGV0U2VsZWN0KTtcbiAgfVxuXG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dhbGxldENoZWNrJyxcbiAgICB2YWx1ZTogd2FsbGV0Q2hlY2ssXG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG5cbiAgaWYgKHdhbGxldENoZWNrKSB7XG4gICAgdmFsaWRhdGVXYWxsZXRDaGVjayh3YWxsZXRDaGVjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdWJzY3JpcHRpb25zKHN1YnNjcmlwdGlvbnMpIHtcbiAgdmFyIGFkZHJlc3MgPSBzdWJzY3JpcHRpb25zLmFkZHJlc3MsXG4gICAgICBuZXR3b3JrID0gc3Vic2NyaXB0aW9ucy5uZXR3b3JrLFxuICAgICAgYmFsYW5jZSA9IHN1YnNjcmlwdGlvbnMuYmFsYW5jZSxcbiAgICAgIHdhbGxldCA9IHN1YnNjcmlwdGlvbnMud2FsbGV0LFxuICAgICAgb3RoZXJQYXJhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc3Vic2NyaXB0aW9ucywgX2V4Y2x1ZGVkMik7XG5cbiAgaW52YWxpZFBhcmFtcyhvdGhlclBhcmFtcywgdmFsaWRTdWJzY3JpcHRpb25LZXlzLCAnc3Vic2NyaXB0aW9ucycpO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdzdWJzY3JpcHRpb25zLmFkZHJlc3MnLFxuICAgIHZhbHVlOiBhZGRyZXNzLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3N1YnNjcmlwdGlvbnMubmV0d29yaycsXG4gICAgdmFsdWU6IG5ldHdvcmssXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnc3Vic2NyaXB0aW9ucy5iYWxhbmNlJyxcbiAgICB2YWx1ZTogYmFsYW5jZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdzdWJzY3JpcHRpb25zLndhbGxldCcsXG4gICAgdmFsdWU6IHdhbGxldCxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVdhbGxldFNlbGVjdCh3YWxsZXRTZWxlY3QpIHtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnd2FsbGV0U2VsZWN0JyxcbiAgICB2YWx1ZTogd2FsbGV0U2VsZWN0LFxuICAgIHR5cGU6ICdvYmplY3QnXG4gIH0pO1xuXG4gIHZhciBoZWFkaW5nID0gd2FsbGV0U2VsZWN0LmhlYWRpbmcsXG4gICAgICBkZXNjcmlwdGlvbiA9IHdhbGxldFNlbGVjdC5kZXNjcmlwdGlvbixcbiAgICAgIGV4cGxhbmF0aW9uID0gd2FsbGV0U2VsZWN0LmV4cGxhbmF0aW9uLFxuICAgICAgd2FsbGV0cyA9IHdhbGxldFNlbGVjdC53YWxsZXRzLFxuICAgICAgYWdyZWVtZW50ID0gd2FsbGV0U2VsZWN0LmFncmVlbWVudCxcbiAgICAgIG90aGVyUGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHdhbGxldFNlbGVjdCwgX2V4Y2x1ZGVkMyk7XG5cbiAgaW52YWxpZFBhcmFtcyhvdGhlclBhcmFtcywgWydoZWFkaW5nJywgJ2Rlc2NyaXB0aW9uJywgJ2V4cGxhbmF0aW9uJywgJ3dhbGxldHMnLCAnYWdyZWVtZW50J10sICd3YWxsZXRTZWxlY3QnKTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnaGVhZGluZycsXG4gICAgdmFsdWU6IGhlYWRpbmcsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2Rlc2NyaXB0aW9uJyxcbiAgICB2YWx1ZTogZGVzY3JpcHRpb24sXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2V4cGxhbmF0aW9uJyxcbiAgICB2YWx1ZTogZXhwbGFuYXRpb24sXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkod2FsbGV0cykpIHtcbiAgICB3YWxsZXRzLmZvckVhY2godmFsaWRhdGVXYWxsZXQpO1xuICB9XG5cbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYWdyZWVtZW50JyxcbiAgICB2YWx1ZTogYWdyZWVtZW50LFxuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuXG4gIGlmIChhZ3JlZW1lbnQpIHtcbiAgICB2YWxpZGF0ZUFncmVlbWVudChhZ3JlZW1lbnQpO1xuICB9XG59XG5cbnZhciB2YWxpZGF0ZUFncmVlbWVudCA9IGZ1bmN0aW9uIHZhbGlkYXRlQWdyZWVtZW50KGFncmVlbWVudCkge1xuICB2YXIgdmVyc2lvbiA9IGFncmVlbWVudC52ZXJzaW9uLFxuICAgICAgdGVybXNVcmwgPSBhZ3JlZW1lbnQudGVybXNVcmwsXG4gICAgICBwcml2YWN5VXJsID0gYWdyZWVtZW50LnByaXZhY3lVcmw7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3ZlcnNpb24nLFxuICAgIHZhbHVlOiB2ZXJzaW9uLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiBmYWxzZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAndGVybXNVcmwnLFxuICAgIHZhbHVlOiB0ZXJtc1VybCxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAncHJpdmFjeVVybCcsXG4gICAgdmFsdWU6IHByaXZhY3lVcmwsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBpc1dhbGxldE1vZHVsZShvYmopIHtcbiAgcmV0dXJuIG9iai53YWxsZXQgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNXYWxsZXRJbml0KG9iaikge1xuICByZXR1cm4gb2JqLndhbGxldE5hbWUgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVXYWxsZXQob2JqKSB7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3NlbGVjdFdhbGxldC53YWxsZXRzIGl0ZW0nLFxuICAgIHZhbHVlOiBvYmosXG4gICAgdHlwZTogJ29iamVjdCdcbiAgfSk7XG5cbiAgaWYgKGlzV2FsbGV0TW9kdWxlKG9iaikpIHtcbiAgICB2YXIgbmFtZSA9IG9iai5uYW1lLFxuICAgICAgICBpY29uU3JjID0gb2JqLmljb25TcmMsXG4gICAgICAgIGljb25TcmNTZXQgPSBvYmouaWNvblNyY1NldCxcbiAgICAgICAgc3ZnID0gb2JqLnN2ZyxcbiAgICAgICAgX3dhbGxldCA9IG9iai53YWxsZXQsXG4gICAgICAgIGxpbmsgPSBvYmoubGluayxcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2UgPSBvYmouaW5zdGFsbE1lc3NhZ2UsXG4gICAgICAgIHByZWZlcnJlZCA9IG9iai5wcmVmZXJyZWQsXG4gICAgICAgIGRlc2t0b3AgPSBvYmouZGVza3RvcCxcbiAgICAgICAgbW9iaWxlID0gb2JqLm1vYmlsZSxcbiAgICAgICAgdHlwZSA9IG9iai50eXBlLFxuICAgICAgICBvc0V4Y2x1c2lvbnMgPSBvYmoub3NFeGNsdXNpb25zLFxuICAgICAgICBvdGhlclBhcmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIF9leGNsdWRlZDQpO1xuXG4gICAgaW52YWxpZFBhcmFtcyhvdGhlclBhcmFtcywgWyduYW1lJywgJ2ljb25TcmMnLCAnaWNvblNyY1NldCcsICdzdmcnLCAnd2FsbGV0JywgJ3R5cGUnLCAnbGluaycsICdpbnN0YWxsTWVzc2FnZScsICdwcmVmZXJyZWQnLCAnZGVza3RvcCcsICdtb2JpbGUnLCAnb3NFeGNsdXNpb25zJ10sICdzZWxlY3RXYWxsZXRzLndhbGxldHMgaXRlbScpO1xuICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICBuYW1lOiAnbmFtZScsXG4gICAgICB2YWx1ZTogbmFtZSxcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICd3YWxsZXQnLFxuICAgICAgdmFsdWU6IF93YWxsZXQsXG4gICAgICB0eXBlOiAnZnVuY3Rpb24nXG4gICAgfSk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICdpY29uU3JjJyxcbiAgICAgIHZhbHVlOiBpY29uU3JjLFxuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0pO1xuICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICBuYW1lOiAnaWNvblNyY1NldCcsXG4gICAgICB2YWx1ZTogaWNvblNyY1NldCxcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9KTtcbiAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgbmFtZTogJ3N2ZycsXG4gICAgICB2YWx1ZTogc3ZnLFxuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0pO1xuICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICBuYW1lOiAnbGluaycsXG4gICAgICB2YWx1ZTogbGluayxcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9KTtcbiAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgbmFtZTogJ2luc3RhbGxNZXNzYWdlJyxcbiAgICAgIHZhbHVlOiBpbnN0YWxsTWVzc2FnZSxcbiAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0pO1xuICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICBuYW1lOiAncHJlZmVycmVkJyxcbiAgICAgIHZhbHVlOiBwcmVmZXJyZWQsXG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0pO1xuICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICBuYW1lOiAnZGVza3RvcCcsXG4gICAgICB2YWx1ZTogZGVza3RvcCxcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICdtb2JpbGUnLFxuICAgICAgdmFsdWU6IG1vYmlsZSxcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICd0eXBlJyxcbiAgICAgIHZhbHVlOiB0eXBlLFxuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0pO1xuICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICBuYW1lOiAnb3NFeGNsdXNpb25zJyxcbiAgICAgIHZhbHVlOiBvc0V4Y2x1c2lvbnMsXG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YWxpZGF0ZVdhbGxldEluaXQob2JqKTtcbn1cblxuZnVuY3Rpb24gaXNXYWxsZXRDaGVja01vZHVsZShvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV2FsbGV0Q2hlY2sod2FsbGV0Q2hlY2spIHtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnd2FsbGV0Q2hlY2snLFxuICAgIHZhbHVlOiB3YWxsZXRDaGVjayxcbiAgICB0eXBlOiAnYXJyYXknXG4gIH0pO1xuICB3YWxsZXRDaGVjay5mb3JFYWNoKGZ1bmN0aW9uIChjaGVjaykge1xuICAgIGlmIChpc1dhbGxldENoZWNrTW9kdWxlKGNoZWNrKSkge1xuICAgICAgdmFsaWRhdGVXYWxsZXRDaGVja01vZHVsZShjaGVjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6ICd3YWxsZXRDaGVjayBpdGVtJyxcbiAgICAgICAgdmFsdWU6IGNoZWNrLFxuICAgICAgICB0eXBlOiAnb2JqZWN0J1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjaGVja05hbWUgPSBjaGVjay5jaGVja05hbWUsXG4gICAgICAgICAgaGVhZGluZyA9IGNoZWNrLmhlYWRpbmcsXG4gICAgICAgICAgZGVzY3JpcHRpb24gPSBjaGVjay5kZXNjcmlwdGlvbixcbiAgICAgICAgICBtaW5pbXVtQmFsYW5jZSA9IGNoZWNrLm1pbmltdW1CYWxhbmNlLFxuICAgICAgICAgIGh0bWwgPSBjaGVjay5odG1sLFxuICAgICAgICAgIGljb24gPSBjaGVjay5pY29uLFxuICAgICAgICAgIGJ1dHRvbiA9IGNoZWNrLmJ1dHRvbixcbiAgICAgICAgICBvdGhlclBhcmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhjaGVjaywgX2V4Y2x1ZGVkNSk7XG5cbiAgICAgIGludmFsaWRQYXJhbXMob3RoZXJQYXJhbXMsIFsnY2hlY2tOYW1lJywgJ2hlYWRpbmcnLCAnZGVzY3JpcHRpb24nLCAnaHRtbCcsICdpY29uJywgJ2J1dHRvbicsICdtaW5pbXVtQmFsYW5jZSddLCAnd2FsbGV0Q2hlY2sgaXRlbScpO1xuICAgICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgICAgbmFtZTogJ2NoZWNrTmFtZScsXG4gICAgICAgIHZhbHVlOiBjaGVja05hbWUsXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6ICdoZWFkaW5nJyxcbiAgICAgICAgdmFsdWU6IGhlYWRpbmcsXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgICBuYW1lOiAnZGVzY3JpcHRpb24nLFxuICAgICAgICB2YWx1ZTogZGVzY3JpcHRpb24sXG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2YWxpZGF0ZVR5cGUoe1xuICAgICAgICBuYW1lOiAnaHRtbCcsXG4gICAgICAgIHZhbHVlOiBodG1sLFxuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgICAgbmFtZTogJ2ljb24nLFxuICAgICAgICB2YWx1ZTogaWNvbixcbiAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6ICdidXR0b24nLFxuICAgICAgICB2YWx1ZTogYnV0dG9uLFxuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgIH0pO1xuICAgICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgICAgbmFtZTogJ21pbmltdW1CYWxhbmNlJyxcbiAgICAgICAgdmFsdWU6IG1pbmltdW1CYWxhbmNlLFxuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV2FsbGV0Q2hlY2tNb2R1bGUobW9kdWxlKSB7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dhbGxldENoZWNrIG1vZHVsZScsXG4gICAgdmFsdWU6IG1vZHVsZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbmZpZyhjb25maWd1cmF0aW9uKSB7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2NvbmZpZ3VyYXRpb24nLFxuICAgIHZhbHVlOiBjb25maWd1cmF0aW9uLFxuICAgIHR5cGU6ICdvYmplY3QnXG4gIH0pO1xuXG4gIHZhciBkYXJrTW9kZSA9IGNvbmZpZ3VyYXRpb24uZGFya01vZGUsXG4gICAgICBuZXR3b3JrSWQgPSBjb25maWd1cmF0aW9uLm5ldHdvcmtJZCxcbiAgICAgIG90aGVyUGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGNvbmZpZ3VyYXRpb24sIF9leGNsdWRlZDYpO1xuXG4gIGludmFsaWRQYXJhbXMob3RoZXJQYXJhbXMsIFsnZGFya01vZGUnLCAnbmV0d29ya0lkJ10sICdjb25maWd1cmF0aW9uJyk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2RhcmtNb2RlJyxcbiAgICB2YWx1ZTogZGFya01vZGUsXG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICduZXR3b3JrSWQnLFxuICAgIHZhbHVlOiBuZXR3b3JrSWQsXG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTW9kYWwobW9kYWwpIHtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnbW9kYWwnLFxuICAgIHZhbHVlOiBtb2RhbCxcbiAgICB0eXBlOiAnb2JqZWN0J1xuICB9KTtcblxuICB2YXIgaGVhZGluZyA9IG1vZGFsLmhlYWRpbmcsXG4gICAgICBkZXNjcmlwdGlvbiA9IG1vZGFsLmRlc2NyaXB0aW9uLFxuICAgICAgYnV0dG9uID0gbW9kYWwuYnV0dG9uLFxuICAgICAgZXZlbnRDb2RlID0gbW9kYWwuZXZlbnRDb2RlLFxuICAgICAgYWN0aW9uID0gbW9kYWwuYWN0aW9uLFxuICAgICAgaWNvbiA9IG1vZGFsLmljb24sXG4gICAgICBodG1sID0gbW9kYWwuaHRtbCxcbiAgICAgIG90aGVyUGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG1vZGFsLCBfZXhjbHVkZWQ3KTtcblxuICBpbnZhbGlkUGFyYW1zKG90aGVyUGFyYW1zLCBbJ2hlYWRpbmcnLCAnZGVzY3JpcHRpb24nLCAnYnV0dG9uJywgJ2V2ZW50Q29kZScsICdhY3Rpb24nLCAnaWNvbicsICdodG1sJ10sICdtb2RhbCcpO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdoZWFkaW5nJyxcbiAgICB2YWx1ZTogaGVhZGluZyxcbiAgICB0eXBlOiAnc3RyaW5nJ1xuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnZGVzY3JpcHRpb24nLFxuICAgIHZhbHVlOiBkZXNjcmlwdGlvbixcbiAgICB0eXBlOiAnc3RyaW5nJ1xuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnZXZlbnRDb2RlJyxcbiAgICB2YWx1ZTogZXZlbnRDb2RlLFxuICAgIHR5cGU6ICdzdHJpbmcnXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdhY3Rpb24nLFxuICAgIHZhbHVlOiBhY3Rpb24sXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYnV0dG9uJyxcbiAgICB2YWx1ZTogYnV0dG9uLFxuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdodG1sJyxcbiAgICB2YWx1ZTogaHRtbCxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcblxuICBpZiAoYnV0dG9uKSB7XG4gICAgdmFyIG9uY2xpY2sgPSBidXR0b24ub25jbGljayxcbiAgICAgICAgX3RleHQgPSBidXR0b24udGV4dCxcbiAgICAgICAgcmVzdFBhcmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhidXR0b24sIF9leGNsdWRlZDgpO1xuXG4gICAgaW52YWxpZFBhcmFtcyhyZXN0UGFyYW1zLCBbJ29uY2xpY2snLCAndGV4dCddLCAnYnV0dG9uJyk7XG4gICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICdvbmNsaWNrJyxcbiAgICAgIHZhbHVlOiBvbmNsaWNrLFxuICAgICAgdHlwZTogJ2Z1bmN0aW9uJ1xuICAgIH0pO1xuICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICBuYW1lOiAndGV4dCcsXG4gICAgICB2YWx1ZTogX3RleHQsXG4gICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH0pO1xuICB9XG5cbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnaWNvbicsXG4gICAgdmFsdWU6IGljb24sXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV2FsbGV0SW50ZXJmYWNlKHdhbGxldEludGVyZmFjZSkge1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICd3YWxsZXRJbnRlcmZhY2UnLFxuICAgIHZhbHVlOiB3YWxsZXRJbnRlcmZhY2UsXG4gICAgdHlwZTogJ29iamVjdCdcbiAgfSk7XG5cbiAgdmFyIG5hbWUgPSB3YWxsZXRJbnRlcmZhY2UubmFtZSxcbiAgICAgIGNvbm5lY3QgPSB3YWxsZXRJbnRlcmZhY2UuY29ubmVjdCxcbiAgICAgIGRpc2Nvbm5lY3QgPSB3YWxsZXRJbnRlcmZhY2UuZGlzY29ubmVjdCxcbiAgICAgIGFkZHJlc3MgPSB3YWxsZXRJbnRlcmZhY2UuYWRkcmVzcyxcbiAgICAgIG5ldHdvcmsgPSB3YWxsZXRJbnRlcmZhY2UubmV0d29yayxcbiAgICAgIGJhbGFuY2UgPSB3YWxsZXRJbnRlcmZhY2UuYmFsYW5jZSxcbiAgICAgIG90aGVyUGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHdhbGxldEludGVyZmFjZSwgX2V4Y2x1ZGVkOSk7XG5cbiAgaW52YWxpZFBhcmFtcyhvdGhlclBhcmFtcywgWyduYW1lJywgJ2Nvbm5lY3QnLCAnZGlzY29ubmVjdCcsICdhZGRyZXNzJywgJ25ldHdvcmsnLCAnYmFsYW5jZSddLCAnd2FsbGV0SW50ZXJmYWNlJyk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ25hbWUnLFxuICAgIHZhbHVlOiBuYW1lLFxuICAgIHR5cGU6ICdzdHJpbmcnXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdjb25uZWN0JyxcbiAgICB2YWx1ZTogY29ubmVjdCxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdkaXNjb25uZWN0JyxcbiAgICB2YWx1ZTogZGlzY29ubmVjdCxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdhZGRyZXNzJyxcbiAgICB2YWx1ZTogYWRkcmVzcyxcbiAgICB0eXBlOiAnb2JqZWN0J1xuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYWRkcmVzcy5nZXQnLFxuICAgIHZhbHVlOiBhZGRyZXNzLmdldCxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdhZGRyZXNzLm9uQ2hhbmdlJyxcbiAgICB2YWx1ZTogYWRkcmVzcy5vbkNoYW5nZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICduZXR3b3JrJyxcbiAgICB2YWx1ZTogbmV0d29yayxcbiAgICB0eXBlOiAnb2JqZWN0J1xuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnbmV0d29yay5nZXQnLFxuICAgIHZhbHVlOiBuZXR3b3JrLmdldCxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICduZXR3b3JrLm9uQ2hhbmdlJyxcbiAgICB2YWx1ZTogbmV0d29yay5vbkNoYW5nZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdiYWxhbmNlJyxcbiAgICB2YWx1ZTogYmFsYW5jZSxcbiAgICB0eXBlOiAnb2JqZWN0J1xuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYmFsYW5jZS5nZXQnLFxuICAgIHZhbHVlOiBiYWxhbmNlLmdldCxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdiYWxhbmNlLm9uQ2hhbmdlJyxcbiAgICB2YWx1ZTogYmFsYW5jZS5vbkNoYW5nZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVdhbGxldEluaXQod2FsbGV0SW5pdCkge1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICd3YWxsZXRJbml0JyxcbiAgICB2YWx1ZTogd2FsbGV0SW5pdCxcbiAgICB0eXBlOiAnb2JqZWN0J1xuICB9KTtcblxuICB2YXIgd2FsbGV0TmFtZSA9IHdhbGxldEluaXQud2FsbGV0TmFtZSxcbiAgICAgIHByZWZlcnJlZCA9IHdhbGxldEluaXQucHJlZmVycmVkLFxuICAgICAgbGFiZWwgPSB3YWxsZXRJbml0LmxhYmVsLFxuICAgICAgaWNvblNyYyA9IHdhbGxldEluaXQuaWNvblNyYyxcbiAgICAgIHN2ZyA9IHdhbGxldEluaXQuc3ZnLFxuICAgICAgb3RoZXJQYXJhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMod2FsbGV0SW5pdCwgX2V4Y2x1ZGVkMTApO1xuXG4gIGludmFsaWRQYXJhbXMob3RoZXJQYXJhbXMsIFsnd2FsbGV0TmFtZScsICdhcGlLZXknLCAnbmV0d29ya0lkJywgJ2luZnVyYUtleScsICdycGMnLCAnYnJpZGdlJywgJ3ByZWZlcnJlZCcsICdsYWJlbCcsICdpY29uU3JjJywgJ3N2ZycsICdhcHBVcmwnLCAnZW1haWwnLCAncnBjVXJsJywgJ0xlZGdlclRyYW5zcG9ydCcsICdidWlsZEVudicsICdidXR0b25Qb3NpdGlvbicsICdlbmFibGVMb2dnaW5nJywgJ2xvZ2luTWV0aG9kJywgJ2xvZ2luQ29uZmlnJywgJ3Nob3dUb3J1c0J1dHRvbicsICdtb2RhbFppbmRleCcsICdpbnRlZ3JpdHknLCAnd2hpdGVMYWJlbCcsICdhcHBOYW1lJywgJ2FwcExvZ29VcmwnLCAnZW5hYmxlZFZlcmlmaWVycycsICdkaXNhYmxlTm90aWZpY2F0aW9ucycsICdycGNVcmknLCAnd2ViVXJpJywgJ3hzVXJpJywgJ2Jsb2NrZWRQb3B1cFJlZGlyZWN0J10sICd3YWxsZXRJbml0T2JqZWN0Jyk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dhbGxldEluaXQud2FsbGV0TmFtZScsXG4gICAgdmFsdWU6IHdhbGxldE5hbWUsXG4gICAgdHlwZTogJ3N0cmluZydcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ3dhbGxldEluaXQucHJlZmVycmVkJyxcbiAgICB2YWx1ZTogcHJlZmVycmVkLFxuICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnd2FsbGV0SW5pdC5sYWJlbCcsXG4gICAgdmFsdWU6IGxhYmVsLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICd3YWxsZXRJbml0Lmljb25TcmMnLFxuICAgIHZhbHVlOiBpY29uU3JjLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICd3YWxsZXRJbml0LnN2ZycsXG4gICAgdmFsdWU6IHN2ZyxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbn1cblxudmFyIGFwcCA9IHdyaXRhYmxlKHtcbiAgZGFwcElkOiAnJyxcbiAgYXBpVXJsOiAnJyxcbiAgbmV0d29ya0lkOiAxLFxuICBuZXR3b3JrTmFtZTogJycsXG4gIHZlcnNpb246ICcnLFxuICBtb2JpbGVEZXZpY2U6IGZhbHNlLFxuICBvczogJycsXG4gIGRhcmtNb2RlOiBmYWxzZSxcbiAgd2FsbGV0U2VsZWN0SW5Qcm9ncmVzczogZmFsc2UsXG4gIHdhbGxldFNlbGVjdENvbXBsZXRlZDogZmFsc2UsXG4gIHdhbGxldENoZWNrSW5Qcm9ncmVzczogZmFsc2UsXG4gIHdhbGxldENoZWNrQ29tcGxldGVkOiBmYWxzZSxcbiAgc3dpdGNoaW5nV2FsbGV0czogZmFsc2UsXG4gIGFjY291bnRTZWxlY3RJblByb2dyZXNzOiBmYWxzZSxcbiAgYXV0b1NlbGVjdFdhbGxldDogJycsXG4gIGNoZWNrTW9kdWxlczogW10sXG4gIHdhbGxldFNlbGVjdERpc3BsYXllZFVJOiBmYWxzZSxcbiAgd2FsbGV0Q2hlY2tEaXNwbGF5ZWRVSTogZmFsc2UsXG4gIGRpc3BsYXlCcmFuZGluZzogZmFsc2UsXG4gIGJsb2NrUG9sbGluZ0ludGVydmFsOiA0MDAwLFxuICBhZ3JlZW1lbnQ6IHt9XG59KTtcbnZhciBzdGF0ZVN5bmNTdGF0dXMgPSB7XG4gIGJhbGFuY2U6IG51bGwsXG4gIGFkZHJlc3M6IG51bGwsXG4gIG5ldHdvcms6IG51bGxcbn07XG52YXIgYWRkcmVzcztcbnZhciBuZXR3b3JrO1xudmFyIGJhbGFuY2U7XG52YXIgd2FsbGV0O1xudmFyIHN0YXRlO1xudmFyIHdhbGxldEludGVyZmFjZTtcbnZhciBjdXJyZW50U3luY2VySW50ZXJ2YWxzO1xuXG5mdW5jdGlvbiBpbml0aWFsaXplU3RvcmVzKCkge1xuICBhZGRyZXNzID0gY3JlYXRlV2FsbGV0U3RhdGVTbGljZVN0b3JlKHtcbiAgICBwYXJhbWV0ZXI6ICdhZGRyZXNzJyxcbiAgICBpbml0aWFsU3RhdGU6IG51bGxcbiAgfSk7XG4gIG5ldHdvcmsgPSBjcmVhdGVXYWxsZXRTdGF0ZVNsaWNlU3RvcmUoe1xuICAgIHBhcmFtZXRlcjogJ25ldHdvcmsnLFxuICAgIGluaXRpYWxTdGF0ZTogbnVsbFxuICB9KTtcbiAgYmFsYW5jZSA9IGdldF9zdG9yZV92YWx1ZShhcHApLmRhcHBJZCA/IGNyZWF0ZUJhbGFuY2VTdG9yZShudWxsKSA6IGNyZWF0ZVdhbGxldFN0YXRlU2xpY2VTdG9yZSh7XG4gICAgcGFyYW1ldGVyOiAnYmFsYW5jZScsXG4gICAgaW5pdGlhbFN0YXRlOiBudWxsLFxuICAgIGludGVydmFsU2V0dGluZzogMTAwMFxuICB9KTtcbiAgd2FsbGV0ID0gd3JpdGFibGUoe1xuICAgIG5hbWU6IG51bGwsXG4gICAgcHJvdmlkZXI6IG51bGwsXG4gICAgY29ubmVjdDogbnVsbCxcbiAgICBpbnN0YW5jZTogbnVsbCxcbiAgICBkYXNoYm9hcmQ6IG51bGwsXG4gICAgdHlwZTogbnVsbCxcbiAgICBpY29uczogbnVsbFxuICB9KTtcbiAgc3RhdGUgPSBkZXJpdmVkKFthZGRyZXNzLCBuZXR3b3JrLCBiYWxhbmNlLCB3YWxsZXQsIGFwcF0sIGZ1bmN0aW9uIChfcmVmNSkge1xuICAgIHZhciBfcmVmNiA9IF9zbGljZWRUb0FycmF5KF9yZWY1LCA1KSxcbiAgICAgICAgJGFkZHJlc3MgPSBfcmVmNlswXSxcbiAgICAgICAgJG5ldHdvcmsgPSBfcmVmNlsxXSxcbiAgICAgICAgJGJhbGFuY2UgPSBfcmVmNlsyXSxcbiAgICAgICAgJHdhbGxldCA9IF9yZWY2WzNdLFxuICAgICAgICAkYXBwID0gX3JlZjZbNF07XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWRkcmVzczogJGFkZHJlc3MsXG4gICAgICBuZXR3b3JrOiAkbmV0d29yayxcbiAgICAgIGJhbGFuY2U6ICRiYWxhbmNlLFxuICAgICAgd2FsbGV0OiAkd2FsbGV0LFxuICAgICAgbW9iaWxlRGV2aWNlOiAkYXBwLm1vYmlsZURldmljZSxcbiAgICAgIGFwcE5ldHdvcmtJZDogJGFwcC5uZXR3b3JrSWRcbiAgICB9O1xuICB9KTtcbiAgY3VycmVudFN5bmNlckludGVydmFscyA9IFtdO1xuICB3YWxsZXRJbnRlcmZhY2UgPSBjcmVhdGVXYWxsZXRJbnRlcmZhY2VTdG9yZShudWxsKTtcbiAgd2FsbGV0SW50ZXJmYWNlLnN1YnNjcmliZShmdW5jdGlvbiAod2FsbGV0SW50ZXJmYWNlKSB7XG4gICAgLy8gbWFrZSBzdXJlIHRoYXQgc3RvcmVzIGhhdmUgYmVlbiBpbml0aWFsaXplZFxuICAgIGlmIChzdGF0ZSkge1xuICAgICAgLy8gY2xlYXIgYWxsIGN1cnJlbnQgaW50ZXJ2YWxzIGlmIHRoZXkgZXhpc3RcbiAgICAgIGN1cnJlbnRTeW5jZXJJbnRlcnZhbHMuZm9yRWFjaChmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgcmV0dXJuIGludGVydmFsICYmIGludGVydmFsLmNsZWFyKCk7XG4gICAgICB9KTtcbiAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBnZXRfc3RvcmVfdmFsdWUoc3RhdGUpOyAvLyByZXNldCBzdGF0ZVxuXG4gICAgICBjdXJyZW50U3RhdGUuYmFsYW5jZSAmJiBiYWxhbmNlLnJlc2V0KCk7XG4gICAgICBjdXJyZW50U3RhdGUuYWRkcmVzcyAmJiBhZGRyZXNzLnJlc2V0KCk7XG4gICAgICBjdXJyZW50U3RhdGUubmV0d29yayAmJiBuZXR3b3JrLnJlc2V0KCk7XG5cbiAgICAgIGlmICh3YWxsZXRJbnRlcmZhY2UpIHtcbiAgICAgICAgLy8gc3RhcnQgc3luY2luZyBzdGF0ZSBhbmQgc2F2ZSBpbnRlcnZhbHNcbiAgICAgICAgY3VycmVudFN5bmNlckludGVydmFscyA9IFthZGRyZXNzLnNldFN0YXRlU3luY2VyKHdhbGxldEludGVyZmFjZS5hZGRyZXNzKSwgbmV0d29yay5zZXRTdGF0ZVN5bmNlcih3YWxsZXRJbnRlcmZhY2UubmV0d29yayksIGJhbGFuY2Uuc2V0U3RhdGVTeW5jZXIod2FsbGV0SW50ZXJmYWNlLmJhbGFuY2UpXTtcbiAgICAgIH1cblxuICAgICAgcmVzZXRDaGVja01vZHVsZXMoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXNldFdhbGxldFN0YXRlKG9wdGlvbnMpIHtcbiAgd2FsbGV0SW50ZXJmYWNlLnVwZGF0ZShmdW5jdGlvbiAoY3VycmVudEludGVyZmFjZSkge1xuICAgIC8vIG5vIGludGVyZmFjZSB0aGVuIGRvbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKCFjdXJyZW50SW50ZXJmYWNlKSB7XG4gICAgICByZXR1cm4gY3VycmVudEludGVyZmFjZTtcbiAgICB9IC8vIG5vIG9wdGlvbnMgb2JqZWN0LCBzbyBkbyBhIGZ1bGwgcmVzZXQgYnkgZGlzY29ubmVjdGluZyBhbmQgc2V0dGluZyBpbnRlcmZhY2UgdG8gbnVsbFxuXG5cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgIHdhbGxldC51cGRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBwcm92aWRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIGNvbm5lY3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICBpbnN0YW5jZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRhc2hib2FyZDogdW5kZWZpbmVkLFxuICAgICAgICAgIHR5cGU6IHVuZGVmaW5lZFxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBjdXJyZW50SW50ZXJmYWNlLmRpc2Nvbm5lY3QgJiYgY3VycmVudEludGVyZmFjZS5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2FsbGV0TmFtZSA9IG9wdGlvbnMud2FsbGV0TmFtZSxcbiAgICAgICAgZGlzY29ubmVjdGVkID0gb3B0aW9ucy5kaXNjb25uZWN0ZWQ7IC8vIGlmIHdhbGxldE5hbWUgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgaW50ZXJmYWNlIG5hbWUgdGhlbiBkbyBhIGZ1bGwgcmVzZXQgKGNoZWNraW5nIGlmIHRvIGRvIGEgZGlzY29ubmVjdClcblxuICAgIGlmIChjdXJyZW50SW50ZXJmYWNlLm5hbWUgPT09IHdhbGxldE5hbWUpIHtcbiAgICAgIHdhbGxldC51cGRhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBwcm92aWRlcjogdW5kZWZpbmVkLFxuICAgICAgICAgIGNvbm5lY3Q6IHVuZGVmaW5lZCxcbiAgICAgICAgICBpbnN0YW5jZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRhc2hib2FyZDogdW5kZWZpbmVkXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgICFkaXNjb25uZWN0ZWQgJiYgY3VycmVudEludGVyZmFjZS5kaXNjb25uZWN0ICYmIGN1cnJlbnRJbnRlcmZhY2UuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJlbnRJbnRlcmZhY2U7XG4gIH0pO1xuICByZXNldENoZWNrTW9kdWxlcygpO1xuICBhcHAudXBkYXRlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgIHdhbGxldFNlbGVjdEluUHJvZ3Jlc3M6IGZhbHNlLFxuICAgICAgd2FsbGV0U2VsZWN0Q29tcGxldGVkOiBmYWxzZVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRDaGVja01vZHVsZXMoKSB7XG4gIHZhciBfZ2V0X3N0b3JlX3ZhbHVlMyA9IGdldF9zdG9yZV92YWx1ZShhcHApLFxuICAgICAgY2hlY2tNb2R1bGVzID0gX2dldF9zdG9yZV92YWx1ZTMuY2hlY2tNb2R1bGVzO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoZWNrTW9kdWxlcykpIHtcbiAgICBjaGVja01vZHVsZXMuZm9yRWFjaChmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG0ucmVzZXQgJiYgbS5yZXNldCgpO1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdhbGxldEludGVyZmFjZVN0b3JlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgX3dyaXRhYmxlID0gd3JpdGFibGUoaW5pdGlhbFN0YXRlKSxcbiAgICAgIHN1YnNjcmliZSA9IF93cml0YWJsZS5zdWJzY3JpYmUsXG4gICAgICBfc2V0ID0gX3dyaXRhYmxlLnNldCxcbiAgICAgIHVwZGF0ZSA9IF93cml0YWJsZS51cGRhdGU7XG5cbiAgcmV0dXJuIHtcbiAgICBzdWJzY3JpYmU6IHN1YnNjcmliZSxcbiAgICB1cGRhdGU6IHVwZGF0ZSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh3YWxsZXRJbnRlcmZhY2UpIHtcbiAgICAgIGlmICh3YWxsZXRJbnRlcmZhY2UpIHtcbiAgICAgICAgdmFsaWRhdGVXYWxsZXRJbnRlcmZhY2Uod2FsbGV0SW50ZXJmYWNlKTtcbiAgICAgIH1cblxuICAgICAgX3NldCh3YWxsZXRJbnRlcmZhY2UpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlV2FsbGV0U3RhdGVTbGljZVN0b3JlKG9wdGlvbnMpIHtcbiAgdmFyIHBhcmFtZXRlciA9IG9wdGlvbnMucGFyYW1ldGVyLFxuICAgICAgaW5pdGlhbFN0YXRlID0gb3B0aW9ucy5pbml0aWFsU3RhdGUsXG4gICAgICBpbnRlcnZhbFNldHRpbmcgPSBvcHRpb25zLmludGVydmFsU2V0dGluZztcblxuICB2YXIgX3dyaXRhYmxlMiA9IHdyaXRhYmxlKGluaXRpYWxTdGF0ZSksXG4gICAgICBzdWJzY3JpYmUgPSBfd3JpdGFibGUyLnN1YnNjcmliZSxcbiAgICAgIHNldCA9IF93cml0YWJsZTIuc2V0O1xuXG4gIHZhciBjdXJyZW50U3RhdGU7XG4gIHN1YnNjcmliZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICBjdXJyZW50U3RhdGUgPSBzdG9yZTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgc3Vic2NyaWJlOiBzdWJzY3JpYmUsXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgc2V0KHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50U3RhdGU7XG4gICAgfSxcbiAgICBzZXRTdGF0ZVN5bmNlcjogZnVuY3Rpb24gc2V0U3RhdGVTeW5jZXIoc3RhdGVTeW5jZXIpIHtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6ICdzdGF0ZVN5bmNlcicsXG4gICAgICAgIHZhbHVlOiBzdGF0ZVN5bmNlcixcbiAgICAgICAgdHlwZTogJ29iamVjdCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGdldCA9IHN0YXRlU3luY2VyLmdldCxcbiAgICAgICAgICBvbkNoYW5nZSA9IHN0YXRlU3luY2VyLm9uQ2hhbmdlO1xuICAgICAgdmFsaWRhdGVUeXBlKHtcbiAgICAgICAgbmFtZTogXCJcIi5jb25jYXQocGFyYW1ldGVyLCBcIi5nZXRcIiksXG4gICAgICAgIHZhbHVlOiBnZXQsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6IFwiXCIuY29uY2F0KHBhcmFtZXRlciwgXCIub25DaGFuZ2VcIiksXG4gICAgICAgIHZhbHVlOiBvbkNoYW5nZSxcbiAgICAgICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgb3B0aW9uYWw6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgICAgc3RhdGVTeW5jU3RhdHVzW3BhcmFtZXRlcl0gPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIG9uQ2hhbmdlKGZ1bmN0aW9uIChuZXdWYWwpIHtcbiAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcblxuICAgICAgICAgICAgaWYgKG5ld1ZhbCB8fCBjdXJyZW50U3RhdGUgIT09IGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgICBzZXQobmV3VmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldCkge1xuICAgICAgICB2YXIgaW50ZXJ2YWwgPSBjcmVhdGVJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgc3RhdGVTeW5jU3RhdHVzW3BhcmFtZXRlcl0gPSBnZXQoKS50aGVuKGZ1bmN0aW9uIChuZXdWYWwpIHtcbiAgICAgICAgICAgIHN0YXRlU3luY1N0YXR1c1twYXJhbWV0ZXJdID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKG5ld1ZhbCB8fCBjdXJyZW50U3RhdGUgIT09IGluaXRpYWxTdGF0ZSkge1xuICAgICAgICAgICAgICBpbnRlcnZhbC5zdGF0dXMuYWN0aXZlICYmIHNldChuZXdWYWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRXJyb3IgZ2V0dGluZyBcIi5jb25jYXQocGFyYW1ldGVyLCBcIiBmcm9tIHN0YXRlIHN5bmNlcjogXCIpLmNvbmNhdChlcnIpKTtcbiAgICAgICAgICAgIHN0YXRlU3luY1N0YXR1c1twYXJhbWV0ZXJdID0gbnVsbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaW50ZXJ2YWxTZXR0aW5nIHx8IDIwMCk7XG4gICAgICAgIHJldHVybiBpbnRlcnZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhbGFuY2VTdG9yZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIHN0YXRlU3luY2VyO1xuICB2YXIgZW1pdHRlcjtcbiAgdmFyIGVtaXR0ZXJBZGRyZXNzO1xuXG4gIHZhciBjYW5jZWwgPSBmdW5jdGlvbiBjYW5jZWwoKSB7fTtcblxuICB2YXIgX2Rlcml2ZWQgPSBkZXJpdmVkKFthZGRyZXNzLCBuZXR3b3JrXSwgZnVuY3Rpb24gKF9yZWY3LCBzZXQpIHtcbiAgICB2YXIgX3JlZjggPSBfc2xpY2VkVG9BcnJheShfcmVmNywgMiksXG4gICAgICAgICRhZGRyZXNzID0gX3JlZjhbMF0sXG4gICAgICAgICRuZXR3b3JrID0gX3JlZjhbMV07XG5cbiAgICBpZiAoc3RhdGVTeW5jZXIgJiYgIXN0YXRlU3luY2VyLm9uQ2hhbmdlKSB7XG4gICAgICBpZiAoJGFkZHJlc3MgJiYgJG5ldHdvcmsgJiYgc3RhdGVTeW5jZXIuZ2V0ICYmIHNldCkge1xuICAgICAgICBjYW5jZWwgPSBzeW5jU3RhdGVXaXRoVGltZW91dCh7XG4gICAgICAgICAgZ2V0U3RhdGU6IHN0YXRlU3luY2VyLmdldCxcbiAgICAgICAgICBzZXRTdGF0ZTogc2V0LFxuICAgICAgICAgIHRpbWVvdXQ6IDIwMDAsXG4gICAgICAgICAgY3VycmVudEJhbGFuY2U6IGdldF9zdG9yZV92YWx1ZShiYWxhbmNlKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZW1pdHRlckFkZHJlc3MgIT09ICRhZGRyZXNzKSB7XG4gICAgICAgICAgdmFyIF9ibG9ja25hdGl2ZTIgPSBnZXRCbG9ja25hdGl2ZSgpOyAvLyB1bnN1YnNjcmliZSBmcm9tIHByZXZpb3VzIGFkZHJlc3NcblxuXG4gICAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBwcmV2aW91cyBhZGRyZXNzXG4gICAgICAgICAgaWYgKGVtaXR0ZXJBZGRyZXNzKSB7XG4gICAgICAgICAgICBfYmxvY2tuYXRpdmUyLnVuc3Vic2NyaWJlKGVtaXR0ZXJBZGRyZXNzKTtcbiAgICAgICAgICB9IC8vIHN1YnNjcmliZSB0byBuZXcgYWRkcmVzcyBhbmQgZmlsdGVyIHRvIGp1c3QgY29uZmlybWVkIHN0YXR1c1xuXG5cbiAgICAgICAgICAvLyBzdWJzY3JpYmUgdG8gbmV3IGFkZHJlc3MgYW5kIGZpbHRlciB0byBqdXN0IGNvbmZpcm1lZCBzdGF0dXNcbiAgICAgICAgICBfYmxvY2tuYXRpdmUyLmNvbmZpZ3VyYXRpb24oe1xuICAgICAgICAgICAgc2NvcGU6ICRhZGRyZXNzLFxuICAgICAgICAgICAgZmlsdGVyczogW3tcbiAgICAgICAgICAgICAgc3RhdHVzOiAnY29uZmlybWVkJ1xuICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB3YXRjaEFkZHJlc3M6IHRydWVcbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIgPSByZXN1bHQuZW1pdHRlcjtcbiAgICAgICAgICAgIGVtaXR0ZXIub24oJ3R4Q29uZmlybWVkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoc3RhdGVTeW5jZXIuZ2V0KSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsID0gc3luY1N0YXRlV2l0aFRpbWVvdXQoe1xuICAgICAgICAgICAgICAgICAgZ2V0U3RhdGU6IHN0YXRlU3luY2VyLmdldCxcbiAgICAgICAgICAgICAgICAgIHNldFN0YXRlOiBzZXQsXG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiAyMDAwLFxuICAgICAgICAgICAgICAgICAgY3VycmVudEJhbGFuY2U6IGdldF9zdG9yZV92YWx1ZShiYWxhbmNlKSxcbiAgICAgICAgICAgICAgICAgIHBvbGxTdGFydDogRGF0ZS5ub3coKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBlbWl0dGVyQWRkcmVzcyA9ICRhZGRyZXNzO1xuICAgICAgICAgIH0pIC8vIHN3YWxsb3cgcG9zc2libGUgdGltZW91dCBlcnJvciBmb3Igc2VuZGluZyBjb25maWd1cmF0aW9uXG4gICAgICAgICAgW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKCkge30pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGVtaXR0ZXJBZGRyZXNzICYmICEkYWRkcmVzcykge1xuICAgICAgICB2YXIgX2Jsb2NrbmF0aXZlMyA9IGdldEJsb2NrbmF0aXZlKCk7IC8vIHVuc3Vic2NyaWJlIGZyb20gcHJldmlvdXMgYWRkcmVzc1xuXG5cbiAgICAgICAgLy8gdW5zdWJzY3JpYmUgZnJvbSBwcmV2aW91cyBhZGRyZXNzXG4gICAgICAgIF9ibG9ja25hdGl2ZTMudW5zdWJzY3JpYmUoZW1pdHRlckFkZHJlc3MpOyAvLyBubyBhZGRyZXNzLCBzbyBzZXQgYmFsYW5jZSB0byB1bmRlZmluZWRcblxuXG4gICAgICAgIC8vIG5vIGFkZHJlc3MsIHNvIHNldCBiYWxhbmNlIHRvIHVuZGVmaW5lZFxuICAgICAgICBzZXQgJiYgc2V0KHVuZGVmaW5lZCk7XG4gICAgICAgIGVtaXR0ZXJBZGRyZXNzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNldChpbml0aWFsU3RhdGUpO1xuICB9KSxcbiAgICAgIHN1YnNjcmliZSA9IF9kZXJpdmVkLnN1YnNjcmliZTtcblxuICB2YXIgY3VycmVudFN0YXRlO1xuICBzdWJzY3JpYmUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgY3VycmVudFN0YXRlID0gc3RvcmU7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHN1YnNjcmliZTogc3Vic2NyaWJlLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRTdGF0ZTtcbiAgICB9LFxuICAgIHNldFN0YXRlU3luY2VyOiBmdW5jdGlvbiBzZXRTdGF0ZVN5bmNlcihzeW5jZXIpIHtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6ICdzeW5jZXInLFxuICAgICAgICB2YWx1ZTogc3luY2VyLFxuICAgICAgICB0eXBlOiAnb2JqZWN0J1xuICAgICAgfSk7XG4gICAgICB2YXIgZ2V0ID0gc3luY2VyLmdldCxcbiAgICAgICAgICBvbkNoYW5nZSA9IHN5bmNlci5vbkNoYW5nZTtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6ICdiYWxhbmNlLmdldCcsXG4gICAgICAgIHZhbHVlOiBnZXQsXG4gICAgICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgICB9KTtcbiAgICAgIHZhbGlkYXRlVHlwZSh7XG4gICAgICAgIG5hbWU6ICdiYWxhbmNlLm9uQ2hhbmdlJyxcbiAgICAgICAgdmFsdWU6IG9uQ2hhbmdlLFxuICAgICAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBzdGF0ZVN5bmNlciA9IHN5bmNlcjtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcbiAgICByZXNldDogY2FuY2VsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHN5bmNTdGF0ZVdpdGhUaW1lb3V0KG9wdGlvbnMpIHtcbiAgdmFyIGdldFN0YXRlID0gb3B0aW9ucy5nZXRTdGF0ZSxcbiAgICAgIHNldFN0YXRlID0gb3B0aW9ucy5zZXRTdGF0ZSxcbiAgICAgIHRpbWVvdXQgPSBvcHRpb25zLnRpbWVvdXQsXG4gICAgICBjdXJyZW50QmFsYW5jZSA9IG9wdGlvbnMuY3VycmVudEJhbGFuY2UsXG4gICAgICBwb2xsU3RhcnQgPSBvcHRpb25zLnBvbGxTdGFydDtcblxuICBpZiAocG9sbFN0YXJ0ICYmIERhdGUubm93KCkgLSBwb2xsU3RhcnQgPiAyNTAwMCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7fTtcbiAgfVxuXG4gIHZhciBwcm9tID0gbWFrZUNhbmNlbGFibGUoZ2V0U3RhdGUoKSk7XG4gIHN0YXRlU3luY1N0YXR1cy5iYWxhbmNlID0gcHJvbTtcbiAgcHJvbS50aGVuKCAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcmVmOSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMocmVzdWx0KSB7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IGN1cnJlbnRCYWxhbmNlICYmIHBvbGxTdGFydCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB3YWl0JDEoMzUwKTtcblxuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBzeW5jU3RhdGVXaXRoVGltZW91dChvcHRpb25zKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBzdGF0ZVN5bmNTdGF0dXMuYmFsYW5jZSA9IG51bGw7XG4gICAgICAgICAgICAgIHNldFN0YXRlKHJlc3VsdCk7XG5cbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMyk7XG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfeDMpIHtcbiAgICAgIHJldHVybiBfcmVmOS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0oKSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgc3RhdGVTeW5jU3RhdHVzLmJhbGFuY2UgPSBudWxsO1xuICB9KTtcbiAgdmFyIHRpbWVkT3V0ID0gd2FpdCQxKHRpbWVvdXQpO1xuICB0aW1lZE91dC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBwcm9tLmNhbmNlbCgpO1xuICB9KTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJvbS5jYW5jZWwoKTtcbiAgfTtcbn1cbi8qIHNyYy9lbGVtZW50cy9CcmFuZGluZy5zdmVsdGUgZ2VuZXJhdGVkIGJ5IFN2ZWx0ZSB2My4zOC4yICovXG5cblxuZnVuY3Rpb24gYWRkX2NzcygpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLTE1bTl1cDYtc3R5bGVcIjtcbiAgc3R5bGUudGV4dENvbnRlbnQgPSBcIi5ibi1icmFuZGluZy5zdmVsdGUtMTVtOXVwNntmb250LXNpemU6MC43NXJlbTtmb250LWZhbWlseTppbmhlcml0O21hcmdpbjowLjRyZW07ZGlzcGxheTpmbGV4O2p1c3RpZnktY29udGVudDpjZW50ZXI7d2lkdGg6MTAwJTthbGlnbi1pdGVtczpjZW50ZXJ9c3Bhbi5zdmVsdGUtMTVtOXVwNntvcGFjaXR5OjAuM31hLnN2ZWx0ZS0xNW05dXA2e2NvbG9yOmluaGVyaXQ7ZGlzcGxheTpmbGV4O21hcmdpbi1sZWZ0OjAuMjVyZW07YWxpZ24taXRlbXM6Y2VudGVyfS5ibi1sb2dvLnN2ZWx0ZS0xNW05dXA2e2hlaWdodDoxLjFyZW07bWFyZ2luLWxlZnQ6MC4yNXJlbTttYXJnaW4tYm90dG9tOjAuMXJlbX1zdmcuc3ZlbHRlLTE1bTl1cDZ7aGVpZ2h0OjEwMCU7d2lkdGg6YXV0b31cIjtcbiAgYXBwZW5kKGRvY3VtZW50LmhlYWQsIHN0eWxlKTtcbn0gLy8gKDgxOjYpIHs6ZWxzZX1cblxuXG5mdW5jdGlvbiBjcmVhdGVfZWxzZV9ibG9jayhjdHgpIHtcbiAgdmFyIHN2ZztcbiAgdmFyIGc7XG4gIHZhciBwYXRoMDtcbiAgdmFyIHBhdGgxO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBzdmcgPSBzdmdfZWxlbWVudChcInN2Z1wiKTtcbiAgICAgIGcgPSBzdmdfZWxlbWVudChcImdcIik7XG4gICAgICBwYXRoMCA9IHN2Z19lbGVtZW50KFwicGF0aFwiKTtcbiAgICAgIHBhdGgxID0gc3ZnX2VsZW1lbnQoXCJwYXRoXCIpO1xuICAgICAgYXR0cihwYXRoMCwgXCJkXCIsIFwibTEuMzU0NzM2NTQgMjUuMjY5NTI2OFxcbiAgICAgICAgICAgICAgNDEuNjg1MTU3ODYtMjQuMjE3NzE3OTJjLjU2NDcwNDQtLjMyODA3NDgyIDEuMjYxOTgzNi0uMzI4MDc3OTVcXG4gICAgICAgICAgICAgIDEuODI2NjkwOS0uMDAwMDA4MjFsMTkuOTI3NTAxM1xcbiAgICAgICAgICAgICAgMTEuNTc2OTg5MjNjLjU2MzU5MzguMzI3NDIyOC45MDg4MDI2LjkzMTQ4MjYuOTA0ODA5NFxcbiAgICAgICAgICAgICAgMS41ODMyNzA3bC0uMTUwMTExMiAyNC41MDE3NzU2IDIwLjg0NzI3MTZcXG4gICAgICAgICAgICAgIDEyLjExMTMzNDhjLjU2MDE1MjUuMzI1NDIzNi45MDQ4NDM0LjkyNDMxMTEuOTA0ODQzNFxcbiAgICAgICAgICAgICAgMS41NzIxMzE3djQ4LjQ1NjAxMjNjMCAuNjQ3ODI1LS4zNDQ2OTUzIDEuMjQ2NzE1LS45MDQ4NTM3XFxuICAgICAgICAgICAgICAxLjU3MjEzOGwtNDEuNjgzNTA5MlxcbiAgICAgICAgICAgICAgMjQuMjE1ODk1Yy0uNTY1NTczMS4zMjg1NjctMS4yNjQwNDQ4LjMyODAyMy0xLjgyOTEwNTItLjAwMTQyNmwtNDEuNTMxMTE5Ny0yNC4yMTQwMWMtLjU1ODc3NjQtLjMyNTc4NS0uOTAyNDA0NzYtLjkyMzg5OS0uOTAyNDA0NzYtMS41NzA3MTJ2LTQ5LjUwNTI1OC0yNC41MDgyOTE3YzAtLjY0NzgxNDcuMzQ0Njg0NzMtMS4yNDY2OTc4LjkwNDgyOTMtMS41NzIxMjM1elwiKTtcbiAgICAgIGF0dHIocGF0aDEsIFwiZFwiLCBcIm0yMi4wNDI4NDUxIDExNC40NDI4MjR2LTI1LjI3MzExNDFsLTIxLjU5Mjg0Nzg4LTEyLjU0NDkzODhcXG4gICAgICAgICAgICAgIDQyLjc1MDE0Mjg4IDI0LjY1NTE5MDljLjU2NDg1MDcuMzI1NzY1IDEuMjYwODk4LjMyNDEwOVxcbiAgICAgICAgICAgICAgMS44MjQxOTI2LS4wMDQzMzlsNDIuMjc2NjU3MS0yNC42NTA4NTE5LTIxLjU5NTU0NzNcXG4gICAgICAgICAgICAgIDEyLjYzNzAwODR2LTI0LjIyNDgyNzZjMC0uNjQ4ODAxMi0uMzQ1NzI2Ni0xLjI0ODQ0MDUtLjkwNzIxODctMS41NzM1MDkybC0yMC45MjIyODA0LTEyLjExMjY4ODNcXG4gICAgICAgICAgICAgIDIxLjY3MjkzMTQtMTIuNjM3MDA4NC00Mi40NTI1OTU4XFxuICAgICAgICAgICAgICAyNC40NzYzMzUyYy0uNTU0NTE1OS4zMTk3MDk5LTEuMjM2ODY1LjMyMTg5MDItMS43OTM0MTI3LjAwNTczMDNsLTIwLjg1Mjg2OTA4LTExLjg0NTk1OThcIik7XG4gICAgICBzZXRfc3R5bGUoZywgXCJzdHJva2VcIiwgXCIjMDAwXCIpO1xuICAgICAgc2V0X3N0eWxlKGcsIFwic3Ryb2tlLXdpZHRoXCIsIFwiMi43MDc5M1wiKTtcbiAgICAgIHNldF9zdHlsZShnLCBcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgc2V0X3N0eWxlKGcsIFwiZmlsbC1ydWxlXCIsIFwiZXZlbm9kZFwiKTtcbiAgICAgIHNldF9zdHlsZShnLCBcInN0cm9rZS1saW5lY2FwXCIsIFwicm91bmRcIik7XG4gICAgICBzZXRfc3R5bGUoZywgXCJzdHJva2UtbGluZWpvaW5cIiwgXCJyb3VuZFwiKTtcbiAgICAgIGF0dHIoZywgXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMS44MTgxODIgLjkwOTA5MSlcIik7XG4gICAgICBhdHRyKHN2ZywgXCJoZWlnaHRcIiwgXCIxMzBcIik7XG4gICAgICBhdHRyKHN2ZywgXCJ2aWV3Qm94XCIsIFwiMCAwIDkxIDEzMFwiKTtcbiAgICAgIGF0dHIoc3ZnLCBcIndpZHRoXCIsIFwiOTFcIik7XG4gICAgICBhdHRyKHN2ZywgXCJ4bWxuc1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpO1xuICAgICAgYXR0cihzdmcsIFwiY2xhc3NcIiwgXCJzdmVsdGUtMTVtOXVwNlwiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIHN2ZywgYW5jaG9yKTtcbiAgICAgIGFwcGVuZChzdmcsIGcpO1xuICAgICAgYXBwZW5kKGcsIHBhdGgwKTtcbiAgICAgIGFwcGVuZChnLCBwYXRoMSk7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHN2Zyk7XG4gICAgfVxuICB9O1xufSAvLyAoNDk6NikgeyNpZiBkYXJrTW9kZX1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2soY3R4KSB7XG4gIHZhciBzdmc7XG4gIHZhciBnO1xuICB2YXIgcGF0aDA7XG4gIHZhciBwYXRoMTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgc3ZnID0gc3ZnX2VsZW1lbnQoXCJzdmdcIik7XG4gICAgICBnID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgcGF0aDAgPSBzdmdfZWxlbWVudChcInBhdGhcIik7XG4gICAgICBwYXRoMSA9IHN2Z19lbGVtZW50KFwicGF0aFwiKTtcbiAgICAgIGF0dHIocGF0aDAsIFwiZFwiLCBcIm0xLjM1NDczNjU0IDI1LjI2OTUyNjhcXG4gICAgICAgICAgICAgIDQxLjY4NTE1Nzg2LTI0LjIxNzcxNzkyYy41NjQ3MDQ0LS4zMjgwNzQ4MiAxLjI2MTk4MzYtLjMyODA3Nzk1XFxuICAgICAgICAgICAgICAxLjgyNjY5MDktLjAwMDAwODIxbDE5LjkyNzUwMTNcXG4gICAgICAgICAgICAgIDExLjU3Njk4OTIzYy41NjM1OTM4LjMyNzQyMjguOTA4ODAyNi45MzE0ODI2LjkwNDgwOTRcXG4gICAgICAgICAgICAgIDEuNTgzMjcwN2wtLjE1MDExMTIgMjQuNTAxNzc1NiAyMC44NDcyNzE2XFxuICAgICAgICAgICAgICAxMi4xMTEzMzQ4Yy41NjAxNTI1LjMyNTQyMzYuOTA0ODQzNC45MjQzMTExLjkwNDg0MzRcXG4gICAgICAgICAgICAgIDEuNTcyMTMxN3Y0OC40NTYwMTIzYzAgLjY0NzgyNS0uMzQ0Njk1MyAxLjI0NjcxNS0uOTA0ODUzN1xcbiAgICAgICAgICAgICAgMS41NzIxMzhsLTQxLjY4MzUwOTJcXG4gICAgICAgICAgICAgIDI0LjIxNTg5NWMtLjU2NTU3MzEuMzI4NTY3LTEuMjY0MDQ0OC4zMjgwMjMtMS44MjkxMDUyLS4wMDE0MjZsLTQxLjUzMTExOTctMjQuMjE0MDFjLS41NTg3NzY0LS4zMjU3ODUtLjkwMjQwNDc2LS45MjM4OTktLjkwMjQwNDc2LTEuNTcwNzEydi00OS41MDUyNTgtMjQuNTA4MjkxN2MwLS42NDc4MTQ3LjM0NDY4NDczLTEuMjQ2Njk3OC45MDQ4MjkzLTEuNTcyMTIzNXpcIik7XG4gICAgICBhdHRyKHBhdGgxLCBcImRcIiwgXCJtMjIuMDQyODQ1MSAxMTQuNDQyODI0di0yNS4yNzMxMTQxbC0yMS41OTI4NDc4OC0xMi41NDQ5Mzg4XFxuICAgICAgICAgICAgICA0Mi43NTAxNDI4OCAyNC42NTUxOTA5Yy41NjQ4NTA3LjMyNTc2NSAxLjI2MDg5OC4zMjQxMDlcXG4gICAgICAgICAgICAgIDEuODI0MTkyNi0uMDA0MzM5bDQyLjI3NjY1NzEtMjQuNjUwODUxOS0yMS41OTU1NDczXFxuICAgICAgICAgICAgICAxMi42MzcwMDg0di0yNC4yMjQ4Mjc2YzAtLjY0ODgwMTItLjM0NTcyNjYtMS4yNDg0NDA1LS45MDcyMTg3LTEuNTczNTA5MmwtMjAuOTIyMjgwNC0xMi4xMTI2ODgzXFxuICAgICAgICAgICAgICAyMS42NzI5MzE0LTEyLjYzNzAwODQtNDIuNDUyNTk1OFxcbiAgICAgICAgICAgICAgMjQuNDc2MzM1MmMtLjU1NDUxNTkuMzE5NzA5OS0xLjIzNjg2NS4zMjE4OTAyLTEuNzkzNDEyNy4wMDU3MzAzbC0yMC44NTI4NjkwOC0xMS44NDU5NTk4XCIpO1xuICAgICAgc2V0X3N0eWxlKGcsIFwic3Ryb2tlXCIsIFwiI2ZmZlwiKTtcbiAgICAgIHNldF9zdHlsZShnLCBcInN0cm9rZS13aWR0aFwiLCBcIjIuNzA3OTNcIik7XG4gICAgICBzZXRfc3R5bGUoZywgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgIHNldF9zdHlsZShnLCBcImZpbGwtcnVsZVwiLCBcImV2ZW5vZGRcIik7XG4gICAgICBzZXRfc3R5bGUoZywgXCJzdHJva2UtbGluZWNhcFwiLCBcInJvdW5kXCIpO1xuICAgICAgc2V0X3N0eWxlKGcsIFwic3Ryb2tlLWxpbmVqb2luXCIsIFwicm91bmRcIik7XG4gICAgICBhdHRyKGcsIFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDEuODE4MTgyIC45MDkwOTEpXCIpO1xuICAgICAgYXR0cihzdmcsIFwiaGVpZ2h0XCIsIFwiMTMwXCIpO1xuICAgICAgYXR0cihzdmcsIFwidmlld0JveFwiLCBcIjAgMCA5MSAxMzBcIik7XG4gICAgICBhdHRyKHN2ZywgXCJ3aWR0aFwiLCBcIjkxXCIpO1xuICAgICAgYXR0cihzdmcsIFwieG1sbnNcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiKTtcbiAgICAgIGF0dHIoc3ZnLCBcImNsYXNzXCIsIFwic3ZlbHRlLTE1bTl1cDZcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBzdmcsIGFuY2hvcik7XG4gICAgICBhcHBlbmQoc3ZnLCBnKTtcbiAgICAgIGFwcGVuZChnLCBwYXRoMCk7XG4gICAgICBhcHBlbmQoZywgcGF0aDEpO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChzdmcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50KGN0eCkge1xuICB2YXIgZGl2MTtcbiAgdmFyIHNwYW4wO1xuICB2YXIgdDE7XG4gIHZhciBhO1xuICB2YXIgc3BhbjE7XG4gIHZhciB0MztcbiAgdmFyIGRpdjA7XG5cbiAgZnVuY3Rpb24gc2VsZWN0X2Jsb2NrX3R5cGUoY3R4LCBkaXJ0eSkge1xuICAgIGlmIChcbiAgICAvKmRhcmtNb2RlKi9cbiAgICBjdHhbMF0pIHJldHVybiBjcmVhdGVfaWZfYmxvY2s7XG4gICAgcmV0dXJuIGNyZWF0ZV9lbHNlX2Jsb2NrO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRfYmxvY2tfdHlwZSA9IHNlbGVjdF9ibG9ja190eXBlKGN0eCk7XG4gIHZhciBpZl9ibG9jayA9IGN1cnJlbnRfYmxvY2tfdHlwZShjdHgpO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBkaXYxID0gZWxlbWVudChcImRpdlwiKTtcbiAgICAgIHNwYW4wID0gZWxlbWVudChcInNwYW5cIik7XG4gICAgICBzcGFuMC50ZXh0Q29udGVudCA9IFwiUG93ZXJlZCBieVwiO1xuICAgICAgdDEgPSBzcGFjZSgpO1xuICAgICAgYSA9IGVsZW1lbnQoXCJhXCIpO1xuICAgICAgc3BhbjEgPSBlbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4xLnRleHRDb250ZW50ID0gXCJCbG9ja25hdGl2ZVwiO1xuICAgICAgdDMgPSBzcGFjZSgpO1xuICAgICAgZGl2MCA9IGVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBpZl9ibG9jay5jKCk7XG4gICAgICBhdHRyKHNwYW4wLCBcImNsYXNzXCIsIFwic3ZlbHRlLTE1bTl1cDZcIik7XG4gICAgICBhdHRyKHNwYW4xLCBcImNsYXNzXCIsIFwic3ZlbHRlLTE1bTl1cDZcIik7XG4gICAgICBhdHRyKGRpdjAsIFwiY2xhc3NcIiwgXCJibi1sb2dvIHN2ZWx0ZS0xNW05dXA2XCIpO1xuICAgICAgYXR0cihhLCBcImhyZWZcIiwgXCJodHRwczovL2h1YnMubHkvSDBxaDJnMTBcIik7XG4gICAgICBhdHRyKGEsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWNsaWNrYWJsZSBzdmVsdGUtMTVtOXVwNlwiKTtcbiAgICAgIGF0dHIoYSwgXCJ0YXJnZXRcIiwgXCJfYmxhbmtcIik7XG4gICAgICBhdHRyKGEsIFwicmVsXCIsIFwibm9vcGVuZXIgbm9yZWZlcnJlclwiKTtcbiAgICAgIGF0dHIoZGl2MSwgXCJjbGFzc1wiLCBcImJuLWJyYW5kaW5nIHN2ZWx0ZS0xNW05dXA2XCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgZGl2MSwgYW5jaG9yKTtcbiAgICAgIGFwcGVuZChkaXYxLCBzcGFuMCk7XG4gICAgICBhcHBlbmQoZGl2MSwgdDEpO1xuICAgICAgYXBwZW5kKGRpdjEsIGEpO1xuICAgICAgYXBwZW5kKGEsIHNwYW4xKTtcbiAgICAgIGFwcGVuZChhLCB0Myk7XG4gICAgICBhcHBlbmQoYSwgZGl2MCk7XG4gICAgICBpZl9ibG9jay5tKGRpdjAsIG51bGwpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIF9yZWYxMCkge1xuICAgICAgdmFyIF9yZWYxMSA9IF9zbGljZWRUb0FycmF5KF9yZWYxMCwgMSksXG4gICAgICAgICAgZGlydHkgPSBfcmVmMTFbMF07XG5cbiAgICAgIGlmIChjdXJyZW50X2Jsb2NrX3R5cGUgIT09IChjdXJyZW50X2Jsb2NrX3R5cGUgPSBzZWxlY3RfYmxvY2tfdHlwZShjdHgpKSkge1xuICAgICAgICBpZl9ibG9jay5kKDEpO1xuICAgICAgICBpZl9ibG9jayA9IGN1cnJlbnRfYmxvY2tfdHlwZShjdHgpO1xuXG4gICAgICAgIGlmIChpZl9ibG9jaykge1xuICAgICAgICAgIGlmX2Jsb2NrLmMoKTtcbiAgICAgICAgICBpZl9ibG9jay5tKGRpdjAsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBub29wLFxuICAgIG86IG5vb3AsXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChkaXYxKTtcbiAgICAgIGlmX2Jsb2NrLmQoKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlKCQkc2VsZiwgJCRwcm9wcywgJCRpbnZhbGlkYXRlKSB7XG4gIHZhciBkYXJrTW9kZSA9ICQkcHJvcHMuZGFya01vZGU7XG5cbiAgJCRzZWxmLiQkc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJkYXJrTW9kZVwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgwLCBkYXJrTW9kZSA9ICQkcHJvcHMuZGFya01vZGUpO1xuICB9O1xuXG4gIHJldHVybiBbZGFya01vZGVdO1xufVxuXG52YXIgQnJhbmRpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdmVsdGVDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzKEJyYW5kaW5nLCBfU3ZlbHRlQ29tcG9uZW50KTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKEJyYW5kaW5nKTtcblxuICBmdW5jdGlvbiBCcmFuZGluZyhvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJyYW5kaW5nKTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS0xNW05dXA2LXN0eWxlXCIpKSBhZGRfY3NzKCk7XG4gICAgaW5pdChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgb3B0aW9ucywgaW5zdGFuY2UsIGNyZWF0ZV9mcmFnbWVudCwgc2FmZV9ub3RfZXF1YWwsIHtcbiAgICAgIGRhcmtNb2RlOiAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIEJyYW5kaW5nO1xufShTdmVsdGVDb21wb25lbnQpO1xuLyogc3JjL2NvbXBvbmVudHMvTW9kYWwuc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMzguMiAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MkMSgpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLXJudG9naC1zdHlsZVwiO1xuICBzdHlsZS50ZXh0Q29udGVudCA9IFwiYXNpZGUuc3ZlbHRlLXJudG9naHtkaXNwbGF5OmZsZXg7Zm9udC1mYW1pbHk6J0hlbHZldGljYSBOZXVlJywgJ0hlbHZldGljYScsICdBcmlhbCcsIHNhbnMtc2VyaWY7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7cG9zaXRpb246Zml4ZWQ7Zm9udC1zaXplOjE2cHg7dG9wOjA7bGVmdDowO3dpZHRoOjEwMHZ3O2hlaWdodDoxMDB2aDtiYWNrZ3JvdW5kOnJnYmEoMCwgMCwgMCwgMC4zKX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0MjBweCl7YXNpZGUuc3ZlbHRlLXJudG9naHtmb250LXNpemU6MTRweH19c2VjdGlvbi5zdmVsdGUtcm50b2doe2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpjb250ZW50LWJveDtiYWNrZ3JvdW5kOiNmZmZmZmY7Ym9yZGVyLXJhZGl1czoxMHB4O2JveC1zaGFkb3c6MCAxcHggNXB4IDAgcmdiYSgwLCAwLCAwLCAwLjEpO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7cGFkZGluZzoxLjMzZW07cG9zaXRpb246cmVsYXRpdmU7b3ZlcmZsb3c6aGlkZGVuO21heC13aWR0aDozN2VtO2NvbG9yOiM0YTRhNGF9ZGl2LnN2ZWx0ZS1ybnRvZ2h7aGVpZ2h0OjAuNjZlbTtwb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjAuMjVlbTt0b3A6MS4zM2VtO3JpZ2h0OjEuMzNlbTtmb250LXNpemU6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O2JvcmRlci1yYWRpdXM6NXB4O3RyYW5zaXRpb246YmFja2dyb3VuZCAyMDBtcyBlYXNlLWluLW91dDtkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXJ9ZGl2LnN2ZWx0ZS1ybnRvZ2g6aG92ZXJ7Y3Vyc29yOnBvaW50ZXI7YmFja2dyb3VuZDojZWVlZWVlfXN2Zy5zdmVsdGUtcm50b2doe3dpZHRoOjEwcHg7aGVpZ2h0OjEwcHh9LmJuLW9uYm9hcmQtZGFyay1tb2RlLWNsb3NlLWJhY2tncm91bmQuc3ZlbHRlLXJudG9naDpob3ZlcntiYWNrZ3JvdW5kOiMwMDIyMmN9Lm5vLXBhZGRpbmctYnJhbmRpbmcuc3ZlbHRlLXJudG9naHtwYWRkaW5nLWJvdHRvbTowfVwiO1xuICBhcHBlbmQoZG9jdW1lbnQuaGVhZCwgc3R5bGUpO1xufSAvLyAoOTc6NCkgeyNpZiAkYXBwLmRpc3BsYXlCcmFuZGluZ31cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfMShjdHgpIHtcbiAgdmFyIGJyYW5kaW5nO1xuICB2YXIgY3VycmVudDtcbiAgYnJhbmRpbmcgPSBuZXcgQnJhbmRpbmcoe1xuICAgIHByb3BzOiB7XG4gICAgICBkYXJrTW9kZTpcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbM10uZGFya01vZGVcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KGJyYW5kaW5nLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChicmFuZGluZywgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIHZhciBicmFuZGluZ19jaGFuZ2VzID0ge307XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokYXBwKi9cbiAgICAgIDgpIGJyYW5kaW5nX2NoYW5nZXMuZGFya01vZGUgPVxuICAgICAgLyokYXBwKi9cbiAgICAgIGN0eFszXS5kYXJrTW9kZTtcbiAgICAgIGJyYW5kaW5nLiRzZXQoYnJhbmRpbmdfY2hhbmdlcyk7XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihicmFuZGluZy4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChicmFuZGluZy4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KGJyYW5kaW5nLCBkZXRhY2hpbmcpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDEwMDo0KSB7I2lmIGNsb3NlYWJsZX1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2skMShjdHgpIHtcbiAgdmFyIGRpdjtcbiAgdmFyIHN2ZztcbiAgdmFyIGcwO1xuICB2YXIgcGF0aDtcbiAgdmFyIGcxO1xuICB2YXIgZzI7XG4gIHZhciBnMztcbiAgdmFyIGc0O1xuICB2YXIgZzU7XG4gIHZhciBnNjtcbiAgdmFyIGc3O1xuICB2YXIgZzg7XG4gIHZhciBnOTtcbiAgdmFyIGcxMDtcbiAgdmFyIGcxMTtcbiAgdmFyIGcxMjtcbiAgdmFyIGcxMztcbiAgdmFyIGcxNDtcbiAgdmFyIGcxNTtcbiAgdmFyIHN2Z19maWxsX3ZhbHVlO1xuICB2YXIgbW91bnRlZDtcbiAgdmFyIGRpc3Bvc2U7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGRpdiA9IGVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBzdmcgPSBzdmdfZWxlbWVudChcInN2Z1wiKTtcbiAgICAgIGcwID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgcGF0aCA9IHN2Z19lbGVtZW50KFwicGF0aFwiKTtcbiAgICAgIGcxID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgZzIgPSBzdmdfZWxlbWVudChcImdcIik7XG4gICAgICBnMyA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGc0ID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgZzUgPSBzdmdfZWxlbWVudChcImdcIik7XG4gICAgICBnNiA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGc3ID0gc3ZnX2VsZW1lbnQoXCJnXCIpO1xuICAgICAgZzggPSBzdmdfZWxlbWVudChcImdcIik7XG4gICAgICBnOSA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGcxMCA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGcxMSA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGcxMiA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGcxMyA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGcxNCA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGcxNSA9IHN2Z19lbGVtZW50KFwiZ1wiKTtcbiAgICAgIGF0dHIocGF0aCwgXCJkXCIsIFwiTTI4LjIyOCwyMy45ODZMNDcuMDkyLDUuMTIyYzEuMTcyLTEuMTcxLDEuMTcyLTMuMDcxLDAtNC4yNDJjLTEuMTcyLTEuMTcyLTMuMDctMS4xNzItNC4yNDIsMEwyMy45ODYsMTkuNzQ0TDUuMTIxLDAuODhcXG4gICAgICAgICAgICAgIGMtMS4xNzItMS4xNzItMy4wNy0xLjE3Mi00LjI0MiwwYy0xLjE3MiwxLjE3MS0xLjE3MiwzLjA3MSwwLDQuMjQybDE4Ljg2NSwxOC44NjRMMC44NzksNDIuODVjLTEuMTcyLDEuMTcxLTEuMTcyLDMuMDcxLDAsNC4yNDJcXG4gICAgICAgICAgICAgIEMxLjQ2NSw0Ny42NzcsMi4yMzMsNDcuOTcsMyw0Ny45N3MxLjUzNS0wLjI5MywyLjEyMS0wLjg3OWwxOC44NjUtMTguODY0TDQyLjg1LDQ3LjA5MWMwLjU4NiwwLjU4NiwxLjM1NCwwLjg3OSwyLjEyMSwwLjg3OVxcbiAgICAgICAgICAgICAgczEuNTM1LTAuMjkzLDIuMTIxLTAuODc5YzEuMTcyLTEuMTcxLDEuMTcyLTMuMDcxLDAtNC4yNDJMMjguMjI4LDIzLjk4NnpcIik7XG4gICAgICBhdHRyKHN2ZywgXCJ4bWxuc1wiLCBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIpO1xuICAgICAgYXR0cihzdmcsIFwieG1sbnM6eGxpbmtcIiwgXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIpO1xuICAgICAgYXR0cihzdmcsIFwieFwiLCBcIjBweFwiKTtcbiAgICAgIGF0dHIoc3ZnLCBcInlcIiwgXCIwcHhcIik7XG4gICAgICBhdHRyKHN2ZywgXCJ2aWV3Qm94XCIsIFwiMCAwIDQ3Ljk3MSA0Ny45NzFcIik7XG4gICAgICBzZXRfc3R5bGUoc3ZnLCBcImVuYWJsZS1iYWNrZ3JvdW5kXCIsIFwibmV3IDAgMCA0Ny45NzEgNDcuOTcxXCIpO1xuICAgICAgc2V0X3N0eWxlKHN2ZywgXCJ0cmFuc2l0aW9uXCIsIFwiZmlsbCAxNTBtc1xcbiAgICAgICAgICBlYXNlLWluLW91dFwiKTtcbiAgICAgIGF0dHIoc3ZnLCBcImZpbGxcIiwgc3ZnX2ZpbGxfdmFsdWUgPVxuICAgICAgLypjbG9zZUhvdmVyZWQqL1xuICAgICAgY3R4WzJdID9cbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbM10uZGFya01vZGUgPyBcIiNmZmZmZmZcIiA6IFwiIzRhNGE0YVwiIDogXCIjOUI5QjlCXCIpO1xuICAgICAgYXR0cihzdmcsIFwieG1sOnNwYWNlXCIsIFwicHJlc2VydmVcIik7XG4gICAgICBhdHRyKHN2ZywgXCJjbGFzc1wiLCBcInN2ZWx0ZS1ybnRvZ2hcIik7XG4gICAgICBhdHRyKGRpdiwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtbW9kYWwtY29udGVudC1jbG9zZSBzdmVsdGUtcm50b2doXCIpO1xuICAgICAgdG9nZ2xlX2NsYXNzKGRpdiwgXCJibi1vbmJvYXJkLWRhcmstbW9kZS1jbG9zZS1iYWNrZ3JvdW5kXCIsXG4gICAgICAvKiRhcHAqL1xuICAgICAgY3R4WzNdLmRhcmtNb2RlKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIGRpdiwgYW5jaG9yKTtcbiAgICAgIGFwcGVuZChkaXYsIHN2Zyk7XG4gICAgICBhcHBlbmQoc3ZnLCBnMCk7XG4gICAgICBhcHBlbmQoZzAsIHBhdGgpO1xuICAgICAgYXBwZW5kKHN2ZywgZzEpO1xuICAgICAgYXBwZW5kKHN2ZywgZzIpO1xuICAgICAgYXBwZW5kKHN2ZywgZzMpO1xuICAgICAgYXBwZW5kKHN2ZywgZzQpO1xuICAgICAgYXBwZW5kKHN2ZywgZzUpO1xuICAgICAgYXBwZW5kKHN2ZywgZzYpO1xuICAgICAgYXBwZW5kKHN2ZywgZzcpO1xuICAgICAgYXBwZW5kKHN2ZywgZzgpO1xuICAgICAgYXBwZW5kKHN2ZywgZzkpO1xuICAgICAgYXBwZW5kKHN2ZywgZzEwKTtcbiAgICAgIGFwcGVuZChzdmcsIGcxMSk7XG4gICAgICBhcHBlbmQoc3ZnLCBnMTIpO1xuICAgICAgYXBwZW5kKHN2ZywgZzEzKTtcbiAgICAgIGFwcGVuZChzdmcsIGcxNCk7XG4gICAgICBhcHBlbmQoc3ZnLCBnMTUpO1xuXG4gICAgICBpZiAoIW1vdW50ZWQpIHtcbiAgICAgICAgZGlzcG9zZSA9IFtsaXN0ZW4oZGl2LCBcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oXG4gICAgICAgICAgLypjbG9zZU1vZGFsKi9cbiAgICAgICAgICBjdHhbMF0pKVxuICAgICAgICAgICAgLypjbG9zZU1vZGFsKi9cbiAgICAgICAgICAgIGN0eFswXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KSwgbGlzdGVuKGRpdiwgXCJtb3VzZWVudGVyXCIsXG4gICAgICAgIC8qbW91c2VlbnRlcl9oYW5kbGVyKi9cbiAgICAgICAgY3R4WzZdKSwgbGlzdGVuKGRpdiwgXCJtb3VzZWxlYXZlXCIsXG4gICAgICAgIC8qbW91c2VsZWF2ZV9oYW5kbGVyKi9cbiAgICAgICAgY3R4WzddKV07XG4gICAgICAgIG1vdW50ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChuZXdfY3R4LCBkaXJ0eSkge1xuICAgICAgY3R4ID0gbmV3X2N0eDtcblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qY2xvc2VIb3ZlcmVkLCAkYXBwKi9cbiAgICAgIDEyICYmIHN2Z19maWxsX3ZhbHVlICE9PSAoc3ZnX2ZpbGxfdmFsdWUgPVxuICAgICAgLypjbG9zZUhvdmVyZWQqL1xuICAgICAgY3R4WzJdID9cbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbM10uZGFya01vZGUgPyBcIiNmZmZmZmZcIiA6IFwiIzRhNGE0YVwiIDogXCIjOUI5QjlCXCIpKSB7XG4gICAgICAgIGF0dHIoc3ZnLCBcImZpbGxcIiwgc3ZnX2ZpbGxfdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokYXBwKi9cbiAgICAgIDgpIHtcbiAgICAgICAgdG9nZ2xlX2NsYXNzKGRpdiwgXCJibi1vbmJvYXJkLWRhcmstbW9kZS1jbG9zZS1iYWNrZ3JvdW5kXCIsXG4gICAgICAgIC8qJGFwcCovXG4gICAgICAgIGN0eFszXS5kYXJrTW9kZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGRpdik7XG4gICAgICBtb3VudGVkID0gZmFsc2U7XG4gICAgICBydW5fYWxsKGRpc3Bvc2UpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50JDEoY3R4KSB7XG4gIHZhciBhc2lkZTtcbiAgdmFyIHNlY3Rpb247XG4gIHZhciB0MDtcbiAgdmFyIHQxO1xuICB2YXIgYXNpZGVfdHJhbnNpdGlvbjtcbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBtb3VudGVkO1xuICB2YXIgZGlzcG9zZTtcbiAgdmFyIGRlZmF1bHRfc2xvdF90ZW1wbGF0ZSA9XG4gIC8qI3Nsb3RzKi9cbiAgY3R4WzVdW1wiZGVmYXVsdFwiXTtcbiAgdmFyIGRlZmF1bHRfc2xvdCA9IGNyZWF0ZV9zbG90KGRlZmF1bHRfc2xvdF90ZW1wbGF0ZSwgY3R4LFxuICAvKiQkc2NvcGUqL1xuICBjdHhbNF0sIG51bGwpO1xuICB2YXIgaWZfYmxvY2swID1cbiAgLyokYXBwKi9cbiAgY3R4WzNdLmRpc3BsYXlCcmFuZGluZyAmJiBjcmVhdGVfaWZfYmxvY2tfMShjdHgpO1xuICB2YXIgaWZfYmxvY2sxID1cbiAgLypjbG9zZWFibGUqL1xuICBjdHhbMV0gJiYgY3JlYXRlX2lmX2Jsb2NrJDEoY3R4KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgYXNpZGUgPSBlbGVtZW50KFwiYXNpZGVcIik7XG4gICAgICBzZWN0aW9uID0gZWxlbWVudChcInNlY3Rpb25cIik7XG4gICAgICBpZiAoZGVmYXVsdF9zbG90KSBkZWZhdWx0X3Nsb3QuYygpO1xuICAgICAgdDAgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMCkgaWZfYmxvY2swLmMoKTtcbiAgICAgIHQxID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5jKCk7XG4gICAgICBhdHRyKHNlY3Rpb24sIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLW1vZGFsLWNvbnRlbnQgc3ZlbHRlLXJudG9naFwiKTtcbiAgICAgIHRvZ2dsZV9jbGFzcyhzZWN0aW9uLCBcImJuLW9uYm9hcmQtZGFyay1tb2RlXCIsXG4gICAgICAvKiRhcHAqL1xuICAgICAgY3R4WzNdLmRhcmtNb2RlKTtcbiAgICAgIHRvZ2dsZV9jbGFzcyhzZWN0aW9uLCBcIm5vLXBhZGRpbmctYnJhbmRpbmdcIixcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbM10uZGlzcGxheUJyYW5kaW5nKTtcbiAgICAgIGF0dHIoYXNpZGUsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLW1vZGFsIHN2ZWx0ZS1ybnRvZ2hcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBhc2lkZSwgYW5jaG9yKTtcbiAgICAgIGFwcGVuZChhc2lkZSwgc2VjdGlvbik7XG5cbiAgICAgIGlmIChkZWZhdWx0X3Nsb3QpIHtcbiAgICAgICAgZGVmYXVsdF9zbG90Lm0oc2VjdGlvbiwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGFwcGVuZChzZWN0aW9uLCB0MCk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAubShzZWN0aW9uLCBudWxsKTtcbiAgICAgIGFwcGVuZChzZWN0aW9uLCB0MSk7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEubShzZWN0aW9uLCBudWxsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoIW1vdW50ZWQpIHtcbiAgICAgICAgZGlzcG9zZSA9IFtsaXN0ZW4oc2VjdGlvbiwgXCJjbGlja1wiLCBjbGlja19oYW5kbGVyKSwgbGlzdGVuKGFzaWRlLCBcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oXG4gICAgICAgICAgLypjbG9zZU1vZGFsKi9cbiAgICAgICAgICBjdHhbMF0pKVxuICAgICAgICAgICAgLypjbG9zZU1vZGFsKi9cbiAgICAgICAgICAgIGN0eFswXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KV07XG4gICAgICAgIG1vdW50ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChuZXdfY3R4LCBfcmVmMTIpIHtcbiAgICAgIHZhciBfcmVmMTMgPSBfc2xpY2VkVG9BcnJheShfcmVmMTIsIDEpLFxuICAgICAgICAgIGRpcnR5ID0gX3JlZjEzWzBdO1xuXG4gICAgICBjdHggPSBuZXdfY3R4O1xuXG4gICAgICBpZiAoZGVmYXVsdF9zbG90KSB7XG4gICAgICAgIGlmIChkZWZhdWx0X3Nsb3QucCAmJiAoIWN1cnJlbnQgfHwgZGlydHkgJlxuICAgICAgICAvKiQkc2NvcGUqL1xuICAgICAgICAxNikpIHtcbiAgICAgICAgICB1cGRhdGVfc2xvdChkZWZhdWx0X3Nsb3QsIGRlZmF1bHRfc2xvdF90ZW1wbGF0ZSwgY3R4LFxuICAgICAgICAgIC8qJCRzY29wZSovXG4gICAgICAgICAgY3R4WzRdLCBkaXJ0eSwgbnVsbCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgLyokYXBwKi9cbiAgICAgIGN0eFszXS5kaXNwbGF5QnJhbmRpbmcpIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrMCkge1xuICAgICAgICAgIGlmX2Jsb2NrMC5wKGN0eCwgZGlydHkpO1xuXG4gICAgICAgICAgaWYgKGRpcnR5ICZcbiAgICAgICAgICAvKiRhcHAqL1xuICAgICAgICAgIDgpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWZfYmxvY2swID0gY3JlYXRlX2lmX2Jsb2NrXzEoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazAuYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swLCAxKTtcbiAgICAgICAgICBpZl9ibG9jazAubShzZWN0aW9uLCB0MSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWZfYmxvY2swKSB7XG4gICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazAsIDEsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZl9ibG9jazAgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgIC8qY2xvc2VhYmxlKi9cbiAgICAgIGN0eFsxXSkge1xuICAgICAgICBpZiAoaWZfYmxvY2sxKSB7XG4gICAgICAgICAgaWZfYmxvY2sxLnAoY3R4LCBkaXJ0eSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWZfYmxvY2sxID0gY3JlYXRlX2lmX2Jsb2NrJDEoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazEuYygpO1xuICAgICAgICAgIGlmX2Jsb2NrMS5tKHNlY3Rpb24sIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICBpZl9ibG9jazEuZCgxKTtcbiAgICAgICAgaWZfYmxvY2sxID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qJGFwcCovXG4gICAgICA4KSB7XG4gICAgICAgIHRvZ2dsZV9jbGFzcyhzZWN0aW9uLCBcImJuLW9uYm9hcmQtZGFyay1tb2RlXCIsXG4gICAgICAgIC8qJGFwcCovXG4gICAgICAgIGN0eFszXS5kYXJrTW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiRhcHAqL1xuICAgICAgOCkge1xuICAgICAgICB0b2dnbGVfY2xhc3Moc2VjdGlvbiwgXCJuby1wYWRkaW5nLWJyYW5kaW5nXCIsXG4gICAgICAgIC8qJGFwcCovXG4gICAgICAgIGN0eFszXS5kaXNwbGF5QnJhbmRpbmcpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4oZGVmYXVsdF9zbG90LCBsb2NhbCk7XG4gICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCk7XG4gICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFhc2lkZV90cmFuc2l0aW9uKSBhc2lkZV90cmFuc2l0aW9uID0gY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbihhc2lkZSwgZmFkZSwge30sIHRydWUpO1xuICAgICAgICBhc2lkZV90cmFuc2l0aW9uLnJ1bigxKTtcbiAgICAgIH0pO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChkZWZhdWx0X3Nsb3QsIGxvY2FsKTtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMCk7XG4gICAgICBpZiAoIWFzaWRlX3RyYW5zaXRpb24pIGFzaWRlX3RyYW5zaXRpb24gPSBjcmVhdGVfYmlkaXJlY3Rpb25hbF90cmFuc2l0aW9uKGFzaWRlLCBmYWRlLCB7fSwgZmFsc2UpO1xuICAgICAgYXNpZGVfdHJhbnNpdGlvbi5ydW4oMCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGFzaWRlKTtcbiAgICAgIGlmIChkZWZhdWx0X3Nsb3QpIGRlZmF1bHRfc2xvdC5kKGRldGFjaGluZyk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAuZCgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLmQoKTtcbiAgICAgIGlmIChkZXRhY2hpbmcgJiYgYXNpZGVfdHJhbnNpdGlvbikgYXNpZGVfdHJhbnNpdGlvbi5lbmQoKTtcbiAgICAgIG1vdW50ZWQgPSBmYWxzZTtcbiAgICAgIHJ1bl9hbGwoZGlzcG9zZSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgY2xpY2tfaGFuZGxlciA9IGZ1bmN0aW9uIGNsaWNrX2hhbmRsZXIoZSkge1xuICByZXR1cm4gZS5zdG9wUHJvcGFnYXRpb24oKTtcbn07XG5cbmZ1bmN0aW9uIGluc3RhbmNlJDEoJCRzZWxmLCAkJHByb3BzLCAkJGludmFsaWRhdGUpIHtcbiAgdmFyICRhcHA7XG4gIGNvbXBvbmVudF9zdWJzY3JpYmUoJCRzZWxmLCBhcHAsIGZ1bmN0aW9uICgkJHZhbHVlKSB7XG4gICAgcmV0dXJuICQkaW52YWxpZGF0ZSgzLCAkYXBwID0gJCR2YWx1ZSk7XG4gIH0pO1xuICB2YXIgXyQkcHJvcHMkJCRzbG90cyA9ICQkcHJvcHMuJCRzbG90cyxcbiAgICAgIHNsb3RzID0gXyQkcHJvcHMkJCRzbG90cyA9PT0gdm9pZCAwID8ge30gOiBfJCRwcm9wcyQkJHNsb3RzLFxuICAgICAgJCRzY29wZSA9ICQkcHJvcHMuJCRzY29wZTtcbiAgdmFyIF8kJHByb3BzJGNsb3NlTW9kYWwgPSAkJHByb3BzLmNsb3NlTW9kYWwsXG4gICAgICBjbG9zZU1vZGFsID0gXyQkcHJvcHMkY2xvc2VNb2RhbCA9PT0gdm9pZCAwID8gZnVuY3Rpb24gKCkge30gOiBfJCRwcm9wcyRjbG9zZU1vZGFsO1xuICB2YXIgXyQkcHJvcHMkY2xvc2VhYmxlID0gJCRwcm9wcy5jbG9zZWFibGUsXG4gICAgICBjbG9zZWFibGUgPSBfJCRwcm9wcyRjbG9zZWFibGUgPT09IHZvaWQgMCA/IHRydWUgOiBfJCRwcm9wcyRjbG9zZWFibGU7XG4gIHZhciBjbG9zZUhvdmVyZWQ7XG5cbiAgdmFyIG1vdXNlZW50ZXJfaGFuZGxlciA9IGZ1bmN0aW9uIG1vdXNlZW50ZXJfaGFuZGxlcigpIHtcbiAgICByZXR1cm4gJCRpbnZhbGlkYXRlKDIsIGNsb3NlSG92ZXJlZCA9IHRydWUpO1xuICB9O1xuXG4gIHZhciBtb3VzZWxlYXZlX2hhbmRsZXIgPSBmdW5jdGlvbiBtb3VzZWxlYXZlX2hhbmRsZXIoKSB7XG4gICAgcmV0dXJuICQkaW52YWxpZGF0ZSgyLCBjbG9zZUhvdmVyZWQgPSBmYWxzZSk7XG4gIH07XG5cbiAgJCRzZWxmLiQkc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJjbG9zZU1vZGFsXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDAsIGNsb3NlTW9kYWwgPSAkJHByb3BzLmNsb3NlTW9kYWwpO1xuICAgIGlmIChcImNsb3NlYWJsZVwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgxLCBjbG9zZWFibGUgPSAkJHByb3BzLmNsb3NlYWJsZSk7XG4gICAgaWYgKFwiJCRzY29wZVwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSg0LCAkJHNjb3BlID0gJCRwcm9wcy4kJHNjb3BlKTtcbiAgfTtcblxuICByZXR1cm4gW2Nsb3NlTW9kYWwsIGNsb3NlYWJsZSwgY2xvc2VIb3ZlcmVkLCAkYXBwLCAkJHNjb3BlLCBzbG90cywgbW91c2VlbnRlcl9oYW5kbGVyLCBtb3VzZWxlYXZlX2hhbmRsZXJdO1xufVxuXG52YXIgTW9kYWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdmVsdGVDb21wb25lbnQyKSB7XG4gIF9pbmhlcml0cyhNb2RhbCwgX1N2ZWx0ZUNvbXBvbmVudDIpO1xuXG4gIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKE1vZGFsKTtcblxuICBmdW5jdGlvbiBNb2RhbChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb2RhbCk7XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS1ybnRvZ2gtc3R5bGVcIikpIGFkZF9jc3MkMSgpO1xuICAgIGluaXQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczIpLCBvcHRpb25zLCBpbnN0YW5jZSQxLCBjcmVhdGVfZnJhZ21lbnQkMSwgc2FmZV9ub3RfZXF1YWwsIHtcbiAgICAgIGNsb3NlTW9kYWw6IDAsXG4gICAgICBjbG9zZWFibGU6IDFcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG5cbiAgcmV0dXJuIE1vZGFsO1xufShTdmVsdGVDb21wb25lbnQpO1xuLyogc3JjL2NvbXBvbmVudHMvTW9kYWxIZWFkZXIuc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMzguMiAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MkMigpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLThpOG82ai1zdHlsZVwiO1xuICBzdHlsZS50ZXh0Q29udGVudCA9IFwiaGVhZGVyLnN2ZWx0ZS04aThvNmp7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtmb250LXNpemU6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O21hcmdpbi1ib3R0b206MWVtfWRpdi5zdmVsdGUtOGk4bzZqe2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2FsaWduLWl0ZW1zOmNlbnRlcjtmb250LXNpemU6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O3BhZGRpbmc6MC42ZW07Ym9yZGVyLXJhZGl1czozMHB4O2JhY2tncm91bmQ6I2VlZWVlZX1oMy5zdmVsdGUtOGk4bzZqe2ZvbnQtd2VpZ2h0OmJvbGQ7Zm9udC1zaXplOjEuMzNlbTtmb250LWZhbWlseTppbmhlcml0O21hcmdpbjowIDAgMCAwLjVlbX1cIjtcbiAgYXBwZW5kKGRvY3VtZW50LmhlYWQsIHN0eWxlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50JDIoY3R4KSB7XG4gIHZhciBoZWFkZXI7XG4gIHZhciBkaXY7XG4gIHZhciB0MDtcbiAgdmFyIGgzO1xuICB2YXIgdDE7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGhlYWRlciA9IGVsZW1lbnQoXCJoZWFkZXJcIik7XG4gICAgICBkaXYgPSBlbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdDAgPSBzcGFjZSgpO1xuICAgICAgaDMgPSBlbGVtZW50KFwiaDNcIik7XG4gICAgICB0MSA9IHRleHQoXG4gICAgICAvKmhlYWRpbmcqL1xuICAgICAgY3R4WzBdKTtcbiAgICAgIGF0dHIoZGl2LCBcImNsYXNzXCIsIFwiYm4tb25ib2FyZC1jdXN0b20gYm4tb25ib2FyZC1tb2RhbC1jb250ZW50LWhlYWRlci1pY29uIHN2ZWx0ZS04aThvNmpcIik7XG4gICAgICB0b2dnbGVfY2xhc3MoZGl2LCBcImJuLW9uYm9hcmQtZGFyay1tb2RlLWJhY2tncm91bmRcIixcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbMl0uZGFya01vZGUpO1xuICAgICAgYXR0cihoMywgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtbW9kYWwtY29udGVudC1oZWFkZXItaGVhZGluZyBzdmVsdGUtOGk4bzZqXCIpO1xuICAgICAgYXR0cihoZWFkZXIsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLW1vZGFsLWNvbnRlbnQtaGVhZGVyIHN2ZWx0ZS04aThvNmpcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBoZWFkZXIsIGFuY2hvcik7XG4gICAgICBhcHBlbmQoaGVhZGVyLCBkaXYpO1xuICAgICAgZGl2LmlubmVySFRNTCA9XG4gICAgICAvKmljb24qL1xuICAgICAgY3R4WzFdO1xuICAgICAgYXBwZW5kKGhlYWRlciwgdDApO1xuICAgICAgYXBwZW5kKGhlYWRlciwgaDMpO1xuICAgICAgYXBwZW5kKGgzLCB0MSk7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgX3JlZjE0KSB7XG4gICAgICB2YXIgX3JlZjE1ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE0LCAxKSxcbiAgICAgICAgICBkaXJ0eSA9IF9yZWYxNVswXTtcblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qaWNvbiovXG4gICAgICAyKSBkaXYuaW5uZXJIVE1MID1cbiAgICAgIC8qaWNvbiovXG4gICAgICBjdHhbMV07XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiRhcHAqL1xuICAgICAgNCkge1xuICAgICAgICB0b2dnbGVfY2xhc3MoZGl2LCBcImJuLW9uYm9hcmQtZGFyay1tb2RlLWJhY2tncm91bmRcIixcbiAgICAgICAgLyokYXBwKi9cbiAgICAgICAgY3R4WzJdLmRhcmtNb2RlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qaGVhZGluZyovXG4gICAgICAxKSBzZXRfZGF0YSh0MSxcbiAgICAgIC8qaGVhZGluZyovXG4gICAgICBjdHhbMF0pO1xuICAgIH0sXG4gICAgaTogbm9vcCxcbiAgICBvOiBub29wLFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goaGVhZGVyKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlJDIoJCRzZWxmLCAkJHByb3BzLCAkJGludmFsaWRhdGUpIHtcbiAgdmFyICRhcHA7XG4gIGNvbXBvbmVudF9zdWJzY3JpYmUoJCRzZWxmLCBhcHAsIGZ1bmN0aW9uICgkJHZhbHVlKSB7XG4gICAgcmV0dXJuICQkaW52YWxpZGF0ZSgyLCAkYXBwID0gJCR2YWx1ZSk7XG4gIH0pO1xuICB2YXIgaGVhZGluZyA9ICQkcHJvcHMuaGVhZGluZztcbiAgdmFyIGljb24gPSAkJHByb3BzLmljb247XG5cbiAgJCRzZWxmLiQkc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJoZWFkaW5nXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDAsIGhlYWRpbmcgPSAkJHByb3BzLmhlYWRpbmcpO1xuICAgIGlmIChcImljb25cIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMSwgaWNvbiA9ICQkcHJvcHMuaWNvbik7XG4gIH07XG5cbiAgcmV0dXJuIFtoZWFkaW5nLCBpY29uLCAkYXBwXTtcbn1cblxudmFyIE1vZGFsSGVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3ZlbHRlQ29tcG9uZW50Mykge1xuICBfaW5oZXJpdHMoTW9kYWxIZWFkZXIsIF9TdmVsdGVDb21wb25lbnQzKTtcblxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihNb2RhbEhlYWRlcik7XG5cbiAgZnVuY3Rpb24gTW9kYWxIZWFkZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW9kYWxIZWFkZXIpO1xuXG4gICAgX3RoaXMzID0gX3N1cGVyMy5jYWxsKHRoaXMpO1xuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdmVsdGUtOGk4bzZqLXN0eWxlXCIpKSBhZGRfY3NzJDIoKTtcbiAgICBpbml0KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMzKSwgb3B0aW9ucywgaW5zdGFuY2UkMiwgY3JlYXRlX2ZyYWdtZW50JDIsIHNhZmVfbm90X2VxdWFsLCB7XG4gICAgICBoZWFkaW5nOiAwLFxuICAgICAgaWNvbjogMVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICByZXR1cm4gTW9kYWxIZWFkZXI7XG59KFN2ZWx0ZUNvbXBvbmVudCk7XG4vKiBzcmMvZWxlbWVudHMvQnV0dG9uLnN2ZWx0ZSBnZW5lcmF0ZWQgYnkgU3ZlbHRlIHYzLjM4LjIgKi9cblxuXG5mdW5jdGlvbiBhZGRfY3NzJDMoKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuaWQgPSBcInN2ZWx0ZS1mbmMzZTEtc3R5bGVcIjtcbiAgc3R5bGUudGV4dENvbnRlbnQgPSBcImJ1dHRvbi5zdmVsdGUtZm5jM2Uxe2JvcmRlcjpub25lO2JhY2tncm91bmQ6aW5oZXJpdDtmb250LXNpemU6MC44ODllbTtmb250LWZhbWlseTppbmhlcml0O3BhZGRpbmc6MC41NWVtIDEuNGVtO2N1cnNvcjpwb2ludGVyO2NvbG9yOiM0YTkwZTI7Zm9udC1mYW1pbHk6aW5oZXJpdDt0cmFuc2l0aW9uOmJhY2tncm91bmQgMTUwbXMgZWFzZS1pbi1vdXQ7bGluZS1oZWlnaHQ6MS4xNTtvcGFjaXR5OjE7dHJhbnNpdGlvbjpvcGFjaXR5IDIwMG1zfWJ1dHRvbi5zdmVsdGUtZm5jM2UxOmZvY3Vze291dGxpbmU6bm9uZX0uYm4tb25ib2FyZC1wcmVwYXJlLWJ1dHRvbi1yaWdodC5zdmVsdGUtZm5jM2Uxe3Bvc2l0aW9uOmFic29sdXRlO3JpZ2h0OjB9LmJuLW9uYm9hcmQtcHJlcGFyZS1idXR0b24tbGVmdC5zdmVsdGUtZm5jM2Uxe3Bvc2l0aW9uOmFic29sdXRlO2xlZnQ6MH0uZGlzYWJsZWQuc3ZlbHRlLWZuYzNlMXtjdXJzb3I6aW5oZXJpdDtwb2ludGVyLWV2ZW50czpub25lO29wYWNpdHk6MC40fS5jdGEuc3ZlbHRlLWZuYzNlMXtib3JkZXI6MXB4IHNvbGlkICM0YTkwZTI7Ym9yZGVyLXJhZGl1czo0MHB4fS5jdGEuc3ZlbHRlLWZuYzNlMTpob3ZlcntiYWNrZ3JvdW5kOiNlY2YzZmN9XCI7XG4gIGFwcGVuZChkb2N1bWVudC5oZWFkLCBzdHlsZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudCQzKGN0eCkge1xuICB2YXIgYnV0dG9uO1xuICB2YXIgY3VycmVudDtcbiAgdmFyIG1vdW50ZWQ7XG4gIHZhciBkaXNwb3NlO1xuICB2YXIgZGVmYXVsdF9zbG90X3RlbXBsYXRlID1cbiAgLyojc2xvdHMqL1xuICBjdHhbNl1bXCJkZWZhdWx0XCJdO1xuICB2YXIgZGVmYXVsdF9zbG90ID0gY3JlYXRlX3Nsb3QoZGVmYXVsdF9zbG90X3RlbXBsYXRlLCBjdHgsXG4gIC8qJCRzY29wZSovXG4gIGN0eFs1XSwgbnVsbCk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGJ1dHRvbiA9IGVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICBpZiAoZGVmYXVsdF9zbG90KSBkZWZhdWx0X3Nsb3QuYygpO1xuICAgICAgYnV0dG9uLmRpc2FibGVkID1cbiAgICAgIC8qZGlzYWJsZWQqL1xuICAgICAgY3R4WzJdO1xuICAgICAgYXR0cihidXR0b24sIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLXByZXBhcmUtYnV0dG9uIHN2ZWx0ZS1mbmMzZTFcIik7XG4gICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImRpc2FibGVkXCIsXG4gICAgICAvKmRpc2FibGVkKi9cbiAgICAgIGN0eFsyXSk7XG4gICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImN0YVwiLFxuICAgICAgLypjdGEqL1xuICAgICAgY3R4WzNdKTtcbiAgICAgIHRvZ2dsZV9jbGFzcyhidXR0b24sIFwiYm4tb25ib2FyZC1wcmVwYXJlLWJ1dHRvbi1yaWdodFwiLFxuICAgICAgLypwb3NpdGlvbiovXG4gICAgICBjdHhbMV0gPT09IFwicmlnaHRcIik7XG4gICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImJuLW9uYm9hcmQtcHJlcGFyZS1idXR0b24tbGVmdFwiLFxuICAgICAgLypwb3NpdGlvbiovXG4gICAgICBjdHhbMV0gPT09IFwibGVmdFwiKTtcbiAgICAgIHRvZ2dsZV9jbGFzcyhidXR0b24sIFwiYm4tb25ib2FyZC1wcmVwYXJlLWJ1dHRvbi1jZW50ZXJcIixcbiAgICAgIC8qcG9zaXRpb24qL1xuICAgICAgY3R4WzFdICE9PSBcImxlZnRcIiAmJlxuICAgICAgLypwb3NpdGlvbiovXG4gICAgICBjdHhbMV0gIT09IFwicmlnaHRcIik7XG4gICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImJuLW9uYm9hcmQtZGFyay1tb2RlLWxpbmtcIixcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbNF0uZGFya01vZGUpO1xuICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJibi1vbmJvYXJkLWRhcmstbW9kZS1iYWNrZ3JvdW5kLWhvdmVyXCIsXG4gICAgICAvKiRhcHAqL1xuICAgICAgY3R4WzRdLmRhcmtNb2RlKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIGJ1dHRvbiwgYW5jaG9yKTtcblxuICAgICAgaWYgKGRlZmF1bHRfc2xvdCkge1xuICAgICAgICBkZWZhdWx0X3Nsb3QubShidXR0b24sIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKCFtb3VudGVkKSB7XG4gICAgICAgIGRpc3Bvc2UgPSBsaXN0ZW4oYnV0dG9uLCBcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oXG4gICAgICAgICAgLypvbmNsaWNrKi9cbiAgICAgICAgICBjdHhbMF0pKVxuICAgICAgICAgICAgLypvbmNsaWNrKi9cbiAgICAgICAgICAgIGN0eFswXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgbW91bnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKG5ld19jdHgsIF9yZWYxNikge1xuICAgICAgdmFyIF9yZWYxNyA9IF9zbGljZWRUb0FycmF5KF9yZWYxNiwgMSksXG4gICAgICAgICAgZGlydHkgPSBfcmVmMTdbMF07XG5cbiAgICAgIGN0eCA9IG5ld19jdHg7XG5cbiAgICAgIGlmIChkZWZhdWx0X3Nsb3QpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRfc2xvdC5wICYmICghY3VycmVudCB8fCBkaXJ0eSAmXG4gICAgICAgIC8qJCRzY29wZSovXG4gICAgICAgIDMyKSkge1xuICAgICAgICAgIHVwZGF0ZV9zbG90KGRlZmF1bHRfc2xvdCwgZGVmYXVsdF9zbG90X3RlbXBsYXRlLCBjdHgsXG4gICAgICAgICAgLyokJHNjb3BlKi9cbiAgICAgICAgICBjdHhbNV0sIGRpcnR5LCBudWxsLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWN1cnJlbnQgfHwgZGlydHkgJlxuICAgICAgLypkaXNhYmxlZCovXG4gICAgICA0KSB7XG4gICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9XG4gICAgICAgIC8qZGlzYWJsZWQqL1xuICAgICAgICBjdHhbMl07XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmRpc2FibGVkKi9cbiAgICAgIDQpIHtcbiAgICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJkaXNhYmxlZFwiLFxuICAgICAgICAvKmRpc2FibGVkKi9cbiAgICAgICAgY3R4WzJdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qY3RhKi9cbiAgICAgIDgpIHtcbiAgICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJjdGFcIixcbiAgICAgICAgLypjdGEqL1xuICAgICAgICBjdHhbM10pO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypwb3NpdGlvbiovXG4gICAgICAyKSB7XG4gICAgICAgIHRvZ2dsZV9jbGFzcyhidXR0b24sIFwiYm4tb25ib2FyZC1wcmVwYXJlLWJ1dHRvbi1yaWdodFwiLFxuICAgICAgICAvKnBvc2l0aW9uKi9cbiAgICAgICAgY3R4WzFdID09PSBcInJpZ2h0XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypwb3NpdGlvbiovXG4gICAgICAyKSB7XG4gICAgICAgIHRvZ2dsZV9jbGFzcyhidXR0b24sIFwiYm4tb25ib2FyZC1wcmVwYXJlLWJ1dHRvbi1sZWZ0XCIsXG4gICAgICAgIC8qcG9zaXRpb24qL1xuICAgICAgICBjdHhbMV0gPT09IFwibGVmdFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qcG9zaXRpb24qL1xuICAgICAgMikge1xuICAgICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImJuLW9uYm9hcmQtcHJlcGFyZS1idXR0b24tY2VudGVyXCIsXG4gICAgICAgIC8qcG9zaXRpb24qL1xuICAgICAgICBjdHhbMV0gIT09IFwibGVmdFwiICYmXG4gICAgICAgIC8qcG9zaXRpb24qL1xuICAgICAgICBjdHhbMV0gIT09IFwicmlnaHRcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiRhcHAqL1xuICAgICAgMTYpIHtcbiAgICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJibi1vbmJvYXJkLWRhcmstbW9kZS1saW5rXCIsXG4gICAgICAgIC8qJGFwcCovXG4gICAgICAgIGN0eFs0XS5kYXJrTW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiRhcHAqL1xuICAgICAgMTYpIHtcbiAgICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJibi1vbmJvYXJkLWRhcmstbW9kZS1iYWNrZ3JvdW5kLWhvdmVyXCIsXG4gICAgICAgIC8qJGFwcCovXG4gICAgICAgIGN0eFs0XS5kYXJrTW9kZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihkZWZhdWx0X3Nsb3QsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoZGVmYXVsdF9zbG90LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGJ1dHRvbik7XG4gICAgICBpZiAoZGVmYXVsdF9zbG90KSBkZWZhdWx0X3Nsb3QuZChkZXRhY2hpbmcpO1xuICAgICAgbW91bnRlZCA9IGZhbHNlO1xuICAgICAgZGlzcG9zZSgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFuY2UkMygkJHNlbGYsICQkcHJvcHMsICQkaW52YWxpZGF0ZSkge1xuICB2YXIgJGFwcDtcbiAgY29tcG9uZW50X3N1YnNjcmliZSgkJHNlbGYsIGFwcCwgZnVuY3Rpb24gKCQkdmFsdWUpIHtcbiAgICByZXR1cm4gJCRpbnZhbGlkYXRlKDQsICRhcHAgPSAkJHZhbHVlKTtcbiAgfSk7XG4gIHZhciBfJCRwcm9wcyQkJHNsb3RzMiA9ICQkcHJvcHMuJCRzbG90cyxcbiAgICAgIHNsb3RzID0gXyQkcHJvcHMkJCRzbG90czIgPT09IHZvaWQgMCA/IHt9IDogXyQkcHJvcHMkJCRzbG90czIsXG4gICAgICAkJHNjb3BlID0gJCRwcm9wcy4kJHNjb3BlO1xuICB2YXIgXyQkcHJvcHMkb25jbGljayA9ICQkcHJvcHMub25jbGljayxcbiAgICAgIG9uY2xpY2sgPSBfJCRwcm9wcyRvbmNsaWNrID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7fSA6IF8kJHByb3BzJG9uY2xpY2s7XG4gIHZhciBfJCRwcm9wcyRwb3NpdGlvbiA9ICQkcHJvcHMucG9zaXRpb24sXG4gICAgICBwb3NpdGlvbiA9IF8kJHByb3BzJHBvc2l0aW9uID09PSB2b2lkIDAgPyBcIlwiIDogXyQkcHJvcHMkcG9zaXRpb247XG4gIHZhciBfJCRwcm9wcyRkaXNhYmxlZCA9ICQkcHJvcHMuZGlzYWJsZWQsXG4gICAgICBkaXNhYmxlZCA9IF8kJHByb3BzJGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF8kJHByb3BzJGRpc2FibGVkO1xuICB2YXIgXyQkcHJvcHMkY3RhID0gJCRwcm9wcy5jdGEsXG4gICAgICBjdGEgPSBfJCRwcm9wcyRjdGEgPT09IHZvaWQgMCA/IHRydWUgOiBfJCRwcm9wcyRjdGE7XG5cbiAgJCRzZWxmLiQkc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJvbmNsaWNrXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDAsIG9uY2xpY2sgPSAkJHByb3BzLm9uY2xpY2spO1xuICAgIGlmIChcInBvc2l0aW9uXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDEsIHBvc2l0aW9uID0gJCRwcm9wcy5wb3NpdGlvbik7XG4gICAgaWYgKFwiZGlzYWJsZWRcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMiwgZGlzYWJsZWQgPSAkJHByb3BzLmRpc2FibGVkKTtcbiAgICBpZiAoXCJjdGFcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMywgY3RhID0gJCRwcm9wcy5jdGEpO1xuICAgIGlmIChcIiQkc2NvcGVcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoNSwgJCRzY29wZSA9ICQkcHJvcHMuJCRzY29wZSk7XG4gIH07XG5cbiAgcmV0dXJuIFtvbmNsaWNrLCBwb3NpdGlvbiwgZGlzYWJsZWQsIGN0YSwgJGFwcCwgJCRzY29wZSwgc2xvdHNdO1xufVxuXG52YXIgQnV0dG9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3ZlbHRlQ29tcG9uZW50NCkge1xuICBfaW5oZXJpdHMoQnV0dG9uLCBfU3ZlbHRlQ29tcG9uZW50NCk7XG5cbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoQnV0dG9uKTtcblxuICBmdW5jdGlvbiBCdXR0b24ob3B0aW9ucykge1xuICAgIHZhciBfdGhpczQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnV0dG9uKTtcblxuICAgIF90aGlzNCA9IF9zdXBlcjQuY2FsbCh0aGlzKTtcbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3ZlbHRlLWZuYzNlMS1zdHlsZVwiKSkgYWRkX2NzcyQzKCk7XG4gICAgaW5pdChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNCksIG9wdGlvbnMsIGluc3RhbmNlJDMsIGNyZWF0ZV9mcmFnbWVudCQzLCBzYWZlX25vdF9lcXVhbCwge1xuICAgICAgb25jbGljazogMCxcbiAgICAgIHBvc2l0aW9uOiAxLFxuICAgICAgZGlzYWJsZWQ6IDIsXG4gICAgICBjdGE6IDNcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM0O1xuICB9XG5cbiAgcmV0dXJuIEJ1dHRvbjtcbn0oU3ZlbHRlQ29tcG9uZW50KTtcbi8qIHNyYy9lbGVtZW50cy9TcGlubmVyLnN2ZWx0ZSBnZW5lcmF0ZWQgYnkgU3ZlbHRlIHYzLjM4LjIgKi9cblxuXG5mdW5jdGlvbiBhZGRfY3NzJDQoKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuaWQgPSBcInN2ZWx0ZS0xNmdoazJoLXN0eWxlXCI7XG4gIHN0eWxlLnRleHRDb250ZW50ID0gXCIuYm4tb25ib2FyZC1sb2FkaW5nLWNvbnRhaW5lci5zdmVsdGUtMTZnaGsyaHtkaXNwbGF5OmZsZXg7ZmxleC1kaXJlY3Rpb246Y29sdW1uO2FsaWduLWl0ZW1zOmNlbnRlcjtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOmluaGVyaXQ7Y29sb3I6aW5oZXJpdH1zcGFuLnN2ZWx0ZS0xNmdoazJoe2ZvbnQtZmFtaWx5OmluaGVyaXQ7Zm9udC1zaXplOjAuODg5ZW07bWFyZ2luLXRvcDoxcmVtfS5ibi1vbmJvYXJkLWxvYWRpbmd7ZGlzcGxheTppbmxpbmUtYmxvY2s7cG9zaXRpb246cmVsYXRpdmU7d2lkdGg6MmVtO2hlaWdodDoyZW19LmJuLW9uYm9hcmQtbG9hZGluZyBkaXZ7Ym94LXNpemluZzpib3JkZXItYm94O2ZvbnQtc2l6ZTppbmhlcml0O2Rpc3BsYXk6YmxvY2s7cG9zaXRpb246YWJzb2x1dGU7d2lkdGg6MmVtO2hlaWdodDoyZW07Ym9yZGVyOjNweCBzb2xpZDtib3JkZXItcmFkaXVzOjUwJTthbmltYXRpb246Ym4tb25ib2FyZC1sb2FkaW5nIDEuMnMgY3ViaWMtYmV6aWVyKDAuNSwgMCwgMC41LCAxKSBpbmZpbml0ZTtib3JkZXItY29sb3I6Y3VycmVudENvbG9yIHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50fS5ibi1vbmJvYXJkLWxvYWRpbmcgLmJuLW9uYm9hcmQtbG9hZGluZy1maXJzdHthbmltYXRpb24tZGVsYXk6LTAuNDVzfS5ibi1vbmJvYXJkLWxvYWRpbmcgLmJuLW9uYm9hcmQtbG9hZGluZy1zZWNvbmR7YW5pbWF0aW9uLWRlbGF5Oi0wLjNzfS5ibi1vbmJvYXJkLWxvYWRpbmcgLmJuLW9uYm9hcmQtbG9hZGluZy10aGlyZHthbmltYXRpb24tZGVsYXk6LTAuMTVzfUBrZXlmcmFtZXMgYm4tb25ib2FyZC1sb2FkaW5nezAle3RyYW5zZm9ybTpyb3RhdGUoMGRlZyl9MTAwJXt0cmFuc2Zvcm06cm90YXRlKDM2MGRlZyl9fVwiO1xuICBhcHBlbmQoZG9jdW1lbnQuaGVhZCwgc3R5bGUpO1xufSAvLyAoNjQ6MikgeyNpZiBkZXNjcmlwdGlvbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2skMihjdHgpIHtcbiAgdmFyIHNwYW47XG4gIHZhciB0O1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBzcGFuID0gZWxlbWVudChcInNwYW5cIik7XG4gICAgICB0ID0gdGV4dChcbiAgICAgIC8qZGVzY3JpcHRpb24qL1xuICAgICAgY3R4WzBdKTtcbiAgICAgIGF0dHIoc3BhbiwgXCJjbGFzc1wiLCBcInN2ZWx0ZS0xNmdoazJoXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgc3BhbiwgYW5jaG9yKTtcbiAgICAgIGFwcGVuZChzcGFuLCB0KTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBkaXJ0eSkge1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qZGVzY3JpcHRpb24qL1xuICAgICAgMSkgc2V0X2RhdGEodCxcbiAgICAgIC8qZGVzY3JpcHRpb24qL1xuICAgICAgY3R4WzBdKTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goc3Bhbik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVfZnJhZ21lbnQkNChjdHgpIHtcbiAgdmFyIGRpdjQ7XG4gIHZhciBkaXYzO1xuICB2YXIgdDI7XG4gIHZhciBpZl9ibG9jayA9XG4gIC8qZGVzY3JpcHRpb24qL1xuICBjdHhbMF0gJiYgY3JlYXRlX2lmX2Jsb2NrJDIoY3R4KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgZGl2NCA9IGVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBkaXYzID0gZWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdjMuaW5uZXJIVE1MID0gXCI8ZGl2IGNsYXNzPVxcXCJibi1vbmJvYXJkLWxvYWRpbmctZmlyc3RcXFwiPjwvZGl2PiBcXG4gICAgPGRpdiBjbGFzcz1cXFwiYm4tb25ib2FyZC1sb2FkaW5nLXNlY29uZFxcXCI+PC9kaXY+IFxcbiAgICA8ZGl2IGNsYXNzPVxcXCJibi1vbmJvYXJkLWxvYWRpbmctdGhpcmRcXFwiPjwvZGl2PlwiO1xuICAgICAgdDIgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrKSBpZl9ibG9jay5jKCk7XG4gICAgICBhdHRyKGRpdjMsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLWxvYWRpbmdcIik7XG4gICAgICBhdHRyKGRpdjQsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWxvYWRpbmctY29udGFpbmVyIHN2ZWx0ZS0xNmdoazJoXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgZGl2NCwgYW5jaG9yKTtcbiAgICAgIGFwcGVuZChkaXY0LCBkaXYzKTtcbiAgICAgIGFwcGVuZChkaXY0LCB0Mik7XG4gICAgICBpZiAoaWZfYmxvY2spIGlmX2Jsb2NrLm0oZGl2NCwgbnVsbCk7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgX3JlZjE4KSB7XG4gICAgICB2YXIgX3JlZjE5ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjE4LCAxKSxcbiAgICAgICAgICBkaXJ0eSA9IF9yZWYxOVswXTtcblxuICAgICAgaWYgKFxuICAgICAgLypkZXNjcmlwdGlvbiovXG4gICAgICBjdHhbMF0pIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrKSB7XG4gICAgICAgICAgaWZfYmxvY2sucChjdHgsIGRpcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jayA9IGNyZWF0ZV9pZl9ibG9jayQyKGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2suYygpO1xuICAgICAgICAgIGlmX2Jsb2NrLm0oZGl2NCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWZfYmxvY2spIHtcbiAgICAgICAgaWZfYmxvY2suZCgxKTtcbiAgICAgICAgaWZfYmxvY2sgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgaTogbm9vcCxcbiAgICBvOiBub29wLFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goZGl2NCk7XG4gICAgICBpZiAoaWZfYmxvY2spIGlmX2Jsb2NrLmQoKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlJDQoJCRzZWxmLCAkJHByb3BzLCAkJGludmFsaWRhdGUpIHtcbiAgdmFyIF8kJHByb3BzJGRlc2NyaXB0aW9uID0gJCRwcm9wcy5kZXNjcmlwdGlvbixcbiAgICAgIGRlc2NyaXB0aW9uID0gXyQkcHJvcHMkZGVzY3JpcHRpb24gPT09IHZvaWQgMCA/IFwiXCIgOiBfJCRwcm9wcyRkZXNjcmlwdGlvbjtcblxuICAkJHNlbGYuJCRzZXQgPSBmdW5jdGlvbiAoJCRwcm9wcykge1xuICAgIGlmIChcImRlc2NyaXB0aW9uXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDAsIGRlc2NyaXB0aW9uID0gJCRwcm9wcy5kZXNjcmlwdGlvbik7XG4gIH07XG5cbiAgcmV0dXJuIFtkZXNjcmlwdGlvbl07XG59XG5cbnZhciBTcGlubmVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3ZlbHRlQ29tcG9uZW50NSkge1xuICBfaW5oZXJpdHMoU3Bpbm5lciwgX1N2ZWx0ZUNvbXBvbmVudDUpO1xuXG4gIHZhciBfc3VwZXI1ID0gX2NyZWF0ZVN1cGVyKFNwaW5uZXIpO1xuXG4gIGZ1bmN0aW9uIFNwaW5uZXIob3B0aW9ucykge1xuICAgIHZhciBfdGhpczU7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3Bpbm5lcik7XG5cbiAgICBfdGhpczUgPSBfc3VwZXI1LmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS0xNmdoazJoLXN0eWxlXCIpKSBhZGRfY3NzJDQoKTtcbiAgICBpbml0KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM1KSwgb3B0aW9ucywgaW5zdGFuY2UkNCwgY3JlYXRlX2ZyYWdtZW50JDQsIHNhZmVfbm90X2VxdWFsLCB7XG4gICAgICBkZXNjcmlwdGlvbjogMFxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpczU7XG4gIH1cblxuICByZXR1cm4gU3Bpbm5lcjtcbn0oU3ZlbHRlQ29tcG9uZW50KTtcbi8qIHNyYy9lbGVtZW50cy9JY29uQnV0dG9uLnN2ZWx0ZSBnZW5lcmF0ZWQgYnkgU3ZlbHRlIHYzLjM4LjIgKi9cblxuXG5mdW5jdGlvbiBhZGRfY3NzJDUoKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuaWQgPSBcInN2ZWx0ZS0xNzk5YmoyLXN0eWxlXCI7XG4gIHN0eWxlLnRleHRDb250ZW50ID0gXCJidXR0b24uc3ZlbHRlLTE3OTliajJ7ZGlzcGxheTpmbGV4O2FsaWduLWl0ZW1zOmNlbnRlcjtib3JkZXI6bm9uZTttYXJnaW46MC4zM2VtIDA7YmFja2dyb3VuZDppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O3dpZHRoOjE4ZW07cGFkZGluZzowLjYyNWVtIDEuMjVlbTt0cmFuc2l0aW9uOmJveC1zaGFkb3cgMTUwbXMgZWFzZS1pbi1vdXQsIGJhY2tncm91bmQgMjAwbXMgZWFzZS1pbi1vdXQ7Ym9yZGVyLXJhZGl1czo0MHB4O2N1cnNvcjpwb2ludGVyO2NvbG9yOmluaGVyaXQ7bGluZS1oZWlnaHQ6MS4xNTtmb250LWZhbWlseTppbmhlcml0O29wYWNpdHk6MTt0cmFuc2l0aW9uOm9wYWNpdHkgMjAwbXN9LmRpc2FibGVkLnN2ZWx0ZS0xNzk5Ymoye2N1cnNvcjppbmhlcml0O3BvaW50ZXItZXZlbnRzOm5vbmU7b3BhY2l0eTowLjR9YnV0dG9uLnN2ZWx0ZS0xNzk5YmoyOmhvdmVye2JveC1zaGFkb3c6MCAycHggMTBweCAwIHJnYmEoMCwgMCwgMCwgMC4xKX1idXR0b24uc3ZlbHRlLTE3OTliajI6Zm9jdXN7b3V0bGluZTpub25lfWRpdi5zdmVsdGUtMTc5OWJqMntkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7dGV4dC1hbGlnbjpjZW50ZXI7aGVpZ2h0OjQwcHg7d2lkdGg6NDBweDtsaW5lLWhlaWdodDo0MHB4O2ZvbnQtZmFtaWx5OmluaGVyaXR9aW1nLnN2ZWx0ZS0xNzk5Ymoye21heC1oZWlnaHQ6MTAwJTttYXgtd2lkdGg6MTAwJTt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9c3Bhbi5zdmVsdGUtMTc5OWJqMnt3aWR0aDoxMDAlO2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2VlbjthbGlnbi1pdGVtczpjZW50ZXI7Zm9udC1zaXplOmluaGVyaXQ7bWFyZ2luLWxlZnQ6MC42NmVtO2ZvbnQtd2VpZ2h0OmJvbGQ7dGV4dC1hbGlnbjpsZWZ0O2ZvbnQtZmFtaWx5OmluaGVyaXR9aS5zdmVsdGUtMTc5OWJqMntmb250LXNpemU6MC44cmVtO2ZvbnQtd2VpZ2h0OmxpZ2h0ZXI7Y29sb3I6aW5oZXJpdDt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfUBtZWRpYSBvbmx5IHNjcmVlbiBhbmQgKG1heC13aWR0aDogNDUwcHgpe2J1dHRvbi5zdmVsdGUtMTc5OWJqMnt3aWR0aDoxMDAlfX0uYm4tb25ib2FyZC1zZWxlY3RlZC13YWxsZXQuc3ZlbHRlLTE3OTliajJ7YmFja2dyb3VuZDojYzNjM2MzfVwiO1xuICBhcHBlbmQoZG9jdW1lbnQuaGVhZCwgc3R5bGUpO1xufSAvLyAoMTA4OjQpIHs6ZWxzZX1cblxuXG5mdW5jdGlvbiBjcmVhdGVfZWxzZV9ibG9jayQxKGN0eCkge1xuICB2YXIgaW1nO1xuICB2YXIgaW1nX3NyY192YWx1ZTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgaW1nID0gZWxlbWVudChcImltZ1wiKTtcbiAgICAgIGlmIChpbWcuc3JjICE9PSAoaW1nX3NyY192YWx1ZSA9XG4gICAgICAvKmljb25TcmMqL1xuICAgICAgY3R4WzBdKSkgYXR0cihpbWcsIFwic3JjXCIsIGltZ19zcmNfdmFsdWUpO1xuICAgICAgYXR0cihpbWcsIFwic3Jjc2V0XCIsXG4gICAgICAvKmljb25TcmNTZXQqL1xuICAgICAgY3R4WzFdKTtcbiAgICAgIGF0dHIoaW1nLCBcImFsdFwiLFxuICAgICAgLyp0ZXh0Ki9cbiAgICAgIGN0eFs0XSk7XG4gICAgICBhdHRyKGltZywgXCJjbGFzc1wiLCBcInN2ZWx0ZS0xNzk5YmoyXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgaW1nLCBhbmNob3IpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyppY29uU3JjKi9cbiAgICAgIDEgJiYgaW1nLnNyYyAhPT0gKGltZ19zcmNfdmFsdWUgPVxuICAgICAgLyppY29uU3JjKi9cbiAgICAgIGN0eFswXSkpIHtcbiAgICAgICAgYXR0cihpbWcsIFwic3JjXCIsIGltZ19zcmNfdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyppY29uU3JjU2V0Ki9cbiAgICAgIDIpIHtcbiAgICAgICAgYXR0cihpbWcsIFwic3Jjc2V0XCIsXG4gICAgICAgIC8qaWNvblNyY1NldCovXG4gICAgICAgIGN0eFsxXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKnRleHQqL1xuICAgICAgMTYpIHtcbiAgICAgICAgYXR0cihpbWcsIFwiYWx0XCIsXG4gICAgICAgIC8qdGV4dCovXG4gICAgICAgIGN0eFs0XSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBub29wLFxuICAgIG86IG5vb3AsXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChpbWcpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDEwNjoxOCkgXG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrXzIoY3R4KSB7XG4gIHZhciBodG1sX3RhZztcbiAgdmFyIGh0bWxfYW5jaG9yO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBodG1sX2FuY2hvciA9IGVtcHR5KCk7XG4gICAgICBodG1sX3RhZyA9IG5ldyBIdG1sVGFnKGh0bWxfYW5jaG9yKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGh0bWxfdGFnLm0oXG4gICAgICAvKnN2ZyovXG4gICAgICBjdHhbMl0sIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIGh0bWxfYW5jaG9yLCBhbmNob3IpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypzdmcqL1xuICAgICAgNCkgaHRtbF90YWcucChcbiAgICAgIC8qc3ZnKi9cbiAgICAgIGN0eFsyXSk7XG4gICAgfSxcbiAgICBpOiBub29wLFxuICAgIG86IG5vb3AsXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChodG1sX2FuY2hvcik7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBodG1sX3RhZy5kKCk7XG4gICAgfVxuICB9O1xufSAvLyAoMTA0OjQpIHsjaWYgbG9hZGluZ1dhbGxldCA9PT0gdGV4dH1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfMSQxKGN0eCkge1xuICB2YXIgc3Bpbm5lcjtcbiAgdmFyIGN1cnJlbnQ7XG4gIHNwaW5uZXIgPSBuZXcgU3Bpbm5lcih7fSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoc3Bpbm5lci4kJC5mcmFnbWVudCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQoc3Bpbm5lciwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBub29wLFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKHNwaW5uZXIuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoc3Bpbm5lci4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHNwaW5uZXIsIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoMTE0OjQpIHsjaWYgY3VycmVudGx5U2VsZWN0ZWR9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrJDMoY3R4KSB7XG4gIHZhciBpO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBpID0gZWxlbWVudChcImlcIik7XG4gICAgICBpLnRleHRDb250ZW50ID0gXCJzZWxlY3RlZFwiO1xuICAgICAgYXR0cihpLCBcImNsYXNzXCIsIFwic3ZlbHRlLTE3OTliajJcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBpLCBhbmNob3IpO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChpKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudCQ1KGN0eCkge1xuICB2YXIgYnV0dG9uO1xuICB2YXIgZGl2O1xuICB2YXIgY3VycmVudF9ibG9ja190eXBlX2luZGV4O1xuICB2YXIgaWZfYmxvY2swO1xuICB2YXIgdDA7XG4gIHZhciBzcGFuO1xuICB2YXIgdDE7XG4gIHZhciB0MjtcbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBtb3VudGVkO1xuICB2YXIgZGlzcG9zZTtcbiAgdmFyIGlmX2Jsb2NrX2NyZWF0b3JzID0gW2NyZWF0ZV9pZl9ibG9ja18xJDEsIGNyZWF0ZV9pZl9ibG9ja18yLCBjcmVhdGVfZWxzZV9ibG9jayQxXTtcbiAgdmFyIGlmX2Jsb2NrcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHNlbGVjdF9ibG9ja190eXBlKGN0eCwgZGlydHkpIHtcbiAgICBpZiAoXG4gICAgLypsb2FkaW5nV2FsbGV0Ki9cbiAgICBjdHhbNV0gPT09XG4gICAgLyp0ZXh0Ki9cbiAgICBjdHhbNF0pIHJldHVybiAwO1xuICAgIGlmIChcbiAgICAvKnN2ZyovXG4gICAgY3R4WzJdKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMjtcbiAgfVxuXG4gIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCA9IHNlbGVjdF9ibG9ja190eXBlKGN0eCk7XG4gIGlmX2Jsb2NrMCA9IGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdID0gaWZfYmxvY2tfY3JlYXRvcnNbY3VycmVudF9ibG9ja190eXBlX2luZGV4XShjdHgpO1xuICB2YXIgaWZfYmxvY2sxID1cbiAgLypjdXJyZW50bHlTZWxlY3RlZCovXG4gIGN0eFs2XSAmJiBjcmVhdGVfaWZfYmxvY2skMygpO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBidXR0b24gPSBlbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgZGl2ID0gZWxlbWVudChcImRpdlwiKTtcbiAgICAgIGlmX2Jsb2NrMC5jKCk7XG4gICAgICB0MCA9IHNwYWNlKCk7XG4gICAgICBzcGFuID0gZWxlbWVudChcInNwYW5cIik7XG4gICAgICB0MSA9IHRleHQoXG4gICAgICAvKnRleHQqL1xuICAgICAgY3R4WzRdKTtcbiAgICAgIHQyID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5jKCk7XG4gICAgICBhdHRyKGRpdiwgXCJjbGFzc1wiLCBcInN2ZWx0ZS0xNzk5YmoyXCIpO1xuICAgICAgYXR0cihzcGFuLCBcImNsYXNzXCIsIFwic3ZlbHRlLTE3OTliajJcIik7XG4gICAgICBidXR0b24uZGlzYWJsZWQgPVxuICAgICAgLypkaXNhYmxlZCovXG4gICAgICBjdHhbN107XG4gICAgICBhdHRyKGJ1dHRvbiwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtaWNvbi1idXR0b24gc3ZlbHRlLTE3OTliajJcIik7XG4gICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImRpc2FibGVkXCIsXG4gICAgICAvKmRpc2FibGVkKi9cbiAgICAgIGN0eFs3XSk7XG4gICAgICB0b2dnbGVfY2xhc3MoYnV0dG9uLCBcImJuLW9uYm9hcmQtZGFyay1tb2RlLWJhY2tncm91bmQtaG92ZXJcIixcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbOF0uZGFya01vZGUpO1xuICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJibi1vbmJvYXJkLXNlbGVjdGVkLXdhbGxldFwiLFxuICAgICAgLypjdXJyZW50bHlTZWxlY3RlZCovXG4gICAgICBjdHhbNl0pO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgYnV0dG9uLCBhbmNob3IpO1xuICAgICAgYXBwZW5kKGJ1dHRvbiwgZGl2KTtcbiAgICAgIGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdLm0oZGl2LCBudWxsKTtcbiAgICAgIGFwcGVuZChidXR0b24sIHQwKTtcbiAgICAgIGFwcGVuZChidXR0b24sIHNwYW4pO1xuICAgICAgYXBwZW5kKHNwYW4sIHQxKTtcbiAgICAgIGFwcGVuZChzcGFuLCB0Mik7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEubShzcGFuLCBudWxsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoIW1vdW50ZWQpIHtcbiAgICAgICAgZGlzcG9zZSA9IGxpc3RlbihidXR0b24sIFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChpc19mdW5jdGlvbihcbiAgICAgICAgICAvKm9uY2xpY2sqL1xuICAgICAgICAgIGN0eFszXSkpXG4gICAgICAgICAgICAvKm9uY2xpY2sqL1xuICAgICAgICAgICAgY3R4WzNdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0pO1xuICAgICAgICBtb3VudGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAobmV3X2N0eCwgX3JlZjIwKSB7XG4gICAgICB2YXIgX3JlZjIxID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIwLCAxKSxcbiAgICAgICAgICBkaXJ0eSA9IF9yZWYyMVswXTtcblxuICAgICAgY3R4ID0gbmV3X2N0eDtcbiAgICAgIHZhciBwcmV2aW91c19ibG9ja19pbmRleCA9IGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleDtcbiAgICAgIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCA9IHNlbGVjdF9ibG9ja190eXBlKGN0eCk7XG5cbiAgICAgIGlmIChjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXggPT09IHByZXZpb3VzX2Jsb2NrX2luZGV4KSB7XG4gICAgICAgIGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdLnAoY3R4LCBkaXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2tzW3ByZXZpb3VzX2Jsb2NrX2luZGV4XSwgMSwgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmX2Jsb2Nrc1twcmV2aW91c19ibG9ja19pbmRleF0gPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICAgIGlmX2Jsb2NrMCA9IGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdO1xuXG4gICAgICAgIGlmICghaWZfYmxvY2swKSB7XG4gICAgICAgICAgaWZfYmxvY2swID0gaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0gPSBpZl9ibG9ja19jcmVhdG9yc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdKGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2swLmMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jazAucChjdHgsIGRpcnR5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swLCAxKTtcbiAgICAgICAgaWZfYmxvY2swLm0oZGl2LCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFjdXJyZW50IHx8IGRpcnR5ICZcbiAgICAgIC8qdGV4dCovXG4gICAgICAxNikgc2V0X2RhdGEodDEsXG4gICAgICAvKnRleHQqL1xuICAgICAgY3R4WzRdKTtcblxuICAgICAgaWYgKFxuICAgICAgLypjdXJyZW50bHlTZWxlY3RlZCovXG4gICAgICBjdHhbNl0pIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrMSkgO2Vsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMSA9IGNyZWF0ZV9pZl9ibG9jayQzKCk7XG4gICAgICAgICAgaWZfYmxvY2sxLmMoKTtcbiAgICAgICAgICBpZl9ibG9jazEubShzcGFuLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jazEpIHtcbiAgICAgICAgaWZfYmxvY2sxLmQoMSk7XG4gICAgICAgIGlmX2Jsb2NrMSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghY3VycmVudCB8fCBkaXJ0eSAmXG4gICAgICAvKmRpc2FibGVkKi9cbiAgICAgIDEyOCkge1xuICAgICAgICBidXR0b24uZGlzYWJsZWQgPVxuICAgICAgICAvKmRpc2FibGVkKi9cbiAgICAgICAgY3R4WzddO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypkaXNhYmxlZCovXG4gICAgICAxMjgpIHtcbiAgICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJkaXNhYmxlZFwiLFxuICAgICAgICAvKmRpc2FibGVkKi9cbiAgICAgICAgY3R4WzddKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qJGFwcCovXG4gICAgICAyNTYpIHtcbiAgICAgICAgdG9nZ2xlX2NsYXNzKGJ1dHRvbiwgXCJibi1vbmJvYXJkLWRhcmstbW9kZS1iYWNrZ3JvdW5kLWhvdmVyXCIsXG4gICAgICAgIC8qJGFwcCovXG4gICAgICAgIGN0eFs4XS5kYXJrTW9kZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmN1cnJlbnRseVNlbGVjdGVkKi9cbiAgICAgIDY0KSB7XG4gICAgICAgIHRvZ2dsZV9jbGFzcyhidXR0b24sIFwiYm4tb25ib2FyZC1zZWxlY3RlZC13YWxsZXRcIixcbiAgICAgICAgLypjdXJyZW50bHlTZWxlY3RlZCovXG4gICAgICAgIGN0eFs2XSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazApO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazApO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChidXR0b24pO1xuICAgICAgaWZfYmxvY2tzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0uZCgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLmQoKTtcbiAgICAgIG1vdW50ZWQgPSBmYWxzZTtcbiAgICAgIGRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlJDUoJCRzZWxmLCAkJHByb3BzLCAkJGludmFsaWRhdGUpIHtcbiAgdmFyICRhcHA7XG4gIGNvbXBvbmVudF9zdWJzY3JpYmUoJCRzZWxmLCBhcHAsIGZ1bmN0aW9uICgkJHZhbHVlKSB7XG4gICAgcmV0dXJuICQkaW52YWxpZGF0ZSg4LCAkYXBwID0gJCR2YWx1ZSk7XG4gIH0pO1xuICB2YXIgaWNvblNyYyA9ICQkcHJvcHMuaWNvblNyYztcbiAgdmFyIGljb25TcmNTZXQgPSAkJHByb3BzLmljb25TcmNTZXQ7XG4gIHZhciBzdmcgPSAkJHByb3BzLnN2ZztcbiAgdmFyIF8kJHByb3BzJG9uY2xpY2syID0gJCRwcm9wcy5vbmNsaWNrLFxuICAgICAgb25jbGljayA9IF8kJHByb3BzJG9uY2xpY2syID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoKSB7fSA6IF8kJHByb3BzJG9uY2xpY2syO1xuICB2YXIgdGV4dCA9ICQkcHJvcHMudGV4dDtcbiAgdmFyIGxvYWRpbmdXYWxsZXQgPSAkJHByb3BzLmxvYWRpbmdXYWxsZXQ7XG4gIHZhciBfJCRwcm9wcyRjdXJyZW50bHlTZWwgPSAkJHByb3BzLmN1cnJlbnRseVNlbGVjdGVkLFxuICAgICAgY3VycmVudGx5U2VsZWN0ZWQgPSBfJCRwcm9wcyRjdXJyZW50bHlTZWwgPT09IHZvaWQgMCA/IGZhbHNlIDogXyQkcHJvcHMkY3VycmVudGx5U2VsO1xuICB2YXIgXyQkcHJvcHMkZGlzYWJsZWQyID0gJCRwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGRpc2FibGVkID0gXyQkcHJvcHMkZGlzYWJsZWQyID09PSB2b2lkIDAgPyBmYWxzZSA6IF8kJHByb3BzJGRpc2FibGVkMjtcblxuICAkJHNlbGYuJCRzZXQgPSBmdW5jdGlvbiAoJCRwcm9wcykge1xuICAgIGlmIChcImljb25TcmNcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMCwgaWNvblNyYyA9ICQkcHJvcHMuaWNvblNyYyk7XG4gICAgaWYgKFwiaWNvblNyY1NldFwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgxLCBpY29uU3JjU2V0ID0gJCRwcm9wcy5pY29uU3JjU2V0KTtcbiAgICBpZiAoXCJzdmdcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMiwgc3ZnID0gJCRwcm9wcy5zdmcpO1xuICAgIGlmIChcIm9uY2xpY2tcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMywgb25jbGljayA9ICQkcHJvcHMub25jbGljayk7XG4gICAgaWYgKFwidGV4dFwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSg0LCB0ZXh0ID0gJCRwcm9wcy50ZXh0KTtcbiAgICBpZiAoXCJsb2FkaW5nV2FsbGV0XCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDUsIGxvYWRpbmdXYWxsZXQgPSAkJHByb3BzLmxvYWRpbmdXYWxsZXQpO1xuICAgIGlmIChcImN1cnJlbnRseVNlbGVjdGVkXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDYsIGN1cnJlbnRseVNlbGVjdGVkID0gJCRwcm9wcy5jdXJyZW50bHlTZWxlY3RlZCk7XG4gICAgaWYgKFwiZGlzYWJsZWRcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoNywgZGlzYWJsZWQgPSAkJHByb3BzLmRpc2FibGVkKTtcbiAgfTtcblxuICByZXR1cm4gW2ljb25TcmMsIGljb25TcmNTZXQsIHN2Zywgb25jbGljaywgdGV4dCwgbG9hZGluZ1dhbGxldCwgY3VycmVudGx5U2VsZWN0ZWQsIGRpc2FibGVkLCAkYXBwXTtcbn1cblxudmFyIEljb25CdXR0b24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdmVsdGVDb21wb25lbnQ2KSB7XG4gIF9pbmhlcml0cyhJY29uQnV0dG9uLCBfU3ZlbHRlQ29tcG9uZW50Nik7XG5cbiAgdmFyIF9zdXBlcjYgPSBfY3JlYXRlU3VwZXIoSWNvbkJ1dHRvbik7XG5cbiAgZnVuY3Rpb24gSWNvbkJ1dHRvbihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzNjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJY29uQnV0dG9uKTtcblxuICAgIF90aGlzNiA9IF9zdXBlcjYuY2FsbCh0aGlzKTtcbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3ZlbHRlLTE3OTliajItc3R5bGVcIikpIGFkZF9jc3MkNSgpO1xuICAgIGluaXQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczYpLCBvcHRpb25zLCBpbnN0YW5jZSQ1LCBjcmVhdGVfZnJhZ21lbnQkNSwgc2FmZV9ub3RfZXF1YWwsIHtcbiAgICAgIGljb25TcmM6IDAsXG4gICAgICBpY29uU3JjU2V0OiAxLFxuICAgICAgc3ZnOiAyLFxuICAgICAgb25jbGljazogMyxcbiAgICAgIHRleHQ6IDQsXG4gICAgICBsb2FkaW5nV2FsbGV0OiA1LFxuICAgICAgY3VycmVudGx5U2VsZWN0ZWQ6IDYsXG4gICAgICBkaXNhYmxlZDogN1xuICAgIH0pO1xuICAgIHJldHVybiBfdGhpczY7XG4gIH1cblxuICByZXR1cm4gSWNvbkJ1dHRvbjtcbn0oU3ZlbHRlQ29tcG9uZW50KTtcbi8qIHNyYy9jb21wb25lbnRzL1dhbGxldHMuc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMzguMiAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MkNigpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLXExNTI3LXN0eWxlXCI7XG4gIHN0eWxlLnRleHRDb250ZW50ID0gXCJ1bC5zdmVsdGUtcTE1Mjcuc3ZlbHRlLXExNTI3e2Rpc3BsYXk6ZmxleDtmbGV4LWZsb3c6cm93IHdyYXA7YWxpZ24taXRlbXM6Y2VudGVyO2xpc3Qtc3R5bGUtdHlwZTpub25lO21hcmdpbjoxLjI1ZW0gMDtwYWRkaW5nOjA7Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6aW5oZXJpdDtsaW5lLWhlaWdodDoxLjE1O2JveC1zaXppbmc6Ym9yZGVyLWJveH11bC5zdmVsdGUtcTE1MjcgbGkuc3ZlbHRlLXExNTI3e3BhZGRpbmc6MCAwLjI1ZW19ZGl2LnN2ZWx0ZS1xMTUyNy5zdmVsdGUtcTE1Mjd7d2lkdGg6MTAwJTtkaXNwbGF5OmZsZXg7Zm9udC1zaXplOmluaGVyaXQ7Zm9udC1mYW1pbHk6aW5oZXJpdDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO21hcmdpbi10b3A6MS4yNWVtfS5zdmVsdGUtcTE1Mjcuc3ZlbHRlLXExNTI3Ojotd2Via2l0LXNjcm9sbGJhcntkaXNwbGF5Om5vbmV9QG1lZGlhIG9ubHkgc2NyZWVuIGFuZCAobWF4LXdpZHRoOiA0NTBweCl7dWwuc3ZlbHRlLXExNTI3IGxpLnN2ZWx0ZS1xMTUyN3t3aWR0aDoxMDAlfXVsLnN2ZWx0ZS1xMTUyNy5zdmVsdGUtcTE1Mjd7bWF4LWhlaWdodDo2NnZoO292ZXJmbG93LXk6c2Nyb2xsfX1cIjtcbiAgYXBwZW5kKGRvY3VtZW50LmhlYWQsIHN0eWxlKTtcbn1cblxuZnVuY3Rpb24gZ2V0X2VhY2hfY29udGV4dChjdHgsIGxpc3QsIGkpIHtcbiAgdmFyIGNoaWxkX2N0eCA9IGN0eC5zbGljZSgpO1xuICBjaGlsZF9jdHhbMTBdID0gbGlzdFtpXTtcbiAgY2hpbGRfY3R4WzEyXSA9IGk7XG4gIHJldHVybiBjaGlsZF9jdHg7XG59XG5cbmZ1bmN0aW9uIGdldF9lYWNoX2NvbnRleHRfMShjdHgsIGxpc3QsIGkpIHtcbiAgdmFyIGNoaWxkX2N0eCA9IGN0eC5zbGljZSgpO1xuICBjaGlsZF9jdHhbMTBdID0gbGlzdFtpXTtcbiAgY2hpbGRfY3R4WzEyXSA9IGk7XG4gIHJldHVybiBjaGlsZF9jdHg7XG59IC8vICg2MjoyKSB7I2VhY2ggbW9kYWxEYXRhLnByaW1hcnlXYWxsZXRzIGFzIHdhbGxldCwgaSAod2FsbGV0Lm5hbWUpfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9lYWNoX2Jsb2NrXzEoa2V5XzEsIGN0eCkge1xuICB2YXIgbGk7XG4gIHZhciBpY29uYnV0dG9uO1xuICB2YXIgY3VycmVudDtcblxuICBmdW5jdGlvbiBmdW5jKCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKmZ1bmMqL1xuICAgICAgY3R4WzddKFxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzEwXSlcbiAgICApO1xuICB9XG5cbiAgaWNvbmJ1dHRvbiA9IG5ldyBJY29uQnV0dG9uKHtcbiAgICBwcm9wczoge1xuICAgICAgZGlzYWJsZWQ6XG4gICAgICAvKndhbGxldHNEaXNhYmxlZCovXG4gICAgICBjdHhbNV0sXG4gICAgICBvbmNsaWNrOiBmdW5jLFxuICAgICAgaWNvblNyYzpcbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFsxMF0uaWNvblNyYyxcbiAgICAgIGljb25TcmNTZXQ6XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbMTBdLmljb25TcmNTZXQsXG4gICAgICBzdmc6XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbMTBdLnN2ZyxcbiAgICAgIHRleHQ6XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbMTBdLm5hbWUsXG4gICAgICBjdXJyZW50bHlTZWxlY3RlZDpcbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFsxMF0ubmFtZSA9PT1cbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXQqL1xuICAgICAgY3R4WzZdLm5hbWUsXG4gICAgICBsb2FkaW5nV2FsbGV0OlxuICAgICAgLypsb2FkaW5nV2FsbGV0Ki9cbiAgICAgIGN0eFsyXVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBrZXlfMSxcbiAgICBmaXJzdDogbnVsbCxcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgbGkgPSBlbGVtZW50KFwibGlcIik7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KGljb25idXR0b24uJCQuZnJhZ21lbnQpO1xuICAgICAgYXR0cihsaSwgXCJjbGFzc1wiLCBcInN2ZWx0ZS1xMTUyN1wiKTtcbiAgICAgIHRoaXMuZmlyc3QgPSBsaTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIGxpLCBhbmNob3IpO1xuICAgICAgbW91bnRfY29tcG9uZW50KGljb25idXR0b24sIGxpLCBudWxsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChuZXdfY3R4LCBkaXJ0eSkge1xuICAgICAgY3R4ID0gbmV3X2N0eDtcbiAgICAgIHZhciBpY29uYnV0dG9uX2NoYW5nZXMgPSB7fTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKndhbGxldHNEaXNhYmxlZCovXG4gICAgICAzMikgaWNvbmJ1dHRvbl9jaGFuZ2VzLmRpc2FibGVkID1cbiAgICAgIC8qd2FsbGV0c0Rpc2FibGVkKi9cbiAgICAgIGN0eFs1XTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmhhbmRsZVdhbGxldFNlbGVjdCwgbW9kYWxEYXRhKi9cbiAgICAgIDMpIGljb25idXR0b25fY2hhbmdlcy5vbmNsaWNrID0gZnVuYztcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAxKSBpY29uYnV0dG9uX2NoYW5nZXMuaWNvblNyYyA9XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbMTBdLmljb25TcmM7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgMSkgaWNvbmJ1dHRvbl9jaGFuZ2VzLmljb25TcmNTZXQgPVxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzEwXS5pY29uU3JjU2V0O1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIDEpIGljb25idXR0b25fY2hhbmdlcy5zdmcgPVxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzEwXS5zdmc7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgMSkgaWNvbmJ1dHRvbl9jaGFuZ2VzLnRleHQgPVxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzEwXS5uYW1lO1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qbW9kYWxEYXRhLCBzZWxlY3RlZFdhbGxldCovXG4gICAgICA2NSkgaWNvbmJ1dHRvbl9jaGFuZ2VzLmN1cnJlbnRseVNlbGVjdGVkID1cbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFsxMF0ubmFtZSA9PT1cbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXQqL1xuICAgICAgY3R4WzZdLm5hbWU7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypsb2FkaW5nV2FsbGV0Ki9cbiAgICAgIDQpIGljb25idXR0b25fY2hhbmdlcy5sb2FkaW5nV2FsbGV0ID1cbiAgICAgIC8qbG9hZGluZ1dhbGxldCovXG4gICAgICBjdHhbMl07XG4gICAgICBpY29uYnV0dG9uLiRzZXQoaWNvbmJ1dHRvbl9jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGljb25idXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoaWNvbmJ1dHRvbi4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChsaSk7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChpY29uYnV0dG9uKTtcbiAgICB9XG4gIH07XG59IC8vICg3NzoyKSB7I2lmIG1vZGFsRGF0YS5zZWNvbmRhcnlXYWxsZXRzICYmIG1vZGFsRGF0YS5zZWNvbmRhcnlXYWxsZXRzLmxlbmd0aCAmJiAhc2hvd2luZ0FsbFdhbGxldE1vZHVsZXN9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrXzEkMihjdHgpIHtcbiAgdmFyIGRpdjtcbiAgdmFyIGJ1dHRvbjtcbiAgdmFyIGN1cnJlbnQ7XG4gIGJ1dHRvbiA9IG5ldyBCdXR0b24oe1xuICAgIHByb3BzOiB7XG4gICAgICBkaXNhYmxlZDpcbiAgICAgIC8qd2FsbGV0c0Rpc2FibGVkKi9cbiAgICAgIGN0eFs1XSxcbiAgICAgIG9uY2xpY2s6XG4gICAgICAvKnNob3dBbGxXYWxsZXRzKi9cbiAgICAgIGN0eFs0XSxcbiAgICAgICQkc2xvdHM6IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IFtjcmVhdGVfZGVmYXVsdF9zbG90XVxuICAgICAgfSxcbiAgICAgICQkc2NvcGU6IHtcbiAgICAgICAgY3R4OiBjdHhcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBkaXYgPSBlbGVtZW50KFwiZGl2XCIpO1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChidXR0b24uJCQuZnJhZ21lbnQpO1xuICAgICAgYXR0cihkaXYsIFwiY2xhc3NcIiwgXCJzdmVsdGUtcTE1MjdcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBkaXYsIGFuY2hvcik7XG4gICAgICBtb3VudF9jb21wb25lbnQoYnV0dG9uLCBkaXYsIG51bGwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIHZhciBidXR0b25fY2hhbmdlcyA9IHt9O1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qd2FsbGV0c0Rpc2FibGVkKi9cbiAgICAgIDMyKSBidXR0b25fY2hhbmdlcy5kaXNhYmxlZCA9XG4gICAgICAvKndhbGxldHNEaXNhYmxlZCovXG4gICAgICBjdHhbNV07XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypzaG93QWxsV2FsbGV0cyovXG4gICAgICAxNikgYnV0dG9uX2NoYW5nZXMub25jbGljayA9XG4gICAgICAvKnNob3dBbGxXYWxsZXRzKi9cbiAgICAgIGN0eFs0XTtcblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qJCRzY29wZSovXG4gICAgICAxNjM4NCkge1xuICAgICAgICBidXR0b25fY2hhbmdlcy4kJHNjb3BlID0ge1xuICAgICAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBidXR0b24uJHNldChidXR0b25fY2hhbmdlcyk7XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihidXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoYnV0dG9uLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGRpdik7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChidXR0b24pO1xuICAgIH1cbiAgfTtcbn0gLy8gKDc5OjYpIDxCdXR0b24gZGlzYWJsZWQ9e3dhbGxldHNEaXNhYmxlZH0gb25jbGljaz17c2hvd0FsbFdhbGxldHN9ICAgICAgICAgPlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9kZWZhdWx0X3Nsb3QoY3R4KSB7XG4gIHZhciB0O1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICB0ID0gdGV4dChcIlNob3cgTW9yZVwiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQsIGFuY2hvcik7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDg1OjIpIHsjaWYgc2hvd2luZ0FsbFdhbGxldE1vZHVsZXN9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrJDQoY3R4KSB7XG4gIHZhciBlYWNoX2Jsb2NrcyA9IFtdO1xuICB2YXIgZWFjaF8xX2xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgdmFyIGVhY2hfMV9hbmNob3I7XG4gIHZhciBjdXJyZW50O1xuICB2YXIgZWFjaF92YWx1ZSA9XG4gIC8qbW9kYWxEYXRhKi9cbiAgY3R4WzBdLnNlY29uZGFyeVdhbGxldHM7XG5cbiAgdmFyIGdldF9rZXkgPSBmdW5jdGlvbiBnZXRfa2V5KGN0eCkge1xuICAgIHJldHVybiAoXG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbMTBdLm5hbWVcbiAgICApO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWFjaF92YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBjaGlsZF9jdHggPSBnZXRfZWFjaF9jb250ZXh0KGN0eCwgZWFjaF92YWx1ZSwgaSk7XG4gICAgdmFyIGtleSA9IGdldF9rZXkoY2hpbGRfY3R4KTtcbiAgICBlYWNoXzFfbG9va3VwLnNldChrZXksIGVhY2hfYmxvY2tzW2ldID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGZvciAodmFyIF9pMyA9IDA7IF9pMyA8IGVhY2hfYmxvY2tzLmxlbmd0aDsgX2kzICs9IDEpIHtcbiAgICAgICAgZWFjaF9ibG9ja3NbX2kzXS5jKCk7XG4gICAgICB9XG5cbiAgICAgIGVhY2hfMV9hbmNob3IgPSBlbXB0eSgpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgZm9yICh2YXIgX2k0ID0gMDsgX2k0IDwgZWFjaF9ibG9ja3MubGVuZ3RoOyBfaTQgKz0gMSkge1xuICAgICAgICBlYWNoX2Jsb2Nrc1tfaTRdLm0odGFyZ2V0LCBhbmNob3IpO1xuICAgICAgfVxuXG4gICAgICBpbnNlcnQodGFyZ2V0LCBlYWNoXzFfYW5jaG9yLCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKndhbGxldHNEaXNhYmxlZCwgaGFuZGxlV2FsbGV0U2VsZWN0LCBtb2RhbERhdGEsIHNlbGVjdGVkV2FsbGV0LCBsb2FkaW5nV2FsbGV0Ki9cbiAgICAgIDEwMykge1xuICAgICAgICBlYWNoX3ZhbHVlID1cbiAgICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgICBjdHhbMF0uc2Vjb25kYXJ5V2FsbGV0cztcbiAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgIGVhY2hfYmxvY2tzID0gdXBkYXRlX2tleWVkX2VhY2goZWFjaF9ibG9ja3MsIGRpcnR5LCBnZXRfa2V5LCAxLCBjdHgsIGVhY2hfdmFsdWUsIGVhY2hfMV9sb29rdXAsIGVhY2hfMV9hbmNob3IucGFyZW50Tm9kZSwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIGNyZWF0ZV9lYWNoX2Jsb2NrLCBlYWNoXzFfYW5jaG9yLCBnZXRfZWFjaF9jb250ZXh0KTtcbiAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBfaTUgPSAwOyBfaTUgPCBlYWNoX3ZhbHVlLmxlbmd0aDsgX2k1ICs9IDEpIHtcbiAgICAgICAgdHJhbnNpdGlvbl9pbihlYWNoX2Jsb2Nrc1tfaTVdKTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICBmb3IgKHZhciBfaTYgPSAwOyBfaTYgPCBlYWNoX2Jsb2Nrcy5sZW5ndGg7IF9pNiArPSAxKSB7XG4gICAgICAgIHRyYW5zaXRpb25fb3V0KGVhY2hfYmxvY2tzW19pNl0pO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgZm9yICh2YXIgX2k3ID0gMDsgX2k3IDwgZWFjaF9ibG9ja3MubGVuZ3RoOyBfaTcgKz0gMSkge1xuICAgICAgICBlYWNoX2Jsb2Nrc1tfaTddLmQoZGV0YWNoaW5nKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGVhY2hfMV9hbmNob3IpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDg2OjQpIHsjZWFjaCBtb2RhbERhdGEuc2Vjb25kYXJ5V2FsbGV0cyBhcyB3YWxsZXQsIGkgKHdhbGxldC5uYW1lKX1cblxuXG5mdW5jdGlvbiBjcmVhdGVfZWFjaF9ibG9jayhrZXlfMSwgY3R4KSB7XG4gIHZhciBsaTtcbiAgdmFyIGljb25idXR0b247XG4gIHZhciB0O1xuICB2YXIgY3VycmVudDtcblxuICBmdW5jdGlvbiBmdW5jXzEoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qZnVuY18xKi9cbiAgICAgIGN0eFs4XShcbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFsxMF0pXG4gICAgKTtcbiAgfVxuXG4gIGljb25idXR0b24gPSBuZXcgSWNvbkJ1dHRvbih7XG4gICAgcHJvcHM6IHtcbiAgICAgIGRpc2FibGVkOlxuICAgICAgLyp3YWxsZXRzRGlzYWJsZWQqL1xuICAgICAgY3R4WzVdLFxuICAgICAgb25jbGljazogZnVuY18xLFxuICAgICAgaWNvblNyYzpcbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFsxMF0uaWNvblNyYyxcbiAgICAgIGljb25TcmNTZXQ6XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbMTBdLmljb25TcmNTZXQsXG4gICAgICBzdmc6XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbMTBdLnN2ZyxcbiAgICAgIHRleHQ6XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbMTBdLm5hbWUsXG4gICAgICBjdXJyZW50bHlTZWxlY3RlZDpcbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFsxMF0ubmFtZSA9PT1cbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXQqL1xuICAgICAgY3R4WzZdLm5hbWUsXG4gICAgICBsb2FkaW5nV2FsbGV0OlxuICAgICAgLypsb2FkaW5nV2FsbGV0Ki9cbiAgICAgIGN0eFsyXVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAga2V5OiBrZXlfMSxcbiAgICBmaXJzdDogbnVsbCxcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgbGkgPSBlbGVtZW50KFwibGlcIik7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KGljb25idXR0b24uJCQuZnJhZ21lbnQpO1xuICAgICAgdCA9IHNwYWNlKCk7XG4gICAgICBhdHRyKGxpLCBcImNsYXNzXCIsIFwic3ZlbHRlLXExNTI3XCIpO1xuICAgICAgdGhpcy5maXJzdCA9IGxpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgbGksIGFuY2hvcik7XG4gICAgICBtb3VudF9jb21wb25lbnQoaWNvbmJ1dHRvbiwgbGksIG51bGwpO1xuICAgICAgYXBwZW5kKGxpLCB0KTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChuZXdfY3R4LCBkaXJ0eSkge1xuICAgICAgY3R4ID0gbmV3X2N0eDtcbiAgICAgIHZhciBpY29uYnV0dG9uX2NoYW5nZXMgPSB7fTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKndhbGxldHNEaXNhYmxlZCovXG4gICAgICAzMikgaWNvbmJ1dHRvbl9jaGFuZ2VzLmRpc2FibGVkID1cbiAgICAgIC8qd2FsbGV0c0Rpc2FibGVkKi9cbiAgICAgIGN0eFs1XTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmhhbmRsZVdhbGxldFNlbGVjdCwgbW9kYWxEYXRhKi9cbiAgICAgIDMpIGljb25idXR0b25fY2hhbmdlcy5vbmNsaWNrID0gZnVuY18xO1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIDEpIGljb25idXR0b25fY2hhbmdlcy5pY29uU3JjID1cbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFsxMF0uaWNvblNyYztcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAxKSBpY29uYnV0dG9uX2NoYW5nZXMuaWNvblNyY1NldCA9XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbMTBdLmljb25TcmNTZXQ7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgMSkgaWNvbmJ1dHRvbl9jaGFuZ2VzLnN2ZyA9XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbMTBdLnN2ZztcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAxKSBpY29uYnV0dG9uX2NoYW5nZXMudGV4dCA9XG4gICAgICAvKndhbGxldCovXG4gICAgICBjdHhbMTBdLm5hbWU7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyptb2RhbERhdGEsIHNlbGVjdGVkV2FsbGV0Ki9cbiAgICAgIDY1KSBpY29uYnV0dG9uX2NoYW5nZXMuY3VycmVudGx5U2VsZWN0ZWQgPVxuICAgICAgLyp3YWxsZXQqL1xuICAgICAgY3R4WzEwXS5uYW1lID09PVxuICAgICAgLypzZWxlY3RlZFdhbGxldCovXG4gICAgICBjdHhbNl0ubmFtZTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmxvYWRpbmdXYWxsZXQqL1xuICAgICAgNCkgaWNvbmJ1dHRvbl9jaGFuZ2VzLmxvYWRpbmdXYWxsZXQgPVxuICAgICAgLypsb2FkaW5nV2FsbGV0Ki9cbiAgICAgIGN0eFsyXTtcbiAgICAgIGljb25idXR0b24uJHNldChpY29uYnV0dG9uX2NoYW5nZXMpO1xuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4oaWNvbmJ1dHRvbi4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChpY29uYnV0dG9uLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGxpKTtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KGljb25idXR0b24pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50JDYoY3R4KSB7XG4gIHZhciB1bDtcbiAgdmFyIGVhY2hfYmxvY2tzID0gW107XG4gIHZhciBlYWNoXzFfbG9va3VwID0gbmV3IE1hcCgpO1xuICB2YXIgdDA7XG4gIHZhciB0MTtcbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBlYWNoX3ZhbHVlXzEgPVxuICAvKm1vZGFsRGF0YSovXG4gIGN0eFswXS5wcmltYXJ5V2FsbGV0cztcblxuICB2YXIgZ2V0X2tleSA9IGZ1bmN0aW9uIGdldF9rZXkoY3R4KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIC8qd2FsbGV0Ki9cbiAgICAgIGN0eFsxMF0ubmFtZVxuICAgICk7XG4gIH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBlYWNoX3ZhbHVlXzEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICB2YXIgY2hpbGRfY3R4ID0gZ2V0X2VhY2hfY29udGV4dF8xKGN0eCwgZWFjaF92YWx1ZV8xLCBpKTtcbiAgICB2YXIga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuICAgIGVhY2hfMV9sb29rdXAuc2V0KGtleSwgZWFjaF9ibG9ja3NbaV0gPSBjcmVhdGVfZWFjaF9ibG9ja18xKGtleSwgY2hpbGRfY3R4KSk7XG4gIH1cblxuICB2YXIgaWZfYmxvY2swID1cbiAgLyptb2RhbERhdGEqL1xuICBjdHhbMF0uc2Vjb25kYXJ5V2FsbGV0cyAmJlxuICAvKm1vZGFsRGF0YSovXG4gIGN0eFswXS5zZWNvbmRhcnlXYWxsZXRzLmxlbmd0aCAmJiAhXG4gIC8qc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMqL1xuICBjdHhbM10gJiYgY3JlYXRlX2lmX2Jsb2NrXzEkMihjdHgpO1xuICB2YXIgaWZfYmxvY2sxID1cbiAgLypzaG93aW5nQWxsV2FsbGV0TW9kdWxlcyovXG4gIGN0eFszXSAmJiBjcmVhdGVfaWZfYmxvY2skNChjdHgpO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICB1bCA9IGVsZW1lbnQoXCJ1bFwiKTtcblxuICAgICAgZm9yICh2YXIgX2k4ID0gMDsgX2k4IDwgZWFjaF9ibG9ja3MubGVuZ3RoOyBfaTggKz0gMSkge1xuICAgICAgICBlYWNoX2Jsb2Nrc1tfaThdLmMoKTtcbiAgICAgIH1cblxuICAgICAgdDAgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMCkgaWZfYmxvY2swLmMoKTtcbiAgICAgIHQxID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5jKCk7XG4gICAgICBhdHRyKHVsLCBcImNsYXNzXCIsIFwiYm4tb25ib2FyZC1jdXN0b20gYm4tb25ib2FyZC1tb2RhbC1zZWxlY3Qtd2FsbGV0cyBzdmVsdGUtcTE1MjdcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB1bCwgYW5jaG9yKTtcblxuICAgICAgZm9yICh2YXIgX2k5ID0gMDsgX2k5IDwgZWFjaF9ibG9ja3MubGVuZ3RoOyBfaTkgKz0gMSkge1xuICAgICAgICBlYWNoX2Jsb2Nrc1tfaTldLm0odWwsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICBhcHBlbmQodWwsIHQwKTtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5tKHVsLCBudWxsKTtcbiAgICAgIGFwcGVuZCh1bCwgdDEpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLm0odWwsIG51bGwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgX3JlZjIyKSB7XG4gICAgICB2YXIgX3JlZjIzID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIyLCAxKSxcbiAgICAgICAgICBkaXJ0eSA9IF9yZWYyM1swXTtcblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qd2FsbGV0c0Rpc2FibGVkLCBoYW5kbGVXYWxsZXRTZWxlY3QsIG1vZGFsRGF0YSwgc2VsZWN0ZWRXYWxsZXQsIGxvYWRpbmdXYWxsZXQqL1xuICAgICAgMTAzKSB7XG4gICAgICAgIGVhY2hfdmFsdWVfMSA9XG4gICAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgICAgY3R4WzBdLnByaW1hcnlXYWxsZXRzO1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgZWFjaF9ibG9ja3MgPSB1cGRhdGVfa2V5ZWRfZWFjaChlYWNoX2Jsb2NrcywgZGlydHksIGdldF9rZXksIDEsIGN0eCwgZWFjaF92YWx1ZV8xLCBlYWNoXzFfbG9va3VwLCB1bCwgb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIGNyZWF0ZV9lYWNoX2Jsb2NrXzEsIHQwLCBnZXRfZWFjaF9jb250ZXh0XzEpO1xuICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgY3R4WzBdLnNlY29uZGFyeVdhbGxldHMgJiZcbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIGN0eFswXS5zZWNvbmRhcnlXYWxsZXRzLmxlbmd0aCAmJiAhXG4gICAgICAvKnNob3dpbmdBbGxXYWxsZXRNb2R1bGVzKi9cbiAgICAgIGN0eFszXSkge1xuICAgICAgICBpZiAoaWZfYmxvY2swKSB7XG4gICAgICAgICAgaWZfYmxvY2swLnAoY3R4LCBkaXJ0eSk7XG5cbiAgICAgICAgICBpZiAoZGlydHkgJlxuICAgICAgICAgIC8qbW9kYWxEYXRhLCBzaG93aW5nQWxsV2FsbGV0TW9kdWxlcyovXG4gICAgICAgICAgOSkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jazAgPSBjcmVhdGVfaWZfYmxvY2tfMSQyKGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2swLmMoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCwgMSk7XG4gICAgICAgICAgaWZfYmxvY2swLm0odWwsIHQxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jazApIHtcbiAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMCwgMSwgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmX2Jsb2NrMCA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgLypzaG93aW5nQWxsV2FsbGV0TW9kdWxlcyovXG4gICAgICBjdHhbM10pIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICAgIGlmX2Jsb2NrMS5wKGN0eCwgZGlydHkpO1xuXG4gICAgICAgICAgaWYgKGRpcnR5ICZcbiAgICAgICAgICAvKnNob3dpbmdBbGxXYWxsZXRNb2R1bGVzKi9cbiAgICAgICAgICA4KSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMSA9IGNyZWF0ZV9pZl9ibG9jayQ0KGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2sxLmMoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMSwgMSk7XG4gICAgICAgICAgaWZfYmxvY2sxLm0odWwsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2sxLCAxLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWZfYmxvY2sxID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcblxuICAgICAgZm9yICh2YXIgX2kxMCA9IDA7IF9pMTAgPCBlYWNoX3ZhbHVlXzEubGVuZ3RoOyBfaTEwICs9IDEpIHtcbiAgICAgICAgdHJhbnNpdGlvbl9pbihlYWNoX2Jsb2Nrc1tfaTEwXSk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swKTtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2sxKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgZm9yICh2YXIgX2kxMSA9IDA7IF9pMTEgPCBlYWNoX2Jsb2Nrcy5sZW5ndGg7IF9pMTEgKz0gMSkge1xuICAgICAgICB0cmFuc2l0aW9uX291dChlYWNoX2Jsb2Nrc1tfaTExXSk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMCk7XG4gICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazEpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh1bCk7XG5cbiAgICAgIGZvciAodmFyIF9pMTIgPSAwOyBfaTEyIDwgZWFjaF9ibG9ja3MubGVuZ3RoOyBfaTEyICs9IDEpIHtcbiAgICAgICAgZWFjaF9ibG9ja3NbX2kxMl0uZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAuZCgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLmQoKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlJDYoJCRzZWxmLCAkJHByb3BzLCAkJGludmFsaWRhdGUpIHtcbiAgdmFyIG1vZGFsRGF0YSA9ICQkcHJvcHMubW9kYWxEYXRhO1xuICB2YXIgaGFuZGxlV2FsbGV0U2VsZWN0ID0gJCRwcm9wcy5oYW5kbGVXYWxsZXRTZWxlY3Q7XG4gIHZhciBsb2FkaW5nV2FsbGV0ID0gJCRwcm9wcy5sb2FkaW5nV2FsbGV0O1xuICB2YXIgXyQkcHJvcHMkc2hvd2luZ0FsbFdhID0gJCRwcm9wcy5zaG93aW5nQWxsV2FsbGV0TW9kdWxlcyxcbiAgICAgIHNob3dpbmdBbGxXYWxsZXRNb2R1bGVzID0gXyQkcHJvcHMkc2hvd2luZ0FsbFdhID09PSB2b2lkIDAgPyBmYWxzZSA6IF8kJHByb3BzJHNob3dpbmdBbGxXYTtcbiAgdmFyIHNob3dBbGxXYWxsZXRzID0gJCRwcm9wcy5zaG93QWxsV2FsbGV0cztcbiAgdmFyIF8kJHByb3BzJHdhbGxldHNEaXNhYiA9ICQkcHJvcHMud2FsbGV0c0Rpc2FibGVkLFxuICAgICAgd2FsbGV0c0Rpc2FibGVkID0gXyQkcHJvcHMkd2FsbGV0c0Rpc2FiID09PSB2b2lkIDAgPyBmYWxzZSA6IF8kJHByb3BzJHdhbGxldHNEaXNhYjtcbiAgdmFyIHNlbGVjdGVkV2FsbGV0O1xuICB2YXIgdW5zdWJzY3JpYmUgPSB3YWxsZXQuc3Vic2NyaWJlKGZ1bmN0aW9uICh3YWxsZXQpIHtcbiAgICByZXR1cm4gJCRpbnZhbGlkYXRlKDYsIHNlbGVjdGVkV2FsbGV0ID0gd2FsbGV0KTtcbiAgfSk7XG4gIG9uRGVzdHJveShmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHVuc3Vic2NyaWJlKCk7XG4gIH0pO1xuXG4gIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYyh3YWxsZXQpIHtcbiAgICByZXR1cm4gaGFuZGxlV2FsbGV0U2VsZWN0KHdhbGxldCk7XG4gIH07XG5cbiAgdmFyIGZ1bmNfMSA9IGZ1bmN0aW9uIGZ1bmNfMSh3YWxsZXQpIHtcbiAgICByZXR1cm4gaGFuZGxlV2FsbGV0U2VsZWN0KHdhbGxldCk7XG4gIH07XG5cbiAgJCRzZWxmLiQkc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJtb2RhbERhdGFcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMCwgbW9kYWxEYXRhID0gJCRwcm9wcy5tb2RhbERhdGEpO1xuICAgIGlmIChcImhhbmRsZVdhbGxldFNlbGVjdFwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgxLCBoYW5kbGVXYWxsZXRTZWxlY3QgPSAkJHByb3BzLmhhbmRsZVdhbGxldFNlbGVjdCk7XG4gICAgaWYgKFwibG9hZGluZ1dhbGxldFwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgyLCBsb2FkaW5nV2FsbGV0ID0gJCRwcm9wcy5sb2FkaW5nV2FsbGV0KTtcbiAgICBpZiAoXCJzaG93aW5nQWxsV2FsbGV0TW9kdWxlc1wiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgzLCBzaG93aW5nQWxsV2FsbGV0TW9kdWxlcyA9ICQkcHJvcHMuc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMpO1xuICAgIGlmIChcInNob3dBbGxXYWxsZXRzXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDQsIHNob3dBbGxXYWxsZXRzID0gJCRwcm9wcy5zaG93QWxsV2FsbGV0cyk7XG4gICAgaWYgKFwid2FsbGV0c0Rpc2FibGVkXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDUsIHdhbGxldHNEaXNhYmxlZCA9ICQkcHJvcHMud2FsbGV0c0Rpc2FibGVkKTtcbiAgfTtcblxuICByZXR1cm4gW21vZGFsRGF0YSwgaGFuZGxlV2FsbGV0U2VsZWN0LCBsb2FkaW5nV2FsbGV0LCBzaG93aW5nQWxsV2FsbGV0TW9kdWxlcywgc2hvd0FsbFdhbGxldHMsIHdhbGxldHNEaXNhYmxlZCwgc2VsZWN0ZWRXYWxsZXQsIGZ1bmMsIGZ1bmNfMV07XG59XG5cbnZhciBXYWxsZXRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3ZlbHRlQ29tcG9uZW50Nykge1xuICBfaW5oZXJpdHMoV2FsbGV0cywgX1N2ZWx0ZUNvbXBvbmVudDcpO1xuXG4gIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKFdhbGxldHMpO1xuXG4gIGZ1bmN0aW9uIFdhbGxldHMob3B0aW9ucykge1xuICAgIHZhciBfdGhpczc7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2FsbGV0cyk7XG5cbiAgICBfdGhpczcgPSBfc3VwZXI3LmNhbGwodGhpcyk7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInN2ZWx0ZS1xMTUyNy1zdHlsZVwiKSkgYWRkX2NzcyQ2KCk7XG4gICAgaW5pdChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzNyksIG9wdGlvbnMsIGluc3RhbmNlJDYsIGNyZWF0ZV9mcmFnbWVudCQ2LCBzYWZlX25vdF9lcXVhbCwge1xuICAgICAgbW9kYWxEYXRhOiAwLFxuICAgICAgaGFuZGxlV2FsbGV0U2VsZWN0OiAxLFxuICAgICAgbG9hZGluZ1dhbGxldDogMixcbiAgICAgIHNob3dpbmdBbGxXYWxsZXRNb2R1bGVzOiAzLFxuICAgICAgc2hvd0FsbFdhbGxldHM6IDQsXG4gICAgICB3YWxsZXRzRGlzYWJsZWQ6IDVcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM3O1xuICB9XG5cbiAgcmV0dXJuIFdhbGxldHM7XG59KFN2ZWx0ZUNvbXBvbmVudCk7XG4vKiBzcmMvZWxlbWVudHMvSWNvbkRpc3BsYXkuc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMzguMiAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MkNygpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLTE4enRzNGItc3R5bGVcIjtcbiAgc3R5bGUudGV4dENvbnRlbnQgPSBcImRpdi5zdmVsdGUtMTh6dHM0YntkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyO2JvcmRlcjpub25lO21hcmdpbjowO2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtZmFtaWx5OmluaGVyaXQ7YmFja2dyb3VuZDppbmhlcml0O3BhZGRpbmc6MDt3aWR0aDoxOGVtO2JvcmRlci1yYWRpdXM6NDBweDtjb2xvcjppbmhlcml0fWltZy5zdmVsdGUtMTh6dHM0Ynt3aWR0aDphdXRvO2hlaWdodDozZW19c3Bhbi5zdmVsdGUtMTh6dHM0YnttYXJnaW4tbGVmdDowLjY2ZW07Zm9udC13ZWlnaHQ6Ym9sZDtmb250LXNpemU6aW5oZXJpdDtmb250LWZhbWlseTppbmhlcml0O29wYWNpdHk6MC43O3RleHQtYWxpZ246bGVmdH1cIjtcbiAgYXBwZW5kKGRvY3VtZW50LmhlYWQsIHN0eWxlKTtcbn0gLy8gKDQxOjIpIHs6ZWxzZX1cblxuXG5mdW5jdGlvbiBjcmVhdGVfZWxzZV9ibG9jayQyKGN0eCkge1xuICB2YXIgaW1nO1xuICB2YXIgaW1nX3NyY192YWx1ZTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgaW1nID0gZWxlbWVudChcImltZ1wiKTtcbiAgICAgIGlmIChpbWcuc3JjICE9PSAoaW1nX3NyY192YWx1ZSA9XG4gICAgICAvKmljb25TcmMqL1xuICAgICAgY3R4WzBdKSkgYXR0cihpbWcsIFwic3JjXCIsIGltZ19zcmNfdmFsdWUpO1xuICAgICAgYXR0cihpbWcsIFwic3Jjc2V0XCIsXG4gICAgICAvKmljb25TcmNTZXQqL1xuICAgICAgY3R4WzFdKTtcbiAgICAgIGF0dHIoaW1nLCBcImFsdFwiLFxuICAgICAgLyp0ZXh0Ki9cbiAgICAgIGN0eFsyXSk7XG4gICAgICBhdHRyKGltZywgXCJjbGFzc1wiLCBcInN2ZWx0ZS0xOHp0czRiXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgaW1nLCBhbmNob3IpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyppY29uU3JjKi9cbiAgICAgIDEgJiYgaW1nLnNyYyAhPT0gKGltZ19zcmNfdmFsdWUgPVxuICAgICAgLyppY29uU3JjKi9cbiAgICAgIGN0eFswXSkpIHtcbiAgICAgICAgYXR0cihpbWcsIFwic3JjXCIsIGltZ19zcmNfdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyppY29uU3JjU2V0Ki9cbiAgICAgIDIpIHtcbiAgICAgICAgYXR0cihpbWcsIFwic3Jjc2V0XCIsXG4gICAgICAgIC8qaWNvblNyY1NldCovXG4gICAgICAgIGN0eFsxXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKnRleHQqL1xuICAgICAgNCkge1xuICAgICAgICBhdHRyKGltZywgXCJhbHRcIixcbiAgICAgICAgLyp0ZXh0Ki9cbiAgICAgICAgY3R4WzJdKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goaW1nKTtcbiAgICB9XG4gIH07XG59IC8vICgzOToyKSB7I2lmIHN2Z31cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2skNShjdHgpIHtcbiAgdmFyIGh0bWxfdGFnO1xuICB2YXIgaHRtbF9hbmNob3I7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGh0bWxfYW5jaG9yID0gZW1wdHkoKTtcbiAgICAgIGh0bWxfdGFnID0gbmV3IEh0bWxUYWcoaHRtbF9hbmNob3IpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaHRtbF90YWcubShcbiAgICAgIC8qc3ZnKi9cbiAgICAgIGN0eFszXSwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgaHRtbF9hbmNob3IsIGFuY2hvcik7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKnN2ZyovXG4gICAgICA4KSBodG1sX3RhZy5wKFxuICAgICAgLypzdmcqL1xuICAgICAgY3R4WzNdKTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goaHRtbF9hbmNob3IpO1xuICAgICAgaWYgKGRldGFjaGluZykgaHRtbF90YWcuZCgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50JDcoY3R4KSB7XG4gIHZhciBkaXY7XG4gIHZhciB0MDtcbiAgdmFyIHNwYW47XG4gIHZhciB0MTtcblxuICBmdW5jdGlvbiBzZWxlY3RfYmxvY2tfdHlwZShjdHgsIGRpcnR5KSB7XG4gICAgaWYgKFxuICAgIC8qc3ZnKi9cbiAgICBjdHhbM10pIHJldHVybiBjcmVhdGVfaWZfYmxvY2skNTtcbiAgICByZXR1cm4gY3JlYXRlX2Vsc2VfYmxvY2skMjtcbiAgfVxuXG4gIHZhciBjdXJyZW50X2Jsb2NrX3R5cGUgPSBzZWxlY3RfYmxvY2tfdHlwZShjdHgpO1xuICB2YXIgaWZfYmxvY2sgPSBjdXJyZW50X2Jsb2NrX3R5cGUoY3R4KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgZGl2ID0gZWxlbWVudChcImRpdlwiKTtcbiAgICAgIGlmX2Jsb2NrLmMoKTtcbiAgICAgIHQwID0gc3BhY2UoKTtcbiAgICAgIHNwYW4gPSBlbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHQxID0gdGV4dChcbiAgICAgIC8qdGV4dCovXG4gICAgICBjdHhbMl0pO1xuICAgICAgYXR0cihzcGFuLCBcImNsYXNzXCIsIFwic3ZlbHRlLTE4enRzNGJcIik7XG4gICAgICBhdHRyKGRpdiwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtaWNvbi1kaXNwbGF5IHN2ZWx0ZS0xOHp0czRiXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgZGl2LCBhbmNob3IpO1xuICAgICAgaWZfYmxvY2subShkaXYsIG51bGwpO1xuICAgICAgYXBwZW5kKGRpdiwgdDApO1xuICAgICAgYXBwZW5kKGRpdiwgc3Bhbik7XG4gICAgICBhcHBlbmQoc3BhbiwgdDEpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIF9yZWYyNCkge1xuICAgICAgdmFyIF9yZWYyNSA9IF9zbGljZWRUb0FycmF5KF9yZWYyNCwgMSksXG4gICAgICAgICAgZGlydHkgPSBfcmVmMjVbMF07XG5cbiAgICAgIGlmIChjdXJyZW50X2Jsb2NrX3R5cGUgPT09IChjdXJyZW50X2Jsb2NrX3R5cGUgPSBzZWxlY3RfYmxvY2tfdHlwZShjdHgpKSAmJiBpZl9ibG9jaykge1xuICAgICAgICBpZl9ibG9jay5wKGN0eCwgZGlydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWZfYmxvY2suZCgxKTtcbiAgICAgICAgaWZfYmxvY2sgPSBjdXJyZW50X2Jsb2NrX3R5cGUoY3R4KTtcblxuICAgICAgICBpZiAoaWZfYmxvY2spIHtcbiAgICAgICAgICBpZl9ibG9jay5jKCk7XG4gICAgICAgICAgaWZfYmxvY2subShkaXYsIHQwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyp0ZXh0Ki9cbiAgICAgIDQpIHNldF9kYXRhKHQxLFxuICAgICAgLyp0ZXh0Ki9cbiAgICAgIGN0eFsyXSk7XG4gICAgfSxcbiAgICBpOiBub29wLFxuICAgIG86IG5vb3AsXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChkaXYpO1xuICAgICAgaWZfYmxvY2suZCgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5zdGFuY2UkNygkJHNlbGYsICQkcHJvcHMsICQkaW52YWxpZGF0ZSkge1xuICB2YXIgaWNvblNyYyA9ICQkcHJvcHMuaWNvblNyYztcbiAgdmFyIGljb25TcmNTZXQgPSAkJHByb3BzLmljb25TcmNTZXQ7XG4gIHZhciB0ZXh0ID0gJCRwcm9wcy50ZXh0O1xuICB2YXIgc3ZnID0gJCRwcm9wcy5zdmc7XG5cbiAgJCRzZWxmLiQkc2V0ID0gZnVuY3Rpb24gKCQkcHJvcHMpIHtcbiAgICBpZiAoXCJpY29uU3JjXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDAsIGljb25TcmMgPSAkJHByb3BzLmljb25TcmMpO1xuICAgIGlmIChcImljb25TcmNTZXRcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMSwgaWNvblNyY1NldCA9ICQkcHJvcHMuaWNvblNyY1NldCk7XG4gICAgaWYgKFwidGV4dFwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgyLCB0ZXh0ID0gJCRwcm9wcy50ZXh0KTtcbiAgICBpZiAoXCJzdmdcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMywgc3ZnID0gJCRwcm9wcy5zdmcpO1xuICB9O1xuXG4gIHJldHVybiBbaWNvblNyYywgaWNvblNyY1NldCwgdGV4dCwgc3ZnXTtcbn1cblxudmFyIEljb25EaXNwbGF5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfU3ZlbHRlQ29tcG9uZW50OCkge1xuICBfaW5oZXJpdHMoSWNvbkRpc3BsYXksIF9TdmVsdGVDb21wb25lbnQ4KTtcblxuICB2YXIgX3N1cGVyOCA9IF9jcmVhdGVTdXBlcihJY29uRGlzcGxheSk7XG5cbiAgZnVuY3Rpb24gSWNvbkRpc3BsYXkob3B0aW9ucykge1xuICAgIHZhciBfdGhpczg7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSWNvbkRpc3BsYXkpO1xuXG4gICAgX3RoaXM4ID0gX3N1cGVyOC5jYWxsKHRoaXMpO1xuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdmVsdGUtMTh6dHM0Yi1zdHlsZVwiKSkgYWRkX2NzcyQ3KCk7XG4gICAgaW5pdChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzOCksIG9wdGlvbnMsIGluc3RhbmNlJDcsIGNyZWF0ZV9mcmFnbWVudCQ3LCBzYWZlX25vdF9lcXVhbCwge1xuICAgICAgaWNvblNyYzogMCxcbiAgICAgIGljb25TcmNTZXQ6IDEsXG4gICAgICB0ZXh0OiAyLFxuICAgICAgc3ZnOiAzXG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzODtcbiAgfVxuXG4gIHJldHVybiBJY29uRGlzcGxheTtcbn0oU3ZlbHRlQ29tcG9uZW50KTtcbi8qIHNyYy9jb21wb25lbnRzL1NlbGVjdGVkV2FsbGV0LnN2ZWx0ZSBnZW5lcmF0ZWQgYnkgU3ZlbHRlIHYzLjM4LjIgKi9cblxuXG5mdW5jdGlvbiBhZGRfY3NzJDgoKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuaWQgPSBcInN2ZWx0ZS1taTZhaGMtc3R5bGVcIjtcbiAgc3R5bGUudGV4dENvbnRlbnQgPSBcInNlY3Rpb24uc3ZlbHRlLW1pNmFoY3tjb2xvcjppbmhlcml0O2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtZmFtaWx5OmluaGVyaXQ7ZGlzcGxheTpibG9ja31mb290ZXIuc3ZlbHRlLW1pNmFoY3tkaXNwbGF5OmZsZXg7Zm9udC1zaXplOmluaGVyaXQ7Zm9udC1mYW1pbHk6aW5oZXJpdDtqdXN0aWZ5LWNvbnRlbnQ6c3BhY2UtYmV0d2Vlbn1cIjtcbiAgYXBwZW5kKGRvY3VtZW50LmhlYWQsIHN0eWxlKTtcbn0gLy8gKDM0OjIpIHsjaWYgaW5zdGFsbE1lc3NhZ2V9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrJDYoY3R4KSB7XG4gIHZhciBodG1sX3RhZztcbiAgdmFyIGh0bWxfYW5jaG9yO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBodG1sX2FuY2hvciA9IGVtcHR5KCk7XG4gICAgICBodG1sX3RhZyA9IG5ldyBIdG1sVGFnKGh0bWxfYW5jaG9yKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGh0bWxfdGFnLm0oXG4gICAgICAvKmluc3RhbGxNZXNzYWdlKi9cbiAgICAgIGN0eFsyXSwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgaHRtbF9hbmNob3IsIGFuY2hvcik7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmluc3RhbGxNZXNzYWdlKi9cbiAgICAgIDQpIGh0bWxfdGFnLnAoXG4gICAgICAvKmluc3RhbGxNZXNzYWdlKi9cbiAgICAgIGN0eFsyXSk7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGh0bWxfYW5jaG9yKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGh0bWxfdGFnLmQoKTtcbiAgICB9XG4gIH07XG59IC8vICgzOTo0KSA8QnV0dG9uIGN0YT17ZmFsc2V9IG9uY2xpY2s9e29uQmFja30+XG5cblxuZnVuY3Rpb24gY3JlYXRlX2RlZmF1bHRfc2xvdF8xKGN0eCkge1xuICB2YXIgdDtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgdCA9IHRleHQoXCJCYWNrXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdCwgYW5jaG9yKTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godCk7XG4gICAgfVxuICB9O1xufSAvLyAoNDU6NikgPEJ1dHRvbj5cblxuXG5mdW5jdGlvbiBjcmVhdGVfZGVmYXVsdF9zbG90JDEoY3R4KSB7XG4gIHZhciB0MDtcbiAgdmFyIHQxX3ZhbHVlID1cbiAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gIGN0eFswXS5uYW1lICsgXCJcIjtcbiAgdmFyIHQxO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICB0MCA9IHRleHQoXCJPcGVuIFwiKTtcbiAgICAgIHQxID0gdGV4dCh0MV92YWx1ZSk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0MCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQxLCBhbmNob3IpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICAxICYmIHQxX3ZhbHVlICE9PSAodDFfdmFsdWUgPVxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbMF0ubmFtZSArIFwiXCIpKSBzZXRfZGF0YSh0MSwgdDFfdmFsdWUpO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0MCk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godDEpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50JDgoY3R4KSB7XG4gIHZhciBzZWN0aW9uO1xuICB2YXIgaWNvbmRpc3BsYXk7XG4gIHZhciB0MDtcbiAgdmFyIHQxO1xuICB2YXIgZm9vdGVyO1xuICB2YXIgYnV0dG9uMDtcbiAgdmFyIHQyO1xuICB2YXIgYTtcbiAgdmFyIGJ1dHRvbjE7XG4gIHZhciBhX2hyZWZfdmFsdWU7XG4gIHZhciBzZWN0aW9uX2ludHJvO1xuICB2YXIgY3VycmVudDtcbiAgaWNvbmRpc3BsYXkgPSBuZXcgSWNvbkRpc3BsYXkoe1xuICAgIHByb3BzOiB7XG4gICAgICBpY29uU3JjOlxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbMF0uaWNvblNyYyxcbiAgICAgIGljb25TcmNTZXQ6XG4gICAgICAvKnNlbGVjdGVkV2FsbGV0TW9kdWxlKi9cbiAgICAgIGN0eFswXS5pY29uU3JjU2V0LFxuICAgICAgc3ZnOlxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbMF0uc3ZnLFxuICAgICAgdGV4dDpcbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgY3R4WzBdLm5hbWVcbiAgICB9XG4gIH0pO1xuICB2YXIgaWZfYmxvY2sgPVxuICAvKmluc3RhbGxNZXNzYWdlKi9cbiAgY3R4WzJdICYmIGNyZWF0ZV9pZl9ibG9jayQ2KGN0eCk7XG4gIGJ1dHRvbjAgPSBuZXcgQnV0dG9uKHtcbiAgICBwcm9wczoge1xuICAgICAgY3RhOiBmYWxzZSxcbiAgICAgIG9uY2xpY2s6XG4gICAgICAvKm9uQmFjayovXG4gICAgICBjdHhbMV0sXG4gICAgICAkJHNsb3RzOiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiBbY3JlYXRlX2RlZmF1bHRfc2xvdF8xXVxuICAgICAgfSxcbiAgICAgICQkc2NvcGU6IHtcbiAgICAgICAgY3R4OiBjdHhcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBidXR0b24xID0gbmV3IEJ1dHRvbih7XG4gICAgcHJvcHM6IHtcbiAgICAgICQkc2xvdHM6IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IFtjcmVhdGVfZGVmYXVsdF9zbG90JDFdXG4gICAgICB9LFxuICAgICAgJCRzY29wZToge1xuICAgICAgICBjdHg6IGN0eFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHNlY3Rpb24gPSBlbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoaWNvbmRpc3BsYXkuJCQuZnJhZ21lbnQpO1xuICAgICAgdDAgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrKSBpZl9ibG9jay5jKCk7XG4gICAgICB0MSA9IHNwYWNlKCk7XG4gICAgICBmb290ZXIgPSBlbGVtZW50KFwiZm9vdGVyXCIpO1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChidXR0b24wLiQkLmZyYWdtZW50KTtcbiAgICAgIHQyID0gc3BhY2UoKTtcbiAgICAgIGEgPSBlbGVtZW50KFwiYVwiKTtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoYnV0dG9uMS4kJC5mcmFnbWVudCk7XG4gICAgICBhdHRyKGEsIFwiaHJlZlwiLCBhX2hyZWZfdmFsdWUgPVxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbMF0ubGluayk7XG4gICAgICBhdHRyKGEsIFwicmVsXCIsIFwibm9yZWZlcnJlciBub29wZW5lclwiKTtcbiAgICAgIGF0dHIoYSwgXCJ0YXJnZXRcIiwgXCJfYmxhbmtcIik7XG4gICAgICBhdHRyKGZvb3RlciwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtbW9kYWwtc2VsZWN0ZWQtd2FsbGV0LWZvb3RlciBzdmVsdGUtbWk2YWhjXCIpO1xuICAgICAgYXR0cihzZWN0aW9uLCBcImNsYXNzXCIsIFwiYm4tb25ib2FyZC1jdXN0b20gYm4tb25ib2FyZC1tb2RhbC1zZWxlY3RlZC13YWxsZXQgc3ZlbHRlLW1pNmFoY1wiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIHNlY3Rpb24sIGFuY2hvcik7XG4gICAgICBtb3VudF9jb21wb25lbnQoaWNvbmRpc3BsYXksIHNlY3Rpb24sIG51bGwpO1xuICAgICAgYXBwZW5kKHNlY3Rpb24sIHQwKTtcbiAgICAgIGlmIChpZl9ibG9jaykgaWZfYmxvY2subShzZWN0aW9uLCBudWxsKTtcbiAgICAgIGFwcGVuZChzZWN0aW9uLCB0MSk7XG4gICAgICBhcHBlbmQoc2VjdGlvbiwgZm9vdGVyKTtcbiAgICAgIG1vdW50X2NvbXBvbmVudChidXR0b24wLCBmb290ZXIsIG51bGwpO1xuICAgICAgYXBwZW5kKGZvb3RlciwgdDIpO1xuICAgICAgYXBwZW5kKGZvb3RlciwgYSk7XG4gICAgICBtb3VudF9jb21wb25lbnQoYnV0dG9uMSwgYSwgbnVsbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBfcmVmMjYpIHtcbiAgICAgIHZhciBfcmVmMjcgPSBfc2xpY2VkVG9BcnJheShfcmVmMjYsIDEpLFxuICAgICAgICAgIGRpcnR5ID0gX3JlZjI3WzBdO1xuXG4gICAgICB2YXIgaWNvbmRpc3BsYXlfY2hhbmdlcyA9IHt9O1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgMSkgaWNvbmRpc3BsYXlfY2hhbmdlcy5pY29uU3JjID1cbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgY3R4WzBdLmljb25TcmM7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICAxKSBpY29uZGlzcGxheV9jaGFuZ2VzLmljb25TcmNTZXQgPVxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbMF0uaWNvblNyY1NldDtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKnNlbGVjdGVkV2FsbGV0TW9kdWxlKi9cbiAgICAgIDEpIGljb25kaXNwbGF5X2NoYW5nZXMuc3ZnID1cbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgY3R4WzBdLnN2ZztcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKnNlbGVjdGVkV2FsbGV0TW9kdWxlKi9cbiAgICAgIDEpIGljb25kaXNwbGF5X2NoYW5nZXMudGV4dCA9XG4gICAgICAvKnNlbGVjdGVkV2FsbGV0TW9kdWxlKi9cbiAgICAgIGN0eFswXS5uYW1lO1xuICAgICAgaWNvbmRpc3BsYXkuJHNldChpY29uZGlzcGxheV9jaGFuZ2VzKTtcblxuICAgICAgaWYgKFxuICAgICAgLyppbnN0YWxsTWVzc2FnZSovXG4gICAgICBjdHhbMl0pIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrKSB7XG4gICAgICAgICAgaWZfYmxvY2sucChjdHgsIGRpcnR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jayA9IGNyZWF0ZV9pZl9ibG9jayQ2KGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2suYygpO1xuICAgICAgICAgIGlmX2Jsb2NrLm0oc2VjdGlvbiwgdDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrKSB7XG4gICAgICAgIGlmX2Jsb2NrLmQoMSk7XG4gICAgICAgIGlmX2Jsb2NrID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIGJ1dHRvbjBfY2hhbmdlcyA9IHt9O1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qb25CYWNrKi9cbiAgICAgIDIpIGJ1dHRvbjBfY2hhbmdlcy5vbmNsaWNrID1cbiAgICAgIC8qb25CYWNrKi9cbiAgICAgIGN0eFsxXTtcblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qJCRzY29wZSovXG4gICAgICA4KSB7XG4gICAgICAgIGJ1dHRvbjBfY2hhbmdlcy4kJHNjb3BlID0ge1xuICAgICAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBidXR0b24wLiRzZXQoYnV0dG9uMF9jaGFuZ2VzKTtcbiAgICAgIHZhciBidXR0b24xX2NoYW5nZXMgPSB7fTtcblxuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qJCRzY29wZSwgc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgOSkge1xuICAgICAgICBidXR0b24xX2NoYW5nZXMuJCRzY29wZSA9IHtcbiAgICAgICAgICBkaXJ0eTogZGlydHksXG4gICAgICAgICAgY3R4OiBjdHhcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgYnV0dG9uMS4kc2V0KGJ1dHRvbjFfY2hhbmdlcyk7XG5cbiAgICAgIGlmICghY3VycmVudCB8fCBkaXJ0eSAmXG4gICAgICAvKnNlbGVjdGVkV2FsbGV0TW9kdWxlKi9cbiAgICAgIDEgJiYgYV9ocmVmX3ZhbHVlICE9PSAoYV9ocmVmX3ZhbHVlID1cbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgY3R4WzBdLmxpbmspKSB7XG4gICAgICAgIGF0dHIoYSwgXCJocmVmXCIsIGFfaHJlZl92YWx1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihpY29uZGlzcGxheS4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgdHJhbnNpdGlvbl9pbihidXR0b24wLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICB0cmFuc2l0aW9uX2luKGJ1dHRvbjEuJCQuZnJhZ21lbnQsIGxvY2FsKTtcblxuICAgICAgaWYgKCFzZWN0aW9uX2ludHJvKSB7XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHNlY3Rpb25faW50cm8gPSBjcmVhdGVfaW5fdHJhbnNpdGlvbihzZWN0aW9uLCBmYWRlLCB7fSk7XG4gICAgICAgICAgc2VjdGlvbl9pbnRyby5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChpY29uZGlzcGxheS4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgdHJhbnNpdGlvbl9vdXQoYnV0dG9uMC4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgdHJhbnNpdGlvbl9vdXQoYnV0dG9uMS4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IGZhbHNlO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChzZWN0aW9uKTtcbiAgICAgIGRlc3Ryb3lfY29tcG9uZW50KGljb25kaXNwbGF5KTtcbiAgICAgIGlmIChpZl9ibG9jaykgaWZfYmxvY2suZCgpO1xuICAgICAgZGVzdHJveV9jb21wb25lbnQoYnV0dG9uMCk7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChidXR0b24xKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlJDgoJCRzZWxmLCAkJHByb3BzLCAkJGludmFsaWRhdGUpIHtcbiAgdmFyIHNlbGVjdGVkV2FsbGV0TW9kdWxlID0gJCRwcm9wcy5zZWxlY3RlZFdhbGxldE1vZHVsZTtcbiAgdmFyIG9uQmFjayA9ICQkcHJvcHMub25CYWNrO1xuICB2YXIgaW5zdGFsbE1lc3NhZ2UgPSAkJHByb3BzLmluc3RhbGxNZXNzYWdlO1xuXG4gICQkc2VsZi4kJHNldCA9IGZ1bmN0aW9uICgkJHByb3BzKSB7XG4gICAgaWYgKFwic2VsZWN0ZWRXYWxsZXRNb2R1bGVcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMCwgc2VsZWN0ZWRXYWxsZXRNb2R1bGUgPSAkJHByb3BzLnNlbGVjdGVkV2FsbGV0TW9kdWxlKTtcbiAgICBpZiAoXCJvbkJhY2tcIiBpbiAkJHByb3BzKSAkJGludmFsaWRhdGUoMSwgb25CYWNrID0gJCRwcm9wcy5vbkJhY2spO1xuICAgIGlmIChcImluc3RhbGxNZXNzYWdlXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDIsIGluc3RhbGxNZXNzYWdlID0gJCRwcm9wcy5pbnN0YWxsTWVzc2FnZSk7XG4gIH07XG5cbiAgcmV0dXJuIFtzZWxlY3RlZFdhbGxldE1vZHVsZSwgb25CYWNrLCBpbnN0YWxsTWVzc2FnZV07XG59XG5cbnZhciBTZWxlY3RlZFdhbGxldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N2ZWx0ZUNvbXBvbmVudDkpIHtcbiAgX2luaGVyaXRzKFNlbGVjdGVkV2FsbGV0LCBfU3ZlbHRlQ29tcG9uZW50OSk7XG5cbiAgdmFyIF9zdXBlcjkgPSBfY3JlYXRlU3VwZXIoU2VsZWN0ZWRXYWxsZXQpO1xuXG4gIGZ1bmN0aW9uIFNlbGVjdGVkV2FsbGV0KG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXM5O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNlbGVjdGVkV2FsbGV0KTtcblxuICAgIF90aGlzOSA9IF9zdXBlcjkuY2FsbCh0aGlzKTtcbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3ZlbHRlLW1pNmFoYy1zdHlsZVwiKSkgYWRkX2NzcyQ4KCk7XG4gICAgaW5pdChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzOSksIG9wdGlvbnMsIGluc3RhbmNlJDgsIGNyZWF0ZV9mcmFnbWVudCQ4LCBzYWZlX25vdF9lcXVhbCwge1xuICAgICAgc2VsZWN0ZWRXYWxsZXRNb2R1bGU6IDAsXG4gICAgICBvbkJhY2s6IDEsXG4gICAgICBpbnN0YWxsTWVzc2FnZTogMlxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpczk7XG4gIH1cblxuICByZXR1cm4gU2VsZWN0ZWRXYWxsZXQ7XG59KFN2ZWx0ZUNvbXBvbmVudCk7XG5cbnZhciB3YWxsZXRJY29uID0gXCJcXG48c3ZnXFxuaGVpZ2h0PVxcXCIxOFxcXCJcXG52aWV3Qm94PVxcXCIwIDAgMTkgMThcXFwiXFxud2lkdGg9XFxcIjE5XFxcIlxcbnhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+XFxuPGcgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBmaWxsLXJ1bGU9XFxcImV2ZW5vZGRcXFwiPlxcblxcdDxwYXRoXFxuXFx0XFx0ZD1cXFwibTE1Ljc3MjE2MTguMDAwMDY2MjNoLTEzLjI3NDY5ODM5Yy0uODY3NjIwNjVcXG5cXHRcXHQwLTEuNDg1OTI2ODEuMzA3ODA4Ni0xLjg5NzQxMDQ2Ljc2MTEzMTkzLS40MDYxNTgyMy40NDc0NTA2NC0uNjA4MzkwNjNcXG5cXHRcXHQxLjA0NjYxOTg4LS41OTk3ODk3NFxcblxcdFxcdDEuNjQ0NjQxMDcuMDAwMjkxODcuMDA1MTI0LjAwMDQwMzM1LjAxMDI1NjUzLjAwMDMzNDIzLjAxNTM4ODIydjMuNjY4OTk4MTFjLjA2NjgyNDA0LS4xMTY4NTc3Ni4xNDE2MjUwNy0uMjI5Mzg4MjcuMjI1MzM4OTQtLjMzNjI4ODk1LjM2Nzc4ODQ1LS40Njk1OTQ2Ni45MDgxMjk1Mi0uODIxMTYxNDVcXG5cXHRcXHQxLjYxODY2MTMyLS45NTYyMzMzOXYtLjU5MDkzNDIyYzAtLjU1MjE0MzUzLjE3NjQ5NjU3LTEuMDU3OTAxNjMuNDcyNzgxNzMtMS40MzM4ODY0NS4yOTYzMDc0NS0uMzc1OTYyNzUuNzIyOTIwNjUtLjYyNTEzMjcyXFxuXFx0XFx0MS4xOTk2OTA4OC0uNjI1MTMyNzJoMTEuMjM1NDYyMzljLjQ3NjU0NzQgMCAuOTAzMjQ5Ny4yNDg1MDc2NFxcblxcdFxcdDEuMTk5NjI0LjYyNDI0OTYxLjI5NjM3NDMuMzc1NzQxOTYuNDcyODcwOS44ODE2MTA0NS40NzI4NzA5XFxuXFx0XFx0MS40MzQ3Njk1NnYuNDY1Mjg5NWMuNTIzNTYyNi0uMTEwNDc3MjguOTI2NjY4Mi0uMzU0NDU4OTdcXG5cXHRcXHQxLjIyNDYwMjItLjY3MzM3MjcuNDExNjM5Ny0uNDQwNjA2NTMuNjIxMDQ2OS0xLjAzMzkyNTE1LjYyMTA0NjktMS42MzAxNTgwNHMtLjIwOTQwNzItMS4xODk1NTE1MS0uNjIxMDQ2OS0xLjYzMDE4MDExYy0uNDExNjM5Ni0uNDQwNjA2NTMtMS4wMjM4NjI3LS43MzgzNDc2NS0xLjg3NzQ2OC0uNzM4MzQ3NjV6XFxcIiAvPlxcblxcdDxwYXRoXFxuXFx0XFx0ZD1cXFwibTE0LjYwOTYwNDcgMi41NzE1MTczNGgtMTEuMjE5MTQyNjdjLS4zMjA3MzAwMlxcblxcdFxcdDAtLjYxODU0MjguMTY1NjE0MzMtLjg0NzIyNTY0LjQ1NzY5NzM5cy0uMzc3ODIyODYuNzA3NjM5MDEtLjM3NzgyMjg2XFxuXFx0XFx0MS4xNjgwODgxNHYuNTM5NTM5MjRjLjA2MjY1NTI3LS4wMDM2MTcyLjEyNjQwMDc4LS4wMDU3MDMxOS4xOTEyNTg3OC0uMDA2MTY5MjEuMDA1MTg0ODItLjAwMDMyOTI0LjAxMDM3OTYxLS4wMDA0NzcyNy4wMTU1NzQ4Mi0uMDAwNDQzODNoLjAxMzI2MDg0XFxuXFx0XFx0MTMuMjQyMTU1OTNjLjA3MDY2NTIgMFxcblxcdFxcdC4xMzk1MjgxLS4wMDIyODU3MS4yMDY5MjI2LS4wMDYzMDIzNXYtLjUyNjcxMjYyYzAtLjQ2MTY0NzQ2LS4xNDkxNjIzLS44NzcxMTQ2NC0uMzc3NzU2MS0xLjE2ODg0MjY0LS4yMjg2MTYxLS4yOTE3NTAxOS0uNTI2MzYyMi0uNDU2OTQyODktLjg0NzMxNDctLjQ1Njk0Mjg5elxcXCIgLz5cXG5cXHQ8cGF0aFxcblxcdFxcdGQ9XFxcIm0xOC4yNzA2NzY3XFxuXFx0XFx0My45MjQ4MTIwM2MtLjA4NTcxOTUuMTMyNzgwNDctLjE4Mzc4MzIuMjU5MDY5OTMtLjI5NDU0NzguMzc2ODI5LS40OTU0NjYuNTI2ODAxODQtMS4yNDM5MjM2Ljg3NDAwNDY4LTIuMjA0NTI5Ni44NzQwMDQ2OGgtMTMuMjYxNDQ3NjVjLS45MzI4NjQ3MVxcblxcdFxcdDAtMS41MzYyODc3Ny4zMzc2NjM2OS0xLjkzMjY4NzMxLjg0MDM2NTVzLS41Nzc0NjQzNFxcblxcdFxcdDEuMTg4Nzc0NDMtLjU3NzQ2NDM0XFxuXFx0XFx0MS44NzIxMjc4NXYuNDEyNTI5NTFjLjEzNzI1ODA4LjE0ODE3NDY3LjI5MjI5NzMyLjIwNDUwODI0LjUwMDE2NzU0LjIzMjExNjkzLjIxMTcwMjc2LjAyODExMzA1LjQ2ODE0ODA5LjAxNDAzNDU5Ljc0MjEyOTQ3LjAyMTcwOTc3aDUuMjU5NzkxOTFjLjk0MTQ2NTY0XFxuXFx0XFx0MCAxLjY3NTg4NTQ4LjM2MDg0MjcxIDIuMTU4Nzg0MzUuOTAzNDExNTUuNDgyODk4ODcuNTQyNTkwNzguNzE4ODY2OVxcblxcdFxcdDEuMjU2NDkxMzguNzE4ODY2OSAxLjk2NzM4NzY4cy0uMjM1OTY4MDMgMS40MjQ3OTY5LS43MTg4NjY5XFxuXFx0XFx0MS45NjczODc3Yy0uNDgyODk4ODcuNTQyNTY4OS0xLjIxNzMxODcxLjkwMzM4OTYtMi4xNTg3ODQzNS45MDMzODk2aC01LjI1OTc5MTkxYy0uMjUwMzg0NThcXG5cXHRcXHQwLS41NTc0OTk1My0uMDE3MTA0Ni0uODQ5MDgzODEtLjA4NjYxOTgtLjEzNTIwODEyLS4wMzIyNTc2LS4yNzAwMzc0NC0uMDc1NjExNC0uMzkzMjEzMi0uMTM4MDY1M3YxLjUzMDIzMThjMFxcblxcdFxcdDEuMzIwMTI5NSAxLjA5NTYxMzU4IDIuMzk4MzgxNSAyLjQzNjk3NzA2XFxuXFx0XFx0Mi4zOTgzODE1aDEzLjM5NjcyMjU0YzEuMzQxMzYzNSAwIDIuNDM2OTc3MS0xLjA3ODI1MlxcblxcdFxcdDIuNDM2OTc3MS0yLjM5ODM4MTV6XFxcIiAvPlxcblxcdDxwYXRoXFxuXFx0XFx0ZD1cXFwibTBcXG5cXHRcXHQ4Ljc5Njk5MjQ4Yy4xNDI2MDYyOC4wNjk1OTAyMi4yOTg2NDY2NS4xMTA1MDM3Ni40NDU1NzUwMS4xMjk5NjQ1LjI3NTMyMDguMDM2NDkxNjMuNTQ0ODQ5MTIuMDEzMzUzMjcuNzkzNjgwNDkuMDIwNTc3MTcuMDAyMzAyLjAwMDAzNTA2LjAwNDYwNDQxLjAwMDAzNTA2LjAwNjkwNjQxXFxuXFx0XFx0MGg1LjI1NjQwMzgzYy44MjgyNzkzOSAwIDEuNDIyMDk3Mi4zMDE1NjQ5MlxcblxcdFxcdDEuODI0MDcyNy43NTI0ODk0MS40MDE5OTc3Ny40NTA5NDYzNC42MDU2OTIzOSAxLjA2MjIxOTU0LjYwNTY5MjM5XFxuXFx0XFx0MS42NzYwMTAxNCAwIC42MTM3NDY3LS4yMDM2OTQ2MiAxLjIyNTA2MzctLjYwNTY5MjM5XFxuXFx0XFx0MS42NzU5ODgyLS40MDE5NzU1LjQ1MDk0NjMtLjk5NTc5MzMxLjc1MjQ4OTQtMS44MjQwNzI3Ljc1MjQ4OTRoLTUuMjU2NDAzODNjLS4yMjgzMTI2NFxcblxcdFxcdDAtLjUwODQ2NzkyLS4wMTg4MjU5LS43NDQ5MzQ1OC0uMDc1MjM4LS4yMzY0NjY2Ni0uMDU2MzI0NS0uNDE0MTYxOTctLjE1MTc2NzYtLjQ4NzM0NzY3LS4yNTk5NzI4LS4wMDQ0MDAxMy0uMDA0NzIwMy0uMDA5MDA4ODMtLjAwOTI0ODctLjAxMzg3OTY2LS4wMTM1NzIydi00LjY1ODYwNDQ4em02LjQyNjAxNTk1XFxuXFx0XFx0MS40MjI4ODkxMmMtLjYyOTc5Nzk5IDAtMS4xNDg3MzY5My41MDI0MTExLTEuMTQ4NzM2OTMgMS4xMjE4OTMzIDBcXG5cXHRcXHQuNjIxMTY3Ny41MTg5Mzg5NCAxLjEyODc0NSAxLjE0ODczNjkzIDEuMTI4NzQ1LjYyOTg0MjU2IDBcXG5cXHRcXHQxLjE0MTc4NTk3LS41MDgyMTIyIDEuMTQxNzg1OTctMS4xMjg3NDVcXG5cXHRcXHQwLS42MTg4NjkyLS41MTE5NDM0MS0xLjEyMTg5MzMtMS4xNDE3ODU5Ny0xLjEyMTg5MzN6XFxcIiAvPlxcbjwvZz5cXG48L3N2Zz5cXG5cXHRcIjtcbnZhciBTVE9SQUdFX0tFWVMgPSB7XG4gIFRFUk1TX0FHUkVFTUVOVDogJ29uYm9hcmQuanM6YWdyZWVtZW50J1xufTtcbi8qIHNyYy92aWV3cy9XYWxsZXRTZWxlY3Quc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMzguMiAqL1xuXG5mdW5jdGlvbiBhZGRfY3NzJDkoKSB7XG4gIHZhciBzdHlsZSA9IGVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgc3R5bGUuaWQgPSBcInN2ZWx0ZS13OWZ0Znktc3R5bGVcIjtcbiAgc3R5bGUudGV4dENvbnRlbnQgPSBcInAuc3ZlbHRlLXc5ZnRmeS5zdmVsdGUtdzlmdGZ5e2ZvbnQtc2l6ZTowLjg4OWVtO21hcmdpbjoxLjZlbSAwIDAgMDtmb250LWZhbWlseTppbmhlcml0fWRpdi5zdmVsdGUtdzlmdGZ5LnN2ZWx0ZS13OWZ0Znl7ZGlzcGxheTpmbGV4O2ZvbnQtc2l6ZTppbmhlcml0O2ZvbnQtZmFtaWx5OmluaGVyaXQ7anVzdGlmeS1jb250ZW50OnNwYWNlLWJldHdlZW59ZGl2LnN2ZWx0ZS13OWZ0Znkgc3Bhbi5zdmVsdGUtdzlmdGZ5e2NvbG9yOiM0YTkwZTI7Zm9udC1zaXplOmluaGVyaXQ7Zm9udC1mYW1pbHk6aW5oZXJpdDttYXJnaW4tdG9wOjAuNjZlbTtjdXJzb3I6cG9pbnRlcn0uYm4tb25ib2FyZC1tb2RhbC10ZXJtcy1vZi1zZXJ2aWNlLnN2ZWx0ZS13OWZ0Znkuc3ZlbHRlLXc5ZnRmeXtkaXNwbGF5OmZsZXg7YWxpZ24taXRlbXM6Y2VudGVyfS5ibi1vbmJvYXJkLW1vZGFsLXRlcm1zLW9mLXNlcnZpY2UtY2hlY2stYm94LnN2ZWx0ZS13OWZ0Znkuc3ZlbHRlLXc5ZnRmeXttYXJnaW4tcmlnaHQ6N3B4fVwiO1xuICBhcHBlbmQoZG9jdW1lbnQuaGVhZCwgc3R5bGUpO1xufSAvLyAoMjEzOjApIHsjaWYgbW9kYWxEYXRhfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9jayQ3KGN0eCkge1xuICB2YXIgbW9kYWw7XG4gIHZhciBjdXJyZW50O1xuICBtb2RhbCA9IG5ldyBNb2RhbCh7XG4gICAgcHJvcHM6IHtcbiAgICAgIGNsb3NlTW9kYWw6XG4gICAgICAvKmZ1bmNfMiovXG4gICAgICBjdHhbMjFdLFxuICAgICAgJCRzbG90czoge1xuICAgICAgICBcImRlZmF1bHRcIjogW2NyZWF0ZV9kZWZhdWx0X3Nsb3QkMl1cbiAgICAgIH0sXG4gICAgICAkJHNjb3BlOiB7XG4gICAgICAgIGN0eDogY3R4XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChtb2RhbC4kJC5mcmFnbWVudCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQobW9kYWwsIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICB2YXIgbW9kYWxfY2hhbmdlcyA9IHt9O1xuXG4gICAgICBpZiAoZGlydHlbMF0gJlxuICAgICAgLyptb2RhbERhdGEsIHNob3dXYWxsZXREZWZpbml0aW9uLCBsb2FkaW5nV2FsbGV0LCBzaG93aW5nQWxsV2FsbGV0TW9kdWxlcywgd2FsbGV0c0Rpc2FibGVkLCBzZWxlY3RlZFdhbGxldE1vZHVsZSwgd2FsbGV0QWxyZWFkeUluc3RhbGxlZCwgaW5zdGFsbE1lc3NhZ2UsIGFncmVlZCovXG4gICAgICA1MTEgfCBkaXJ0eVsxXSAmXG4gICAgICAvKiQkc2NvcGUqL1xuICAgICAgMzIpIHtcbiAgICAgICAgbW9kYWxfY2hhbmdlcy4kJHNjb3BlID0ge1xuICAgICAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBtb2RhbC4kc2V0KG1vZGFsX2NoYW5nZXMpO1xuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4obW9kYWwuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQobW9kYWwuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChtb2RhbCwgZGV0YWNoaW5nKTtcbiAgICB9XG4gIH07XG59IC8vICgyMTY6NCkgeyNpZiBzaG93VGVybXNPZlNlcnZpY2V9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrXzQoY3R4KSB7XG4gIHZhciBwO1xuICB2YXIgbGFiZWw7XG4gIHZhciBpbnB1dDtcbiAgdmFyIHQwO1xuICB2YXIgc3BhbjtcbiAgdmFyIHQxO1xuICB2YXIgdDI7XG4gIHZhciBtb3VudGVkO1xuICB2YXIgZGlzcG9zZTtcbiAgdmFyIGlmX2Jsb2NrMCA9XG4gIC8qdGVybXNVcmwqL1xuICBjdHhbMTBdICYmIGNyZWF0ZV9pZl9ibG9ja182KGN0eCk7XG4gIHZhciBpZl9ibG9jazEgPVxuICAvKnByaXZhY3lVcmwqL1xuICBjdHhbMTFdICYmIGNyZWF0ZV9pZl9ibG9ja181KGN0eCk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHAgPSBlbGVtZW50KFwicFwiKTtcbiAgICAgIGxhYmVsID0gZWxlbWVudChcImxhYmVsXCIpO1xuICAgICAgaW5wdXQgPSBlbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICB0MCA9IHNwYWNlKCk7XG4gICAgICBzcGFuID0gZWxlbWVudChcInNwYW5cIik7XG4gICAgICB0MSA9IHRleHQoXCJJIGFncmVlIHRvIHRoZVxcbiAgICAgICAgICAgIFwiKTtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5jKCk7XG4gICAgICB0MiA9IHNwYWNlKCk7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEuYygpO1xuICAgICAgYXR0cihpbnB1dCwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtbW9kYWwtdGVybXMtb2Ytc2VydmljZS1jaGVjay1ib3ggc3ZlbHRlLXc5ZnRmeVwiKTtcbiAgICAgIGF0dHIoaW5wdXQsIFwidHlwZVwiLCBcImNoZWNrYm94XCIpO1xuICAgICAgYXR0cihsYWJlbCwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtbW9kYWwtdGVybXMtb2Ytc2VydmljZSBzdmVsdGUtdzlmdGZ5XCIpO1xuICAgICAgYXR0cihwLCBcImNsYXNzXCIsIFwic3ZlbHRlLXc5ZnRmeVwiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIHAsIGFuY2hvcik7XG4gICAgICBhcHBlbmQocCwgbGFiZWwpO1xuICAgICAgYXBwZW5kKGxhYmVsLCBpbnB1dCk7XG4gICAgICBpbnB1dC5jaGVja2VkID1cbiAgICAgIC8qYWdyZWVkKi9cbiAgICAgIGN0eFswXTtcbiAgICAgIGFwcGVuZChsYWJlbCwgdDApO1xuICAgICAgYXBwZW5kKGxhYmVsLCBzcGFuKTtcbiAgICAgIGFwcGVuZChzcGFuLCB0MSk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAubShzcGFuLCBudWxsKTtcbiAgICAgIGFwcGVuZChzcGFuLCB0Mik7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEubShzcGFuLCBudWxsKTtcblxuICAgICAgaWYgKCFtb3VudGVkKSB7XG4gICAgICAgIGRpc3Bvc2UgPSBsaXN0ZW4oaW5wdXQsIFwiY2hhbmdlXCIsXG4gICAgICAgIC8qaW5wdXRfY2hhbmdlX2hhbmRsZXIqL1xuICAgICAgICBjdHhbMTddKTtcbiAgICAgICAgbW91bnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIGlmIChkaXJ0eVswXSAmXG4gICAgICAvKmFncmVlZCovXG4gICAgICAxKSB7XG4gICAgICAgIGlucHV0LmNoZWNrZWQgPVxuICAgICAgICAvKmFncmVlZCovXG4gICAgICAgIGN0eFswXTtcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgLyp0ZXJtc1VybCovXG4gICAgICBjdHhbMTBdKSBpZl9ibG9jazAucChjdHgsIGRpcnR5KTtcbiAgICAgIGlmIChcbiAgICAgIC8qcHJpdmFjeVVybCovXG4gICAgICBjdHhbMTFdKSBpZl9ibG9jazEucChjdHgsIGRpcnR5KTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2gocCk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAuZCgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLmQoKTtcbiAgICAgIG1vdW50ZWQgPSBmYWxzZTtcbiAgICAgIGRpc3Bvc2UoKTtcbiAgICB9XG4gIH07XG59IC8vICgyMjY6MTIpIHsjaWYgdGVybXNVcmx9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrXzYoY3R4KSB7XG4gIHZhciBhO1xuICB2YXIgdDA7XG4gIHZhciB0MV92YWx1ZSA9IChcbiAgLypwcml2YWN5VXJsKi9cbiAgY3R4WzExXSA/IFwiIGFuZFwiIDogXCIuXCIpICsgXCJcIjtcbiAgdmFyIHQxO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBhID0gZWxlbWVudChcImFcIik7XG4gICAgICB0MCA9IHRleHQoXCJUZXJtcyAmIENvbmRpdGlvbnNcIik7XG4gICAgICB0MSA9IHRleHQodDFfdmFsdWUpO1xuICAgICAgYXR0cihhLCBcImhyZWZcIixcbiAgICAgIC8qdGVybXNVcmwqL1xuICAgICAgY3R4WzEwXSk7XG4gICAgICBhdHRyKGEsIFwidGFyZ2V0XCIsIFwiX2JsYW5rXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgYSwgYW5jaG9yKTtcbiAgICAgIGFwcGVuZChhLCB0MCk7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0MSwgYW5jaG9yKTtcbiAgICB9LFxuICAgIHA6IG5vb3AsXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChhKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0MSk7XG4gICAgfVxuICB9O1xufSAvLyAoMjMwOjEyKSB7I2lmIHByaXZhY3lVcmx9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrXzUoY3R4KSB7XG4gIHZhciBhO1xuICB2YXIgdDA7XG4gIHZhciB0MTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgYSA9IGVsZW1lbnQoXCJhXCIpO1xuICAgICAgdDAgPSB0ZXh0KFwiUHJpdmFjeSBQb2xpY3lcIik7XG4gICAgICB0MSA9IHRleHQoXCIuXCIpO1xuICAgICAgYXR0cihhLCBcImhyZWZcIixcbiAgICAgIC8qcHJpdmFjeVVybCovXG4gICAgICBjdHhbMTFdKTtcbiAgICAgIGF0dHIoYSwgXCJ0YXJnZXRcIiwgXCJfYmxhbmtcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBhLCBhbmNob3IpO1xuICAgICAgYXBwZW5kKGEsIHQwKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQxLCBhbmNob3IpO1xuICAgIH0sXG4gICAgcDogbm9vcCxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGEpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQxKTtcbiAgICB9XG4gIH07XG59IC8vICgyNzA6NCkgezplbHNlfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9lbHNlX2Jsb2NrJDMoY3R4KSB7XG4gIHZhciBzZWxlY3RlZHdhbGxldDtcbiAgdmFyIGN1cnJlbnQ7XG4gIHNlbGVjdGVkd2FsbGV0ID0gbmV3IFNlbGVjdGVkV2FsbGV0KHtcbiAgICBwcm9wczoge1xuICAgICAgc2VsZWN0ZWRXYWxsZXRNb2R1bGU6XG4gICAgICAvKnNlbGVjdGVkV2FsbGV0TW9kdWxlKi9cbiAgICAgIGN0eFs1XSxcbiAgICAgIG9uQmFjazpcbiAgICAgIC8qZnVuY18xKi9cbiAgICAgIGN0eFsyMF0sXG4gICAgICBpbnN0YWxsTWVzc2FnZTpcbiAgICAgIC8qaW5zdGFsbE1lc3NhZ2UqL1xuICAgICAgY3R4WzRdXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChzZWxlY3RlZHdhbGxldC4kJC5mcmFnbWVudCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQoc2VsZWN0ZWR3YWxsZXQsIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICB2YXIgc2VsZWN0ZWR3YWxsZXRfY2hhbmdlcyA9IHt9O1xuICAgICAgaWYgKGRpcnR5WzBdICZcbiAgICAgIC8qc2VsZWN0ZWRXYWxsZXRNb2R1bGUqL1xuICAgICAgMzIpIHNlbGVjdGVkd2FsbGV0X2NoYW5nZXMuc2VsZWN0ZWRXYWxsZXRNb2R1bGUgPVxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgICBjdHhbNV07XG4gICAgICBpZiAoZGlydHlbMF0gJlxuICAgICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSwgd2FsbGV0QWxyZWFkeUluc3RhbGxlZCovXG4gICAgICA0MCkgc2VsZWN0ZWR3YWxsZXRfY2hhbmdlcy5vbkJhY2sgPVxuICAgICAgLypmdW5jXzEqL1xuICAgICAgY3R4WzIwXTtcbiAgICAgIGlmIChkaXJ0eVswXSAmXG4gICAgICAvKmluc3RhbGxNZXNzYWdlKi9cbiAgICAgIDE2KSBzZWxlY3RlZHdhbGxldF9jaGFuZ2VzLmluc3RhbGxNZXNzYWdlID1cbiAgICAgIC8qaW5zdGFsbE1lc3NhZ2UqL1xuICAgICAgY3R4WzRdO1xuICAgICAgc2VsZWN0ZWR3YWxsZXQuJHNldChzZWxlY3RlZHdhbGxldF9jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKHNlbGVjdGVkd2FsbGV0LiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KHNlbGVjdGVkd2FsbGV0LiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQoc2VsZWN0ZWR3YWxsZXQsIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoMjM3OjQpIHsjaWYgIXNlbGVjdGVkV2FsbGV0TW9kdWxlfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9ja18xJDMoY3R4KSB7XG4gIHZhciBfcDtcblxuICB2YXIgcmF3X3ZhbHVlID1cbiAgLyptb2RhbERhdGEqL1xuICBjdHhbMV0uZGVzY3JpcHRpb24gKyBcIlwiO1xuICB2YXIgdDA7XG4gIHZhciB3YWxsZXRzXzE7XG4gIHZhciB0MTtcbiAgdmFyIGRpdjtcbiAgdmFyIHNwYW47XG4gIHZhciB0MztcbiAgdmFyIHQ0O1xuICB2YXIgaWZfYmxvY2sxX2FuY2hvcjtcbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBtb3VudGVkO1xuICB2YXIgZGlzcG9zZTtcbiAgd2FsbGV0c18xID0gbmV3IFdhbGxldHMoe1xuICAgIHByb3BzOiB7XG4gICAgICBtb2RhbERhdGE6XG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICBjdHhbMV0sXG4gICAgICBoYW5kbGVXYWxsZXRTZWxlY3Q6XG4gICAgICAvKmhhbmRsZVdhbGxldFNlbGVjdCovXG4gICAgICBjdHhbMTRdLFxuICAgICAgbG9hZGluZ1dhbGxldDpcbiAgICAgIC8qbG9hZGluZ1dhbGxldCovXG4gICAgICBjdHhbN10sXG4gICAgICBzaG93aW5nQWxsV2FsbGV0TW9kdWxlczpcbiAgICAgIC8qc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMqL1xuICAgICAgY3R4WzhdLFxuICAgICAgc2hvd0FsbFdhbGxldHM6XG4gICAgICAvKnNob3dBbGxXYWxsZXRzKi9cbiAgICAgIGN0eFsxM10sXG4gICAgICB3YWxsZXRzRGlzYWJsZWQ6XG4gICAgICAvKndhbGxldHNEaXNhYmxlZCovXG4gICAgICBjdHhbNl1cbiAgICB9XG4gIH0pO1xuICB2YXIgaWZfYmxvY2swID1cbiAgLyptb2JpbGVEZXZpY2UqL1xuICBjdHhbOV0gJiYgY3JlYXRlX2lmX2Jsb2NrXzMoY3R4KTtcbiAgdmFyIGlmX2Jsb2NrMSA9XG4gIC8qc2hvd1dhbGxldERlZmluaXRpb24qL1xuICBjdHhbMl0gJiYgY3JlYXRlX2lmX2Jsb2NrXzIkMShjdHgpO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBfcCA9IGVsZW1lbnQoXCJwXCIpO1xuICAgICAgdDAgPSBzcGFjZSgpO1xuICAgICAgY3JlYXRlX2NvbXBvbmVudCh3YWxsZXRzXzEuJCQuZnJhZ21lbnQpO1xuICAgICAgdDEgPSBzcGFjZSgpO1xuICAgICAgZGl2ID0gZWxlbWVudChcImRpdlwiKTtcbiAgICAgIHNwYW4gPSBlbGVtZW50KFwic3BhblwiKTtcbiAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIldoYXQgaXMgYSB3YWxsZXQ/XCI7XG4gICAgICB0MyA9IHNwYWNlKCk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAuYygpO1xuICAgICAgdDQgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMSkgaWZfYmxvY2sxLmMoKTtcbiAgICAgIGlmX2Jsb2NrMV9hbmNob3IgPSBlbXB0eSgpO1xuICAgICAgYXR0cihfcCwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtc2VsZWN0LWRlc2NyaXB0aW9uIHN2ZWx0ZS13OWZ0ZnlcIik7XG4gICAgICBhdHRyKHNwYW4sIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLXNlbGVjdC13YWxsZXQtaW5mbyBzdmVsdGUtdzlmdGZ5XCIpO1xuICAgICAgYXR0cihkaXYsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLXNlbGVjdC1pbmZvLWNvbnRhaW5lciBzdmVsdGUtdzlmdGZ5XCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgX3AsIGFuY2hvcik7XG4gICAgICBfcC5pbm5lckhUTUwgPSByYXdfdmFsdWU7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0MCwgYW5jaG9yKTtcbiAgICAgIG1vdW50X2NvbXBvbmVudCh3YWxsZXRzXzEsIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQxLCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgZGl2LCBhbmNob3IpO1xuICAgICAgYXBwZW5kKGRpdiwgc3Bhbik7XG4gICAgICBhcHBlbmQoZGl2LCB0Myk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAubShkaXYsIG51bGwpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdDQsIGFuY2hvcik7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBpZl9ibG9jazFfYW5jaG9yLCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG5cbiAgICAgIGlmICghbW91bnRlZCkge1xuICAgICAgICBkaXNwb3NlID0gbGlzdGVuKHNwYW4sIFwiY2xpY2tcIixcbiAgICAgICAgLypjbGlja19oYW5kbGVyKi9cbiAgICAgICAgY3R4WzE4XSk7XG4gICAgICAgIG1vdW50ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoKCFjdXJyZW50IHx8IGRpcnR5WzBdICZcbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIDIpICYmIHJhd192YWx1ZSAhPT0gKHJhd192YWx1ZSA9XG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICBjdHhbMV0uZGVzY3JpcHRpb24gKyBcIlwiKSkgX3AuaW5uZXJIVE1MID0gcmF3X3ZhbHVlO1xuICAgICAgdmFyIHdhbGxldHNfMV9jaGFuZ2VzID0ge307XG4gICAgICBpZiAoZGlydHlbMF0gJlxuICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgMikgd2FsbGV0c18xX2NoYW5nZXMubW9kYWxEYXRhID1cbiAgICAgIC8qbW9kYWxEYXRhKi9cbiAgICAgIGN0eFsxXTtcbiAgICAgIGlmIChkaXJ0eVswXSAmXG4gICAgICAvKmxvYWRpbmdXYWxsZXQqL1xuICAgICAgMTI4KSB3YWxsZXRzXzFfY2hhbmdlcy5sb2FkaW5nV2FsbGV0ID1cbiAgICAgIC8qbG9hZGluZ1dhbGxldCovXG4gICAgICBjdHhbN107XG4gICAgICBpZiAoZGlydHlbMF0gJlxuICAgICAgLypzaG93aW5nQWxsV2FsbGV0TW9kdWxlcyovXG4gICAgICAyNTYpIHdhbGxldHNfMV9jaGFuZ2VzLnNob3dpbmdBbGxXYWxsZXRNb2R1bGVzID1cbiAgICAgIC8qc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMqL1xuICAgICAgY3R4WzhdO1xuICAgICAgaWYgKGRpcnR5WzBdICZcbiAgICAgIC8qd2FsbGV0c0Rpc2FibGVkKi9cbiAgICAgIDY0KSB3YWxsZXRzXzFfY2hhbmdlcy53YWxsZXRzRGlzYWJsZWQgPVxuICAgICAgLyp3YWxsZXRzRGlzYWJsZWQqL1xuICAgICAgY3R4WzZdO1xuICAgICAgd2FsbGV0c18xLiRzZXQod2FsbGV0c18xX2NoYW5nZXMpO1xuICAgICAgaWYgKFxuICAgICAgLyptb2JpbGVEZXZpY2UqL1xuICAgICAgY3R4WzldKSBpZl9ibG9jazAucChjdHgsIGRpcnR5KTtcblxuICAgICAgaWYgKFxuICAgICAgLypzaG93V2FsbGV0RGVmaW5pdGlvbiovXG4gICAgICBjdHhbMl0pIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICAgIGlmX2Jsb2NrMS5wKGN0eCwgZGlydHkpO1xuXG4gICAgICAgICAgaWYgKGRpcnR5WzBdICZcbiAgICAgICAgICAvKnNob3dXYWxsZXREZWZpbml0aW9uKi9cbiAgICAgICAgICA0KSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMSwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMSA9IGNyZWF0ZV9pZl9ibG9ja18yJDEoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazEuYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2sxLCAxKTtcbiAgICAgICAgICBpZl9ibG9jazEubShpZl9ibG9jazFfYW5jaG9yLnBhcmVudE5vZGUsIGlmX2Jsb2NrMV9hbmNob3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICBpZl9ibG9jazEuZCgxKTtcbiAgICAgICAgaWZfYmxvY2sxID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKHdhbGxldHNfMS4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazApO1xuICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazEpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dCh3YWxsZXRzXzEuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKF9wKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0MCk7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudCh3YWxsZXRzXzEsIGRldGFjaGluZyk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godDEpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKGRpdik7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAuZCgpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQ0KTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5kKGRldGFjaGluZyk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goaWZfYmxvY2sxX2FuY2hvcik7XG4gICAgICBtb3VudGVkID0gZmFsc2U7XG4gICAgICBkaXNwb3NlKCk7XG4gICAgfVxuICB9O1xufSAvLyAoMjU2OjgpIHsjaWYgbW9iaWxlRGV2aWNlfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9ja18zKGN0eCkge1xuICB2YXIgYnV0dG9uO1xuICB2YXIgY3VycmVudDtcbiAgYnV0dG9uID0gbmV3IEJ1dHRvbih7XG4gICAgcHJvcHM6IHtcbiAgICAgIGN0YTogZmFsc2UsXG4gICAgICBvbmNsaWNrOlxuICAgICAgLypmdW5jKi9cbiAgICAgIGN0eFsxOV0sXG4gICAgICAkJHNsb3RzOiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiBbY3JlYXRlX2RlZmF1bHRfc2xvdF8xJDFdXG4gICAgICB9LFxuICAgICAgJCRzY29wZToge1xuICAgICAgICBjdHg6IGN0eFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoYnV0dG9uLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChidXR0b24sIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICB2YXIgYnV0dG9uX2NoYW5nZXMgPSB7fTtcblxuICAgICAgaWYgKGRpcnR5WzFdICZcbiAgICAgIC8qJCRzY29wZSovXG4gICAgICAzMikge1xuICAgICAgICBidXR0b25fY2hhbmdlcy4kJHNjb3BlID0ge1xuICAgICAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBidXR0b24uJHNldChidXR0b25fY2hhbmdlcyk7XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihidXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoYnV0dG9uLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQoYnV0dG9uLCBkZXRhY2hpbmcpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDI1NzoxMCkgPEJ1dHRvbiBjdGE9e2ZhbHNlfSBvbmNsaWNrPXsoKSA9PiBmaW5pc2goeyBjb21wbGV0ZWQ6IGZhbHNlIH0pfSAgICAgICAgICAgICA+XG5cblxuZnVuY3Rpb24gY3JlYXRlX2RlZmF1bHRfc2xvdF8xJDEoY3R4KSB7XG4gIHZhciB0O1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICB0ID0gdGV4dChcIkRpc21pc3NcIik7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0LCBhbmNob3IpO1xuICAgIH0sXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0KTtcbiAgICB9XG4gIH07XG59IC8vICgyNjI6NikgeyNpZiBzaG93V2FsbGV0RGVmaW5pdGlvbn1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfMiQxKGN0eCkge1xuICB2YXIgX3AyO1xuXG4gIHZhciByYXdfdmFsdWUgPVxuICAvKm1vZGFsRGF0YSovXG4gIGN0eFsxXS5leHBsYW5hdGlvbiArIFwiXCI7XG4gIHZhciBwX2ludHJvO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBfcDIgPSBlbGVtZW50KFwicFwiKTtcbiAgICAgIGF0dHIoX3AyLCBcImNsYXNzXCIsIFwiYm4tb25ib2FyZC1jdXN0b20gYm4tb25ib2FyZC1zZWxlY3Qtd2FsbGV0LWRlZmluaXRpb24gc3ZlbHRlLXc5ZnRmeVwiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIF9wMiwgYW5jaG9yKTtcbiAgICAgIF9wMi5pbm5lckhUTUwgPSByYXdfdmFsdWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIGlmIChkaXJ0eVswXSAmXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAyICYmIHJhd192YWx1ZSAhPT0gKHJhd192YWx1ZSA9XG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICBjdHhbMV0uZXhwbGFuYXRpb24gKyBcIlwiKSkgX3AyLmlubmVySFRNTCA9IHJhd192YWx1ZTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmICghcF9pbnRybykge1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwX2ludHJvID0gY3JlYXRlX2luX3RyYW5zaXRpb24oX3AyLCBmYWRlLCB7fSk7XG4gICAgICAgICAgcF9pbnRyby5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG86IG5vb3AsXG4gICAgZDogZnVuY3Rpb24gZChkZXRhY2hpbmcpIHtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChfcDIpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDIxNDoyKSA8TW9kYWwgY2xvc2VNb2RhbD17KCkgPT4gZmluaXNoKHsgY29tcGxldGVkOiBmYWxzZSB9KX0+XG5cblxuZnVuY3Rpb24gY3JlYXRlX2RlZmF1bHRfc2xvdCQyKGN0eCkge1xuICB2YXIgbW9kYWxoZWFkZXI7XG4gIHZhciB0MDtcbiAgdmFyIHQxO1xuICB2YXIgY3VycmVudF9ibG9ja190eXBlX2luZGV4O1xuICB2YXIgaWZfYmxvY2sxO1xuICB2YXIgaWZfYmxvY2sxX2FuY2hvcjtcbiAgdmFyIGN1cnJlbnQ7XG4gIG1vZGFsaGVhZGVyID0gbmV3IE1vZGFsSGVhZGVyKHtcbiAgICBwcm9wczoge1xuICAgICAgaWNvbjogd2FsbGV0SWNvbixcbiAgICAgIGhlYWRpbmc6XG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICBjdHhbMV0uaGVhZGluZ1xuICAgIH1cbiAgfSk7XG4gIHZhciBpZl9ibG9jazAgPVxuICAvKnNob3dUZXJtc09mU2VydmljZSovXG4gIGN0eFsxMl0gJiYgY3JlYXRlX2lmX2Jsb2NrXzQoY3R4KTtcbiAgdmFyIGlmX2Jsb2NrX2NyZWF0b3JzID0gW2NyZWF0ZV9pZl9ibG9ja18xJDMsIGNyZWF0ZV9lbHNlX2Jsb2NrJDNdO1xuICB2YXIgaWZfYmxvY2tzID0gW107XG5cbiAgZnVuY3Rpb24gc2VsZWN0X2Jsb2NrX3R5cGUoY3R4LCBkaXJ0eSkge1xuICAgIGlmICghXG4gICAgLypzZWxlY3RlZFdhbGxldE1vZHVsZSovXG4gICAgY3R4WzVdKSByZXR1cm4gMDtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIGN1cnJlbnRfYmxvY2tfdHlwZV9pbmRleCA9IHNlbGVjdF9ibG9ja190eXBlKGN0eCk7XG4gIGlmX2Jsb2NrMSA9IGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdID0gaWZfYmxvY2tfY3JlYXRvcnNbY3VycmVudF9ibG9ja190eXBlX2luZGV4XShjdHgpO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KG1vZGFsaGVhZGVyLiQkLmZyYWdtZW50KTtcbiAgICAgIHQwID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5jKCk7XG4gICAgICB0MSA9IHNwYWNlKCk7XG4gICAgICBpZl9ibG9jazEuYygpO1xuICAgICAgaWZfYmxvY2sxX2FuY2hvciA9IGVtcHR5KCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQobW9kYWxoZWFkZXIsIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQwLCBhbmNob3IpO1xuICAgICAgaWYgKGlmX2Jsb2NrMCkgaWZfYmxvY2swLm0odGFyZ2V0LCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdDEsIGFuY2hvcik7XG4gICAgICBpZl9ibG9ja3NbY3VycmVudF9ibG9ja190eXBlX2luZGV4XS5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIGlmX2Jsb2NrMV9hbmNob3IsIGFuY2hvcik7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBkaXJ0eSkge1xuICAgICAgdmFyIG1vZGFsaGVhZGVyX2NoYW5nZXMgPSB7fTtcbiAgICAgIGlmIChkaXJ0eVswXSAmXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICAyKSBtb2RhbGhlYWRlcl9jaGFuZ2VzLmhlYWRpbmcgPVxuICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgY3R4WzFdLmhlYWRpbmc7XG4gICAgICBtb2RhbGhlYWRlci4kc2V0KG1vZGFsaGVhZGVyX2NoYW5nZXMpO1xuICAgICAgaWYgKFxuICAgICAgLypzaG93VGVybXNPZlNlcnZpY2UqL1xuICAgICAgY3R4WzEyXSkgaWZfYmxvY2swLnAoY3R4LCBkaXJ0eSk7XG4gICAgICB2YXIgcHJldmlvdXNfYmxvY2tfaW5kZXggPSBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXg7XG4gICAgICBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXggPSBzZWxlY3RfYmxvY2tfdHlwZShjdHgpO1xuXG4gICAgICBpZiAoY3VycmVudF9ibG9ja190eXBlX2luZGV4ID09PSBwcmV2aW91c19ibG9ja19pbmRleCkge1xuICAgICAgICBpZl9ibG9ja3NbY3VycmVudF9ibG9ja190eXBlX2luZGV4XS5wKGN0eCwgZGlydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2Nrc1twcmV2aW91c19ibG9ja19pbmRleF0sIDEsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZl9ibG9ja3NbcHJldmlvdXNfYmxvY2tfaW5kZXhdID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgICBpZl9ibG9jazEgPSBpZl9ibG9ja3NbY3VycmVudF9ibG9ja190eXBlX2luZGV4XTtcblxuICAgICAgICBpZiAoIWlmX2Jsb2NrMSkge1xuICAgICAgICAgIGlmX2Jsb2NrMSA9IGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdID0gaWZfYmxvY2tfY3JlYXRvcnNbY3VycmVudF9ibG9ja190eXBlX2luZGV4XShjdHgpO1xuICAgICAgICAgIGlmX2Jsb2NrMS5jKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWZfYmxvY2sxLnAoY3R4LCBkaXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMSwgMSk7XG4gICAgICAgIGlmX2Jsb2NrMS5tKGlmX2Jsb2NrMV9hbmNob3IucGFyZW50Tm9kZSwgaWZfYmxvY2sxX2FuY2hvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihtb2RhbGhlYWRlci4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazEpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChtb2RhbGhlYWRlci4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2sxKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChtb2RhbGhlYWRlciwgZGV0YWNoaW5nKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0MCk7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAuZChkZXRhY2hpbmcpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQxKTtcbiAgICAgIGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdLmQoZGV0YWNoaW5nKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChpZl9ibG9jazFfYW5jaG9yKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudCQ5KGN0eCkge1xuICB2YXIgaWZfYmxvY2tfYW5jaG9yO1xuICB2YXIgY3VycmVudDtcbiAgdmFyIGlmX2Jsb2NrID1cbiAgLyptb2RhbERhdGEqL1xuICBjdHhbMV0gJiYgY3JlYXRlX2lmX2Jsb2NrJDcoY3R4KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgaWYgKGlmX2Jsb2NrKSBpZl9ibG9jay5jKCk7XG4gICAgICBpZl9ibG9ja19hbmNob3IgPSBlbXB0eSgpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaWYgKGlmX2Jsb2NrKSBpZl9ibG9jay5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIGlmX2Jsb2NrX2FuY2hvciwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoXG4gICAgICAvKm1vZGFsRGF0YSovXG4gICAgICBjdHhbMV0pIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrKSB7XG4gICAgICAgICAgaWZfYmxvY2sucChjdHgsIGRpcnR5KTtcblxuICAgICAgICAgIGlmIChkaXJ0eVswXSAmXG4gICAgICAgICAgLyptb2RhbERhdGEqL1xuICAgICAgICAgIDIpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2ssIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jayA9IGNyZWF0ZV9pZl9ibG9jayQ3KGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2suYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2ssIDEpO1xuICAgICAgICAgIGlmX2Jsb2NrLm0oaWZfYmxvY2tfYW5jaG9yLnBhcmVudE5vZGUsIGlmX2Jsb2NrX2FuY2hvcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWZfYmxvY2spIHtcbiAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrLCAxLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWZfYmxvY2sgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jayk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoaWZfYmxvY2spIGlmX2Jsb2NrLmQoZGV0YWNoaW5nKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChpZl9ibG9ja19hbmNob3IpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gbG9ja1Njcm9sbCgpIHtcbiAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xufVxuXG5mdW5jdGlvbiBpbnN0YW5jZSQ5KCQkc2VsZiwgJCRwcm9wcywgJCRpbnZhbGlkYXRlKSB7XG4gIHZhciBfJCRwcm9wcyRtb2R1bGUgPSAkJHByb3BzLm1vZHVsZSxcbiAgICAgIG1vZHVsZSA9IF8kJHByb3BzJG1vZHVsZSA9PT0gdm9pZCAwID8ge1xuICAgIGhlYWRpbmc6IFwiXCIsXG4gICAgZGVzY3JpcHRpb246IFwiXCIsXG4gICAgd2FsbGV0czogW10sXG4gICAgYWdyZWVtZW50OiB1bmRlZmluZWRcbiAgfSA6IF8kJHByb3BzJG1vZHVsZTtcbiAgdmFyIG1vZGFsRGF0YTtcbiAgdmFyIHNob3dXYWxsZXREZWZpbml0aW9uO1xuICB2YXIgd2FsbGV0QWxyZWFkeUluc3RhbGxlZDtcbiAgdmFyIGluc3RhbGxNZXNzYWdlO1xuICB2YXIgc2VsZWN0ZWRXYWxsZXRNb2R1bGU7XG5cbiAgdmFyIF9nZXRfc3RvcmVfdmFsdWU0ID0gZ2V0X3N0b3JlX3ZhbHVlKGFwcCksXG4gICAgICBtb2JpbGVEZXZpY2UgPSBfZ2V0X3N0b3JlX3ZhbHVlNC5tb2JpbGVEZXZpY2UsXG4gICAgICBvcyA9IF9nZXRfc3RvcmVfdmFsdWU0Lm9zO1xuXG4gIHZhciBfbW9kdWxlID0gbW9kdWxlLFxuICAgICAgaGVhZGluZyA9IF9tb2R1bGUuaGVhZGluZyxcbiAgICAgIGRlc2NyaXB0aW9uID0gX21vZHVsZS5kZXNjcmlwdGlvbixcbiAgICAgIGV4cGxhbmF0aW9uID0gX21vZHVsZS5leHBsYW5hdGlvbixcbiAgICAgIHdhbGxldHMgPSBfbW9kdWxlLndhbGxldHMsXG4gICAgICBhZ3JlZW1lbnQgPSBfbW9kdWxlLmFncmVlbWVudDtcblxuICB2YXIgX3JlZjI4ID0gYWdyZWVtZW50IHx8IHt9LFxuICAgICAgdGVybXNVcmwgPSBfcmVmMjgudGVybXNVcmwsXG4gICAgICBwcml2YWN5VXJsID0gX3JlZjI4LnByaXZhY3lVcmwsXG4gICAgICB2ZXJzaW9uID0gX3JlZjI4LnZlcnNpb247XG5cbiAgdmFyIF9KU09OJHBhcnNlID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTVE9SQUdFX0tFWVMuVEVSTVNfQUdSRUVNRU5UKSB8fCBcInt9XCIpLFxuICAgICAgdGVybXNBZ3JlZWQgPSBfSlNPTiRwYXJzZS50ZXJtcyxcbiAgICAgIHByaXZhY3lBZ3JlZWQgPSBfSlNPTiRwYXJzZS5wcml2YWN5LFxuICAgICAgdmVyc2lvbkFncmVlZCA9IF9KU09OJHBhcnNlLnZlcnNpb247XG5cbiAgdmFyIHNob3dUZXJtc09mU2VydmljZSA9ICEhKHRlcm1zVXJsICYmICF0ZXJtc0FncmVlZCB8fCBwcml2YWN5VXJsICYmICFwcml2YWN5QWdyZWVkIHx8IHZlcnNpb24gJiYgdmVyc2lvbiAhPT0gdmVyc2lvbkFncmVlZCk7XG4gIHZhciB3YWxsZXRzRGlzYWJsZWQgPSBzaG93VGVybXNPZlNlcnZpY2U7XG4gIHZhciBhZ3JlZWQgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmltYXJ5V2FsbGV0cztcbiAgdmFyIHNlY29uZGFyeVdhbGxldHM7XG4gIHZhciBsb2FkaW5nV2FsbGV0ID0gdW5kZWZpbmVkO1xuICB2YXIgc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMgPSBmYWxzZTtcblxuICB2YXIgc2hvd0FsbFdhbGxldHMgPSBmdW5jdGlvbiBzaG93QWxsV2FsbGV0cygpIHtcbiAgICByZXR1cm4gJCRpbnZhbGlkYXRlKDgsIHNob3dpbmdBbGxXYWxsZXRNb2R1bGVzID0gdHJ1ZSk7XG4gIH07XG5cbiAgdmFyIG9yaWdpbmFsT3ZlcmZsb3dWYWx1ZTtcbiAgb25Nb3VudChmdW5jdGlvbiAoKSB7XG4gICAgb3JpZ2luYWxPdmVyZmxvd1ZhbHVlID0gd2luZG93LmRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3c7XG4gICAgd2luZG93LmRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGxvY2tTY3JvbGwpO1xuICB9KTtcbiAgb25EZXN0cm95KGZ1bmN0aW9uICgpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBsb2NrU2Nyb2xsKTtcbiAgICB3aW5kb3cuZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9IG9yaWdpbmFsT3ZlcmZsb3dWYWx1ZTtcbiAgfSk7XG4gIHJlbmRlcldhbGxldFNlbGVjdCgpO1xuXG4gIGZ1bmN0aW9uIHJlbmRlcldhbGxldFNlbGVjdCgpIHtcbiAgICByZXR1cm4gX3JlbmRlcldhbGxldFNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3JlbmRlcldhbGxldFNlbGVjdCgpIHtcbiAgICBfcmVuZGVyV2FsbGV0U2VsZWN0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICAgIHZhciBhcHBTdGF0ZSwgZGV2aWNlV2FsbGV0cywgX21vZHVsZTI7XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGFwcFN0YXRlID0gZ2V0X3N0b3JlX3ZhbHVlKGFwcCk7XG4gICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldHM7XG5cbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgd2FsbGV0cyA9IF9jb250ZXh0NC5zZW50O1xuICAgICAgICAgICAgICBkZXZpY2VXYWxsZXRzID0gd2FsbGV0cy5maWx0ZXIoZnVuY3Rpb24gKHdhbGxldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXRbbW9iaWxlRGV2aWNlID8gXCJtb2JpbGVcIiA6IFwiZGVza3RvcFwiXTtcbiAgICAgICAgICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh3YWxsZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3dhbGxldCRvc0V4Y2x1c2lvbnMgPSB3YWxsZXQub3NFeGNsdXNpb25zLFxuICAgICAgICAgICAgICAgICAgICBvc0V4Y2x1c2lvbnMgPSBfd2FsbGV0JG9zRXhjbHVzaW9ucyA9PT0gdm9pZCAwID8gW10gOiBfd2FsbGV0JG9zRXhjbHVzaW9ucztcbiAgICAgICAgICAgICAgICByZXR1cm4gIW9zRXhjbHVzaW9ucy5pbmNsdWRlcyhvcy5uYW1lKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgaWYgKGRldmljZVdhbGxldHMuZmluZChmdW5jdGlvbiAod2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5wcmVmZXJyZWQ7XG4gICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgcHJlZmVycmVkIHdhbGxldHMsIHRoZW4gc3BsaXQgaW4gdG8gcHJlZmVycmVkIGFuZCBub3QgcHJlZmVycmVkXG4gICAgICAgICAgICAgICAgcHJpbWFyeVdhbGxldHMgPSBkZXZpY2VXYWxsZXRzLmZpbHRlcihmdW5jdGlvbiAod2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0LnByZWZlcnJlZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzZWNvbmRhcnlXYWxsZXRzID0gZGV2aWNlV2FsbGV0cy5maWx0ZXIoZnVuY3Rpb24gKHdhbGxldCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICF3YWxsZXQucHJlZmVycmVkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBtYWtlIHRoZSBmaXJzdCA0IHdhbGxldHMgcHJlZmVycmVkXG4gICAgICAgICAgICAgICAgcHJpbWFyeVdhbGxldHMgPSBkZXZpY2VXYWxsZXRzLnNsaWNlKDAsIDQpO1xuICAgICAgICAgICAgICAgIHNlY29uZGFyeVdhbGxldHMgPSBkZXZpY2VXYWxsZXRzLmxlbmd0aCA+IDQgPyBkZXZpY2VXYWxsZXRzLnNsaWNlKDQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFhcHBTdGF0ZS5hdXRvU2VsZWN0V2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF9tb2R1bGUyID0gZGV2aWNlV2FsbGV0cy5maW5kKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG0ubmFtZSA9PT0gYXBwU3RhdGUuYXV0b1NlbGVjdFdhbGxldDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFwcC51cGRhdGUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgYXV0b1NlbGVjdFdhbGxldDogXCJcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBpZiAoIV9tb2R1bGUyKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGhhbmRsZVdhbGxldFNlbGVjdChfbW9kdWxlMiwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAkJGludmFsaWRhdGUoMSwgbW9kYWxEYXRhID0ge1xuICAgICAgICAgICAgICAgIGhlYWRpbmc6IGhlYWRpbmcsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uOiBleHBsYW5hdGlvbixcbiAgICAgICAgICAgICAgICBwcmltYXJ5V2FsbGV0czogcHJpbWFyeVdhbGxldHMsXG4gICAgICAgICAgICAgICAgc2Vjb25kYXJ5V2FsbGV0czogc2Vjb25kYXJ5V2FsbGV0c1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXBwLnVwZGF0ZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgICB3YWxsZXRTZWxlY3REaXNwbGF5ZWRVSTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlNCk7XG4gICAgfSkpO1xuICAgIHJldHVybiBfcmVuZGVyV2FsbGV0U2VsZWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVXYWxsZXRTZWxlY3QoX3g0LCBfeDUpIHtcbiAgICByZXR1cm4gX2hhbmRsZVdhbGxldFNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2hhbmRsZVdhbGxldFNlbGVjdCgpIHtcbiAgICBfaGFuZGxlV2FsbGV0U2VsZWN0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNShtb2R1bGUsIGF1dG9TZWxlY3RlZCkge1xuICAgICAgdmFyIGN1cnJlbnRXYWxsZXRJbnRlcmZhY2UsIF9nZXRfc3RvcmVfdmFsdWU1LCBicm93c2VyLCBvcywgX3lpZWxkJG1vZHVsZSR3YWxsZXQsIHByb3ZpZGVyLCBzZWxlY3RlZFdhbGxldEludGVyZmFjZSwgaW5zdGFuY2UsIG5hbWUsIHR5cGUsIHN2ZywgaWNvblNyYywgaWNvblNyY1NldDtcblxuICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1JChfY29udGV4dDUpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NS5wcmV2ID0gX2NvbnRleHQ1Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY3VycmVudFdhbGxldEludGVyZmFjZSA9IGdldF9zdG9yZV92YWx1ZSh3YWxsZXRJbnRlcmZhY2UpO1xuICAgICAgICAgICAgICBfZ2V0X3N0b3JlX3ZhbHVlNSA9IGdldF9zdG9yZV92YWx1ZShhcHApLCBicm93c2VyID0gX2dldF9zdG9yZV92YWx1ZTUuYnJvd3Nlciwgb3MgPSBfZ2V0X3N0b3JlX3ZhbHVlNS5vcztcblxuICAgICAgICAgICAgICBpZiAoIShjdXJyZW50V2FsbGV0SW50ZXJmYWNlICYmIGN1cnJlbnRXYWxsZXRJbnRlcmZhY2UubmFtZSA9PT0gbW9kdWxlLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgZmluaXNoKHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQ6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICQkaW52YWxpZGF0ZSg3LCBsb2FkaW5nV2FsbGV0ID0gbW9kdWxlLm5hbWUpO1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDg7XG4gICAgICAgICAgICAgIHJldHVybiBtb2R1bGUud2FsbGV0KHtcbiAgICAgICAgICAgICAgICBnZXRQcm92aWRlck5hbWU6IGdldFByb3ZpZGVyTmFtZSxcbiAgICAgICAgICAgICAgICBjcmVhdGVMZWdhY3lQcm92aWRlckludGVyZmFjZTogY3JlYXRlTGVnYWN5UHJvdmlkZXJJbnRlcmZhY2UsXG4gICAgICAgICAgICAgICAgY3JlYXRlTW9kZXJuUHJvdmlkZXJJbnRlcmZhY2U6IGNyZWF0ZU1vZGVyblByb3ZpZGVySW50ZXJmYWNlLFxuICAgICAgICAgICAgICAgIEJpZ051bWJlcjogQmlnTnVtYmVyLFxuICAgICAgICAgICAgICAgIGdldE5ldHdvcms6IGdldE5ldHdvcmssXG4gICAgICAgICAgICAgICAgZ2V0QWRkcmVzczogZ2V0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICBnZXRCYWxhbmNlOiBnZXRCYWxhbmNlLFxuICAgICAgICAgICAgICAgIHJlc2V0V2FsbGV0U3RhdGU6IHJlc2V0V2FsbGV0U3RhdGUsXG4gICAgICAgICAgICAgICAgbmV0d29ya05hbWU6IG5ldHdvcmtOYW1lLFxuICAgICAgICAgICAgICAgIGJyb3dzZXI6IGJyb3dzZXIsXG4gICAgICAgICAgICAgICAgb3M6IG9zXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF95aWVsZCRtb2R1bGUkd2FsbGV0ID0gX2NvbnRleHQ1LnNlbnQ7XG4gICAgICAgICAgICAgIHByb3ZpZGVyID0gX3lpZWxkJG1vZHVsZSR3YWxsZXQucHJvdmlkZXI7XG4gICAgICAgICAgICAgIHNlbGVjdGVkV2FsbGV0SW50ZXJmYWNlID0gX3lpZWxkJG1vZHVsZSR3YWxsZXRbXCJpbnRlcmZhY2VcIl07XG4gICAgICAgICAgICAgIGluc3RhbmNlID0gX3lpZWxkJG1vZHVsZSR3YWxsZXQuaW5zdGFuY2U7XG4gICAgICAgICAgICAgICQkaW52YWxpZGF0ZSg3LCBsb2FkaW5nV2FsbGV0ID0gdW5kZWZpbmVkKTsgLy8gaWYgbm8gaW50ZXJmYWNlIHRoZW4gdGhlIHVzZXIgZG9lcyBub3QgaGF2ZSB0aGUgd2FsbGV0IHRoZXkgc2VsZWN0ZWQgaW5zdGFsbGVkIG9yIGF2YWlsYWJsZVxuXG4gICAgICAgICAgICAgIGlmIChzZWxlY3RlZFdhbGxldEludGVyZmFjZSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NS5uZXh0ID0gMTk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAkJGludmFsaWRhdGUoNSwgc2VsZWN0ZWRXYWxsZXRNb2R1bGUgPSBtb2R1bGUpO1xuICAgICAgICAgICAgICAkJGludmFsaWRhdGUoMywgd2FsbGV0QWxyZWFkeUluc3RhbGxlZCA9IHByb3ZpZGVyICYmIGdldFByb3ZpZGVyTmFtZShwcm92aWRlcikpO1xuICAgICAgICAgICAgICAkJGludmFsaWRhdGUoNCwgaW5zdGFsbE1lc3NhZ2UgPSBtb2R1bGUuaW5zdGFsbE1lc3NhZ2UgPyBtb2R1bGUuaW5zdGFsbE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGN1cnJlbnRXYWxsZXQ6IHdhbGxldEFscmVhZHlJbnN0YWxsZWQsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRXYWxsZXQ6IHNlbGVjdGVkV2FsbGV0TW9kdWxlLm5hbWVcbiAgICAgICAgICAgICAgfSkgOiBcIlwiKTsgLy8gaWYgaXQgd2FzIGF1dG9TZWxlY3RlZCB0aGVuIHdlIG5lZWQgdG8gYWRkIG1vZGFsRGF0YSB0byBzaG93IHRoZSBtb2RhbFxuXG4gICAgICAgICAgICAgIGlmIChhdXRvU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAkJGludmFsaWRhdGUoMSwgbW9kYWxEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgaGVhZGluZzogaGVhZGluZyxcbiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgIGV4cGxhbmF0aW9uOiBleHBsYW5hdGlvbixcbiAgICAgICAgICAgICAgICAgIHByaW1hcnlXYWxsZXRzOiBwcmltYXJ5V2FsbGV0cyxcbiAgICAgICAgICAgICAgICAgIHNlY29uZGFyeVdhbGxldHM6IHNlY29uZGFyeVdhbGxldHNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhcHAudXBkYXRlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRTZWxlY3REaXNwbGF5ZWRVSTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgd2FsbGV0SW50ZXJmYWNlLnVwZGF0ZShmdW5jdGlvbiAoY3VycmVudEludGVyZmFjZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW50ZXJmYWNlICYmIGN1cnJlbnRJbnRlcmZhY2UuZGlzY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudEludGVyZmFjZS5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkV2FsbGV0SW50ZXJmYWNlO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbmFtZSA9IG1vZHVsZS5uYW1lLCB0eXBlID0gbW9kdWxlLnR5cGUsIHN2ZyA9IG1vZHVsZS5zdmcsIGljb25TcmMgPSBtb2R1bGUuaWNvblNyYywgaWNvblNyY1NldCA9IG1vZHVsZS5pY29uU3JjU2V0O1xuICAgICAgICAgICAgICB3YWxsZXQuc2V0KHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogcHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgICAgIGRhc2hib2FyZDogc2VsZWN0ZWRXYWxsZXRJbnRlcmZhY2UuZGFzaGJvYXJkLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgY29ubmVjdDogc2VsZWN0ZWRXYWxsZXRJbnRlcmZhY2UuY29ubmVjdCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIGljb25zOiB7XG4gICAgICAgICAgICAgICAgICBzdmc6IHN2ZyxcbiAgICAgICAgICAgICAgICAgIGljb25TcmM6IGljb25TcmMsXG4gICAgICAgICAgICAgICAgICBpY29uU3JjU2V0OiBpY29uU3JjU2V0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgZmluaXNoKHtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQ6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgX2NhbGxlZTUpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gX2hhbmRsZVdhbGxldFNlbGVjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoKG9wdGlvbnMpIHtcbiAgICAkJGludmFsaWRhdGUoMSwgbW9kYWxEYXRhID0gbnVsbCk7XG4gICAgYXBwLnVwZGF0ZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgd2FsbGV0U2VsZWN0SW5Qcm9ncmVzczogZmFsc2UsXG4gICAgICAgIHdhbGxldFNlbGVjdENvbXBsZXRlZDogb3B0aW9ucy5jb21wbGV0ZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5wdXRfY2hhbmdlX2hhbmRsZXIoKSB7XG4gICAgYWdyZWVkID0gdGhpcy5jaGVja2VkO1xuICAgICQkaW52YWxpZGF0ZSgwLCBhZ3JlZWQpO1xuICB9XG5cbiAgdmFyIGNsaWNrX2hhbmRsZXIgPSBmdW5jdGlvbiBjbGlja19oYW5kbGVyKCkge1xuICAgIHJldHVybiAkJGludmFsaWRhdGUoMiwgc2hvd1dhbGxldERlZmluaXRpb24gPSAhc2hvd1dhbGxldERlZmluaXRpb24pO1xuICB9O1xuXG4gIHZhciBmdW5jID0gZnVuY3Rpb24gZnVuYygpIHtcbiAgICByZXR1cm4gZmluaXNoKHtcbiAgICAgIGNvbXBsZXRlZDogZmFsc2VcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgZnVuY18xID0gZnVuY3Rpb24gZnVuY18xKCkge1xuICAgICQkaW52YWxpZGF0ZSg1LCBzZWxlY3RlZFdhbGxldE1vZHVsZSA9IG51bGwpO1xuICAgICQkaW52YWxpZGF0ZSgzLCB3YWxsZXRBbHJlYWR5SW5zdGFsbGVkID0gdW5kZWZpbmVkKTtcbiAgfTtcblxuICB2YXIgZnVuY18yID0gZnVuY3Rpb24gZnVuY18yKCkge1xuICAgIHJldHVybiBmaW5pc2goe1xuICAgICAgY29tcGxldGVkOiBmYWxzZVxuICAgIH0pO1xuICB9O1xuXG4gICQkc2VsZi4kJHNldCA9IGZ1bmN0aW9uICgkJHByb3BzKSB7XG4gICAgaWYgKFwibW9kdWxlXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDE2LCBtb2R1bGUgPSAkJHByb3BzLm1vZHVsZSk7XG4gIH07XG5cbiAgJCRzZWxmLiQkLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJCRzZWxmLiQkLmRpcnR5WzBdICZcbiAgICAvKmFncmVlZCovXG4gICAgMSkge1xuICAgICAgaWYgKGFncmVlZCkge1xuICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShTVE9SQUdFX0tFWVMuVEVSTVNfQUdSRUVNRU5ULCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgICAgICB0ZXJtczogISF0ZXJtc1VybCxcbiAgICAgICAgICBwcml2YWN5OiAhIXByaXZhY3lVcmxcbiAgICAgICAgfSkpO1xuICAgICAgICAkJGludmFsaWRhdGUoNiwgd2FsbGV0c0Rpc2FibGVkID0gZmFsc2UpO1xuICAgICAgfSBlbHNlIGlmIChhZ3JlZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKFNUT1JBR0VfS0VZUy5URVJNU19BR1JFRU1FTlQpO1xuICAgICAgICAkJGludmFsaWRhdGUoNiwgd2FsbGV0c0Rpc2FibGVkID0gdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBbYWdyZWVkLCBtb2RhbERhdGEsIHNob3dXYWxsZXREZWZpbml0aW9uLCB3YWxsZXRBbHJlYWR5SW5zdGFsbGVkLCBpbnN0YWxsTWVzc2FnZSwgc2VsZWN0ZWRXYWxsZXRNb2R1bGUsIHdhbGxldHNEaXNhYmxlZCwgbG9hZGluZ1dhbGxldCwgc2hvd2luZ0FsbFdhbGxldE1vZHVsZXMsIG1vYmlsZURldmljZSwgdGVybXNVcmwsIHByaXZhY3lVcmwsIHNob3dUZXJtc09mU2VydmljZSwgc2hvd0FsbFdhbGxldHMsIGhhbmRsZVdhbGxldFNlbGVjdCwgZmluaXNoLCBtb2R1bGUsIGlucHV0X2NoYW5nZV9oYW5kbGVyLCBjbGlja19oYW5kbGVyLCBmdW5jLCBmdW5jXzEsIGZ1bmNfMl07XG59XG5cbnZhciBXYWxsZXRTZWxlY3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdmVsdGVDb21wb25lbnQxMCkge1xuICBfaW5oZXJpdHMoV2FsbGV0U2VsZWN0LCBfU3ZlbHRlQ29tcG9uZW50MTApO1xuXG4gIHZhciBfc3VwZXIxMCA9IF9jcmVhdGVTdXBlcihXYWxsZXRTZWxlY3QpO1xuXG4gIGZ1bmN0aW9uIFdhbGxldFNlbGVjdChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMTA7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2FsbGV0U2VsZWN0KTtcblxuICAgIF90aGlzMTAgPSBfc3VwZXIxMC5jYWxsKHRoaXMpO1xuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdmVsdGUtdzlmdGZ5LXN0eWxlXCIpKSBhZGRfY3NzJDkoKTtcbiAgICBpbml0KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMxMCksIG9wdGlvbnMsIGluc3RhbmNlJDksIGNyZWF0ZV9mcmFnbWVudCQ5LCBzYWZlX25vdF9lcXVhbCwge1xuICAgICAgbW9kdWxlOiAxNlxuICAgIH0sIFstMSwgLTFdKTtcbiAgICByZXR1cm4gX3RoaXMxMDtcbiAgfVxuXG4gIHJldHVybiBXYWxsZXRTZWxlY3Q7XG59KFN2ZWx0ZUNvbXBvbmVudCk7XG4vKiBzcmMvdmlld3MvV2FsbGV0Q2hlY2suc3ZlbHRlIGdlbmVyYXRlZCBieSBTdmVsdGUgdjMuMzguMiAqL1xuXG5cbmZ1bmN0aW9uIGFkZF9jc3MkYSgpIHtcbiAgdmFyIHN0eWxlID0gZWxlbWVudChcInN0eWxlXCIpO1xuICBzdHlsZS5pZCA9IFwic3ZlbHRlLXpydnNjdy1zdHlsZVwiO1xuICBzdHlsZS50ZXh0Q29udGVudCA9IFwicC5zdmVsdGUtenJ2c2N3e2ZvbnQtc2l6ZTowLjg4OWVtO2ZvbnQtZmFtaWx5OmluaGVyaXQ7bWFyZ2luOjFlbSAwfXNwYW4uc3ZlbHRlLXpydnNjd3tjb2xvcjojZTI1MDRhO2ZvbnQtc2l6ZTowLjg4OWVtO2ZvbnQtZmFtaWx5OmluaGVyaXQ7ZGlzcGxheTpibG9jazttYXJnaW4tYm90dG9tOjAuNzVlbTtwYWRkaW5nOjAuNWVtO2JvcmRlcjoxcHggc29saWQgI2UyNTA0YTtib3JkZXItcmFkaXVzOjVweH1kaXYuc3ZlbHRlLXpydnNjd3tkaXNwbGF5OmZsZXg7anVzdGlmeS1jb250ZW50OmNlbnRlcjthbGlnbi1pdGVtczpjZW50ZXI7bWluLWhlaWdodDoyLjVyZW07cG9zaXRpb246cmVsYXRpdmV9c2VjdGlvbi5zdmVsdGUtenJ2c2N3e2Rpc3BsYXk6ZmxleDtqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO2ZsZXgtZGlyZWN0aW9uOmNvbHVtbjthbGlnbi1pdGVtczpjZW50ZXI7bWFyZ2luLWJvdHRvbToxcmVtfVwiO1xuICBhcHBlbmQoZG9jdW1lbnQuaGVhZCwgc3R5bGUpO1xufSAvLyAoMjQyOjApIHsjaWYgbG9hZGluZ01vZGFsfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9ja182JDEoY3R4KSB7XG4gIHZhciBtb2RhbDtcbiAgdmFyIGN1cnJlbnQ7XG4gIG1vZGFsID0gbmV3IE1vZGFsKHtcbiAgICBwcm9wczoge1xuICAgICAgY2xvc2VhYmxlOiBmYWxzZSxcbiAgICAgICQkc2xvdHM6IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IFtjcmVhdGVfZGVmYXVsdF9zbG90XzRdXG4gICAgICB9LFxuICAgICAgJCRzY29wZToge1xuICAgICAgICBjdHg6IGN0eFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQobW9kYWwuJCQuZnJhZ21lbnQpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgbW91bnRfY29tcG9uZW50KG1vZGFsLCB0YXJnZXQsIGFuY2hvcik7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKG1vZGFsLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KG1vZGFsLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQobW9kYWwsIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoMjQzOjIpIDxNb2RhbCBjbG9zZWFibGU9e2ZhbHNlfT5cblxuXG5mdW5jdGlvbiBjcmVhdGVfZGVmYXVsdF9zbG90XzQoY3R4KSB7XG4gIHZhciBzcGlubmVyO1xuICB2YXIgY3VycmVudDtcbiAgc3Bpbm5lciA9IG5ldyBTcGlubmVyKHtcbiAgICBwcm9wczoge1xuICAgICAgZGVzY3JpcHRpb246IFwiQ2hlY2tpbmcgd2FsbGV0XCJcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KHNwaW5uZXIuJCQuZnJhZ21lbnQpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgbW91bnRfY29tcG9uZW50KHNwaW5uZXIsIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogbm9vcCxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihzcGlubmVyLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KHNwaW5uZXIuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChzcGlubmVyLCBkZXRhY2hpbmcpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDI0ODowKSB7I2lmIGFjdGl2ZU1vZGFsfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9jayQ4KGN0eCkge1xuICB2YXIgbW9kYWw7XG4gIHZhciBjdXJyZW50O1xuICBtb2RhbCA9IG5ldyBNb2RhbCh7XG4gICAgcHJvcHM6IHtcbiAgICAgIGNsb3NlTW9kYWw6XG4gICAgICAvKmZ1bmNfMSovXG4gICAgICBjdHhbMTJdLFxuICAgICAgJCRzbG90czoge1xuICAgICAgICBcImRlZmF1bHRcIjogW2NyZWF0ZV9kZWZhdWx0X3Nsb3QkM11cbiAgICAgIH0sXG4gICAgICAkJHNjb3BlOiB7XG4gICAgICAgIGN0eDogY3R4XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChtb2RhbC4kJC5mcmFnbWVudCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQobW9kYWwsIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICB2YXIgbW9kYWxfY2hhbmdlcyA9IHt9O1xuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokJHNjb3BlLCBsb2FkaW5nLCBhY3RpdmVNb2RhbCwgZXJyb3JNc2csICRhcHAqL1xuICAgICAgMzM1NTQ0NTUpIHtcbiAgICAgICAgbW9kYWxfY2hhbmdlcy4kJHNjb3BlID0ge1xuICAgICAgICAgIGRpcnR5OiBkaXJ0eSxcbiAgICAgICAgICBjdHg6IGN0eFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBtb2RhbC4kc2V0KG1vZGFsX2NoYW5nZXMpO1xuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4obW9kYWwuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQobW9kYWwuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChtb2RhbCwgZGV0YWNoaW5nKTtcbiAgICB9XG4gIH07XG59IC8vICgyNTQ6NCkgeyNpZiBlcnJvck1zZ31cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfNSQxKGN0eCkge1xuICB2YXIgc3BhbjtcbiAgdmFyIHQ7XG4gIHZhciBzcGFuX2ludHJvO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBzcGFuID0gZWxlbWVudChcInNwYW5cIik7XG4gICAgICB0ID0gdGV4dChcbiAgICAgIC8qZXJyb3JNc2cqL1xuICAgICAgY3R4WzFdKTtcbiAgICAgIGF0dHIoc3BhbiwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtcHJlcGFyZS1lcnJvciBzdmVsdGUtenJ2c2N3XCIpO1xuICAgICAgdG9nZ2xlX2NsYXNzKHNwYW4sIFwiYm4tb25ib2FyZC1kYXJrLW1vZGUtYmFja2dyb3VuZFwiLFxuICAgICAgLyokYXBwKi9cbiAgICAgIGN0eFs0XS5kYXJrTW9kZSk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBzcGFuLCBhbmNob3IpO1xuICAgICAgYXBwZW5kKHNwYW4sIHQpO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyplcnJvck1zZyovXG4gICAgICAyKSBzZXRfZGF0YSh0LFxuICAgICAgLyplcnJvck1zZyovXG4gICAgICBjdHhbMV0pO1xuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokYXBwKi9cbiAgICAgIDE2KSB7XG4gICAgICAgIHRvZ2dsZV9jbGFzcyhzcGFuLCBcImJuLW9uYm9hcmQtZGFyay1tb2RlLWJhY2tncm91bmRcIixcbiAgICAgICAgLyokYXBwKi9cbiAgICAgICAgY3R4WzRdLmRhcmtNb2RlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmICghc3Bhbl9pbnRybykge1xuICAgICAgICBhZGRfcmVuZGVyX2NhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzcGFuX2ludHJvID0gY3JlYXRlX2luX3RyYW5zaXRpb24oc3BhbiwgZmFkZSwge30pO1xuICAgICAgICAgIHNwYW5faW50cm8uc3RhcnQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvOiBub29wLFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goc3Bhbik7XG4gICAgfVxuICB9O1xufSAvLyAoMjY0OjQpIHsjaWYgYWN0aXZlTW9kYWwuaHRtbH1cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfNCQxKGN0eCkge1xuICB2YXIgc2VjdGlvbjtcbiAgdmFyIHJhd192YWx1ZSA9XG4gIC8qYWN0aXZlTW9kYWwqL1xuICBjdHhbMF0uaHRtbCArIFwiXCI7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHNlY3Rpb24gPSBlbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICAgIGF0dHIoc2VjdGlvbiwgXCJjbGFzc1wiLCBcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtd2FsbGV0LWNoZWNrLXNlY3Rpb24gc3ZlbHRlLXpydnNjd1wiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIHNlY3Rpb24sIGFuY2hvcik7XG4gICAgICBzZWN0aW9uLmlubmVySFRNTCA9IHJhd192YWx1ZTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBkaXJ0eSkge1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgMSAmJiByYXdfdmFsdWUgIT09IChyYXdfdmFsdWUgPVxuICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICBjdHhbMF0uaHRtbCArIFwiXCIpKSBzZWN0aW9uLmlubmVySFRNTCA9IHJhd192YWx1ZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goc2VjdGlvbik7XG4gICAgfVxuICB9O1xufSAvLyAoMjcxOjYpIHsjaWYgYWN0aXZlTW9kYWwuYnV0dG9ufVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9ja18zJDEoY3R4KSB7XG4gIHZhciBidXR0b247XG4gIHZhciBjdXJyZW50O1xuICBidXR0b24gPSBuZXcgQnV0dG9uKHtcbiAgICBwcm9wczoge1xuICAgICAgcG9zaXRpb246IFwicmlnaHRcIixcbiAgICAgIG9uY2xpY2s6XG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIGN0eFswXS5idXR0b24ub25jbGljayxcbiAgICAgICQkc2xvdHM6IHtcbiAgICAgICAgXCJkZWZhdWx0XCI6IFtjcmVhdGVfZGVmYXVsdF9zbG90XzNdXG4gICAgICB9LFxuICAgICAgJCRzY29wZToge1xuICAgICAgICBjdHg6IGN0eFxuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoYnV0dG9uLiQkLmZyYWdtZW50KTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChidXR0b24sIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICB2YXIgYnV0dG9uX2NoYW5nZXMgPSB7fTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIDEpIGJ1dHRvbl9jaGFuZ2VzLm9uY2xpY2sgPVxuICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICBjdHhbMF0uYnV0dG9uLm9uY2xpY2s7XG5cbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKiQkc2NvcGUsIGFjdGl2ZU1vZGFsKi9cbiAgICAgIDMzNTU0NDMzKSB7XG4gICAgICAgIGJ1dHRvbl9jaGFuZ2VzLiQkc2NvcGUgPSB7XG4gICAgICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGJ1dHRvbi4kc2V0KGJ1dHRvbl9jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGJ1dHRvbi4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChidXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChidXR0b24sIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoMjcyOjgpIDxCdXR0b24gcG9zaXRpb249XCJyaWdodFwiIG9uY2xpY2s9e2FjdGl2ZU1vZGFsLmJ1dHRvbi5vbmNsaWNrfT5cblxuXG5mdW5jdGlvbiBjcmVhdGVfZGVmYXVsdF9zbG90XzMoY3R4KSB7XG4gIHZhciB0X3ZhbHVlID1cbiAgLyphY3RpdmVNb2RhbCovXG4gIGN0eFswXS5idXR0b24udGV4dCArIFwiXCI7XG4gIHZhciB0O1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICB0ID0gdGV4dCh0X3ZhbHVlKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQsIGFuY2hvcik7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIDEgJiYgdF92YWx1ZSAhPT0gKHRfdmFsdWUgPVxuICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICBjdHhbMF0uYnV0dG9uLnRleHQgKyBcIlwiKSkgc2V0X2RhdGEodCwgdF92YWx1ZSk7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDI4Mzo2KSB7OmVsc2V9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2Vsc2VfYmxvY2skNChjdHgpIHtcbiAgdmFyIGRpdjtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgZGl2ID0gZWxlbWVudChcImRpdlwiKTtcbiAgICAgIGF0dHIoZGl2LCBcImNsYXNzXCIsIFwic3ZlbHRlLXpydnNjd1wiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIGRpdiwgYW5jaG9yKTtcbiAgICB9LFxuICAgIHA6IG5vb3AsXG4gICAgaTogbm9vcCxcbiAgICBvOiBub29wLFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goZGl2KTtcbiAgICB9XG4gIH07XG59IC8vICgyNzY6NikgeyNpZiBlcnJvck1zZ31cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfMiQyKGN0eCkge1xuICB2YXIgYnV0dG9uO1xuICB2YXIgY3VycmVudDtcbiAgYnV0dG9uID0gbmV3IEJ1dHRvbih7XG4gICAgcHJvcHM6IHtcbiAgICAgIHBvc2l0aW9uOiAhXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIGN0eFswXS5idXR0b24gPyBcInJpZ2h0XCIgOiBcIlwiLFxuICAgICAgb25jbGljazpcbiAgICAgIC8qZG9BY3Rpb24qL1xuICAgICAgY3R4WzVdLFxuICAgICAgJCRzbG90czoge1xuICAgICAgICBcImRlZmF1bHRcIjogW2NyZWF0ZV9kZWZhdWx0X3Nsb3RfMl1cbiAgICAgIH0sXG4gICAgICAkJHNjb3BlOiB7XG4gICAgICAgIGN0eDogY3R4XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChidXR0b24uJCQuZnJhZ21lbnQpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgbW91bnRfY29tcG9uZW50KGJ1dHRvbiwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIHZhciBidXR0b25fY2hhbmdlcyA9IHt9O1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgMSkgYnV0dG9uX2NoYW5nZXMucG9zaXRpb24gPSAhXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIGN0eFswXS5idXR0b24gPyBcInJpZ2h0XCIgOiBcIlwiO1xuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokJHNjb3BlKi9cbiAgICAgIDMzNTU0NDMyKSB7XG4gICAgICAgIGJ1dHRvbl9jaGFuZ2VzLiQkc2NvcGUgPSB7XG4gICAgICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGJ1dHRvbi4kc2V0KGJ1dHRvbl9jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGJ1dHRvbi4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChidXR0b24uJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChidXR0b24sIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoMjc3OjgpIDxCdXR0b24gICAgICAgICAgIHBvc2l0aW9uPXshYWN0aXZlTW9kYWwuYnV0dG9uID8gJ3JpZ2h0JyA6ICcnfSAgICAgICAgICAgb25jbGljaz17ZG9BY3Rpb259ICAgICAgICAgPlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9kZWZhdWx0X3Nsb3RfMihjdHgpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHQgPSB0ZXh0KFwiVHJ5IEFnYWluXCIpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdCwgYW5jaG9yKTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godCk7XG4gICAgfVxuICB9O1xufSAvLyAoMjg2OjYpIHsjaWYgbG9hZGluZ31cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfMSQ0KGN0eCkge1xuICB2YXIgc3Bpbm5lcjtcbiAgdmFyIGN1cnJlbnQ7XG4gIHNwaW5uZXIgPSBuZXcgU3Bpbm5lcih7fSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQoc3Bpbm5lci4kJC5mcmFnbWVudCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQoc3Bpbm5lciwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBpOiBmdW5jdGlvbiBpKGxvY2FsKSB7XG4gICAgICBpZiAoY3VycmVudCkgcmV0dXJuO1xuICAgICAgdHJhbnNpdGlvbl9pbihzcGlubmVyLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KHNwaW5uZXIuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChzcGlubmVyLCBkZXRhY2hpbmcpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDI4OTo2KSA8QnV0dG9uIHBvc2l0aW9uPVwibGVmdFwiIG9uY2xpY2s9eygpID0+IGhhbmRsZUV4aXQoZmFsc2UpfSBjdGE9e2ZhbHNlfSAgICAgICAgID5cblxuXG5mdW5jdGlvbiBjcmVhdGVfZGVmYXVsdF9zbG90XzEkMihjdHgpIHtcbiAgdmFyIHQ7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIHQgPSB0ZXh0KFwiRGlzbWlzc1wiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQsIGFuY2hvcik7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQpO1xuICAgIH1cbiAgfTtcbn0gLy8gKDI0OToyKSA8TW9kYWwgY2xvc2VNb2RhbD17KCkgPT4gaGFuZGxlRXhpdCgpfT5cblxuXG5mdW5jdGlvbiBjcmVhdGVfZGVmYXVsdF9zbG90JDMoY3R4KSB7XG4gIHZhciBtb2RhbGhlYWRlcjtcbiAgdmFyIHQwO1xuXG4gIHZhciBfcDM7XG5cbiAgdmFyIHJhd192YWx1ZSA9XG4gIC8qYWN0aXZlTW9kYWwqL1xuICBjdHhbMF0uZGVzY3JpcHRpb24gKyBcIlwiO1xuICB2YXIgdDE7XG4gIHZhciB0MjtcbiAgdmFyIHQzO1xuICB2YXIgZGl2O1xuICB2YXIgdDQ7XG4gIHZhciBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXg7XG4gIHZhciBpZl9ibG9jazM7XG4gIHZhciB0NTtcbiAgdmFyIHQ2O1xuICB2YXIgYnV0dG9uO1xuICB2YXIgY3VycmVudDtcbiAgbW9kYWxoZWFkZXIgPSBuZXcgTW9kYWxIZWFkZXIoe1xuICAgIHByb3BzOiB7XG4gICAgICBpY29uOlxuICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICBjdHhbMF0uaWNvbiB8fCBcIlwiLFxuICAgICAgaGVhZGluZzpcbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgY3R4WzBdLmhlYWRpbmdcbiAgICB9XG4gIH0pO1xuICB2YXIgaWZfYmxvY2swID1cbiAgLyplcnJvck1zZyovXG4gIGN0eFsxXSAmJiBjcmVhdGVfaWZfYmxvY2tfNSQxKGN0eCk7XG4gIHZhciBpZl9ibG9jazEgPVxuICAvKmFjdGl2ZU1vZGFsKi9cbiAgY3R4WzBdLmh0bWwgJiYgY3JlYXRlX2lmX2Jsb2NrXzQkMShjdHgpO1xuICB2YXIgaWZfYmxvY2syID1cbiAgLyphY3RpdmVNb2RhbCovXG4gIGN0eFswXS5idXR0b24gJiYgY3JlYXRlX2lmX2Jsb2NrXzMkMShjdHgpO1xuICB2YXIgaWZfYmxvY2tfY3JlYXRvcnMgPSBbY3JlYXRlX2lmX2Jsb2NrXzIkMiwgY3JlYXRlX2Vsc2VfYmxvY2skNF07XG4gIHZhciBpZl9ibG9ja3MgPSBbXTtcblxuICBmdW5jdGlvbiBzZWxlY3RfYmxvY2tfdHlwZShjdHgsIGRpcnR5KSB7XG4gICAgaWYgKFxuICAgIC8qZXJyb3JNc2cqL1xuICAgIGN0eFsxXSkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXggPSBzZWxlY3RfYmxvY2tfdHlwZShjdHgpO1xuICBpZl9ibG9jazMgPSBpZl9ibG9ja3NbY3VycmVudF9ibG9ja190eXBlX2luZGV4XSA9IGlmX2Jsb2NrX2NyZWF0b3JzW2N1cnJlbnRfYmxvY2tfdHlwZV9pbmRleF0oY3R4KTtcbiAgdmFyIGlmX2Jsb2NrNCA9XG4gIC8qbG9hZGluZyovXG4gIGN0eFsyXSAmJiBjcmVhdGVfaWZfYmxvY2tfMSQ0KCk7XG4gIGJ1dHRvbiA9IG5ldyBCdXR0b24oe1xuICAgIHByb3BzOiB7XG4gICAgICBwb3NpdGlvbjogXCJsZWZ0XCIsXG4gICAgICBvbmNsaWNrOlxuICAgICAgLypmdW5jKi9cbiAgICAgIGN0eFsxMV0sXG4gICAgICBjdGE6IGZhbHNlLFxuICAgICAgJCRzbG90czoge1xuICAgICAgICBcImRlZmF1bHRcIjogW2NyZWF0ZV9kZWZhdWx0X3Nsb3RfMSQyXVxuICAgICAgfSxcbiAgICAgICQkc2NvcGU6IHtcbiAgICAgICAgY3R4OiBjdHhcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KG1vZGFsaGVhZGVyLiQkLmZyYWdtZW50KTtcbiAgICAgIHQwID0gc3BhY2UoKTtcbiAgICAgIF9wMyA9IGVsZW1lbnQoXCJwXCIpO1xuICAgICAgdDEgPSBzcGFjZSgpO1xuICAgICAgaWYgKGlmX2Jsb2NrMCkgaWZfYmxvY2swLmMoKTtcbiAgICAgIHQyID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5jKCk7XG4gICAgICB0MyA9IHNwYWNlKCk7XG4gICAgICBkaXYgPSBlbGVtZW50KFwiZGl2XCIpO1xuICAgICAgaWYgKGlmX2Jsb2NrMikgaWZfYmxvY2syLmMoKTtcbiAgICAgIHQ0ID0gc3BhY2UoKTtcbiAgICAgIGlmX2Jsb2NrMy5jKCk7XG4gICAgICB0NSA9IHNwYWNlKCk7XG4gICAgICBpZiAoaWZfYmxvY2s0KSBpZl9ibG9jazQuYygpO1xuICAgICAgdDYgPSBzcGFjZSgpO1xuICAgICAgY3JlYXRlX2NvbXBvbmVudChidXR0b24uJCQuZnJhZ21lbnQpO1xuICAgICAgYXR0cihfcDMsIFwiY2xhc3NcIiwgXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLXByZXBhcmUtZGVzY3JpcHRpb24gc3ZlbHRlLXpydnNjd1wiKTtcbiAgICAgIGF0dHIoZGl2LCBcImNsYXNzXCIsIFwiYm4tb25ib2FyZC1jdXN0b20gYm4tb25ib2FyZC1wcmVwYXJlLWJ1dHRvbi1jb250YWluZXIgc3ZlbHRlLXpydnNjd1wiKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIG1vdW50X2NvbXBvbmVudChtb2RhbGhlYWRlciwgdGFyZ2V0LCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdDAsIGFuY2hvcik7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBfcDMsIGFuY2hvcik7XG4gICAgICBfcDMuaW5uZXJIVE1MID0gcmF3X3ZhbHVlO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgdDEsIGFuY2hvcik7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0MiwgYW5jaG9yKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQzLCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgZGl2LCBhbmNob3IpO1xuICAgICAgaWYgKGlmX2Jsb2NrMikgaWZfYmxvY2syLm0oZGl2LCBudWxsKTtcbiAgICAgIGFwcGVuZChkaXYsIHQ0KTtcbiAgICAgIGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdLm0oZGl2LCBudWxsKTtcbiAgICAgIGFwcGVuZChkaXYsIHQ1KTtcbiAgICAgIGlmIChpZl9ibG9jazQpIGlmX2Jsb2NrNC5tKGRpdiwgbnVsbCk7XG4gICAgICBhcHBlbmQoZGl2LCB0Nik7XG4gICAgICBtb3VudF9jb21wb25lbnQoYnV0dG9uLCBkaXYsIG51bGwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgZGlydHkpIHtcbiAgICAgIHZhciBtb2RhbGhlYWRlcl9jaGFuZ2VzID0ge307XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICAxKSBtb2RhbGhlYWRlcl9jaGFuZ2VzLmljb24gPVxuICAgICAgLyphY3RpdmVNb2RhbCovXG4gICAgICBjdHhbMF0uaWNvbiB8fCBcIlwiO1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgMSkgbW9kYWxoZWFkZXJfY2hhbmdlcy5oZWFkaW5nID1cbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgY3R4WzBdLmhlYWRpbmc7XG4gICAgICBtb2RhbGhlYWRlci4kc2V0KG1vZGFsaGVhZGVyX2NoYW5nZXMpO1xuICAgICAgaWYgKCghY3VycmVudCB8fCBkaXJ0eSAmXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIDEpICYmIHJhd192YWx1ZSAhPT0gKHJhd192YWx1ZSA9XG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIGN0eFswXS5kZXNjcmlwdGlvbiArIFwiXCIpKSBfcDMuaW5uZXJIVE1MID0gcmF3X3ZhbHVlO1xuXG4gICAgICBpZiAoXG4gICAgICAvKmVycm9yTXNnKi9cbiAgICAgIGN0eFsxXSkge1xuICAgICAgICBpZiAoaWZfYmxvY2swKSB7XG4gICAgICAgICAgaWZfYmxvY2swLnAoY3R4LCBkaXJ0eSk7XG5cbiAgICAgICAgICBpZiAoZGlydHkgJlxuICAgICAgICAgIC8qZXJyb3JNc2cqL1xuICAgICAgICAgIDIpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWZfYmxvY2swID0gY3JlYXRlX2lmX2Jsb2NrXzUkMShjdHgpO1xuICAgICAgICAgIGlmX2Jsb2NrMC5jKCk7XG4gICAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazAsIDEpO1xuICAgICAgICAgIGlmX2Jsb2NrMC5tKHQyLnBhcmVudE5vZGUsIHQyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jazApIHtcbiAgICAgICAgaWZfYmxvY2swLmQoMSk7XG4gICAgICAgIGlmX2Jsb2NrMCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgY3R4WzBdLmh0bWwpIHtcbiAgICAgICAgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICAgIGlmX2Jsb2NrMS5wKGN0eCwgZGlydHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMSA9IGNyZWF0ZV9pZl9ibG9ja180JDEoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazEuYygpO1xuICAgICAgICAgIGlmX2Jsb2NrMS5tKHQzLnBhcmVudE5vZGUsIHQzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jazEpIHtcbiAgICAgICAgaWZfYmxvY2sxLmQoMSk7XG4gICAgICAgIGlmX2Jsb2NrMSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChcbiAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgY3R4WzBdLmJ1dHRvbikge1xuICAgICAgICBpZiAoaWZfYmxvY2syKSB7XG4gICAgICAgICAgaWZfYmxvY2syLnAoY3R4LCBkaXJ0eSk7XG5cbiAgICAgICAgICBpZiAoZGlydHkgJlxuICAgICAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgICAgIDEpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2syLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWZfYmxvY2syID0gY3JlYXRlX2lmX2Jsb2NrXzMkMShjdHgpO1xuICAgICAgICAgIGlmX2Jsb2NrMi5jKCk7XG4gICAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazIsIDEpO1xuICAgICAgICAgIGlmX2Jsb2NrMi5tKGRpdiwgdDQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMikge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2syLCAxLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWZfYmxvY2syID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldmlvdXNfYmxvY2tfaW5kZXggPSBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXg7XG4gICAgICBjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXggPSBzZWxlY3RfYmxvY2tfdHlwZShjdHgpO1xuXG4gICAgICBpZiAoY3VycmVudF9ibG9ja190eXBlX2luZGV4ID09PSBwcmV2aW91c19ibG9ja19pbmRleCkge1xuICAgICAgICBpZl9ibG9ja3NbY3VycmVudF9ibG9ja190eXBlX2luZGV4XS5wKGN0eCwgZGlydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2Nrc1twcmV2aW91c19ibG9ja19pbmRleF0sIDEsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZl9ibG9ja3NbcHJldmlvdXNfYmxvY2tfaW5kZXhdID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgICBpZl9ibG9jazMgPSBpZl9ibG9ja3NbY3VycmVudF9ibG9ja190eXBlX2luZGV4XTtcblxuICAgICAgICBpZiAoIWlmX2Jsb2NrMykge1xuICAgICAgICAgIGlmX2Jsb2NrMyA9IGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdID0gaWZfYmxvY2tfY3JlYXRvcnNbY3VycmVudF9ibG9ja190eXBlX2luZGV4XShjdHgpO1xuICAgICAgICAgIGlmX2Jsb2NrMy5jKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWZfYmxvY2szLnAoY3R4LCBkaXJ0eSk7XG4gICAgICAgIH1cblxuICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMywgMSk7XG4gICAgICAgIGlmX2Jsb2NrMy5tKGRpdiwgdDUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAvKmxvYWRpbmcqL1xuICAgICAgY3R4WzJdKSB7XG4gICAgICAgIGlmIChpZl9ibG9jazQpIHtcbiAgICAgICAgICBpZiAoZGlydHkgJlxuICAgICAgICAgIC8qbG9hZGluZyovXG4gICAgICAgICAgNCkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazQsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jazQgPSBjcmVhdGVfaWZfYmxvY2tfMSQ0KCk7XG4gICAgICAgICAgaWZfYmxvY2s0LmMoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrNCwgMSk7XG4gICAgICAgICAgaWZfYmxvY2s0Lm0oZGl2LCB0Nik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaWZfYmxvY2s0KSB7XG4gICAgICAgIGdyb3VwX291dHJvcygpO1xuICAgICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazQsIDEsIDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZl9ibG9jazQgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICAgICAgY2hlY2tfb3V0cm9zKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBidXR0b25fY2hhbmdlcyA9IHt9O1xuXG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyokJHNjb3BlKi9cbiAgICAgIDMzNTU0NDMyKSB7XG4gICAgICAgIGJ1dHRvbl9jaGFuZ2VzLiQkc2NvcGUgPSB7XG4gICAgICAgICAgZGlydHk6IGRpcnR5LFxuICAgICAgICAgIGN0eDogY3R4XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGJ1dHRvbi4kc2V0KGJ1dHRvbl9jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKG1vZGFsaGVhZGVyLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCk7XG4gICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMik7XG4gICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMyk7XG4gICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrNCk7XG4gICAgICB0cmFuc2l0aW9uX2luKGJ1dHRvbi4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dChtb2RhbGhlYWRlci4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2syKTtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMyk7XG4gICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazQpO1xuICAgICAgdHJhbnNpdGlvbl9vdXQoYnV0dG9uLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQobW9kYWxoZWFkZXIsIGRldGFjaGluZyk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godDApO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKF9wMyk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godDEpO1xuICAgICAgaWYgKGlmX2Jsb2NrMCkgaWZfYmxvY2swLmQoZGV0YWNoaW5nKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0Mik7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEuZChkZXRhY2hpbmcpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQzKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChkaXYpO1xuICAgICAgaWYgKGlmX2Jsb2NrMikgaWZfYmxvY2syLmQoKTtcbiAgICAgIGlmX2Jsb2Nrc1tjdXJyZW50X2Jsb2NrX3R5cGVfaW5kZXhdLmQoKTtcbiAgICAgIGlmIChpZl9ibG9jazQpIGlmX2Jsb2NrNC5kKCk7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudChidXR0b24pO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlX2ZyYWdtZW50JGEoY3R4KSB7XG4gIHZhciB0O1xuICB2YXIgaWZfYmxvY2sxX2FuY2hvcjtcbiAgdmFyIGN1cnJlbnQ7XG4gIHZhciBpZl9ibG9jazAgPVxuICAvKmxvYWRpbmdNb2RhbCovXG4gIGN0eFszXSAmJiBjcmVhdGVfaWZfYmxvY2tfNiQxKGN0eCk7XG4gIHZhciBpZl9ibG9jazEgPVxuICAvKmFjdGl2ZU1vZGFsKi9cbiAgY3R4WzBdICYmIGNyZWF0ZV9pZl9ibG9jayQ4KGN0eCk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5jKCk7XG4gICAgICB0ID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5jKCk7XG4gICAgICBpZl9ibG9jazFfYW5jaG9yID0gZW1wdHkoKTtcbiAgICB9LFxuICAgIG06IGZ1bmN0aW9uIG0odGFyZ2V0LCBhbmNob3IpIHtcbiAgICAgIGlmIChpZl9ibG9jazApIGlmX2Jsb2NrMC5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQsIGFuY2hvcik7XG4gICAgICBpZiAoaWZfYmxvY2sxKSBpZl9ibG9jazEubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgICBpbnNlcnQodGFyZ2V0LCBpZl9ibG9jazFfYW5jaG9yLCBhbmNob3IpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBwOiBmdW5jdGlvbiBwKGN0eCwgX3JlZjI5KSB7XG4gICAgICB2YXIgX3JlZjMwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjI5LCAxKSxcbiAgICAgICAgICBkaXJ0eSA9IF9yZWYzMFswXTtcblxuICAgICAgaWYgKFxuICAgICAgLypsb2FkaW5nTW9kYWwqL1xuICAgICAgY3R4WzNdKSB7XG4gICAgICAgIGlmIChpZl9ibG9jazApIHtcbiAgICAgICAgICBpZiAoZGlydHkgJlxuICAgICAgICAgIC8qbG9hZGluZ01vZGFsKi9cbiAgICAgICAgICA4KSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMCA9IGNyZWF0ZV9pZl9ibG9ja182JDEoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazAuYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swLCAxKTtcbiAgICAgICAgICBpZl9ibG9jazAubSh0LnBhcmVudE5vZGUsIHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMCkge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2swLCAxLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWZfYmxvY2swID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAvKmFjdGl2ZU1vZGFsKi9cbiAgICAgIGN0eFswXSkge1xuICAgICAgICBpZiAoaWZfYmxvY2sxKSB7XG4gICAgICAgICAgaWZfYmxvY2sxLnAoY3R4LCBkaXJ0eSk7XG5cbiAgICAgICAgICBpZiAoZGlydHkgJlxuICAgICAgICAgIC8qYWN0aXZlTW9kYWwqL1xuICAgICAgICAgIDEpIHtcbiAgICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2sxLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWZfYmxvY2sxID0gY3JlYXRlX2lmX2Jsb2NrJDgoY3R4KTtcbiAgICAgICAgICBpZl9ibG9jazEuYygpO1xuICAgICAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2sxLCAxKTtcbiAgICAgICAgICBpZl9ibG9jazEubShpZl9ibG9jazFfYW5jaG9yLnBhcmVudE5vZGUsIGlmX2Jsb2NrMV9hbmNob3IpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2sxLCAxLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWZfYmxvY2sxID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2swKTtcbiAgICAgIHRyYW5zaXRpb25faW4oaWZfYmxvY2sxKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2swKTtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMSk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgaWYgKGlmX2Jsb2NrMCkgaWZfYmxvY2swLmQoZGV0YWNoaW5nKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaCh0KTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5kKGRldGFjaGluZyk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2goaWZfYmxvY2sxX2FuY2hvcik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBsb2NrU2Nyb2xsJDEoKSB7XG4gIHdpbmRvdy5zY3JvbGxUbygwLCAwKTtcbn1cblxuZnVuY3Rpb24gaXNDaGVja01vZGFsKHZhbCkge1xuICByZXR1cm4gdmFsLmhlYWRpbmcgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaW5zdGFuY2UkYSgkJHNlbGYsICQkcHJvcHMsICQkaW52YWxpZGF0ZSkge1xuICB2YXIgJGFwcDtcbiAgY29tcG9uZW50X3N1YnNjcmliZSgkJHNlbGYsIGFwcCwgZnVuY3Rpb24gKCQkdmFsdWUpIHtcbiAgICByZXR1cm4gJCRpbnZhbGlkYXRlKDQsICRhcHAgPSAkJHZhbHVlKTtcbiAgfSk7XG4gIHZhciB3YWxsZXRDaGVjayA9ICQkcHJvcHMud2FsbGV0Q2hlY2s7XG4gIHZhciB3YWxsZXRTZWxlY3QgPSAkJHByb3BzLndhbGxldFNlbGVjdDtcbiAgdmFyIG1vZHVsZXMgPSAkJHByb3BzLm1vZHVsZXM7XG4gIHZhciBibG9ja25hdGl2ZSA9IGdldEJsb2NrbmF0aXZlKCk7XG4gIHZhciBjdXJyZW50U3RhdGU7XG4gIHZhciBhY3RpdmVNb2RhbCA9IHVuZGVmaW5lZDtcbiAgdmFyIGN1cnJlbnRNb2R1bGUgPSB1bmRlZmluZWQ7XG4gIHZhciBlcnJvck1zZztcbiAgdmFyIHBvbGxpbmdJbnRlcnZhbDtcbiAgdmFyIGNoZWNraW5nTW9kdWxlID0gZmFsc2U7XG4gIHZhciBhY3Rpb25SZXNvbHZlZCA9IHVuZGVmaW5lZDtcbiAgdmFyIGxvYWRpbmcgPSBmYWxzZTtcbiAgdmFyIGxvYWRpbmdNb2RhbCA9IGZhbHNlO1xuICB2YXIgdW5zdWJzY3JpYmUgPSB3YWxsZXRJbnRlcmZhY2Uuc3Vic2NyaWJlKGZ1bmN0aW9uIChjdXJyZW50SW50ZXJmYWNlKSB7XG4gICAgaWYgKGN1cnJlbnRJbnRlcmZhY2UgPT09IG51bGwpIHtcbiAgICAgIGhhbmRsZUV4aXQoKTtcbiAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9KTtcbiAgdmFyIG9yaWdpbmFsT3ZlcmZsb3dWYWx1ZTtcbiAgdmFyIHVuc3Vic2NyaWJlQ3VycmVudFN0YXRlID0gc3RhdGUuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGUgPSBzdG9yZTtcbiAgfSk7XG4gIG9uTW91bnQoZnVuY3Rpb24gKCkge1xuICAgIG9yaWdpbmFsT3ZlcmZsb3dWYWx1ZSA9IHdpbmRvdy5kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93O1xuICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gXCJoaWRkZW5cIjtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBsb2NrU2Nyb2xsJDEpO1xuICB9KTtcbiAgb25EZXN0cm95KGZ1bmN0aW9uICgpIHtcbiAgICB1bnN1YnNjcmliZUN1cnJlbnRTdGF0ZSgpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGxvY2tTY3JvbGwkMSk7XG4gICAgd2luZG93LmRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSBvcmlnaW5hbE92ZXJmbG93VmFsdWU7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHJlbmRlck1vZHVsZSgpIHtcbiAgICByZXR1cm4gX3JlbmRlck1vZHVsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX3JlbmRlck1vZHVsZSgpIHtcbiAgICBfcmVuZGVyTW9kdWxlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOCgpIHtcbiAgICAgIHZhciBjaGVja01vZHVsZXMsIGN1cnJlbnRXYWxsZXQ7XG4gICAgICByZXR1cm4gcmVnZW5lcmF0b3JSdW50aW1lLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgkKF9jb250ZXh0OCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ4LnByZXYgPSBfY29udGV4dDgubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAkJGludmFsaWRhdGUoMTAsIGNoZWNraW5nTW9kdWxlID0gdHJ1ZSk7XG4gICAgICAgICAgICAgIGNoZWNrTW9kdWxlcyA9IG1vZHVsZXMgfHwgZ2V0X3N0b3JlX3ZhbHVlKGFwcCkuY2hlY2tNb2R1bGVzO1xuXG4gICAgICAgICAgICAgIGlmICghaXNQcm9taXNlKGNoZWNrTW9kdWxlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDU7XG4gICAgICAgICAgICAgIHJldHVybiBjaGVja01vZHVsZXM7XG5cbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgY2hlY2tNb2R1bGVzID0gX2NvbnRleHQ4LnNlbnQ7XG4gICAgICAgICAgICAgIGNoZWNrTW9kdWxlcy5mb3JFYWNoKHZhbGlkYXRlV2FsbGV0Q2hlY2tNb2R1bGUpO1xuICAgICAgICAgICAgICBhcHAudXBkYXRlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgICAgICAgICAgIGNoZWNrTW9kdWxlczogY2hlY2tNb2R1bGVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGN1cnJlbnRXYWxsZXQgPSBnZXRfc3RvcmVfdmFsdWUod2FsbGV0KS5uYW1lOyAvLyBsb29wIHRocm91Z2ggYW5kIHJ1biBlYWNoIG1vZHVsZSB0byBjaGVjayBpZiBhIG1vZGFsIG5lZWRzIHRvIGJlIHNob3duXG5cbiAgICAgICAgICAgICAgcnVuTW9kdWxlcyhjaGVja01vZHVsZXMpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIC8vIG5vIHJlc3VsdCB0aGVuIHVzZXIgaGFzIHBhc3NlZCBhbGwgY29uZGl0aW9uc1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0Lm1vZGFsKSB7XG4gICAgICAgICAgICAgICAgICBibG9ja25hdGl2ZSAmJiBibG9ja25hdGl2ZS5ldmVudCh7XG4gICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5Q29kZTogXCJvbmJvYXJkXCIsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q29kZTogXCJvbmJvYXJkaW5nQ29tcGxldGVkXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgaGFuZGxlRXhpdCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9IC8vIHNldCB0aGF0IFVJIGhhcyBiZWVuIGRpc3BsYXllZCwgc28gdGhhdCB0aW1lb3V0cyBjYW4gYmUgYWRkZWQgZm9yIFVJIHRyYW5zaXRpb25zXG5cblxuICAgICAgICAgICAgICAgIGFwcC51cGRhdGUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldENoZWNrRGlzcGxheWVkVUk6IHRydWVcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICQkaW52YWxpZGF0ZSgwLCBhY3RpdmVNb2RhbCA9IHJlc3VsdC5tb2RhbCk7XG4gICAgICAgICAgICAgICAgY3VycmVudE1vZHVsZSA9IHJlc3VsdC5tb2R1bGU7IC8vIGxvZyB0aGUgZXZlbnQgY29kZSBmb3IgdGhpcyBtb2R1bGVcblxuICAgICAgICAgICAgICAgIGJsb2NrbmF0aXZlICYmIGJsb2NrbmF0aXZlLmV2ZW50KHtcbiAgICAgICAgICAgICAgICAgIGV2ZW50Q29kZTogYWN0aXZlTW9kYWwuZXZlbnRDb2RlLFxuICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlDb2RlOiBcIm9uYm9hcmRcIlxuICAgICAgICAgICAgICAgIH0pOyAvLyBydW4gYW55IGFjdGlvbnMgdGhhdCBtb2R1bGUgcmVxdWlyZSBhcyBwYXJ0IG9mIHRoaXMgc3RlcFxuXG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZU1vZGFsLmFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgZG9BY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9IC8vIHBvbGwgdG8gYXV0b21hdGljYWxseSB0byBjaGVjayBpZiBjb25kaXRpb24gaGFzIGJlZW4gbWV0XG5cblxuICAgICAgICAgICAgICAgIHBvbGxpbmdJbnRlcnZhbCA9IHNldEludGVydmFsKCAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlNygpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVzdWx0MjtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3JChfY29udGV4dDcpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50TW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW52YWxpZFN0YXRlKGN1cnJlbnRNb2R1bGUsIGdldF9zdG9yZV92YWx1ZShzdGF0ZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXN1bHQyID0gX2NvbnRleHQ3LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfcmVzdWx0MiAmJiBhY3Rpb25SZXNvbHZlZCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNldFN0YXRlKCk7IC8vIGRlbGF5ZWQgZm9yIGFuaW1hdGlvbnNcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJCRpbnZhbGlkYXRlKDEwLCBjaGVja2luZ01vZHVsZSA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAyNTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICQkaW52YWxpZGF0ZSgwLCBhY3RpdmVNb2RhbCA9IF9yZXN1bHQyICYmIF9yZXN1bHQyLm1vZGFsID8gX3Jlc3VsdDIubW9kYWwgOiBhY3RpdmVNb2RhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU3KTtcbiAgICAgICAgICAgICAgICB9KSksIDEwMCk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWU4KTtcbiAgICB9KSk7XG4gICAgcmV0dXJuIF9yZW5kZXJNb2R1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRvQWN0aW9uKCkge1xuICAgIGFjdGlvblJlc29sdmVkID0gZmFsc2U7XG4gICAgJCRpbnZhbGlkYXRlKDIsIGxvYWRpbmcgPSB0cnVlKTtcbiAgICBhY3RpdmVNb2RhbCAmJiBhY3RpdmVNb2RhbC5hY3Rpb24gJiYgYWN0aXZlTW9kYWwuYWN0aW9uKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBhY3Rpb25SZXNvbHZlZCA9IHRydWU7XG4gICAgICAkJGludmFsaWRhdGUoMiwgbG9hZGluZyA9IGZhbHNlKTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICQkaW52YWxpZGF0ZSgxLCBlcnJvck1zZyA9IGVyci5tZXNzYWdlKTtcbiAgICAgICQkaW52YWxpZGF0ZSgyLCBsb2FkaW5nID0gZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlRXhpdCgpIHtcbiAgICB2YXIgY29tcGxldGVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgIHZhciBfcmVmMzEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBzd2l0Y2hpbmdXYWxsZXRzID0gX3JlZjMxLnN3aXRjaGluZ1dhbGxldHM7XG5cbiAgICByZXNldFN0YXRlKCk7XG4gICAgYXBwLnVwZGF0ZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgc3dpdGNoaW5nV2FsbGV0czogc3dpdGNoaW5nV2FsbGV0cyxcbiAgICAgICAgd2FsbGV0Q2hlY2tJblByb2dyZXNzOiBmYWxzZSxcbiAgICAgICAgd2FsbGV0Q2hlY2tDb21wbGV0ZWQ6IGNvbXBsZXRlZCxcbiAgICAgICAgYWNjb3VudFNlbGVjdEluUHJvZ3Jlc3M6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0U3RhdGUoKSB7XG4gICAgY2xlYXJJbnRlcnZhbChwb2xsaW5nSW50ZXJ2YWwpO1xuICAgICQkaW52YWxpZGF0ZSgxLCBlcnJvck1zZyA9IFwiXCIpO1xuICAgIGFjdGlvblJlc29sdmVkID0gdW5kZWZpbmVkO1xuICAgICQkaW52YWxpZGF0ZSgwLCBhY3RpdmVNb2RhbCA9IHVuZGVmaW5lZCk7XG4gICAgY3VycmVudE1vZHVsZSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJ1bk1vZHVsZXMobW9kdWxlcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVmMzIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2KHJlc29sdmUpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvciwgX3N0ZXAsIG1vZHVsZSwgcmVzdWx0O1xuXG4gICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobW9kdWxlcyk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAxO1xuXG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLnMoKTtcblxuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgaWYgKChfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb2R1bGUgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludmFsaWRTdGF0ZShtb2R1bGUsIGN1cnJlbnRTdGF0ZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0Ni5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCByZXNvbHZlKHJlc3VsdCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Lm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Ni5wcmV2ID0gMTQ7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2LnQwID0gX2NvbnRleHQ2W1wiY2F0Y2hcIl0oMSk7XG5cbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IuZShfY29udGV4dDYudDApO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2LnByZXYgPSAxNztcblxuICAgICAgICAgICAgICAgIF9pdGVyYXRvci5mKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmZpbmlzaCgxNyk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2LmFicnVwdChcInJldHVyblwiLCByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgIG1vZGFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBtb2R1bGU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNiwgbnVsbCwgW1sxLCAxNCwgMTcsIDIwXV0pO1xuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKF94Nikge1xuICAgICAgICByZXR1cm4gX3JlZjMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0oKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZhbGlkU3RhdGUoX3g3LCBfeDgpIHtcbiAgICByZXR1cm4gX2ludmFsaWRTdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZnVuY3Rpb24gX2ludmFsaWRTdGF0ZSgpIHtcbiAgICBfaW52YWxpZFN0YXRlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlOShtb2R1bGUsIHN0YXRlKSB7XG4gICAgICB2YXIgcmVzdWx0LCBtb2RhbDtcbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlOSQoX2NvbnRleHQ5KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dDkucHJldiA9IF9jb250ZXh0OS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG1vZHVsZShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0YXRlKSwge30sIHtcbiAgICAgICAgICAgICAgICBCaWdOdW1iZXI6IEJpZ051bWJlcixcbiAgICAgICAgICAgICAgICB3YWxsZXRTZWxlY3Q6IHdhbGxldFNlbGVjdCxcbiAgICAgICAgICAgICAgICB3YWxsZXRDaGVjazogd2FsbGV0Q2hlY2ssXG4gICAgICAgICAgICAgICAgZXhpdDogaGFuZGxlRXhpdCxcbiAgICAgICAgICAgICAgICB3YWxsZXQ6IGdldF9zdG9yZV92YWx1ZSh3YWxsZXQpLFxuICAgICAgICAgICAgICAgIHN0YXRlU3luY1N0YXR1czogc3RhdGVTeW5jU3RhdHVzLFxuICAgICAgICAgICAgICAgIHN0YXRlU3RvcmU6IHtcbiAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICBuZXR3b3JrOiBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgYmFsYW5jZTogYmFsYW5jZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNDaGVja01vZGFsKHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YWxpZGF0ZU1vZGFsKHJlc3VsdCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBtb2R1bGU6IG1vZHVsZSxcbiAgICAgICAgICAgICAgICBtb2RhbDogcmVzdWx0XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICQkaW52YWxpZGF0ZSgzLCBsb2FkaW5nTW9kYWwgPSBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgbW9kYWwgPSByZXM7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAkJGludmFsaWRhdGUoMywgbG9hZGluZ01vZGFsID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSwgNjUwKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgaWYgKCFtb2RhbCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OS5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YWxpZGF0ZU1vZGFsKG1vZGFsKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgIG1vZHVsZTogbW9kdWxlLFxuICAgICAgICAgICAgICAgIG1vZGFsOiBtb2RhbFxuICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlOSk7XG4gICAgfSkpO1xuICAgIHJldHVybiBfaW52YWxpZFN0YXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICB2YXIgZnVuYyA9IGZ1bmN0aW9uIGZ1bmMoKSB7XG4gICAgcmV0dXJuIGhhbmRsZUV4aXQoZmFsc2UpO1xuICB9O1xuXG4gIHZhciBmdW5jXzEgPSBmdW5jdGlvbiBmdW5jXzEoKSB7XG4gICAgcmV0dXJuIGhhbmRsZUV4aXQoKTtcbiAgfTtcblxuICAkJHNlbGYuJCRzZXQgPSBmdW5jdGlvbiAoJCRwcm9wcykge1xuICAgIGlmIChcIndhbGxldENoZWNrXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDcsIHdhbGxldENoZWNrID0gJCRwcm9wcy53YWxsZXRDaGVjayk7XG4gICAgaWYgKFwid2FsbGV0U2VsZWN0XCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDgsIHdhbGxldFNlbGVjdCA9ICQkcHJvcHMud2FsbGV0U2VsZWN0KTtcbiAgICBpZiAoXCJtb2R1bGVzXCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDksIG1vZHVsZXMgPSAkJHByb3BzLm1vZHVsZXMpO1xuICB9O1xuXG4gICQkc2VsZi4kJC51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCQkc2VsZi4kJC5kaXJ0eSAmXG4gICAgLyphY3RpdmVNb2RhbCwgY2hlY2tpbmdNb2R1bGUqL1xuICAgIDEwMjUpIHtcbiAgICAgIC8vIHJlY2hlY2sgbW9kdWxlcyBpZiBiZWxvdyBjb25kaXRpb25zXG4gICAgICBpZiAoIWFjdGl2ZU1vZGFsICYmICFjaGVja2luZ01vZHVsZSkge1xuICAgICAgICByZW5kZXJNb2R1bGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFthY3RpdmVNb2RhbCwgZXJyb3JNc2csIGxvYWRpbmcsIGxvYWRpbmdNb2RhbCwgJGFwcCwgZG9BY3Rpb24sIGhhbmRsZUV4aXQsIHdhbGxldENoZWNrLCB3YWxsZXRTZWxlY3QsIG1vZHVsZXMsIGNoZWNraW5nTW9kdWxlLCBmdW5jLCBmdW5jXzFdO1xufVxuXG52YXIgV2FsbGV0Q2hlY2tfMSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1N2ZWx0ZUNvbXBvbmVudDExKSB7XG4gIF9pbmhlcml0cyhXYWxsZXRDaGVja18xLCBfU3ZlbHRlQ29tcG9uZW50MTEpO1xuXG4gIHZhciBfc3VwZXIxMSA9IF9jcmVhdGVTdXBlcihXYWxsZXRDaGVja18xKTtcblxuICBmdW5jdGlvbiBXYWxsZXRDaGVja18xKG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMxMTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXYWxsZXRDaGVja18xKTtcblxuICAgIF90aGlzMTEgPSBfc3VwZXIxMS5jYWxsKHRoaXMpO1xuICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzdmVsdGUtenJ2c2N3LXN0eWxlXCIpKSBhZGRfY3NzJGEoKTtcbiAgICBpbml0KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMxMSksIG9wdGlvbnMsIGluc3RhbmNlJGEsIGNyZWF0ZV9mcmFnbWVudCRhLCBzYWZlX25vdF9lcXVhbCwge1xuICAgICAgd2FsbGV0Q2hlY2s6IDcsXG4gICAgICB3YWxsZXRTZWxlY3Q6IDgsXG4gICAgICBtb2R1bGVzOiA5XG4gICAgfSk7XG4gICAgcmV0dXJuIF90aGlzMTE7XG4gIH1cblxuICByZXR1cm4gV2FsbGV0Q2hlY2tfMTtcbn0oU3ZlbHRlQ29tcG9uZW50KTtcblxudmFyIHVzYkljb24gPSBcIlxcblxcdDxzdmcgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIiB4bWxuczp4bGluaz1cXFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1xcXCIgeD1cXFwiMHB4XFxcIiB5PVxcXCIwcHhcXFwiIHZpZXdCb3g9XFxcIjAgMCA1MTIgNTEyXFxcIiBzdHlsZT1cXFwiZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1MTIgNTEyO1xcXCIgeG1sOnNwYWNlPVxcXCJwcmVzZXJ2ZVxcXCIgd2lkdGg9XFxcIjE4cHhcXFwiIGhlaWdodD1cXFwiMThweFxcXCI+XFxuXFx0PGc+XFxuXFx0PGc+XFxuXFx0PHBhdGggZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiBkPVxcXCJNMzE0LjQ2OCwxNTcuMTk3djEwMy45NDJoMzEuNTUzdjIuMzEyYzAsOS44ODgtNC44MTUsMTkuMjA1LTEyLjg4MSwyNC45MjRsLTU2LjY1Miw0MC4xNzFWMTA5LjkzOWg0NC41NDZMMjU3LjYzNCwwXFxuXFx0XFx0bC02Ni41MjcsMTA5LjkzOWg0NS40MDRWMzU4LjI1bC01Ni42NTItNDAuMTcxYy04LjA2Ni01LjcxOS0xMi44ODEtMTUuMDM3LTEyLjg4MS0yNC45MjR2LTguNDg5XFxuXFx0XFx0YzIwLjE5LTcuODE1LDM0LjU1Mi0yNy40MjcsMzQuNTUyLTUwLjM0MmMwLTI5Ljc1OS0yNC4yMTEtNTMuOTctNTMuOTctNTMuOTdjLTI5Ljc2LDAtNTMuOTcsMjQuMjExLTUzLjk3LDUzLjk3XFxuXFx0XFx0YzAsMjIuNDgyLDEzLjgyMSw0MS43ODksMzMuNDEsNDkuODkxdjguOTRjMCwyMi44MjQsMTEuMTE2LDQ0LjMzMywyOS43MzUsNTcuNTM2bDY2Ljg5NSw0Ny40MzRcXG5cXHRcXHRjNC4yNTUsMy4wMTYsNy41OTMsNy4wNCw5LjgwOSwxMS42MTVjLTE3LjcxMyw4Ljg2Mi0yOS45MDksMjcuMTczLTI5LjkwOSw0OC4yOWMwLDI5Ljc2LDI0LjIxMSw1My45Nyw1My45Nyw1My45N1xcblxcdFxcdGMyOS43NTksMCw1My45Ny0yNC4yMTEsNTMuOTctNTMuOTdjMC0yMy4wNzgtMTQuNTY0LTQyLjgxLTM0Ljk4MS01MC41MTF2LTE0LjE3NGMwLTkuODg4LDQuODE1LTE5LjIwNSwxMi44ODEtMjQuOTI0XFxuXFx0XFx0bDY2Ljg5NS00Ny40MzRjMTguNjE5LTEzLjIwMiwyOS43MzUtMzQuNzExLDI5LjczNS01Ny41MzZ2LTIuMzEyaDMyLjQxMVYxNTcuMTk3SDMxNC40Njh6IE0xNDcuNTYsMjQ4LjMxNlxcblxcdFxcdGMtNy43MTYsMC0xMy45OTItNi4yNzctMTMuOTkyLTEzLjk5MmMwLTcuNzE2LDYuMjc2LTEzLjk5MiwxMy45OTItMTMuOTkyYzcuNzE2LDAsMTMuOTkyLDYuMjc2LDEzLjk5MiwxMy45OTJcXG5cXHRcXHRDMTYxLjU1MiwyNDIuMDQsMTU1LjI3NiwyNDguMzE2LDE0Ny41NiwyNDguMzE2eiBNMjU3LjQ5OSw0NzIuMDIyYy03LjcxNiwwLTEzLjk5Mi02LjI3Ni0xMy45OTItMTMuOTkyXFxuXFx0XFx0YzAtNy43MTYsNi4yNzctMTMuOTkyLDEzLjk5Mi0xMy45OTJjNy43MTYsMCwxMy45OTIsNi4yNzYsMTMuOTkyLDEzLjk5MkMyNzEuNDkxLDQ2NS43NDYsMjY1LjIxNSw0NzIuMDIyLDI1Ny40OTksNDcyLjAyMnpcXG5cXHRcXHRNMzc4LjQzMiwyMjEuMTYxaC0yMy45ODd2LTIzLjk4N2gyMy45ODdWMjIxLjE2MXpcXFwiLz5cXG5cXHQ8L2c+XFxuXFx0PC9nPlxcblxcdDxnPlxcblxcdDwvZz5cXG5cXHQ8Zz5cXG5cXHQ8L2c+XFxuXFx0PGc+XFxuXFx0PC9nPlxcblxcdDxnPlxcblxcdDwvZz5cXG5cXHQ8Zz5cXG5cXHQ8L2c+XFxuXFx0PGc+XFxuXFx0PC9nPlxcblxcdDxnPlxcblxcdDwvZz5cXG5cXHQ8Zz5cXG5cXHQ8L2c+XFxuXFx0PGc+XFxuXFx0PC9nPlxcblxcdDxnPlxcblxcdDwvZz5cXG5cXHQ8Zz5cXG5cXHQ8L2c+XFxuXFx0PGc+XFxuXFx0PC9nPlxcblxcdDxnPlxcblxcdDwvZz5cXG5cXHQ8Zz5cXG5cXHQ8L2c+XFxuXFx0PGc+XFxuXFx0PC9nPlxcblxcdDwvc3ZnPlxcdCAgXFxuXCI7XG52YXIgbmV0d29ya0ljb24gPSBcIlxcblxcdDxzdmcgaGVpZ2h0PVxcXCIxOFxcXCIgdmlld0JveD1cXFwiMCAwIDE4IDE4XFxcIiB3aWR0aD1cXFwiMThcXFwiIHhtbG5zPVxcXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1xcXCI+XFxuXFx0XFx0PHBhdGggZD1cXFwibTEzLjM3NSAyOGMtMS44NjA3NSAwLTMuMzc1LTEuNTE0MjUtMy4zNzUtMy4zNzVzMS41MTQyNS0zLjM3NSAzLjM3NS0zLjM3NSAzLjM3NSAxLjUxNDI1IDMuMzc1IDMuMzc1LTEuNTE0MjUgMy4zNzUtMy4zNzUgMy4zNzV6bTAtNC41Yy0uNjE5ODc1IDAtMS4xMjUuNTA0LTEuMTI1IDEuMTI1cy41MDUxMjUgMS4xMjUgMS4xMjUgMS4xMjUgMS4xMjUtLjUwNCAxLjEyNS0xLjEyNS0uNTA1MTI1LTEuMTI1LTEuMTI1LTEuMTI1em0wLTYuNzVjLTEuODYwNzUgMC0zLjM3NS0xLjUxNDI1LTMuMzc1LTMuMzc1czEuNTE0MjUtMy4zNzUgMy4zNzUtMy4zNzUgMy4zNzUgMS41MTQyNSAzLjM3NSAzLjM3NS0xLjUxNDI1IDMuMzc1LTMuMzc1IDMuMzc1em0wLTQuNWMtLjYxOTg3NSAwLTEuMTI1LjUwNTEyNS0xLjEyNSAxLjEyNXMuNTA1MTI1IDEuMTI1IDEuMTI1IDEuMTI1IDEuMTI1LS41MDUxMjUgMS4xMjUtMS4xMjUtLjUwNTEyNS0xLjEyNS0xLjEyNS0xLjEyNXptMTEuMjUgNC41Yy0xLjg2MDc1IDAtMy4zNzUtMS41MTQyNS0zLjM3NS0zLjM3NXMxLjUxNDI1LTMuMzc1IDMuMzc1LTMuMzc1IDMuMzc1IDEuNTE0MjUgMy4zNzUgMy4zNzUtMS41MTQyNSAzLjM3NS0zLjM3NSAzLjM3NXptMC00LjVjLS42MjEgMC0xLjEyNS41MDUxMjUtMS4xMjUgMS4xMjVzLjUwNCAxLjEyNSAxLjEyNSAxLjEyNSAxLjEyNS0uNTA1MTI1IDEuMTI1LTEuMTI1LS41MDQtMS4xMjUtMS4xMjUtMS4xMjV6bS0xMS4yNSAxMC4xMTcxMjVoLS4wMTQ2MjVjLS42MTUzNzUtLjAwNzg3NS0xLjExMDM3NS0uNTAxNzUtMS4xMTAzNzUtMS4xMTcxMjUgMC0xLjM1Njc1Ljg5ODg3NS0zLjM3NSAzLjM3NS0zLjM3NWg2Ljc1Yy41MDYyNS0uMDEzNSAxLjEyNS0uMjE5Mzc1IDEuMTI1LTEuMTI1di0xLjEyNWMwLS42MjEuNTAyODc1LTEuMTI1IDEuMTI1LTEuMTI1czEuMTI1LjUwNCAxLjEyNSAxLjEyNXYxLjEyNWMwIDIuNDc2MTI1LTIuMDE4MjUgMy4zNzUtMy4zNzUgMy4zNzVoLTYuNzVjLS45MDU2MjUgMC0xLjExMTUuNjE4NzUtMS4xMjUgMS4xMzg1LS4wMTU3NS42MTA4NzUtLjUxNTI1IDEuMTAzNjI1LTEuMTI1IDEuMTAzNjI1em0wIDEuMTMyODc1Yy0uNjIxIDAtMS4xMjUtLjUwMjg3NS0xLjEyNS0xLjEyNXYtNi43NWMwLS42MjEuNTA0LTEuMTI1IDEuMTI1LTEuMTI1czEuMTI1LjUwNCAxLjEyNSAxLjEyNXY2Ljc1YzAgLjYyMjEyNS0uNTA0IDEuMTI1LTEuMTI1IDEuMTI1elxcXCIgZmlsbD1cXFwiY3VycmVudENvbG9yXFxcIiB0cmFuc2Zvcm09XFxcInRyYW5zbGF0ZSgtMTAgLTEwKVxcXCIvPlxcblxcdDwvc3ZnPlxcblwiO1xudmFyIGNvbm5lY3RJY29uID0gXCJcXG5cXHQ8c3ZnIGhlaWdodD1cXFwiMTRcXFwiIHZpZXdCb3g9XFxcIjAgMCAxOCAxNFxcXCIgd2lkdGg9XFxcIjE4XFxcIiB4bWxucz1cXFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcXFwiPlxcblxcdFxcdDxnIGZpbGw9XFxcImN1cnJlbnRDb2xvclxcXCI+XFxuXFx0XFx0XFx0PHBhdGggZD1cXFwibTEwLjI5Mzc1IDQuMDUzNTE1NjNjMC0uMDQ5MjE4NzUgMC0uMDkxNDA2MjUgMC0uMTMwMDc4MTMgMC0xLjA1NDY4NzUgMC0yLjEwOTM3NSAwLTMuMTY0MDYyNSAwLS40Mzk0NTMxMi4zNDgwNDY5LS43Njk5MjE4OC43ODA0Njg4LS43NDUzMTI1LjIwMDM5MDYuMDEwNTQ2ODguMzU4NTkzNy4xMDU0Njg3NS40OTkyMTg3LjI0NjA5Mzc1LjU4MDA3ODEuNTgzNTkzNzUgMS4xNTY2NDA2IDEuMTYzNjcxODggMS43MzY3MTg3IDEuNzQwMjM0MzggMS40Njk1MzEzIDEuNDY5NTMxMjUgMi45MzkwNjI1IDIuOTM5MDYyNDkgNC40MDUwNzgyIDQuNDA4NTkzNzUuMTMzNTkzNy4xMzM1OTM3NS4yNDI1NzgxLjI3NDIxODc1LjI3MDcwMzEuNDY3NTc4MTIuMDM1MTU2Mi4yMDc0MjE4OC0uMDI0NjA5NC40MjE4NzUtLjE2NTIzNDQuNTgwMDc4MTMtLjAyNDYwOTQuMDI4MTI1LS4wNDkyMTg3LjA1MjczNDM3LS4wNzM4MjgxLjA4MDg1OTM3LTIuMDYwMTU2MyAyLjA2MzY3MTg4LTQuMTIwMzEyNSA0LjEyMzgyODEtNi4xODA0Njg4IDYuMTg3NS0uMjEwOTM3NS4yMTA5Mzc1LS40NTcwMzEyLjMwMjM0MzgtLjc0NTMxMjUuMjE3OTY4OC0uMjcwNzAzMS0uMDgwODU5NC0uNDQ2NDg0My0uMjcwNzAzMi0uNTEzMjgxMi0uNTQ4NDM3NS0uMDE0MDYyNS0uMDczODI4Mi0uMDE3NTc4MS0uMTQ0MTQwNy0uMDE0MDYyNS0uMjE3OTY4OCAwLTEuMDMzNTkzNyAwLTIuMDcwNzAzMSAwLTMuMTA0Mjk2OSAwLS4wMzg2NzE5IDAtLjA4MDg1OTM1IDAtLjEzMzU5MzcyaC01LjA2OTUzMTI1Yy0uNDk1NzAzMTMgMC0uODA1MDc4MTMtLjMwOTM3NS0uODA1MDc4MTMtLjgwODU5Mzc1IDAtMS40MjM4MjgxMyAwLTIuODQ0MTQwNjMgMC00LjI2Nzk2ODc1IDAtLjQ5NTcwMzEzLjMwNTg1OTM4LS44MDE1NjI1LjgwMTU2MjUtLjgwMTU2MjVoNC45MzU5Mzc0OHpcXFwiLz5cXG5cXHRcXHRcXHQ8cGF0aCBkPVxcXCJtNS42OTg4MjgxMiAxMy45NzgxMjVoLTQuMDExMzI4MTJjLS45MjgxMjUgMC0xLjY4NzUtLjg3NTM5MDYtMS42ODc1LTEuOTUxMTcxOXYtMTAuMDYxNzE4NzJjMC0xLjA3NTc4MTI1Ljc1NTg1OTM4LTEuOTUxMTcxODggMS42ODc1LTEuOTUxMTcxODhoNC4wMTEzMjgxMmMuMzQxMDE1NjMgMCAuNjE1MjM0MzguMzE5OTIxODguNjE1MjM0MzguNzEwMTU2MjUgMCAuMzkwMjM0MzgtLjI3NDIxODc1LjcxMDE1NjI1LS42MTUyMzQzOC43MTAxNTYyNWgtNC4wMTEzMjgxMmMtLjI1MzEyNSAwLS40NTcwMzEyNS4yMzU1NDY4OC0uNDU3MDMxMjUuNTI3MzQzNzV2MTAuMDYxNzE4NzVjMCAuMjkxNzk2OS4yMDM5MDYyNS41MjczNDM3LjQ1NzAzMTI1LjUyNzM0MzdoNC4wMTEzMjgxMmMuMzQxMDE1NjMgMCAuNjE1MjM0MzguMzE5OTIxOS42MTUyMzQzOC43MTAxNTYzcy0uMjc3NzM0MzguNzE3MTg3NS0uNjE1MjM0MzguNzE3MTg3NXpcXFwiLz5cXG5cXHRcXHQ8L2c+XFxuXFx0PC9zdmc+XFxuXCI7XG52YXIgYmFsYW5jZUljb24gPSBcIlxcblxcdDxzdmcgaGVpZ2h0PVxcXCIxOFxcXCIgdmlld0JveD1cXFwiMCAwIDQyOSA2OTVcXFwiIHdpZHRoPVxcXCIxOFxcXCIgeG1sbnM9XFxcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXFxcIj5cXG5cXHRcXHQ8ZyBmaWxsPVxcXCJjdXJyZW50Q29sb3JcXFwiIGZpbGwtcnVsZT1cXFwiZXZlbm9kZFxcXCI+XFxuXFx0XFx0XFx0PHBhdGggZD1cXFwibTAgMzk0IDIxMyAxMjYuMjI4NTE2IDIxNC0xMjYuMjI4NTE2LTIxNCAzMDF6XFxcIi8+XFxuXFx0XFx0XFx0PHBhdGggZD1cXFwibTAgMzUzLjk2MjI2NCAyMTMuNS0zNTMuOTYyMjY0IDIxMy41IDM1My45NjIyNjQtMjEzLjUgMTI2LjAzNzczNnpcXFwiLz5cXG5cXHRcXHQ8L2c+XFxuXFx0PC9zdmc+XFxuXCI7XG52YXIgbXNnU3R5bGVzID0gXCJcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbiAgZm9udC1zaXplOiAwLjg4OWVtO1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICBjb2xvcjogaW5oZXJpdDtcXG4gIG1hcmdpbi10b3A6IDAuNXJlbTtcXG5cIjtcblxuZnVuY3Rpb24gYWNjb3VudFNlbGVjdCgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICB2YXIgaGVhZGluZyA9IG9wdGlvbnMuaGVhZGluZyxcbiAgICAgIGRlc2NyaXB0aW9uID0gb3B0aW9ucy5kZXNjcmlwdGlvbixcbiAgICAgIGljb24gPSBvcHRpb25zLmljb247XG4gIHZhciBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgdmFyIGxvYWRpbmdBY2NvdW50cyA9IGZhbHNlO1xuICB2YXIgYWNjb3VudHNBbmRCYWxhbmNlcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGNoZWNrTW9kdWxlKF94OSkge1xuICAgIHJldHVybiBfY2hlY2tNb2R1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF9jaGVja01vZHVsZSgpIHtcbiAgICBfY2hlY2tNb2R1bGUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMShzdGF0ZUFuZEhlbHBlcnMpIHtcbiAgICAgIHZhciB3YWxsZXQsIEJpZ051bWJlciwgcHJvdmlkZXIsIHR5cGUsIF9hY2NvdW50cywgZGVsZXRlV2luZG93UHJvcGVydGllcywgbG9hZE1vcmVBY2NvdW50cywgX2FjY291bnRTZWxlY3Q7XG5cbiAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0MTEucHJldiA9IF9jb250ZXh0MTEubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICB3YWxsZXQgPSBzdGF0ZUFuZEhlbHBlcnMud2FsbGV0LCBCaWdOdW1iZXIgPSBzdGF0ZUFuZEhlbHBlcnMuQmlnTnVtYmVyO1xuICAgICAgICAgICAgICBwcm92aWRlciA9IHdhbGxldC5wcm92aWRlciwgdHlwZSA9IHdhbGxldC50eXBlO1xuXG4gICAgICAgICAgICAgIGlmICghKHR5cGUgPT09ICdoYXJkd2FyZScgJiYgIWNvbXBsZXRlZCAmJiAhcHJvdmlkZXIuaXNDdXN0b21QYXRoKCkpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMS5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIShhY2NvdW50c0FuZEJhbGFuY2VzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDExLm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGxvYWRpbmdBY2NvdW50cyA9IHRydWU7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5lbmFibGUoKTtcblxuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfYWNjb3VudHMgPSBfY29udGV4dDExLnNlbnQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDEwO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0QmFsYW5jZXMoX2FjY291bnRzKTtcblxuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgYWNjb3VudHNBbmRCYWxhbmNlcyA9IF9jb250ZXh0MTEuc2VudDtcbiAgICAgICAgICAgICAgbG9hZGluZ0FjY291bnRzID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIGRlbGV0ZVdpbmRvd1Byb3BlcnRpZXMgPSBmdW5jdGlvbiBkZWxldGVXaW5kb3dQcm9wZXJ0aWVzKCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cuYWNjb3VudFNlbGVjdDtcbiAgICAgICAgICAgICAgICBkZWxldGUgd2luZG93LmxvYWRNb3JlQWNjb3VudHM7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgbG9hZE1vcmVBY2NvdW50cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9yZWYzNCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovcmVnZW5lcmF0b3JSdW50aW1lLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMCQoX2NvbnRleHQxMCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQxMC5wcmV2ID0gX2NvbnRleHQxMC5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRpbmdBY2NvdW50cyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTAubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRNb3JlQWNjb3VudHMoKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50c0FuZEJhbGFuY2VzID0gX2NvbnRleHQxMC5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkaW5nQWNjb3VudHMgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMTApO1xuICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBsb2FkTW9yZUFjY291bnRzKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYzNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0oKTtcblxuICAgICAgICAgICAgICBfYWNjb3VudFNlbGVjdCA9IGZ1bmN0aW9uIF9hY2NvdW50U2VsZWN0KCkge1xuICAgICAgICAgICAgICAgIHZhciBhY2NvdW50SW5kZXggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYWNjb3VudC1zZWxlY3QnKS5zZWxlY3RlZEluZGV4O1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyLnNldFByaW1hcnlBY2NvdW50KGFjY291bnRzQW5kQmFsYW5jZXNbYWNjb3VudEluZGV4XS5hZGRyZXNzKTtcbiAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICB3aW5kb3cuYWNjb3VudFNlbGVjdCA9IF9hY2NvdW50U2VsZWN0O1xuICAgICAgICAgICAgICB3aW5kb3cubG9hZE1vcmVBY2NvdW50cyA9IGxvYWRNb3JlQWNjb3VudHM7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgaGVhZGluZzogaGVhZGluZyB8fCAnU2VsZWN0IEFjY291bnQnLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB8fCBcIlBsZWFzZSBzZWxlY3Qgd2hpY2ggYWNjb3VudCB5b3Ugd291bGQgbGlrZSB0byB1c2Ugd2l0aCB0aGlzIERhcHA6XCIsXG4gICAgICAgICAgICAgICAgZXZlbnRDb2RlOiAnYWNjb3VudFNlbGVjdCcsXG4gICAgICAgICAgICAgICAgaHRtbDogbG9hZGluZ0FjY291bnRzID8gXCI8ZGl2IGNsYXNzPVxcXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLWxvYWRpbmdcXFwiPlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm4tb25ib2FyZC1sb2FkaW5nLWZpcnN0XFxcIj48L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJuLW9uYm9hcmQtbG9hZGluZy1zZWNvbmRcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiYm4tb25ib2FyZC1sb2FkaW5nLXRoaXJkXFxcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8c3BhbiBzdHlsZT1cXFwiXCIuY29uY2F0KG1zZ1N0eWxlcywgXCJcXFwiPkxvYWRpbmcgTW9yZSBBY2NvdW50cy4uLjwvc3Bhbj5cXG4gICAgICAgICAgICBcIikgOiBcIlxcbiAgICAgICAgICA8ZGl2IHN0eWxlPVxcXCJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyO1xcXCI+XFxuICAgICAgICAgICAgPHNlbGVjdCBpZD1cXFwiYWNjb3VudC1zZWxlY3RcXFwiIG9uY2hhbmdlPVxcXCJ3aW5kb3cuYWNjb3VudFNlbGVjdCgpO1xcXCIgY2xhc3M9XFxcImJuLW9uYm9hcmQtY3VzdG9tIGJuLW9uYm9hcmQtYWNjb3VudC1zZWxlY3RcXFwiPlxcbiAgICAgICAgICAgICAgXCIuY29uY2F0KGFjY291bnRzQW5kQmFsYW5jZXMubWFwKGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gXCI8b3B0aW9uPlwiLmNvbmNhdChhY2NvdW50LmFkZHJlc3MsIFwiIC0tLSBcIikuY29uY2F0KGFjY291bnQuYmFsYW5jZSAhPSBudWxsID8gbmV3IEJpZ051bWJlcihhY2NvdW50LmJhbGFuY2UpLmRpdignMTAwMDAwMDAwMDAwMDAwMDAwMCcpLnRvRml4ZWQoMykgOiAnMCcsIFwiIEVUSDwvb3B0aW9uPlwiKTtcbiAgICAgICAgICAgICAgICB9KSwgXCJcXG4gICAgICAgICAgICA8L3NlbGVjdD5cXG4gICAgICAgICAgICA8YnV0dG9uIHN0eWxlPVxcXCJkaXNwbGF5OiBmbGV4OyBhbGlnbi1pdGVtczogY2VudGVyOyB0ZXh0LWFsaWduOiBjZW50ZXI7IGhlaWdodDogMS41cmVtOyBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDsgbWFyZ2luOiAwIDAuMjVyZW07IHBhZGRpbmc6IDAgMC41cmVtOyBib3JkZXItcmFkaXVzOiA0MHB4OyBjdXJzb3I6IHBvaW50ZXI7IGNvbG9yOiBpbmhlcml0OyBib3JkZXItY29sb3I6IGluaGVyaXQ7IGJvcmRlci13aWR0aDogMXB4OyBib3JkZXItc3R5bGU6IHNvbGlkO1xcXCIgb25jbGljaz1cXFwid2luZG93LmxvYWRNb3JlQWNjb3VudHMoKVxcXCI+TG9hZCBNb3JlPC9idXR0b24+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgXCIpLFxuICAgICAgICAgICAgICAgIGJ1dHRvbjoge1xuICAgICAgICAgICAgICAgICAgb25jbGljazogZnVuY3Rpb24gb25jbGljaygpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlV2luZG93UHJvcGVydGllcygpO1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6ICdEb25lJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaWNvbjogaWNvbiB8fCB1c2JJY29uXG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMTEpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gX2NoZWNrTW9kdWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBjaGVja01vZHVsZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBhY2NvdW50c0FuZEJhbGFuY2VzID0gW107XG4gICAgbG9hZGluZ0FjY291bnRzID0gZmFsc2U7XG4gIH07XG5cbiAgcmV0dXJuIGNoZWNrTW9kdWxlO1xufVxuXG52YXIgYWNjb3VudHMgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgJ2RlZmF1bHQnOiBhY2NvdW50U2VsZWN0XG59KTtcbnZhciBkZXJpdmF0aW9uUGF0aHMgPSB7XG4gIExlZGdlcjogW3tcbiAgICBwYXRoOiBcIm0vNDQnLzYwJy8wJ1wiLFxuICAgIGxhYmVsOiAnRXRoZXJldW0nXG4gIH0sIHtcbiAgICBwYXRoOiBcIm0vNDQnLzYwJ1wiLFxuICAgIGxhYmVsOiAnRXRoZXJldW0gTGVkZ2VyIExpdmUnXG4gIH1dLFxuICBUcmV6b3I6IFt7XG4gICAgcGF0aDogXCJtLzQ0Jy82MCcvMCcvMFwiLFxuICAgIGxhYmVsOiAnRXRoZXJldW0nXG4gIH1dLFxuICBMYXR0aWNlOiBbe1xuICAgIHBhdGg6IFwibS80NCcvNjAnLzAnLzBcIixcbiAgICBsYWJlbDogJ0V0aGVyZXVtJ1xuICB9XSxcbiAgS2VlcEtleTogW3tcbiAgICBwYXRoOiBcIm0vNDQnLzYwJy8wJy8wLzBcIixcbiAgICBsYWJlbDogJ0V0aGVyZXVtJ1xuICB9XVxufTtcbnZhciBzdHlsZXMgPSBcIlxcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXCI7XG52YXIgYmFzZVN0eWxlcyA9IFwiXFxuICBiYWNrZ3JvdW5kOiBpbmhlcml0O1xcbiAgZm9udC1zaXplOiAwLjg4OWVtO1xcbiAgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxuICBib3JkZXItd2lkdGg6IDFweDtcXG4gIGJvcmRlci1zdHlsZTogc29saWQ7XFxuICBib3JkZXItY29sb3I6IGluaGVyaXQ7XFxuICBib3JkZXItcmFkaXVzOiA0MHB4O1xcbiAgbWFyZ2luLXRvcDogMC41cmVtO1xcbiAgcGFkZGluZzogMC41NWVtIDEuNGVtO1xcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDtcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQgMTUwbXMgZWFzZS1pbi1vdXQ7XFxuICBsaW5lLWhlaWdodDogMS4xNTtcXG5cIjtcbnZhciBidXR0b25TdHlsZXMgPSBcIlxcbiAgY3Vyc29yOiBwb2ludGVyO1xcblwiO1xudmFyIHNlbGVjdGVkU3R5bGVzID0gXCJcXG4gIGJvcmRlcjogMXB4IHNvbGlkICM0YTkwZTI7XFxuXCI7XG52YXIgZXJyb3JTdHlsZXMgPSBcIlxcbiAgYm9yZGVyOiAxcHggc29saWQgI2UyNTA0YTtcXG5cIjtcbnZhciBtc2dTdHlsZXMkMSA9IFwiXFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZvbnQtc2l6ZTogMC44ODllbTtcXG4gIGZvbnQtZmFtaWx5OiBpbmhlcml0O1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICBtYXJnaW4tdG9wOiAwLjVyZW07XFxuXCI7XG52YXIgZXJyb3JNc2dTdHlsZXMgPSBcIlxcbiAgY29sb3I6ICNlMjUwNGE7XFxuXCI7XG5cbmZ1bmN0aW9uIGRlcml2YXRpb25QYXRoKCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciBoZWFkaW5nID0gb3B0aW9ucy5oZWFkaW5nLFxuICAgICAgZGVzY3JpcHRpb24gPSBvcHRpb25zLmRlc2NyaXB0aW9uLFxuICAgICAgaWNvbiA9IG9wdGlvbnMuaWNvbjtcbiAgdmFyIHN0YXRlID0ge1xuICAgIGNvbXBsZXRlZDogZmFsc2UsXG4gICAgc2hvd0N1c3RvbUlucHV0OiBmYWxzZSxcbiAgICBkUGF0aDogJycsXG4gICAgbG9hZGluZzogZmFsc2UsXG4gICAgZXJyb3I6ICcnXG4gIH07XG5cbiAgdmFyIGN1c3RvbUlucHV0SHRtbFN0cmluZyA9IGZ1bmN0aW9uIGN1c3RvbUlucHV0SHRtbFN0cmluZyhlcnJvcikge1xuICAgIHJldHVybiBcIlxcbiAgICAgIDxpbnB1dCBcXG4gICAgICAgIGlkPVxcXCJjdXN0b20tZGVyaXZhdGlvbi1pbnB1dFxcXCIgXFxuICAgICAgICBzdHlsZT1cXFwiXCIuY29uY2F0KGJhc2VTdHlsZXMgKyBzZWxlY3RlZFN0eWxlcyArIChlcnJvciA/IGVycm9yU3R5bGVzIDogJycpLCBcIlxcXCIgXFxuICAgICAgICB0eXBlPVxcXCJ0ZXh0XFxcIiBcXG4gICAgICAgIHZhbHVlPVxcXCJcIikuY29uY2F0KHN0YXRlLmRQYXRoLCBcIlxcXCJcXG4gICAgICAgIHBsYWNlaG9sZGVyPVxcXCJjdXN0b20gZGVyaXZhdGlvbiBwYXRoXFxcIiBcXG4gICAgICAgIG9uY2hhbmdlPVxcXCJ3aW5kb3cuaGFuZGxlQ3VzdG9tSW5wdXQodGhpcy52YWx1ZSlcXFwiIC8+XFxuICAgICAgXCIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGRlcml2YXRpb25TZWxlY3RIdG1sU3RyaW5nKHdhbGxldE5hbWUpIHtcbiAgICByZXR1cm4gXCJcXG4gICAgICA8ZGl2IGlkPVxcXCJkZXJpdmF0aW9uLXNlbGVjdFxcXCIgc3R5bGU9XFxcIlwiLmNvbmNhdChzdHlsZXMsIFwiXFxcIj5cXG4gICAgICAgIFwiKS5jb25jYXQoZGVyaXZhdGlvblBhdGhzW3dhbGxldE5hbWVdLm1hcChmdW5jdGlvbiAoZGVyaXZhdGlvbikge1xuICAgICAgdmFyIHBhdGggPSBkZXJpdmF0aW9uLnBhdGgsXG4gICAgICAgICAgbGFiZWwgPSBkZXJpdmF0aW9uLmxhYmVsO1xuICAgICAgcmV0dXJuIFwiXFxuICAgICAgICAgICAgICA8YnV0dG9uIHN0eWxlPVxcXCJcIi5jb25jYXQoYmFzZVN0eWxlcyArIGJ1dHRvblN0eWxlcyArIChzdGF0ZS5kUGF0aCA9PT0gcGF0aCAmJiAhc3RhdGUuc2hvd0N1c3RvbUlucHV0ID8gc2VsZWN0ZWRTdHlsZXMgOiAnJyksIFwiXFxcIiBvbmNsaWNrPVxcXCJ3aW5kb3cuaGFuZGxlRGVyaXZhdGlvbkNsaWNrKHRoaXMpXFxcIiBkYXRhLXBhdGg9XFxcIlwiKS5jb25jYXQocGF0aCwgXCJcXFwiPlxcbiAgICAgICAgICAgICAgICBcIikuY29uY2F0KGxhYmVsLCBcIiAtIFwiKS5jb25jYXQocGF0aCwgXCJcXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgIFwiKTtcbiAgICB9KS5qb2luKCcgJyksIFwiXFxuICAgICAgICBcIikuY29uY2F0KHN0YXRlLnNob3dDdXN0b21JbnB1dCA/IGN1c3RvbUlucHV0SHRtbFN0cmluZyhzdGF0ZS5lcnJvcikgOiBcIjxidXR0b24gc3R5bGU9XFxcIlwiLmNvbmNhdChiYXNlU3R5bGVzICsgYnV0dG9uU3R5bGVzLCBcIlxcXCIgb25jbGljaz1cXFwid2luZG93LmhhbmRsZURlcml2YXRpb25DbGljayh0aGlzKVxcXCIgZGF0YS1wYXRoPVxcXCJjdXN0b21cXFwiPkN1c3RvbSBQYXRoPC9idXR0b24+XCIpLCBcIlxcbiAgICAgICAgXCIpLmNvbmNhdChzdGF0ZS5sb2FkaW5nID8gXCI8ZGl2IGNsYXNzPVxcXCJibi1vbmJvYXJkLWN1c3RvbSBibi1vbmJvYXJkLWxvYWRpbmdcXFwiIHN0eWxlPVxcXCJtYXJnaW4tdG9wOiAxcmVtO1xcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJuLW9uYm9hcmQtbG9hZGluZy1maXJzdFxcXCI+PC9kaXY+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImJuLW9uYm9hcmQtbG9hZGluZy1zZWNvbmRcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJibi1vbmJvYXJkLWxvYWRpbmctdGhpcmRcXFwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICA8c3BhbiBzdHlsZT1cXFwiXCIuY29uY2F0KG1zZ1N0eWxlcyQxLCBcIlxcXCI+TG9hZGluZyBBY2NvdW50cy4uLjwvc3Bhbj5cXG4gICAgICAgICAgICAgIFwiKSA6IHN0YXRlLmVycm9yID8gXCI8c3BhbiBzdHlsZT1cXFwiXCIuY29uY2F0KG1zZ1N0eWxlcyQxICsgZXJyb3JNc2dTdHlsZXMsIFwiXFxcIj5cIikuY29uY2F0KHN0YXRlLmVycm9yLCBcIjwvc3Bhbj5cIikgOiAnJywgXCJcXG4gICAgICA8L2Rpdj5cXG4gICAgXCIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRTdGF0ZSgpIHtcbiAgICBzdGF0ZS5jb21wbGV0ZWQgPSBmYWxzZTtcbiAgICBzdGF0ZS5zaG93Q3VzdG9tSW5wdXQgPSBmYWxzZTtcbiAgICBzdGF0ZS5kUGF0aCA9ICcnO1xuICAgIHN0YXRlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICBzdGF0ZS5lcnJvciA9ICcnO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tNb2R1bGUoc3RhdGVBbmRIZWxwZXJzKSB7XG4gICAgdmFyIHdhbGxldCA9IHN0YXRlQW5kSGVscGVycy53YWxsZXQ7XG5cbiAgICBpZiAod2FsbGV0ICYmIHdhbGxldC50eXBlID09PSAnaGFyZHdhcmUnICYmICFzdGF0ZS5jb21wbGV0ZWQpIHtcbiAgICAgIHZhciBoYW5kbGVDdXN0b21JbnB1dCA9IGZ1bmN0aW9uIGhhbmRsZUN1c3RvbUlucHV0KCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY3VzdG9tLWRlcml2YXRpb24taW5wdXQnKTtcbiAgICAgICAgc3RhdGUuZFBhdGggPSBpbnB1dCAmJiBpbnB1dC52YWx1ZTtcbiAgICAgICAgc3RhdGUuZXJyb3IgPSAnJztcbiAgICAgIH07XG5cbiAgICAgIHZhciBoYW5kbGVEZXJpdmF0aW9uQ2xpY2sgPSBmdW5jdGlvbiBoYW5kbGVEZXJpdmF0aW9uQ2xpY2soYnV0dG9uKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZFBhdGggPSBidXR0b24uZGF0YXNldC5wYXRoO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZFBhdGggPT09ICdjdXN0b20nKSB7XG4gICAgICAgICAgc3RhdGUuc2hvd0N1c3RvbUlucHV0ID0gdHJ1ZTtcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjdXN0b20tZGVyaXZhdGlvbi1pbnB1dCcpO1xuICAgICAgICAgICAgaW5wdXQgJiYgaW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICB9LCAxMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0YXRlLmVycm9yID0gJyc7XG4gICAgICAgICAgc3RhdGUuc2hvd0N1c3RvbUlucHV0ID0gZmFsc2U7XG4gICAgICAgICAgc3RhdGUuZFBhdGggPSBzZWxlY3RlZFBhdGg7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBkZWxldGVXaW5kb3dQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVsZXRlV2luZG93UHJvcGVydGllcygpIHtcbiAgICAgICAgZGVsZXRlIHdpbmRvdy5oYW5kbGVDdXN0b21JbnB1dDtcbiAgICAgICAgZGVsZXRlIHdpbmRvdy5oYW5kbGVEZXJpdmF0aW9uU2VsZWN0O1xuICAgICAgfTtcblxuICAgICAgd2luZG93LmhhbmRsZUN1c3RvbUlucHV0ID0gaGFuZGxlQ3VzdG9tSW5wdXQ7XG4gICAgICB3aW5kb3cuaGFuZGxlRGVyaXZhdGlvbkNsaWNrID0gaGFuZGxlRGVyaXZhdGlvbkNsaWNrO1xuICAgICAgcmV0dXJuIGRlcml2YXRpb25QYXRoc1t3YWxsZXQubmFtZV0gJiYge1xuICAgICAgICBoZWFkaW5nOiBoZWFkaW5nIHx8ICdIYXJkd2FyZSBXYWxsZXQgQ29ubmVjdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB8fCBcIk1ha2Ugc3VyZSB5b3VyIFwiLmNvbmNhdCh3YWxsZXQubmFtZSwgXCIgaXMgcGx1Z2dlZCBpbiwgXCIpLmNvbmNhdCh3YWxsZXQubmFtZSA9PT0gJ0xlZGdlcicgPyAnYW5kIHRoZSBFdGhlcmV1bSBhcHAgaXMgb3BlbiwgJyA6ICcnLCBcInRoZW4gc2VsZWN0IGEgZGVyaXZhdGlvbiBwYXRoIHRvIGNvbm5lY3QgeW91ciBhY2NvdW50czpcIiksXG4gICAgICAgIGV2ZW50Q29kZTogJ2Rlcml2YXRpb25QYXRoJyxcbiAgICAgICAgaHRtbDogZGVyaXZhdGlvblNlbGVjdEh0bWxTdHJpbmcod2FsbGV0Lm5hbWUpLFxuICAgICAgICBidXR0b246IHtcbiAgICAgICAgICB0ZXh0OiAnQ29ubmVjdCcsXG4gICAgICAgICAgb25jbGljazogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9vbmNsaWNrID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlMTIoKSB7XG4gICAgICAgICAgICAgIHZhciBwYXRoLCB2YWxpZFBhdGg7XG4gICAgICAgICAgICAgIHJldHVybiByZWdlbmVyYXRvclJ1bnRpbWUud3JhcChmdW5jdGlvbiBfY2FsbGVlMTIkKF9jb250ZXh0MTIpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDEyLnByZXYgPSBfY29udGV4dDEyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBzdGF0ZS5kUGF0aCB8fCBkZXJpdmF0aW9uUGF0aHNbd2FsbGV0Lm5hbWVdWzBdLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQxMi5wcmV2ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3YWxsZXQucHJvdmlkZXIuc2V0UGF0aChwYXRoLCBzdGF0ZS5zaG93Q3VzdG9tSW5wdXQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICB2YWxpZFBhdGggPSBfY29udGV4dDEyLnNlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmVycm9yID0gXCJcIi5jb25jYXQocGF0aCwgXCIgaXMgbm90IGEgdmFsaWQgZGVyaXZhdGlvbiBwYXRoXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIucHJldiA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MTIudDAgPSBfY29udGV4dDEyW1wiY2F0Y2hcIl0oMik7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhdGUuZXJyb3IgPSBfY29udGV4dDEyLnQwO1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5lcnJvciA9ICcnO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHdhbGxldC5jb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuY29ubmVjdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGVXaW5kb3dQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLmVycm9yID0gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCBfY2FsbGVlMTIsIG51bGwsIFtbMiwgMTJdXSk7XG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9uY2xpY2soKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfb25jbGljay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb25jbGljaztcbiAgICAgICAgICB9KClcbiAgICAgICAgfSxcbiAgICAgICAgaWNvbjogaWNvbiB8fCB1c2JJY29uXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGNoZWNrTW9kdWxlLnJlc2V0ID0gcmVzZXRTdGF0ZTtcbiAgcmV0dXJuIGNoZWNrTW9kdWxlO1xufVxuXG52YXIgZGVyaXZhdGlvblBhdGgkMSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICAnZGVmYXVsdCc6IGRlcml2YXRpb25QYXRoXG59KTtcbi8qIHNyYy92aWV3cy9PbmJvYXJkLnN2ZWx0ZSBnZW5lcmF0ZWQgYnkgU3ZlbHRlIHYzLjM4LjIgKi9cblxuZnVuY3Rpb24gYWRkX2NzcyRiKCkge1xuICB2YXIgc3R5bGUgPSBlbGVtZW50KFwic3R5bGVcIik7XG4gIHN0eWxlLmlkID0gXCJzdmVsdGUtMXl4eTYxMi1zdHlsZVwiO1xuICBzdHlsZS50ZXh0Q29udGVudCA9IFwiLmJuLW9uYm9hcmQtY3VzdG9tLmJuLW9uYm9hcmQtZGFyay1tb2Rle2JhY2tncm91bmQ6IzI4Mzk0NDtjb2xvcjojZmZmZmZmfS5ibi1vbmJvYXJkLWN1c3RvbS5ibi1vbmJvYXJkLWRhcmstbW9kZS1iYWNrZ3JvdW5kLWhvdmVyOmhvdmVyLCAuYm4tb25ib2FyZC1jdXN0b20uYm4tb25ib2FyZC1kYXJrLW1vZGUtYmFja2dyb3VuZHtiYWNrZ3JvdW5kOiMwZTIxMmF9LmJuLW9uYm9hcmQtY2xpY2thYmxle3RleHQtZGVjb3JhdGlvbjpub25lfS5ibi1vbmJvYXJkLWNsaWNrYWJsZTpob3ZlcntjdXJzb3I6cG9pbnRlcjt0ZXh0LWRlY29yYXRpb246dW5kZXJsaW5lfS5ibi1vbmJvYXJkLWN1c3RvbS5ibi1vbmJvYXJkLWRhcmstbW9kZS1saW5re2NvbG9yOiM5MWJjZWQ7Ym9yZGVyLWNvbG9yOiM5MWJjZWR9LmJuLW9uYm9hcmQtd2FsbGV0LWNoZWNrLXNlY3Rpb24gc2VsZWN0e3BhZGRpbmc6MC41cmVtfVwiO1xuICBhcHBlbmQoZG9jdW1lbnQuaGVhZCwgc3R5bGUpO1xufSAvLyAoNDE6MCkgeyNpZiAkYXBwLndhbGxldFNlbGVjdEluUHJvZ3Jlc3N9XG5cblxuZnVuY3Rpb24gY3JlYXRlX2lmX2Jsb2NrXzIkMyhjdHgpIHtcbiAgdmFyIHdhbGxldHNlbGVjdDtcbiAgdmFyIGN1cnJlbnQ7XG4gIHdhbGxldHNlbGVjdCA9IG5ldyBXYWxsZXRTZWxlY3Qoe1xuICAgIHByb3BzOiB7XG4gICAgICBtb2R1bGU6XG4gICAgICAvKndhbGxldFNlbGVjdE1vZHVsZSovXG4gICAgICBjdHhbMF1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIGM6IGZ1bmN0aW9uIGMoKSB7XG4gICAgICBjcmVhdGVfY29tcG9uZW50KHdhbGxldHNlbGVjdC4kJC5mcmFnbWVudCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQod2FsbGV0c2VsZWN0LCB0YXJnZXQsIGFuY2hvcik7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBkaXJ0eSkge1xuICAgICAgdmFyIHdhbGxldHNlbGVjdF9jaGFuZ2VzID0ge307XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyp3YWxsZXRTZWxlY3RNb2R1bGUqL1xuICAgICAgMSkgd2FsbGV0c2VsZWN0X2NoYW5nZXMubW9kdWxlID1cbiAgICAgIC8qd2FsbGV0U2VsZWN0TW9kdWxlKi9cbiAgICAgIGN0eFswXTtcbiAgICAgIHdhbGxldHNlbGVjdC4kc2V0KHdhbGxldHNlbGVjdF9jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKHdhbGxldHNlbGVjdC4kJC5mcmFnbWVudCwgbG9jYWwpO1xuICAgICAgY3VycmVudCA9IHRydWU7XG4gICAgfSxcbiAgICBvOiBmdW5jdGlvbiBvKGxvY2FsKSB7XG4gICAgICB0cmFuc2l0aW9uX291dCh3YWxsZXRzZWxlY3QuJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudCh3YWxsZXRzZWxlY3QsIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoNDU6MCkgeyNpZiAkYXBwLndhbGxldENoZWNrSW5Qcm9ncmVzc31cblxuXG5mdW5jdGlvbiBjcmVhdGVfaWZfYmxvY2tfMSQ1KGN0eCkge1xuICB2YXIgd2FsbGV0Y2hlY2s7XG4gIHZhciBjdXJyZW50O1xuICB3YWxsZXRjaGVjayA9IG5ldyBXYWxsZXRDaGVja18xKHtcbiAgICBwcm9wczoge1xuICAgICAgbW9kdWxlczogdW5kZWZpbmVkLFxuICAgICAgd2FsbGV0U2VsZWN0OlxuICAgICAgLyp3YWxsZXRTZWxlY3QqL1xuICAgICAgY3R4WzFdLFxuICAgICAgd2FsbGV0Q2hlY2s6XG4gICAgICAvKndhbGxldENoZWNrKi9cbiAgICAgIGN0eFsyXVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7XG4gICAgYzogZnVuY3Rpb24gYygpIHtcbiAgICAgIGNyZWF0ZV9jb21wb25lbnQod2FsbGV0Y2hlY2suJCQuZnJhZ21lbnQpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gbSh0YXJnZXQsIGFuY2hvcikge1xuICAgICAgbW91bnRfY29tcG9uZW50KHdhbGxldGNoZWNrLCB0YXJnZXQsIGFuY2hvcik7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIHA6IGZ1bmN0aW9uIHAoY3R4LCBkaXJ0eSkge1xuICAgICAgdmFyIHdhbGxldGNoZWNrX2NoYW5nZXMgPSB7fTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKndhbGxldFNlbGVjdCovXG4gICAgICAyKSB3YWxsZXRjaGVja19jaGFuZ2VzLndhbGxldFNlbGVjdCA9XG4gICAgICAvKndhbGxldFNlbGVjdCovXG4gICAgICBjdHhbMV07XG4gICAgICBpZiAoZGlydHkgJlxuICAgICAgLyp3YWxsZXRDaGVjayovXG4gICAgICA0KSB3YWxsZXRjaGVja19jaGFuZ2VzLndhbGxldENoZWNrID1cbiAgICAgIC8qd2FsbGV0Q2hlY2sqL1xuICAgICAgY3R4WzJdO1xuICAgICAgd2FsbGV0Y2hlY2suJHNldCh3YWxsZXRjaGVja19jaGFuZ2VzKTtcbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKHdhbGxldGNoZWNrLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KHdhbGxldGNoZWNrLiQkLmZyYWdtZW50LCBsb2NhbCk7XG4gICAgICBjdXJyZW50ID0gZmFsc2U7XG4gICAgfSxcbiAgICBkOiBmdW5jdGlvbiBkKGRldGFjaGluZykge1xuICAgICAgZGVzdHJveV9jb21wb25lbnQod2FsbGV0Y2hlY2ssIGRldGFjaGluZyk7XG4gICAgfVxuICB9O1xufSAvLyAoNDk6MCkgeyNpZiAkYXBwLmFjY291bnRTZWxlY3RJblByb2dyZXNzfVxuXG5cbmZ1bmN0aW9uIGNyZWF0ZV9pZl9ibG9jayQ5KGN0eCkge1xuICB2YXIgd2FsbGV0Y2hlY2s7XG4gIHZhciBjdXJyZW50O1xuICB3YWxsZXRjaGVjayA9IG5ldyBXYWxsZXRDaGVja18xKHtcbiAgICBwcm9wczoge1xuICAgICAgbW9kdWxlczogW2Rlcml2YXRpb25QYXRoKCksIGFjY291bnRTZWxlY3QoKV0sXG4gICAgICB3YWxsZXRTZWxlY3Q6XG4gICAgICAvKndhbGxldFNlbGVjdCovXG4gICAgICBjdHhbMV0sXG4gICAgICB3YWxsZXRDaGVjazpcbiAgICAgIC8qd2FsbGV0Q2hlY2sqL1xuICAgICAgY3R4WzJdXG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgY3JlYXRlX2NvbXBvbmVudCh3YWxsZXRjaGVjay4kJC5mcmFnbWVudCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBtb3VudF9jb21wb25lbnQod2FsbGV0Y2hlY2ssIHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIGRpcnR5KSB7XG4gICAgICB2YXIgd2FsbGV0Y2hlY2tfY2hhbmdlcyA9IHt9O1xuICAgICAgaWYgKGRpcnR5ICZcbiAgICAgIC8qd2FsbGV0U2VsZWN0Ki9cbiAgICAgIDIpIHdhbGxldGNoZWNrX2NoYW5nZXMud2FsbGV0U2VsZWN0ID1cbiAgICAgIC8qd2FsbGV0U2VsZWN0Ki9cbiAgICAgIGN0eFsxXTtcbiAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAvKndhbGxldENoZWNrKi9cbiAgICAgIDQpIHdhbGxldGNoZWNrX2NoYW5nZXMud2FsbGV0Q2hlY2sgPVxuICAgICAgLyp3YWxsZXRDaGVjayovXG4gICAgICBjdHhbMl07XG4gICAgICB3YWxsZXRjaGVjay4kc2V0KHdhbGxldGNoZWNrX2NoYW5nZXMpO1xuICAgIH0sXG4gICAgaTogZnVuY3Rpb24gaShsb2NhbCkge1xuICAgICAgaWYgKGN1cnJlbnQpIHJldHVybjtcbiAgICAgIHRyYW5zaXRpb25faW4od2FsbGV0Y2hlY2suJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgbzogZnVuY3Rpb24gbyhsb2NhbCkge1xuICAgICAgdHJhbnNpdGlvbl9vdXQod2FsbGV0Y2hlY2suJCQuZnJhZ21lbnQsIGxvY2FsKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBkZXN0cm95X2NvbXBvbmVudCh3YWxsZXRjaGVjaywgZGV0YWNoaW5nKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9mcmFnbWVudCRiKGN0eCkge1xuICB2YXIgdDA7XG4gIHZhciB0MTtcbiAgdmFyIGlmX2Jsb2NrMl9hbmNob3I7XG4gIHZhciBjdXJyZW50O1xuICB2YXIgaWZfYmxvY2swID1cbiAgLyokYXBwKi9cbiAgY3R4WzNdLndhbGxldFNlbGVjdEluUHJvZ3Jlc3MgJiYgY3JlYXRlX2lmX2Jsb2NrXzIkMyhjdHgpO1xuICB2YXIgaWZfYmxvY2sxID1cbiAgLyokYXBwKi9cbiAgY3R4WzNdLndhbGxldENoZWNrSW5Qcm9ncmVzcyAmJiBjcmVhdGVfaWZfYmxvY2tfMSQ1KGN0eCk7XG4gIHZhciBpZl9ibG9jazIgPVxuICAvKiRhcHAqL1xuICBjdHhbM10uYWNjb3VudFNlbGVjdEluUHJvZ3Jlc3MgJiYgY3JlYXRlX2lmX2Jsb2NrJDkoY3R4KTtcbiAgcmV0dXJuIHtcbiAgICBjOiBmdW5jdGlvbiBjKCkge1xuICAgICAgaWYgKGlmX2Jsb2NrMCkgaWZfYmxvY2swLmMoKTtcbiAgICAgIHQwID0gc3BhY2UoKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5jKCk7XG4gICAgICB0MSA9IHNwYWNlKCk7XG4gICAgICBpZiAoaWZfYmxvY2syKSBpZl9ibG9jazIuYygpO1xuICAgICAgaWZfYmxvY2syX2FuY2hvciA9IGVtcHR5KCk7XG4gICAgfSxcbiAgICBtOiBmdW5jdGlvbiBtKHRhcmdldCwgYW5jaG9yKSB7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAubSh0YXJnZXQsIGFuY2hvcik7XG4gICAgICBpbnNlcnQodGFyZ2V0LCB0MCwgYW5jaG9yKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5tKHRhcmdldCwgYW5jaG9yKTtcbiAgICAgIGluc2VydCh0YXJnZXQsIHQxLCBhbmNob3IpO1xuICAgICAgaWYgKGlmX2Jsb2NrMikgaWZfYmxvY2syLm0odGFyZ2V0LCBhbmNob3IpO1xuICAgICAgaW5zZXJ0KHRhcmdldCwgaWZfYmxvY2syX2FuY2hvciwgYW5jaG9yKTtcbiAgICAgIGN1cnJlbnQgPSB0cnVlO1xuICAgIH0sXG4gICAgcDogZnVuY3Rpb24gcChjdHgsIF9yZWYzNSkge1xuICAgICAgdmFyIF9yZWYzNiA9IF9zbGljZWRUb0FycmF5KF9yZWYzNSwgMSksXG4gICAgICAgICAgZGlydHkgPSBfcmVmMzZbMF07XG5cbiAgICAgIGlmIChcbiAgICAgIC8qJGFwcCovXG4gICAgICBjdHhbM10ud2FsbGV0U2VsZWN0SW5Qcm9ncmVzcykge1xuICAgICAgICBpZiAoaWZfYmxvY2swKSB7XG4gICAgICAgICAgaWZfYmxvY2swLnAoY3R4LCBkaXJ0eSk7XG5cbiAgICAgICAgICBpZiAoZGlydHkgJlxuICAgICAgICAgIC8qJGFwcCovXG4gICAgICAgICAgOCkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazAsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jazAgPSBjcmVhdGVfaWZfYmxvY2tfMiQzKGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2swLmMoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCwgMSk7XG4gICAgICAgICAgaWZfYmxvY2swLm0odDAucGFyZW50Tm9kZSwgdDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMCkge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2swLCAxLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWZfYmxvY2swID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAvKiRhcHAqL1xuICAgICAgY3R4WzNdLndhbGxldENoZWNrSW5Qcm9ncmVzcykge1xuICAgICAgICBpZiAoaWZfYmxvY2sxKSB7XG4gICAgICAgICAgaWZfYmxvY2sxLnAoY3R4LCBkaXJ0eSk7XG5cbiAgICAgICAgICBpZiAoZGlydHkgJlxuICAgICAgICAgIC8qJGFwcCovXG4gICAgICAgICAgOCkge1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihpZl9ibG9jazEsIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZl9ibG9jazEgPSBjcmVhdGVfaWZfYmxvY2tfMSQ1KGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2sxLmMoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMSwgMSk7XG4gICAgICAgICAgaWZfYmxvY2sxLm0odDEucGFyZW50Tm9kZSwgdDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlmX2Jsb2NrMSkge1xuICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2sxLCAxLCAxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWZfYmxvY2sxID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGNoZWNrX291dHJvcygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAvKiRhcHAqL1xuICAgICAgY3R4WzNdLmFjY291bnRTZWxlY3RJblByb2dyZXNzKSB7XG4gICAgICAgIGlmIChpZl9ibG9jazIpIHtcbiAgICAgICAgICBpZl9ibG9jazIucChjdHgsIGRpcnR5KTtcblxuICAgICAgICAgIGlmIChkaXJ0eSAmXG4gICAgICAgICAgLyokYXBwKi9cbiAgICAgICAgICA4KSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMiwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmX2Jsb2NrMiA9IGNyZWF0ZV9pZl9ibG9jayQ5KGN0eCk7XG4gICAgICAgICAgaWZfYmxvY2syLmMoKTtcbiAgICAgICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMiwgMSk7XG4gICAgICAgICAgaWZfYmxvY2syLm0oaWZfYmxvY2syX2FuY2hvci5wYXJlbnROb2RlLCBpZl9ibG9jazJfYW5jaG9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpZl9ibG9jazIpIHtcbiAgICAgICAgZ3JvdXBfb3V0cm9zKCk7XG4gICAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMiwgMSwgMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmX2Jsb2NrMiA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGk6IGZ1bmN0aW9uIGkobG9jYWwpIHtcbiAgICAgIGlmIChjdXJyZW50KSByZXR1cm47XG4gICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMCk7XG4gICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMSk7XG4gICAgICB0cmFuc2l0aW9uX2luKGlmX2Jsb2NrMik7XG4gICAgICBjdXJyZW50ID0gdHJ1ZTtcbiAgICB9LFxuICAgIG86IGZ1bmN0aW9uIG8obG9jYWwpIHtcbiAgICAgIHRyYW5zaXRpb25fb3V0KGlmX2Jsb2NrMCk7XG4gICAgICB0cmFuc2l0aW9uX291dChpZl9ibG9jazEpO1xuICAgICAgdHJhbnNpdGlvbl9vdXQoaWZfYmxvY2syKTtcbiAgICAgIGN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIGQoZGV0YWNoaW5nKSB7XG4gICAgICBpZiAoaWZfYmxvY2swKSBpZl9ibG9jazAuZChkZXRhY2hpbmcpO1xuICAgICAgaWYgKGRldGFjaGluZykgZGV0YWNoKHQwKTtcbiAgICAgIGlmIChpZl9ibG9jazEpIGlmX2Jsb2NrMS5kKGRldGFjaGluZyk7XG4gICAgICBpZiAoZGV0YWNoaW5nKSBkZXRhY2godDEpO1xuICAgICAgaWYgKGlmX2Jsb2NrMikgaWZfYmxvY2syLmQoZGV0YWNoaW5nKTtcbiAgICAgIGlmIChkZXRhY2hpbmcpIGRldGFjaChpZl9ibG9jazJfYW5jaG9yKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluc3RhbmNlJGIoJCRzZWxmLCAkJHByb3BzLCAkJGludmFsaWRhdGUpIHtcbiAgdmFyICRhcHA7XG4gIGNvbXBvbmVudF9zdWJzY3JpYmUoJCRzZWxmLCBhcHAsIGZ1bmN0aW9uICgkJHZhbHVlKSB7XG4gICAgcmV0dXJuICQkaW52YWxpZGF0ZSgzLCAkYXBwID0gJCR2YWx1ZSk7XG4gIH0pO1xuICB2YXIgd2FsbGV0U2VsZWN0TW9kdWxlID0gJCRwcm9wcy53YWxsZXRTZWxlY3RNb2R1bGU7XG4gIHZhciB3YWxsZXRTZWxlY3QgPSAkJHByb3BzLndhbGxldFNlbGVjdDtcbiAgdmFyIHdhbGxldENoZWNrID0gJCRwcm9wcy53YWxsZXRDaGVjaztcblxuICAkJHNlbGYuJCRzZXQgPSBmdW5jdGlvbiAoJCRwcm9wcykge1xuICAgIGlmIChcIndhbGxldFNlbGVjdE1vZHVsZVwiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgwLCB3YWxsZXRTZWxlY3RNb2R1bGUgPSAkJHByb3BzLndhbGxldFNlbGVjdE1vZHVsZSk7XG4gICAgaWYgKFwid2FsbGV0U2VsZWN0XCIgaW4gJCRwcm9wcykgJCRpbnZhbGlkYXRlKDEsIHdhbGxldFNlbGVjdCA9ICQkcHJvcHMud2FsbGV0U2VsZWN0KTtcbiAgICBpZiAoXCJ3YWxsZXRDaGVja1wiIGluICQkcHJvcHMpICQkaW52YWxpZGF0ZSgyLCB3YWxsZXRDaGVjayA9ICQkcHJvcHMud2FsbGV0Q2hlY2spO1xuICB9O1xuXG4gIHJldHVybiBbd2FsbGV0U2VsZWN0TW9kdWxlLCB3YWxsZXRTZWxlY3QsIHdhbGxldENoZWNrLCAkYXBwXTtcbn1cblxudmFyIE9uYm9hcmQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdmVsdGVDb21wb25lbnQxMikge1xuICBfaW5oZXJpdHMoT25ib2FyZCwgX1N2ZWx0ZUNvbXBvbmVudDEyKTtcblxuICB2YXIgX3N1cGVyMTIgPSBfY3JlYXRlU3VwZXIoT25ib2FyZCk7XG5cbiAgZnVuY3Rpb24gT25ib2FyZChvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzMTI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgT25ib2FyZCk7XG5cbiAgICBfdGhpczEyID0gX3N1cGVyMTIuY2FsbCh0aGlzKTtcbiAgICBpZiAoIWRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic3ZlbHRlLTF5eHk2MTItc3R5bGVcIikpIGFkZF9jc3MkYigpO1xuICAgIGluaXQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpczEyKSwgb3B0aW9ucywgaW5zdGFuY2UkYiwgY3JlYXRlX2ZyYWdtZW50JGIsIHNhZmVfbm90X2VxdWFsLCB7XG4gICAgICB3YWxsZXRTZWxlY3RNb2R1bGU6IDAsXG4gICAgICB3YWxsZXRTZWxlY3Q6IDEsXG4gICAgICB3YWxsZXRDaGVjazogMlxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpczEyO1xuICB9XG5cbiAgcmV0dXJuIE9uYm9hcmQ7XG59KFN2ZWx0ZUNvbXBvbmVudCk7IC8vIHdhbGxldHMgdGhhdCBxdWFsaWZ5IGZvciBkZWZhdWx0IHdhbGxldHMgbmVlZCB0byBoYXZlIG5vXG4vLyBpbml0IHBhcmFtZXRlcnMgdGhhdCBhcmUgcmVxdWlyZWQgZm9yIGZ1bGwgZnVuY3Rpb25hbGl0eVxuXG5cbnZhciBkZXNrdG9wRGVmYXVsdFdhbGxldE5hbWVzID0gWydkZXRlY3RlZHdhbGxldCcsICdtZXRhbWFzaycsICdmcmFtZScsICd0b3J1cycsICdvcGVyYScsICdsaXF1YWxpdHknXTtcbnZhciBtb2JpbGVEZWZhdWx0V2FsbGV0TmFtZXMgPSBbJ2RldGVjdGVkd2FsbGV0JywgJ21ldGFtYXNrJywgJ2NvaW5iYXNlJywgJ3RydXN0JywgJ3RvcnVzJywgJ29wZXJhJywgJ29wZXJhVG91Y2gnLCAnc3RhdHVzJywgJ2h5cGVycGF5JywgJ3Rva2VucG9ja2V0JywgJ2RjZW50JywgJ2F0b2tlbicsICdsaXF1YWxpdHknLCAnYWxwaGF3YWxsZXQnLCAnb3duYml0JywgJ2JpdHBpZScsICdhdXRoZXJldW0nXTtcblxudmFyIGluamVjdGVkV2FsbGV0RGV0ZWN0ZWQgPSBmdW5jdGlvbiBpbmplY3RlZFdhbGxldERldGVjdGVkKCkge1xuICByZXR1cm4gd2luZG93LmV0aGVyZXVtICYmIGdldFByb3ZpZGVyTmFtZSh3aW5kb3cuZXRoZXJldW0pID09PSB1bmRlZmluZWQ7XG59O1xuXG5mdW5jdGlvbiBzZWxlY3Qod2FsbGV0cywgbmV0d29ya0lkLCBpc01vYmlsZSkge1xuICB2YXIgZGVmYXVsdFdhbGxldE5hbWVzID0gaXNNb2JpbGUgPyBtb2JpbGVEZWZhdWx0V2FsbGV0TmFtZXMgOiBkZXNrdG9wRGVmYXVsdFdhbGxldE5hbWVzO1xuXG4gIGlmICh3YWxsZXRzKSB7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHdhbGxldHMgLy8gb25seSBpbmNsdWRlIGEgZGV0ZWN0ZWQgd2FsbGV0IGlmIGl0J3Mgbm90IGFscmVhZHkgb25lIG9mIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gICAgLmZpbHRlcihmdW5jdGlvbiAod2FsbGV0KSB7XG4gICAgICByZXR1cm4gaXNXYWxsZXRJbml0KHdhbGxldCkgJiYgKHdhbGxldC53YWxsZXROYW1lICE9PSAnZGV0ZWN0ZWR3YWxsZXQnIHx8IGluamVjdGVkV2FsbGV0RGV0ZWN0ZWQoKSk7XG4gICAgfSkubWFwKGZ1bmN0aW9uICh3YWxsZXQpIHtcbiAgICAgIHZhciB3YWxsZXROYW1lID0gd2FsbGV0LndhbGxldE5hbWUsXG4gICAgICAgICAgaW5pdFBhcmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyh3YWxsZXQsIF9leGNsdWRlZDExKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGdldE1vZHVsZSh3YWxsZXROYW1lKS50aGVuKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG1bXCJkZWZhdWx0XCJdKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgaW5pdFBhcmFtcyksIHt9LCB7XG4gICAgICAgICAgICBuZXR3b3JrSWQ6IG5ldHdvcmtJZCxcbiAgICAgICAgICAgIGlzTW9iaWxlOiBpc01vYmlsZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0RlcHJlY2F0ZWRXYWxsZXRFcnJvcicpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh3YWxsZXQpO1xuICAgIH0pKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLmFsbChkZWZhdWx0V2FsbGV0TmFtZXMgLy8gb25seSBpbmNsdWRlIGEgZGV0ZWN0ZWQgd2FsbGV0IGlmIGl0J3Mgbm90IGFscmVhZHkgb25lIG9mIHRoZSBwcm92aWRlZCBvcHRpb25zXG4gIC5maWx0ZXIoZnVuY3Rpb24gKHdhbGxldE5hbWUpIHtcbiAgICByZXR1cm4gd2FsbGV0TmFtZSAhPT0gJ2RldGVjdGVkd2FsbGV0JyB8fCBpbmplY3RlZFdhbGxldERldGVjdGVkKCk7XG4gIH0pLm1hcChmdW5jdGlvbiAod2FsbGV0TmFtZSkge1xuICAgIHJldHVybiBnZXRNb2R1bGUod2FsbGV0TmFtZSkudGhlbihmdW5jdGlvbiAobSkge1xuICAgICAgcmV0dXJuIG1bXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgbmV0d29ya0lkOiBuZXR3b3JrSWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIGdldE1vZHVsZShuYW1lKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIC8vIERlcHJlY2F0ZWQgd2FsbGV0c1xuICAgIGNhc2UgJ2RhcHBlcic6XG4gICAgY2FzZSAnc3F1YXJlbGluayc6XG4gICAgY2FzZSAndW5pbG9naW4nOlxuICAgICAgdGhyb3cge1xuICAgICAgICBuYW1lOiAnRGVwcmVjYXRlZFdhbGxldEVycm9yJyxcbiAgICAgICAgbWVzc2FnZTogXCJcIi5jb25jYXQobmFtZSwgXCIgd2FsbGV0IGhhcyBiZWVuIGRlcHJlY2F0ZWRcIilcbiAgICAgIH07XG5cbiAgICBjYXNlICdtZWV0b25lJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vbWVldG9uZS0xMDcxNDI5Mi5qcycpO1xuXG4gICAgY2FzZSAnbWV0YW1hc2snOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9tZXRhbWFzay02MTI4OWFjZC5qcycpO1xuXG4gICAgY2FzZSAncG9ydGlzJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vcG9ydGlzLTIwZGEzMzA1LmpzJyk7XG5cbiAgICBjYXNlICdmb3J0bWF0aWMnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9mb3J0bWF0aWMtNGZlOTM1OWQuanMnKTtcblxuICAgIGNhc2UgJ2F1dGhlcmV1bSc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL2F1dGhlcmV1bS1kMTdmZDJlYi5qcycpO1xuXG4gICAgY2FzZSAndHJ1c3QnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi90cnVzdC0zNjZiYWNmZS5qcycpO1xuXG4gICAgY2FzZSAnY29pbmJhc2UnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9jb2luYmFzZS1mZjIwMTlhYS5qcycpO1xuXG4gICAgY2FzZSAnd2FsbGV0Q29ubmVjdCc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL3dhbGxldC1jb25uZWN0LWIwMWNiZDllLmpzJyk7XG5cbiAgICBjYXNlICdvcGVyYSc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL29wZXJhLWIzMjhlZDA1LmpzJyk7XG5cbiAgICBjYXNlICdvcGVyYVRvdWNoJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vb3BlcmEtdG91Y2gtMjY5YzM4YTkuanMnKTtcblxuICAgIGNhc2UgJ3RvcnVzJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vdG9ydXMtYTNlYWQyZmMuanMnKTtcblxuICAgIGNhc2UgJ3N0YXR1cyc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL3N0YXR1cy1iNjhiMTBiMy5qcycpO1xuXG4gICAgY2FzZSAndHJlem9yJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vdHJlem9yLTc5YjFhNjM5LmpzJyk7XG5cbiAgICBjYXNlICdsYXR0aWNlJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vbGF0dGljZS1hOTIyNWMyMS5qcycpO1xuXG4gICAgY2FzZSAnY29ib3ZhdWx0JzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vY29ib3ZhdWx0LTI4ZjVlYWIyLmpzJyk7XG5cbiAgICBjYXNlICdsZWRnZXInOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9sZWRnZXItZTMzYTk4ZTUuanMnKTtcblxuICAgIGNhc2UgJ3dhbGxldExpbmsnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi93YWxsZXQtbGluay1iNzhkZGMwZS5qcycpO1xuXG4gICAgY2FzZSAnaW1Ub2tlbic6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL2ltdG9rZW4tY2M1ZTE1YzkuanMnKTtcblxuICAgIGNhc2UgJ215a2V5JzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vbXlrZXktZDA4Y2FkMjAuanMnKTtcblxuICAgIGNhc2UgJ2h1b2Jpd2FsbGV0JzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vaHVvYml3YWxsZXQtMDM0ODk4OGUuanMnKTtcblxuICAgIGNhc2UgJ3dhbGxldC5pbyc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL3dhbGxldC1pby00ZGIzZGJlYS5qcycpO1xuXG4gICAgY2FzZSAnaHlwZXJwYXknOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9oeXBlcnBheS1jYjUzYzQ4Ny5qcycpO1xuXG4gICAgY2FzZSAndG9rZW5wb2NrZXQnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi90b2tlbnBvY2tldC0zYjQ5ZmRiYS5qcycpO1xuXG4gICAgY2FzZSAnZGNlbnQnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9kY2VudC1hYWQ3YWI0MS5qcycpO1xuXG4gICAgY2FzZSAnYXRva2VuJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vYXRva2VuLTY4ZmM0OGI4LmpzJyk7XG5cbiAgICBjYXNlICdsaXF1YWxpdHknOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9saXF1YWxpdHktMGFkY2E4MjYuanMnKTtcblxuICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vZnJhbWUtYTNmNGU1YTUuanMnKTtcblxuICAgIGNhc2UgJ3hkZWZpJzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4veGRlZmktMDQxYjFhNjQuanMnKTtcblxuICAgIGNhc2UgJ2FscGhhd2FsbGV0JzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vYWxwaGF3YWxsZXQtNDhkZTcwY2EuanMnKTtcblxuICAgIGNhc2UgJ293bmJpdCc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL293bmJpdC1iOTMzYWY3ZS5qcycpO1xuXG4gICAgY2FzZSAna2VlcGtleSc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL2luZGV4LTRhNDhiNWVhLmpzJyk7XG5cbiAgICBjYXNlICdiaXRwaWUnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9iaXRwaWUtYTdhY2ZlMGUuanMnKTtcblxuICAgIGNhc2UgJ2dub3Npcyc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL2dub3Npcy0xOWI5MGU1Ny5qcycpO1xuXG4gICAgY2FzZSAnZGV0ZWN0ZWR3YWxsZXQnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9kZXRlY3RlZHdhbGxldC1iZTI2MzdiZS5qcycpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlwiLmNvbmNhdChuYW1lLCBcIiBpcyBub3QgYSB2YWxpZCB3YWxsZXROYW1lLlwiKSk7XG4gIH1cbn1cblxudmFyIGRlZmF1bHRDaGVja3MgPSBbJ2Nvbm5lY3QnLCAnbmV0d29yayddO1xuXG5mdW5jdGlvbiBjaGVjayhfeDEwLCBfeDExKSB7XG4gIHJldHVybiBfY2hlY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX2NoZWNrKCkge1xuICBfY2hlY2sgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL3JlZ2VuZXJhdG9yUnVudGltZS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMyh3YWxsZXRDaGVja3MsIG5ldHdvcmtJZCkge1xuICAgIHZhciBjaGVja3M7XG4gICAgcmV0dXJuIHJlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMyQoX2NvbnRleHQxMykge1xuICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgc3dpdGNoIChfY29udGV4dDEzLnByZXYgPSBfY29udGV4dDEzLm5leHQpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBpZiAoIXdhbGxldENoZWNrcykge1xuICAgICAgICAgICAgICBfY29udGV4dDEzLm5leHQgPSAzO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2hlY2tzID0gd2FsbGV0Q2hlY2tzLm1hcChmdW5jdGlvbiAoY2hlY2tPck1vZHVsZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzV2FsbGV0Q2hlY2tNb2R1bGUoY2hlY2tPck1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tOYW1lID0gY2hlY2tPck1vZHVsZS5jaGVja05hbWUsXG4gICAgICAgICAgICAgICAgICAgIG90aGVyUGFyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGNoZWNrT3JNb2R1bGUsIF9leGNsdWRlZDEyKTtcblxuICAgICAgICAgICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGUkMShjaGVja05hbWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2R1bGUgJiYgbW9kdWxlLnRoZW4oZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBtW1wiZGVmYXVsdFwiXShfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIG90aGVyUGFyYW1zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgbmV0d29ya0lkOiBuZXR3b3JrSWRcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2hlY2tPck1vZHVsZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmFicnVwdChcInJldHVyblwiLCBQcm9taXNlLmFsbChjaGVja3MpKTtcblxuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEzLmFicnVwdChcInJldHVyblwiLCBQcm9taXNlLmFsbChkZWZhdWx0Q2hlY2tzLm1hcChmdW5jdGlvbiAoY2hlY2tOYW1lKSB7XG4gICAgICAgICAgICAgIHZhciBtb2R1bGUgPSBnZXRNb2R1bGUkMShjaGVja05hbWUpO1xuICAgICAgICAgICAgICByZXR1cm4gbW9kdWxlICYmIG1vZHVsZS50aGVuKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1bXCJkZWZhdWx0XCJdKHtcbiAgICAgICAgICAgICAgICAgIG5ldHdvcmtJZDogbmV0d29ya0lkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSkpKTtcblxuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMTMpO1xuICB9KSk7XG4gIHJldHVybiBfY2hlY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gZ2V0TW9kdWxlJDEobmFtZSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdjb25uZWN0JzpcbiAgICAgIHJldHVybiBpbXBvcnQoJy4vY29ubmVjdC05NDVkYWFiYS5qcycpO1xuXG4gICAgY2FzZSAnbmV0d29yayc6XG4gICAgICByZXR1cm4gaW1wb3J0KCcuL25ldHdvcmstZDdmZGYwY2EuanMnKTtcblxuICAgIGNhc2UgJ2JhbGFuY2UnOlxuICAgICAgcmV0dXJuIGltcG9ydCgnLi9iYWxhbmNlLTU1YmEyZWRhLmpzJyk7XG5cbiAgICBjYXNlICdhY2NvdW50cyc6XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhY2NvdW50cztcbiAgICAgIH0pO1xuXG4gICAgY2FzZSAnZGVyaXZhdGlvblBhdGgnOlxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZGVyaXZhdGlvblBhdGgkMTtcbiAgICAgIH0pO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgbW9kdWxlIG5hbWU6IFwiLmNvbmNhdChuYW1lKSk7XG4gIH1cbn1cblxudmFyIGRlZmF1bHRIZWFkaW5nID0gJ1NlbGVjdCBhIFdhbGxldCc7XG52YXIgZGVmYXVsdERlc2NyaXB0aW9uID0gJ1BsZWFzZSBzZWxlY3QgYSB3YWxsZXQgdG8gY29ubmVjdCB0byB0aGlzIGRhcHA6JztcbnZhciBkZWZhdWx0V2FsbGV0RXhwbGFuYXRpb24gPSBcIldhbGxldHMgYXJlIHVzZWQgdG8gc2VuZCwgcmVjZWl2ZSwgYW5kIHN0b3JlIGRpZ2l0YWwgYXNzZXRzIGxpa2UgRXRoZXIuIFdhbGxldHMgY29tZSBpbiBtYW55IGZvcm1zLiBUaGV5IGFyZSBlaXRoZXIgYnVpbHQgaW50byB5b3VyIGJyb3dzZXIsIGFuIGV4dGVuc2lvbiBhZGRlZCB0byB5b3VyIGJyb3dzZXIsIGEgcGllY2Ugb2YgaGFyZHdhcmUgcGx1Z2dlZCBpbnRvIHlvdXIgY29tcHV0ZXIgb3IgZXZlbiBhbiBhcHAgb24geW91ciBwaG9uZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24gYWJvdXQgd2FsbGV0cywgc2VlIDxhIHN0eWxlPVxcXCJjb2xvcjogIzRhOTBlMjsgZm9udC1zaXplOiAwLjg4OXJlbTsgZm9udC1mYW1pbHk6IGluaGVyaXQ7XFxcIiBjbGFzcz1cXFwiYm4tb25ib2FyZC1jbGlja2FibGVcXFwiIGhyZWY9XFxcImh0dHBzOi8vZG9jcy5ldGhodWIuaW8vdXNpbmctZXRoZXJldW0vd2FsbGV0cy9pbnRyby10by1ldGhlcmV1bS13YWxsZXRzL1xcXCIgdGFyZ2V0PVxcXCJfYmxhbmtcXFwiIHJlbD1cXFwibm9vcGVuZXIgbm9yZWZlcnJlclxcXCI+dGhpcyBleHBsYW5hdGlvbjwvYT4uXCI7XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVNb2R1bGVzKG5ldHdvcmtJZCwgd2FsbGV0U2VsZWN0T3B0aW9ucywgd2FsbGV0Q2hlY2ssIGlzTW9iaWxlKSB7XG4gIHZhciB3YWxsZXRzID0gc2VsZWN0KHdhbGxldFNlbGVjdE9wdGlvbnMgJiYgd2FsbGV0U2VsZWN0T3B0aW9ucy53YWxsZXRzLCBuZXR3b3JrSWQsIGlzTW9iaWxlKTtcblxuICB2YXIgX3JlZjM3ID0gd2FsbGV0U2VsZWN0T3B0aW9ucyB8fCB7fSxcbiAgICAgIF9yZWYzNyRoZWFkaW5nID0gX3JlZjM3LmhlYWRpbmcsXG4gICAgICBoZWFkaW5nID0gX3JlZjM3JGhlYWRpbmcgPT09IHZvaWQgMCA/IGRlZmF1bHRIZWFkaW5nIDogX3JlZjM3JGhlYWRpbmcsXG4gICAgICBfcmVmMzckZGVzY3JpcHRpb24gPSBfcmVmMzcuZGVzY3JpcHRpb24sXG4gICAgICBkZXNjcmlwdGlvbiA9IF9yZWYzNyRkZXNjcmlwdGlvbiA9PT0gdm9pZCAwID8gZGVmYXVsdERlc2NyaXB0aW9uIDogX3JlZjM3JGRlc2NyaXB0aW9uLFxuICAgICAgX3JlZjM3JGV4cGxhbmF0aW9uID0gX3JlZjM3LmV4cGxhbmF0aW9uLFxuICAgICAgZXhwbGFuYXRpb24gPSBfcmVmMzckZXhwbGFuYXRpb24gPT09IHZvaWQgMCA/IGRlZmF1bHRXYWxsZXRFeHBsYW5hdGlvbiA6IF9yZWYzNyRleHBsYW5hdGlvbixcbiAgICAgIF9yZWYzNyRhZ3JlZW1lbnQgPSBfcmVmMzcuYWdyZWVtZW50LFxuICAgICAgYWdyZWVtZW50ID0gX3JlZjM3JGFncmVlbWVudCA9PT0gdm9pZCAwID8ge30gOiBfcmVmMzckYWdyZWVtZW50O1xuXG4gIHJldHVybiB7XG4gICAgd2FsbGV0U2VsZWN0OiB7XG4gICAgICBoZWFkaW5nOiBoZWFkaW5nLFxuICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLFxuICAgICAgd2FsbGV0czogd2FsbGV0cyxcbiAgICAgIGV4cGxhbmF0aW9uOiBleHBsYW5hdGlvbixcbiAgICAgIGFncmVlbWVudDogYWdyZWVtZW50XG4gICAgfSxcbiAgICB3YWxsZXRDaGVjazogY2hlY2sod2FsbGV0Q2hlY2ssIG5ldHdvcmtJZClcbiAgfTtcbn1cblxudmFyIG9uYm9hcmQ7XG5cbmZ1bmN0aW9uIGluaXQkMShpbml0aWFsaXphdGlvbikge1xuICB2YXIgX2luaXRpYWxpemF0aW9uJHdhbGxlMiwgX2luaXRpYWxpemF0aW9uJHdhbGxlMztcblxuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oJ09uYm9hcmQuanMgbXVzdCBiZSBydW4gaW4gYSBicm93c2VyIGVudmlyb25tZW50LiBJZiB5b3UgYXJlIHV0aWxpemluZyBzZXJ2ZXIgc2lkZSByZW5kZXJpbmcgeW91IGNhbiBpZ25vcmUgdGhpcyB3YXJuaW5nLicpO1xuICAgIHZhciBzdHViYmVkQVBJID0ge1xuICAgICAgd2FsbGV0U2VsZWN0OiBmdW5jdGlvbiB3YWxsZXRTZWxlY3QoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgfSxcbiAgICAgIHdhbGxldENoZWNrOiBmdW5jdGlvbiB3YWxsZXRDaGVjaygpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICB9LFxuICAgICAgd2FsbGV0UmVzZXQ6IGZ1bmN0aW9uIHdhbGxldFJlc2V0KCkge30sXG4gICAgICBjb25maWc6IGZ1bmN0aW9uIGNvbmZpZygpIHt9LFxuICAgICAgZ2V0U3RhdGU6IGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgICAgICByZXR1cm4gZ2V0X3N0b3JlX3ZhbHVlKHN0YXRlKTtcbiAgICAgIH0sXG4gICAgICBhY2NvdW50U2VsZWN0OiBmdW5jdGlvbiBhY2NvdW50U2VsZWN0KCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzdHViYmVkQVBJO1xuICB9XG5cbiAgaWYgKG9uYm9hcmQpIHtcbiAgICBjb25zb2xlLndhcm4oJ0luaXRpYWxpemluZyBPbmJvYXJkIGFuZCBkZXN0cm95aW5nIHByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgaW5zdGFuY2UuJyk7IC8vIGNsb3NlIFdlYlNvY2tldCBjb25uZWN0aW9uXG5cbiAgICBjbG9zZVNvY2tldENvbm5lY3Rpb24oKTsgLy8gcmVzZXQgdGhlIHdhbGxldCBzdGF0ZVxuXG4gICAgcmVzZXRXYWxsZXRTdGF0ZSgpOyAvLyBkZXN0cm95IHN2ZWx0ZSBpbnN0YW5jZSBhbmQgcmVtb3ZlIGZyb20gRE9NXG5cbiAgICBvbmJvYXJkLiRkZXN0cm95KCk7XG4gIH1cblxuICB2YWxpZGF0ZUluaXQoaW5pdGlhbGl6YXRpb24pO1xuICB2YXIgc3Vic2NyaXB0aW9ucyA9IGluaXRpYWxpemF0aW9uLnN1YnNjcmlwdGlvbnMsXG4gICAgICBkYXBwSWQgPSBpbml0aWFsaXphdGlvbi5kYXBwSWQsXG4gICAgICBuZXR3b3JrSWQgPSBpbml0aWFsaXphdGlvbi5uZXR3b3JrSWQsXG4gICAgICBuZXR3b3JrTmFtZSA9IGluaXRpYWxpemF0aW9uLm5ldHdvcmtOYW1lLFxuICAgICAgZGFya01vZGUgPSBpbml0aWFsaXphdGlvbi5kYXJrTW9kZSxcbiAgICAgIGFwaVVybCA9IGluaXRpYWxpemF0aW9uLmFwaVVybCxcbiAgICAgIGhpZGVCcmFuZGluZyA9IGluaXRpYWxpemF0aW9uLmhpZGVCcmFuZGluZyxcbiAgICAgIF9pbml0aWFsaXphdGlvbiRibG9jayA9IGluaXRpYWxpemF0aW9uLmJsb2NrUG9sbGluZ0ludGVydmFsLFxuICAgICAgYmxvY2tQb2xsaW5nSW50ZXJ2YWwgPSBfaW5pdGlhbGl6YXRpb24kYmxvY2sgPT09IHZvaWQgMCA/IDQwMDAgOiBfaW5pdGlhbGl6YXRpb24kYmxvY2s7XG5cbiAgdmFyIF9nZXREZXZpY2VJbmZvID0gZ2V0RGV2aWNlSW5mbygpLFxuICAgICAgb3MgPSBfZ2V0RGV2aWNlSW5mby5vcyxcbiAgICAgIGJyb3dzZXIgPSBfZ2V0RGV2aWNlSW5mby5icm93c2VyLFxuICAgICAgaXNNb2JpbGUgPSBfZ2V0RGV2aWNlSW5mby5pc01vYmlsZTtcblxuICB2YXIgaW5pdGlhbGl6ZWRNb2R1bGVzID0gaW5pdGlhbGl6ZU1vZHVsZXMobmV0d29ya0lkLCBpbml0aWFsaXphdGlvbi53YWxsZXRTZWxlY3QsIGluaXRpYWxpemF0aW9uLndhbGxldENoZWNrLCBpc01vYmlsZSk7XG4gIHZhciBkaXNwbGF5QnJhbmRpbmc7XG5cbiAgaWYgKGRhcHBJZCkge1xuICAgIGlmIChoaWRlQnJhbmRpbmcgIT09IGZhbHNlKSB7XG4gICAgICBkaXNwbGF5QnJhbmRpbmcgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzcGxheUJyYW5kaW5nID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGhpZGVCcmFuZGluZyAhPT0gdHJ1ZSkge1xuICAgICAgZGlzcGxheUJyYW5kaW5nID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGlzcGxheUJyYW5kaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgYXBwLnVwZGF0ZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICB2YXIgX2luaXRpYWxpemF0aW9uJHdhbGxlO1xuXG4gICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgZGFwcElkOiBkYXBwSWQsXG4gICAgICBhcGlVcmw6IGFwaVVybCxcbiAgICAgIG5ldHdvcmtJZDogbmV0d29ya0lkLFxuICAgICAgbmV0d29ya05hbWU6IG5ldHdvcmtOYW1lLFxuICAgICAgdmVyc2lvbjogdmVyc2lvbixcbiAgICAgIG1vYmlsZURldmljZTogaXNNb2JpbGUsXG4gICAgICBvczogb3MsXG4gICAgICBicm93c2VyOiBicm93c2VyLFxuICAgICAgZGFya01vZGU6IGRhcmtNb2RlLFxuICAgICAgZGlzcGxheUJyYW5kaW5nOiBkaXNwbGF5QnJhbmRpbmcsXG4gICAgICBjaGVja01vZHVsZXM6IGluaXRpYWxpemVkTW9kdWxlcy53YWxsZXRDaGVjayxcbiAgICAgIGJsb2NrUG9sbGluZ0ludGVydmFsOiBibG9ja1BvbGxpbmdJbnRlcnZhbCxcbiAgICAgIGFncmVlbWVudDogKChfaW5pdGlhbGl6YXRpb24kd2FsbGUgPSBpbml0aWFsaXphdGlvbi53YWxsZXRTZWxlY3QpID09PSBudWxsIHx8IF9pbml0aWFsaXphdGlvbiR3YWxsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2luaXRpYWxpemF0aW9uJHdhbGxlLmFncmVlbWVudCkgfHwgbnVsbFxuICAgIH0pO1xuICB9KTtcbiAgaW5pdGlhbGl6ZVN0b3JlcygpO1xuICBvbmJvYXJkID0gbmV3IE9uYm9hcmQoe1xuICAgIHRhcmdldDogZG9jdW1lbnQuYm9keSxcbiAgICBwcm9wczoge1xuICAgICAgd2FsbGV0U2VsZWN0TW9kdWxlOiBpbml0aWFsaXplZE1vZHVsZXMud2FsbGV0U2VsZWN0LFxuICAgICAgd2FsbGV0U2VsZWN0OiB3YWxsZXRTZWxlY3QsXG4gICAgICB3YWxsZXRDaGVjazogd2FsbGV0Q2hlY2tcbiAgICB9XG4gIH0pOyAvLyByZWdpc3RlciBzdWJzY3JpcHRpb25zXG5cbiAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICBpZiAoc3Vic2NyaXB0aW9ucy5hZGRyZXNzKSB7XG4gICAgICBhZGRyZXNzLnN1YnNjcmliZShmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICBpZiAoYWRkcmVzcyAhPT0gbnVsbCkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMuYWRkcmVzcyAmJiBzdWJzY3JpcHRpb25zLmFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChzdWJzY3JpcHRpb25zLm5ldHdvcmspIHtcbiAgICAgIG5ldHdvcmsuc3Vic2NyaWJlKGZ1bmN0aW9uIChuZXR3b3JrSWQpIHtcbiAgICAgICAgaWYgKG5ldHdvcmtJZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHN1YnNjcmlwdGlvbnMubmV0d29yayAmJiBzdWJzY3JpcHRpb25zLm5ldHdvcmsobmV0d29ya0lkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHN1YnNjcmlwdGlvbnMuYmFsYW5jZSkge1xuICAgICAgYmFsYW5jZS5zdWJzY3JpYmUoZnVuY3Rpb24gKGJhbGFuY2UpIHtcbiAgICAgICAgaWYgKGJhbGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICBzdWJzY3JpcHRpb25zLmJhbGFuY2UgJiYgc3Vic2NyaXB0aW9ucy5iYWxhbmNlKGJhbGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoc3Vic2NyaXB0aW9ucy53YWxsZXQpIHtcbiAgICAgIHdhbGxldC5zdWJzY3JpYmUoZnVuY3Rpb24gKHdhbGxldCkge1xuICAgICAgICBpZiAod2FsbGV0LnByb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9ucy53YWxsZXQgJiYgc3Vic2NyaXB0aW9ucy53YWxsZXQod2FsbGV0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gd2FsbGV0U2VsZWN0KGF1dG9TZWxlY3RXYWxsZXQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGFwcC51cGRhdGUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgICB3YWxsZXRTZWxlY3RJblByb2dyZXNzOiB0cnVlLFxuICAgICAgICAgIGF1dG9TZWxlY3RXYWxsZXQ6IHR5cGVvZiBhdXRvU2VsZWN0V2FsbGV0ID09PSAnc3RyaW5nJyAmJiBhdXRvU2VsZWN0V2FsbGV0XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICB2YXIgYXBwVW5zdWJzY3JpYmUgPSBhcHAuc3Vic2NyaWJlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICB2YXIgd2FsbGV0U2VsZWN0SW5Qcm9ncmVzcyA9IHN0b3JlLndhbGxldFNlbGVjdEluUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3YWxsZXRTZWxlY3RDb21wbGV0ZWQgPSBzdG9yZS53YWxsZXRTZWxlY3RDb21wbGV0ZWQsXG4gICAgICAgICAgICB3YWxsZXRTZWxlY3REaXNwbGF5ZWRVSSA9IHN0b3JlLndhbGxldFNlbGVjdERpc3BsYXllZFVJO1xuXG4gICAgICAgIGlmICh3YWxsZXRTZWxlY3RJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgIGFwcFVuc3Vic2NyaWJlKCk7IC8vIHRpbWVvdXQgZm9yIFVJIHRyYW5zaXRpb25zIGlmIGl0IHdhcyBkaXNwbGF5ZWRcblxuICAgICAgICAgIHdhbGxldFNlbGVjdERpc3BsYXllZFVJID8gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKHdhbGxldFNlbGVjdENvbXBsZXRlZCk7XG4gICAgICAgICAgICBhcHAudXBkYXRlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheWVkVUk6IGZhbHNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgNTAwKSA6IHJlc29sdmUod2FsbGV0U2VsZWN0Q29tcGxldGVkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB3YWxsZXRDaGVjaygpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGlmICghZ2V0X3N0b3JlX3ZhbHVlKHdhbGxldEludGVyZmFjZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3YWxsZXRTZWxlY3QgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHdhbGxldENoZWNrJyk7XG4gICAgICB9XG5cbiAgICAgIGFwcC51cGRhdGUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgICB3YWxsZXRDaGVja0luUHJvZ3Jlc3M6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBhcHBVbnN1YnNjcmliZSA9IGFwcC5zdWJzY3JpYmUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgIHZhciB3YWxsZXRDaGVja0luUHJvZ3Jlc3MgPSBzdG9yZS53YWxsZXRDaGVja0luUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3YWxsZXRDaGVja0NvbXBsZXRlZCA9IHN0b3JlLndhbGxldENoZWNrQ29tcGxldGVkLFxuICAgICAgICAgICAgd2FsbGV0Q2hlY2tEaXNwbGF5ZWRVSSA9IHN0b3JlLndhbGxldENoZWNrRGlzcGxheWVkVUksXG4gICAgICAgICAgICBzd2l0Y2hpbmdXYWxsZXRzID0gc3RvcmUuc3dpdGNoaW5nV2FsbGV0cztcblxuICAgICAgICBpZiAoIXN3aXRjaGluZ1dhbGxldHMgJiYgd2FsbGV0Q2hlY2tJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgIGFwcFVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgd2FsbGV0Q2hlY2tEaXNwbGF5ZWRVSSA/IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmVzb2x2ZSh3YWxsZXRDaGVja0NvbXBsZXRlZCk7XG4gICAgICAgICAgICBhcHAudXBkYXRlKGZ1bmN0aW9uIChzdG9yZSkge1xuICAgICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdG9yZSksIHt9LCB7XG4gICAgICAgICAgICAgICAgZGlzcGxheWVkVUk6IGZhbHNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgNTAwKSA6IHJlc29sdmUod2FsbGV0Q2hlY2tDb21wbGV0ZWQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhbGxldFJlc2V0KCkge1xuICAgIHJlc2V0V2FsbGV0U3RhdGUoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY291bnRTZWxlY3QoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICB2YXIgX2dldF9zdG9yZV92YWx1ZTYgPSBnZXRfc3RvcmVfdmFsdWUod2FsbGV0KSxcbiAgICAgICAgICB0eXBlID0gX2dldF9zdG9yZV92YWx1ZTYudHlwZTtcblxuICAgICAgaWYgKHR5cGUgIT09ICdoYXJkd2FyZScpIHtcbiAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIGFwcC51cGRhdGUoZnVuY3Rpb24gKHN0b3JlKSB7XG4gICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwge30sIHtcbiAgICAgICAgICBhY2NvdW50U2VsZWN0SW5Qcm9ncmVzczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGFwcFVuc3Vic2NyaWJlID0gYXBwLnN1YnNjcmliZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICAgICAgdmFyIGFjY291bnRTZWxlY3RJblByb2dyZXNzID0gc3RvcmUuYWNjb3VudFNlbGVjdEluUHJvZ3Jlc3MsXG4gICAgICAgICAgICB3YWxsZXRTZWxlY3REaXNwbGF5ZWRVSSA9IHN0b3JlLndhbGxldFNlbGVjdERpc3BsYXllZFVJO1xuXG4gICAgICAgIGlmIChhY2NvdW50U2VsZWN0SW5Qcm9ncmVzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBhcHBVbnN1YnNjcmliZSgpO1xuICAgICAgICAgIHdhbGxldFNlbGVjdERpc3BsYXllZFVJID8gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgYXBwLnVwZGF0ZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3RvcmUpLCB7fSwge1xuICAgICAgICAgICAgICAgIGRpc3BsYXllZFVJOiBmYWxzZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIDUwMCkgOiByZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZyhvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVDb25maWcob3B0aW9ucyk7XG4gICAgYXBwLnVwZGF0ZShmdW5jdGlvbiAoc3RvcmUpIHtcbiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN0b3JlKSwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICByZXR1cm4gZ2V0X3N0b3JlX3ZhbHVlKHN0YXRlKTtcbiAgfSAvLyBGaW5kIHRoZSBHbm9zaXMgd2FsbGV0IGZyb20gdGhlIHdhbGxldCBpbml0IG9wdGlvbnMuIElnbm9yZSBpdFxuICAvLyBpZiBpdCBpcyBhIHdhbGxldCBtb2R1bGUuIFdlIG5lZWQgdG8gZ2V0IHRoZSB3YWxsZXQgaW5pdCBmaXJzdFxuICAvLyBpbiBvcmRlciB0byBkZXRlcm1pbmUgdGhlIHdhbGxldCBuYW1lOiBgd2FsbGV0TmFtZWAgb3IgYGxhYmVsYC5cblxuXG4gIHZhciBfcmVmMzggPSAoKF9pbml0aWFsaXphdGlvbiR3YWxsZTIgPSBpbml0aWFsaXphdGlvbi53YWxsZXRTZWxlY3QpID09PSBudWxsIHx8IF9pbml0aWFsaXphdGlvbiR3YWxsZTIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfaW5pdGlhbGl6YXRpb24kd2FsbGUzID0gX2luaXRpYWxpemF0aW9uJHdhbGxlMi53YWxsZXRzKSA9PT0gbnVsbCB8fCBfaW5pdGlhbGl6YXRpb24kd2FsbGUzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfaW5pdGlhbGl6YXRpb24kd2FsbGUzLmZpbmQoZnVuY3Rpb24gKHdhbGxldCkge1xuICAgIHJldHVybiBpc1dhbGxldEluaXQod2FsbGV0KSAmJiB3YWxsZXQud2FsbGV0TmFtZSA9PT0gJ2dub3Npcyc7XG4gIH0pKSB8fCB7fSxcbiAgICAgIF9yZWYzOCRsYWJlbCA9IF9yZWYzOC5sYWJlbCxcbiAgICAgIGdub3Npc1dhbGxldE5hbWUgPSBfcmVmMzgkbGFiZWwgPT09IHZvaWQgMCA/ICdHbm9zaXMgU2FmZScgOiBfcmVmMzgkbGFiZWw7XG5cbiAgaWYgKGdub3Npc1dhbGxldE5hbWUpIHtcbiAgICBpbXBvcnQoJy4vZ25vc2lzLTE5YjkwZTU3LmpzJykudGhlbihmdW5jdGlvbiAoX3JlZjM5KSB7XG4gICAgICB2YXIgY2hlY2tHbm9zaXNTYWZlQ29udGV4dCA9IF9yZWYzOS5jaGVja0dub3Npc1NhZmVDb250ZXh0O1xuICAgICAgcmV0dXJuIGNoZWNrR25vc2lzU2FmZUNvbnRleHQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gd2FsbGV0U2VsZWN0KGdub3Npc1dhbGxldE5hbWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHdhbGxldFNlbGVjdDogd2FsbGV0U2VsZWN0LFxuICAgIHdhbGxldENoZWNrOiB3YWxsZXRDaGVjayxcbiAgICB3YWxsZXRSZXNldDogd2FsbGV0UmVzZXQsXG4gICAgY29uZmlnOiBjb25maWcsXG4gICAgZ2V0U3RhdGU6IGdldFN0YXRlLFxuICAgIGFjY291bnRTZWxlY3Q6IGFjY291bnRTZWxlY3RcbiAgfTtcbn1cblxuZXhwb3J0IHsgQnV0dG9uIGFzIEIsIE1vZGFsIGFzIE0sIGFwcCBhcyBhLCBub29wIGFzIGIsIGluc2VydCBhcyBjLCBkZXRhY2ggYXMgZCwgY29ubmVjdEljb24gYXMgZSwgbmV0d29ya0ljb24gYXMgZiwgZ2V0X3N0b3JlX3ZhbHVlIGFzIGcsIGJhbGFuY2VJY29uIGFzIGgsIGluaXQkMSBhcyBpLCBuZXR3b3JrTmFtZSBhcyBuLCBvcGVuTGluayBhcyBvIH07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bnc-onboard/dist/esm/onboard-584c044d.js\n");

/***/ }),

/***/ "./node_modules/bnc-onboard/dist/esm/onboard.js":
/*!******************************************************!*\
  !*** ./node_modules/bnc-onboard/dist/esm/onboard.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* reexport safe */ _onboard_584c044d_js__WEBPACK_IMPORTED_MODULE_1__.i; }\n/* harmony export */ });\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! regenerator-runtime/runtime */ \"./node_modules/regenerator-runtime/runtime.js\");\n/* harmony import */ var regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(regenerator_runtime_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _onboard_584c044d_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./onboard-584c044d.js */ \"./node_modules/bnc-onboard/dist/esm/onboard-584c044d.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bignumber.js */ \"./node_modules/bignumber.js/bignumber.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bignumber_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var bnc_sdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! bnc-sdk */ \"./node_modules/bnc-sdk/dist/esm/index.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bowser */ \"./node_modules/bowser/es5.js\");\n/* harmony import */ var bowser__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(bowser__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JuYy1vbmJvYXJkL2Rpc3QvZXNtL29uYm9hcmQuanM/ODNjZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBcUM7QUFDZ0I7QUFDL0I7QUFDTCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ibmMtb25ib2FyZC9kaXN0L2VzbS9vbmJvYXJkLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICdyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUnO1xuZXhwb3J0IHsgaSBhcyBkZWZhdWx0IH0gZnJvbSAnLi9vbmJvYXJkLTU4NGMwNDRkLmpzJztcbmltcG9ydCAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCAnYm5jLXNkayc7XG5pbXBvcnQgJ2Jvd3Nlcic7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bnc-onboard/dist/esm/onboard.js\n");

/***/ }),

/***/ "./node_modules/bnc-sdk/dist/esm/index.js":
/*!************************************************!*\
  !*** ./node_modules/bnc-sdk/dist/esm/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sturdy-websocket */ \"./node_modules/sturdy-websocket/dist/index.js\");\n/* harmony import */ var crypto_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto-es */ \"./node_modules/crypto-es/lib/index.js\");\n\n\nconst networks = {\n  bitcoin: {\n    '1': 'main',\n    '2': 'testnet'\n  },\n  ethereum: {\n    '1': 'main',\n    '3': 'ropsten',\n    '4': 'rinkeby',\n    '5': 'goerli',\n    '42': 'kovan',\n    '56': 'bsc-main',\n    '100': 'xdai'\n  }\n};\nconst DEFAULT_RATE_LIMIT_RULES = {\n  points: 150,\n  duration: 1\n};\nconst QUEUE_LIMIT = 10000;\n\nfunction createEmitter() {\n  return {\n    listeners: {},\n    on: function (eventCode, listener) {\n      // check if valid eventCode\n      switch (eventCode) {\n        case 'txSent':\n        case 'txPool':\n        case 'txConfirmed':\n        case 'txSpeedUp':\n        case 'txCancel':\n        case 'txFailed':\n        case 'txDropped':\n        case 'txRequest':\n        case 'nsfFail':\n        case 'txRepeat':\n        case 'txAwaitingApproval':\n        case 'txConfirmReminder':\n        case 'txSendFail':\n        case 'txError':\n        case 'txUnderPriced':\n        case 'txPoolSimulation':\n        case 'all':\n          break;\n\n        default:\n          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://docs.blocknative.com/notify-sdk#event-codes`);\n      } // check that listener is a function\n\n\n      if (typeof listener !== 'function') {\n        throw new Error('Listener must be a function');\n      } // add listener for the eventCode\n\n\n      this.listeners[eventCode] = listener;\n    },\n    off: function (eventCode) {\n      delete this.listeners[eventCode];\n    },\n    emit: function (state) {\n      if (this.listeners[state.eventCode]) {\n        return this.listeners[state.eventCode](state);\n      }\n\n      if (this.listeners.all) {\n        return this.listeners.all(state);\n      }\n    }\n  };\n}\n\nfunction networkName(blockchain, id) {\n  return networks[blockchain][id];\n}\n\nfunction serverEcho(eventCode) {\n  switch (eventCode) {\n    case 'txRequest':\n    case 'nsfFail':\n    case 'txRepeat':\n    case 'txAwaitingApproval':\n    case 'txConfirmReminder':\n    case 'txSendFail':\n    case 'txError':\n    case 'txUnderPriced':\n    case 'txSent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction last(arr) {\n  return arr.reverse()[0];\n} // isAddress and isTxid are not meant to perform real validation,\n// just needs to work out if it is an address or a transaction id\n// the server will do more thorough validation\n\n\nfunction isAddress(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 42;\n\n    case 'bitcoin':\n      return addressOrHash.length !== 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction isTxid(blockchain, addressOrHash) {\n  switch (blockchain) {\n    case 'ethereum':\n      return addressOrHash.length === 66;\n\n    case 'bitcoin':\n      return addressOrHash.length === 64;\n\n    default:\n      return false;\n  }\n}\n\nfunction wait(time) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time);\n  });\n}\n\nconst jsonPreserveUndefined = (k, v) => v === undefined ? 'undefined' : v;\n\nfunction transaction(hash, id) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // create startTime for transaction\n\n  const startTime = Date.now(); // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'txSent'; // put in queue\n\n  this._watchedTransactions.push({\n    hash,\n    emitter\n  });\n\n  const transaction = {\n    [this._system === 'ethereum' ? 'hash' : 'txid']: hash,\n    id: id || hash,\n    startTime,\n    status: 'sent'\n  };\n  const newState = { ...transaction,\n    eventCode\n  }; // logEvent to server\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'activeTransaction',\n    transaction\n  });\n\n  const transactionObj = {\n    details: newState,\n    emitter\n  };\n\n  function emitState() {\n    const emitterResult = emitter.emit(newState);\n\n    this._transactionHandlers.forEach(handler => handler({\n      transaction: newState,\n      emitterResult\n    }));\n  } // emit after delay to allow for listener to be registered\n\n\n  setTimeout(emitState.bind(this), 5);\n  return transactionObj;\n}\n\nfunction account(address) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.'); // lowercase the address if Ethereum\n\n  address = this._system === 'ethereum' ? address.toLowerCase() : address; // create emitter for transaction\n\n  const emitter = createEmitter(); // create eventCode for transaction\n\n  const eventCode = 'watch';\n\n  const existingAddressWatcher = this._watchedAccounts.find(ac => ac.address === address);\n\n  if (existingAddressWatcher) {\n    // add to existing emitters array\n    existingAddressWatcher.emitters.push(emitter);\n  } else {\n    // put in accounts queue\n    this._watchedAccounts.push({\n      address,\n      emitters: [emitter]\n    });\n  } // logEvent to server\n\n\n  this._sendMessage({\n    eventCode,\n    categoryCode: 'accountAddress',\n    account: {\n      address\n    }\n  });\n\n  return {\n    emitter,\n    details: {\n      address\n    }\n  };\n}\n\nfunction event(eventObj) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n\n  this._sendMessage(eventObj);\n}\n\nfunction unsubscribe(addressOrHash) {\n  if (this._destroyed) throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  const address = isAddress(this._system, addressOrHash);\n  const txid = isTxid(this._system, addressOrHash); // check if it is an address or a hash\n\n  if (address) {\n    const normalizedAddress = this._system === 'ethereum' ? addressOrHash.toLowerCase() : addressOrHash; // remove address from accounts\n\n    this._watchedAccounts = this._watchedAccounts.filter(ac => ac.address !== normalizedAddress); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'accountAddress',\n      eventCode: 'unwatch',\n      account: {\n        address: normalizedAddress\n      }\n    });\n  } else if (txid) {\n    // remove transaction from transactions\n    this._watchedTransactions = this._watchedTransactions.filter(tx => tx.hash !== addressOrHash); // logEvent to server\n\n    this._sendMessage({\n      categoryCode: 'activeTransaction',\n      eventCode: 'unwatch',\n      transaction: {\n        [this._system === 'ethereum' ? 'hash' : 'txid']: addressOrHash,\n        id: addressOrHash,\n        status: 'unsubscribed'\n      }\n    });\n  } else {\n    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);\n  }\n}\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isFunction(x) {\n  return typeof x === 'function';\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar _enable_super_gross_mode_that_will_cause_bad_things = false;\nvar config = {\n  Promise: undefined,\n\n  set useDeprecatedSynchronousErrorHandling(value) {\n    if (value) {\n      var error = /*@__PURE__*/new Error();\n      /*@__PURE__*/\n\n      console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n    }\n\n    _enable_super_gross_mode_that_will_cause_bad_things = value;\n  },\n\n  get useDeprecatedSynchronousErrorHandling() {\n    return _enable_super_gross_mode_that_will_cause_bad_things;\n  }\n\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nfunction hostReportError(err) {\n  setTimeout(function () {\n    throw err;\n  }, 0);\n}\n/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */\n\n\nvar empty = {\n  closed: true,\n  next: function (value) {},\n  error: function (err) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      throw err;\n    } else {\n      hostReportError(err);\n    }\n  },\n  complete: function () {}\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nvar isArray = /*@__PURE__*/function () {\n  return Array.isArray || function (x) {\n    return x && typeof x.length === 'number';\n  };\n}();\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isObject(x) {\n  return x !== null && typeof x === 'object';\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar UnsubscriptionErrorImpl = /*@__PURE__*/function () {\n  function UnsubscriptionErrorImpl(errors) {\n    Error.call(this);\n    this.message = errors ? errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) {\n      return i + 1 + \") \" + err.toString();\n    }).join('\\n  ') : '';\n    this.name = 'UnsubscriptionError';\n    this.errors = errors;\n    return this;\n  }\n\n  UnsubscriptionErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return UnsubscriptionErrorImpl;\n}();\n\nvar UnsubscriptionError = UnsubscriptionErrorImpl;\n/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */\n\nvar Subscription = /*@__PURE__*/function () {\n  function Subscription(unsubscribe) {\n    this.closed = false;\n    this._parentOrParents = null;\n    this._subscriptions = null;\n\n    if (unsubscribe) {\n      this._ctorUnsubscribe = true;\n      this._unsubscribe = unsubscribe;\n    }\n  }\n\n  Subscription.prototype.unsubscribe = function () {\n    var errors;\n\n    if (this.closed) {\n      return;\n    }\n\n    var _a = this,\n        _parentOrParents = _a._parentOrParents,\n        _ctorUnsubscribe = _a._ctorUnsubscribe,\n        _unsubscribe = _a._unsubscribe,\n        _subscriptions = _a._subscriptions;\n\n    this.closed = true;\n    this._parentOrParents = null;\n    this._subscriptions = null;\n\n    if (_parentOrParents instanceof Subscription) {\n      _parentOrParents.remove(this);\n    } else if (_parentOrParents !== null) {\n      for (var index = 0; index < _parentOrParents.length; ++index) {\n        var parent_1 = _parentOrParents[index];\n        parent_1.remove(this);\n      }\n    }\n\n    if (isFunction(_unsubscribe)) {\n      if (_ctorUnsubscribe) {\n        this._unsubscribe = undefined;\n      }\n\n      try {\n        _unsubscribe.call(this);\n      } catch (e) {\n        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];\n      }\n    }\n\n    if (isArray(_subscriptions)) {\n      var index = -1;\n      var len = _subscriptions.length;\n\n      while (++index < len) {\n        var sub = _subscriptions[index];\n\n        if (isObject(sub)) {\n          try {\n            sub.unsubscribe();\n          } catch (e) {\n            errors = errors || [];\n\n            if (e instanceof UnsubscriptionError) {\n              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));\n            } else {\n              errors.push(e);\n            }\n          }\n        }\n      }\n    }\n\n    if (errors) {\n      throw new UnsubscriptionError(errors);\n    }\n  };\n\n  Subscription.prototype.add = function (teardown) {\n    var subscription = teardown;\n\n    if (!teardown) {\n      return Subscription.EMPTY;\n    }\n\n    switch (typeof teardown) {\n      case 'function':\n        subscription = new Subscription(teardown);\n\n      case 'object':\n        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {\n          return subscription;\n        } else if (this.closed) {\n          subscription.unsubscribe();\n          return subscription;\n        } else if (!(subscription instanceof Subscription)) {\n          var tmp = subscription;\n          subscription = new Subscription();\n          subscription._subscriptions = [tmp];\n        }\n\n        break;\n\n      default:\n        {\n          throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n        }\n    }\n\n    var _parentOrParents = subscription._parentOrParents;\n\n    if (_parentOrParents === null) {\n      subscription._parentOrParents = this;\n    } else if (_parentOrParents instanceof Subscription) {\n      if (_parentOrParents === this) {\n        return subscription;\n      }\n\n      subscription._parentOrParents = [_parentOrParents, this];\n    } else if (_parentOrParents.indexOf(this) === -1) {\n      _parentOrParents.push(this);\n    } else {\n      return subscription;\n    }\n\n    var subscriptions = this._subscriptions;\n\n    if (subscriptions === null) {\n      this._subscriptions = [subscription];\n    } else {\n      subscriptions.push(subscription);\n    }\n\n    return subscription;\n  };\n\n  Subscription.prototype.remove = function (subscription) {\n    var subscriptions = this._subscriptions;\n\n    if (subscriptions) {\n      var subscriptionIndex = subscriptions.indexOf(subscription);\n\n      if (subscriptionIndex !== -1) {\n        subscriptions.splice(subscriptionIndex, 1);\n      }\n    }\n  };\n\n  Subscription.EMPTY = function (empty) {\n    empty.closed = true;\n    return empty;\n  }(new Subscription());\n\n  return Subscription;\n}();\n\nfunction flattenUnsubscriptionErrors(errors) {\n  return errors.reduce(function (errs, err) {\n    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);\n  }, []);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar rxSubscriber = /*@__PURE__*/function () {\n  return typeof Symbol === 'function' ? /*@__PURE__*/Symbol('rxSubscriber') : '@@rxSubscriber_' + /*@__PURE__*/Math.random();\n}();\n/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */\n\n\nvar Subscriber = /*@__PURE__*/function (_super) {\n  __extends(Subscriber, _super);\n\n  function Subscriber(destinationOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n\n    _this.syncErrorValue = null;\n    _this.syncErrorThrown = false;\n    _this.syncErrorThrowable = false;\n    _this.isStopped = false;\n\n    switch (arguments.length) {\n      case 0:\n        _this.destination = empty;\n        break;\n\n      case 1:\n        if (!destinationOrNext) {\n          _this.destination = empty;\n          break;\n        }\n\n        if (typeof destinationOrNext === 'object') {\n          if (destinationOrNext instanceof Subscriber) {\n            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n            _this.destination = destinationOrNext;\n            destinationOrNext.add(_this);\n          } else {\n            _this.syncErrorThrowable = true;\n            _this.destination = new SafeSubscriber(_this, destinationOrNext);\n          }\n\n          break;\n        }\n\n      default:\n        _this.syncErrorThrowable = true;\n        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\n        break;\n    }\n\n    return _this;\n  }\n\n  Subscriber.prototype[rxSubscriber] = function () {\n    return this;\n  };\n\n  Subscriber.create = function (next, error, complete) {\n    var subscriber = new Subscriber(next, error, complete);\n    subscriber.syncErrorThrowable = false;\n    return subscriber;\n  };\n\n  Subscriber.prototype.next = function (value) {\n    if (!this.isStopped) {\n      this._next(value);\n    }\n  };\n\n  Subscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._error(err);\n    }\n  };\n\n  Subscriber.prototype.complete = function () {\n    if (!this.isStopped) {\n      this.isStopped = true;\n\n      this._complete();\n    }\n  };\n\n  Subscriber.prototype.unsubscribe = function () {\n    if (this.closed) {\n      return;\n    }\n\n    this.isStopped = true;\n\n    _super.prototype.unsubscribe.call(this);\n  };\n\n  Subscriber.prototype._next = function (value) {\n    this.destination.next(value);\n  };\n\n  Subscriber.prototype._error = function (err) {\n    this.destination.error(err);\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._complete = function () {\n    this.destination.complete();\n    this.unsubscribe();\n  };\n\n  Subscriber.prototype._unsubscribeAndRecycle = function () {\n    var _parentOrParents = this._parentOrParents;\n    this._parentOrParents = null;\n    this.unsubscribe();\n    this.closed = false;\n    this.isStopped = false;\n    this._parentOrParents = _parentOrParents;\n    return this;\n  };\n\n  return Subscriber;\n}(Subscription);\n\nvar SafeSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SafeSubscriber, _super);\n\n  function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n    var _this = _super.call(this) || this;\n\n    _this._parentSubscriber = _parentSubscriber;\n    var next;\n    var context = _this;\n\n    if (isFunction(observerOrNext)) {\n      next = observerOrNext;\n    } else if (observerOrNext) {\n      next = observerOrNext.next;\n      error = observerOrNext.error;\n      complete = observerOrNext.complete;\n\n      if (observerOrNext !== empty) {\n        context = Object.create(observerOrNext);\n\n        if (isFunction(context.unsubscribe)) {\n          _this.add(context.unsubscribe.bind(context));\n        }\n\n        context.unsubscribe = _this.unsubscribe.bind(_this);\n      }\n    }\n\n    _this._context = context;\n    _this._next = next;\n    _this._error = error;\n    _this._complete = complete;\n    return _this;\n  }\n\n  SafeSubscriber.prototype.next = function (value) {\n    if (!this.isStopped && this._next) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n        this.__tryOrUnsub(this._next, value);\n      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.error = function (err) {\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;\n\n      if (this._error) {\n        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(this._error, err);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, this._error, err);\n\n          this.unsubscribe();\n        }\n      } else if (!_parentSubscriber.syncErrorThrowable) {\n        this.unsubscribe();\n\n        if (useDeprecatedSynchronousErrorHandling) {\n          throw err;\n        }\n\n        hostReportError(err);\n      } else {\n        if (useDeprecatedSynchronousErrorHandling) {\n          _parentSubscriber.syncErrorValue = err;\n          _parentSubscriber.syncErrorThrown = true;\n        } else {\n          hostReportError(err);\n        }\n\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.complete = function () {\n    var _this = this;\n\n    if (!this.isStopped) {\n      var _parentSubscriber = this._parentSubscriber;\n\n      if (this._complete) {\n        var wrappedComplete = function () {\n          return _this._complete.call(_this._context);\n        };\n\n        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n          this.__tryOrUnsub(wrappedComplete);\n\n          this.unsubscribe();\n        } else {\n          this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n\n          this.unsubscribe();\n        }\n      } else {\n        this.unsubscribe();\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      this.unsubscribe();\n\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        throw err;\n      } else {\n        hostReportError(err);\n      }\n    }\n  };\n\n  SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n    if (!config.useDeprecatedSynchronousErrorHandling) {\n      throw new Error('bad call');\n    }\n\n    try {\n      fn.call(this._context, value);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        parent.syncErrorValue = err;\n        parent.syncErrorThrown = true;\n        return true;\n      } else {\n        hostReportError(err);\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  SafeSubscriber.prototype._unsubscribe = function () {\n    var _parentSubscriber = this._parentSubscriber;\n    this._context = null;\n    this._parentSubscriber = null;\n\n    _parentSubscriber.unsubscribe();\n  };\n\n  return SafeSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */\n\n\nfunction canReportError(observer) {\n  while (observer) {\n    var _a = observer,\n        closed_1 = _a.closed,\n        destination = _a.destination,\n        isStopped = _a.isStopped;\n\n    if (closed_1 || isStopped) {\n      return false;\n    } else if (destination && destination instanceof Subscriber) {\n      observer = destination;\n    } else {\n      observer = null;\n    }\n  }\n\n  return true;\n}\n/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */\n\n\nfunction toSubscriber(nextOrObserver, error, complete) {\n  if (nextOrObserver) {\n    if (nextOrObserver instanceof Subscriber) {\n      return nextOrObserver;\n    }\n\n    if (nextOrObserver[rxSubscriber]) {\n      return nextOrObserver[rxSubscriber]();\n    }\n  }\n\n  if (!nextOrObserver && !error && !complete) {\n    return new Subscriber(empty);\n  }\n\n  return new Subscriber(nextOrObserver, error, complete);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar observable = /*@__PURE__*/function () {\n  return typeof Symbol === 'function' && Symbol.observable || '@@observable';\n}();\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction identity(x) {\n  return x;\n}\n/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */\n\n\nfunction pipeFromArray(fns) {\n  if (fns.length === 0) {\n    return identity;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input) {\n    return fns.reduce(function (prev, fn) {\n      return fn(prev);\n    }, input);\n  };\n}\n/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */\n\n\nvar Observable = /*@__PURE__*/function () {\n  function Observable(subscribe) {\n    this._isScalar = false;\n\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  Observable.prototype.lift = function (operator) {\n    var observable = new Observable();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  };\n\n  Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n    var operator = this.operator;\n    var sink = toSubscriber(observerOrNext, error, complete);\n\n    if (operator) {\n      sink.add(operator.call(sink, this.source));\n    } else {\n      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));\n    }\n\n    if (config.useDeprecatedSynchronousErrorHandling) {\n      if (sink.syncErrorThrowable) {\n        sink.syncErrorThrowable = false;\n\n        if (sink.syncErrorThrown) {\n          throw sink.syncErrorValue;\n        }\n      }\n    }\n\n    return sink;\n  };\n\n  Observable.prototype._trySubscribe = function (sink) {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      if (config.useDeprecatedSynchronousErrorHandling) {\n        sink.syncErrorThrown = true;\n        sink.syncErrorValue = err;\n      }\n\n      if (canReportError(sink)) {\n        sink.error(err);\n      } else {\n        console.warn(err);\n      }\n    }\n  };\n\n  Observable.prototype.forEach = function (next, promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      var subscription;\n      subscription = _this.subscribe(function (value) {\n        try {\n          next(value);\n        } catch (err) {\n          reject(err);\n\n          if (subscription) {\n            subscription.unsubscribe();\n          }\n        }\n      }, reject, resolve);\n    });\n  };\n\n  Observable.prototype._subscribe = function (subscriber) {\n    var source = this.source;\n    return source && source.subscribe(subscriber);\n  };\n\n  Observable.prototype[observable] = function () {\n    return this;\n  };\n\n  Observable.prototype.pipe = function () {\n    var operations = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      operations[_i] = arguments[_i];\n    }\n\n    if (operations.length === 0) {\n      return this;\n    }\n\n    return pipeFromArray(operations)(this);\n  };\n\n  Observable.prototype.toPromise = function (promiseCtor) {\n    var _this = this;\n\n    promiseCtor = getPromiseCtor(promiseCtor);\n    return new promiseCtor(function (resolve, reject) {\n      var value;\n\n      _this.subscribe(function (x) {\n        return value = x;\n      }, function (err) {\n        return reject(err);\n      }, function () {\n        return resolve(value);\n      });\n    });\n  };\n\n  Observable.create = function (subscribe) {\n    return new Observable(subscribe);\n  };\n\n  return Observable;\n}();\n\nfunction getPromiseCtor(promiseCtor) {\n  if (!promiseCtor) {\n    promiseCtor = Promise;\n  }\n\n  if (!promiseCtor) {\n    throw new Error('no Promise impl found');\n  }\n\n  return promiseCtor;\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar ObjectUnsubscribedErrorImpl = /*@__PURE__*/function () {\n  function ObjectUnsubscribedErrorImpl() {\n    Error.call(this);\n    this.message = 'object unsubscribed';\n    this.name = 'ObjectUnsubscribedError';\n    return this;\n  }\n\n  ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return ObjectUnsubscribedErrorImpl;\n}();\n\nvar ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n\nvar SubjectSubscription = /*@__PURE__*/function (_super) {\n  __extends(SubjectSubscription, _super);\n\n  function SubjectSubscription(subject, subscriber) {\n    var _this = _super.call(this) || this;\n\n    _this.subject = subject;\n    _this.subscriber = subscriber;\n    _this.closed = false;\n    return _this;\n  }\n\n  SubjectSubscription.prototype.unsubscribe = function () {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n    var subject = this.subject;\n    var observers = subject.observers;\n    this.subject = null;\n\n    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n      return;\n    }\n\n    var subscriberIndex = observers.indexOf(this.subscriber);\n\n    if (subscriberIndex !== -1) {\n      observers.splice(subscriberIndex, 1);\n    }\n  };\n\n  return SubjectSubscription;\n}(Subscription);\n/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */\n\n\nvar SubjectSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SubjectSubscriber, _super);\n\n  function SubjectSubscriber(destination) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.destination = destination;\n    return _this;\n  }\n\n  return SubjectSubscriber;\n}(Subscriber);\n\nvar Subject = /*@__PURE__*/function (_super) {\n  __extends(Subject, _super);\n\n  function Subject() {\n    var _this = _super.call(this) || this;\n\n    _this.observers = [];\n    _this.closed = false;\n    _this.isStopped = false;\n    _this.hasError = false;\n    _this.thrownError = null;\n    return _this;\n  }\n\n  Subject.prototype[rxSubscriber] = function () {\n    return new SubjectSubscriber(this);\n  };\n\n  Subject.prototype.lift = function (operator) {\n    var subject = new AnonymousSubject(this, this);\n    subject.operator = operator;\n    return subject;\n  };\n\n  Subject.prototype.next = function (value) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n\n    if (!this.isStopped) {\n      var observers = this.observers;\n      var len = observers.length;\n      var copy = observers.slice();\n\n      for (var i = 0; i < len; i++) {\n        copy[i].next(value);\n      }\n    }\n  };\n\n  Subject.prototype.error = function (err) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n\n    this.hasError = true;\n    this.thrownError = err;\n    this.isStopped = true;\n    var observers = this.observers;\n    var len = observers.length;\n    var copy = observers.slice();\n\n    for (var i = 0; i < len; i++) {\n      copy[i].error(err);\n    }\n\n    this.observers.length = 0;\n  };\n\n  Subject.prototype.complete = function () {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n\n    this.isStopped = true;\n    var observers = this.observers;\n    var len = observers.length;\n    var copy = observers.slice();\n\n    for (var i = 0; i < len; i++) {\n      copy[i].complete();\n    }\n\n    this.observers.length = 0;\n  };\n\n  Subject.prototype.unsubscribe = function () {\n    this.isStopped = true;\n    this.closed = true;\n    this.observers = null;\n  };\n\n  Subject.prototype._trySubscribe = function (subscriber) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else {\n      return _super.prototype._trySubscribe.call(this, subscriber);\n    }\n  };\n\n  Subject.prototype._subscribe = function (subscriber) {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.hasError) {\n      subscriber.error(this.thrownError);\n      return Subscription.EMPTY;\n    } else if (this.isStopped) {\n      subscriber.complete();\n      return Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      return new SubjectSubscription(this, subscriber);\n    }\n  };\n\n  Subject.prototype.asObservable = function () {\n    var observable = new Observable();\n    observable.source = this;\n    return observable;\n  };\n\n  Subject.create = function (destination, source) {\n    return new AnonymousSubject(destination, source);\n  };\n\n  return Subject;\n}(Observable);\n\nvar AnonymousSubject = /*@__PURE__*/function (_super) {\n  __extends(AnonymousSubject, _super);\n\n  function AnonymousSubject(destination, source) {\n    var _this = _super.call(this) || this;\n\n    _this.destination = destination;\n    _this.source = source;\n    return _this;\n  }\n\n  AnonymousSubject.prototype.next = function (value) {\n    var destination = this.destination;\n\n    if (destination && destination.next) {\n      destination.next(value);\n    }\n  };\n\n  AnonymousSubject.prototype.error = function (err) {\n    var destination = this.destination;\n\n    if (destination && destination.error) {\n      this.destination.error(err);\n    }\n  };\n\n  AnonymousSubject.prototype.complete = function () {\n    var destination = this.destination;\n\n    if (destination && destination.complete) {\n      this.destination.complete();\n    }\n  };\n\n  AnonymousSubject.prototype._subscribe = function (subscriber) {\n    var source = this.source;\n\n    if (source) {\n      return this.source.subscribe(subscriber);\n    } else {\n      return Subscription.EMPTY;\n    }\n  };\n\n  return AnonymousSubject;\n}(Subject);\n/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\n\n\nvar Action = /*@__PURE__*/function (_super) {\n  __extends(Action, _super);\n\n  function Action(scheduler, work) {\n    return _super.call(this) || this;\n  }\n\n  Action.prototype.schedule = function (state, delay) {\n    return this;\n  };\n\n  return Action;\n}(Subscription);\n/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */\n\n\nvar AsyncAction = /*@__PURE__*/function (_super) {\n  __extends(AsyncAction, _super);\n\n  function AsyncAction(scheduler, work) {\n    var _this = _super.call(this, scheduler, work) || this;\n\n    _this.scheduler = scheduler;\n    _this.work = work;\n    _this.pending = false;\n    return _this;\n  }\n\n  AsyncAction.prototype.schedule = function (state, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (this.closed) {\n      return this;\n    }\n\n    this.state = state;\n    var id = this.id;\n    var scheduler = this.scheduler;\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    this.pending = true;\n    this.delay = delay;\n    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n    return this;\n  };\n\n  AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return setInterval(scheduler.flush.bind(scheduler, this), delay);\n  };\n\n  AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (delay !== null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n\n    clearInterval(id);\n    return undefined;\n  };\n\n  AsyncAction.prototype.execute = function (state, delay) {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n\n    var error = this._execute(state, delay);\n\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  };\n\n  AsyncAction.prototype._execute = function (state, delay) {\n    var errored = false;\n    var errorValue = undefined;\n\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      errorValue = !!e && e || new Error(e);\n    }\n\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  };\n\n  AsyncAction.prototype._unsubscribe = function () {\n    var id = this.id;\n    var scheduler = this.scheduler;\n    var actions = scheduler.actions;\n    var index = actions.indexOf(this);\n    this.work = null;\n    this.state = null;\n    this.pending = false;\n    this.scheduler = null;\n\n    if (index !== -1) {\n      actions.splice(index, 1);\n    }\n\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, null);\n    }\n\n    this.delay = null;\n  };\n\n  return AsyncAction;\n}(Action);\n\nvar Scheduler = /*@__PURE__*/function () {\n  function Scheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    this.SchedulerAction = SchedulerAction;\n    this.now = now;\n  }\n\n  Scheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    return new this.SchedulerAction(this, work).schedule(state, delay);\n  };\n\n  Scheduler.now = function () {\n    return Date.now();\n  };\n\n  return Scheduler;\n}();\n/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\n\n\nvar AsyncScheduler = /*@__PURE__*/function (_super) {\n  __extends(AsyncScheduler, _super);\n\n  function AsyncScheduler(SchedulerAction, now) {\n    if (now === void 0) {\n      now = Scheduler.now;\n    }\n\n    var _this = _super.call(this, SchedulerAction, function () {\n      if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {\n        return AsyncScheduler.delegate.now();\n      } else {\n        return now();\n      }\n    }) || this;\n\n    _this.actions = [];\n    _this.active = false;\n    _this.scheduled = undefined;\n    return _this;\n  }\n\n  AsyncScheduler.prototype.schedule = function (work, delay, state) {\n    if (delay === void 0) {\n      delay = 0;\n    }\n\n    if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {\n      return AsyncScheduler.delegate.schedule(work, delay, state);\n    } else {\n      return _super.prototype.schedule.call(this, work, delay, state);\n    }\n  };\n\n  AsyncScheduler.prototype.flush = function (action) {\n    var actions = this.actions;\n\n    if (this.active) {\n      actions.push(action);\n      return;\n    }\n\n    var error;\n    this.active = true;\n\n    do {\n      if (error = action.execute(action.state, action.delay)) {\n        break;\n      }\n    } while (action = actions.shift());\n\n    this.active = false;\n\n    if (error) {\n      while (action = actions.shift()) {\n        action.unsubscribe();\n      }\n\n      throw error;\n    }\n  };\n\n  return AsyncScheduler;\n}(Scheduler);\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n\n\nvar EMPTY = /*@__PURE__*/new Observable(function (subscriber) {\n  return subscriber.complete();\n});\n\nfunction empty$1(scheduler) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler) {\n  return new Observable(function (subscriber) {\n    return scheduler.schedule(function () {\n      return subscriber.complete();\n    });\n  });\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar subscribeToArray = function (array) {\n  return function (subscriber) {\n    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n\n    subscriber.complete();\n  };\n};\n/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */\n\n\nfunction throwError(error, scheduler) {\n  if (!scheduler) {\n    return new Observable(function (subscriber) {\n      return subscriber.error(error);\n    });\n  } else {\n    return new Observable(function (subscriber) {\n      return scheduler.schedule(dispatch, 0, {\n        error: error,\n        subscriber: subscriber\n      });\n    });\n  }\n}\n\nfunction dispatch(_a) {\n  var error = _a.error,\n      subscriber = _a.subscriber;\n  subscriber.error(error);\n}\n/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */\n\n\nvar asyncScheduler = /*@__PURE__*/new AsyncScheduler(AsyncAction);\nvar async = asyncScheduler;\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nvar ArgumentOutOfRangeErrorImpl = /*@__PURE__*/function () {\n  function ArgumentOutOfRangeErrorImpl() {\n    Error.call(this);\n    this.message = 'argument out of range';\n    this.name = 'ArgumentOutOfRangeError';\n    return this;\n  }\n\n  ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return ArgumentOutOfRangeErrorImpl;\n}();\n\nvar ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\nvar TimeoutErrorImpl = /*@__PURE__*/function () {\n  function TimeoutErrorImpl() {\n    Error.call(this);\n    this.message = 'Timeout has occurred';\n    this.name = 'TimeoutError';\n    return this;\n  }\n\n  TimeoutErrorImpl.prototype = /*@__PURE__*/Object.create(Error.prototype);\n  return TimeoutErrorImpl;\n}();\n\nvar TimeoutError = TimeoutErrorImpl;\n/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */\n\nvar subscribeToPromise = function (promise) {\n  return function (subscriber) {\n    promise.then(function (value) {\n      if (!subscriber.closed) {\n        subscriber.next(value);\n        subscriber.complete();\n      }\n    }, function (err) {\n      return subscriber.error(err);\n    }).then(null, hostReportError);\n    return subscriber;\n  };\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction getSymbolIterator() {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator';\n  }\n\n  return Symbol.iterator;\n}\n\nvar iterator = /*@__PURE__*/getSymbolIterator();\n/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */\n\nvar subscribeToIterable = function (iterable) {\n  return function (subscriber) {\n    var iterator$1 = iterable[iterator]();\n\n    do {\n      var item = void 0;\n\n      try {\n        item = iterator$1.next();\n      } catch (err) {\n        subscriber.error(err);\n        return subscriber;\n      }\n\n      if (item.done) {\n        subscriber.complete();\n        break;\n      }\n\n      subscriber.next(item.value);\n\n      if (subscriber.closed) {\n        break;\n      }\n    } while (true);\n\n    if (typeof iterator$1.return === 'function') {\n      subscriber.add(function () {\n        if (iterator$1.return) {\n          iterator$1.return();\n        }\n      });\n    }\n\n    return subscriber;\n  };\n};\n/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */\n\n\nvar subscribeToObservable = function (obj) {\n  return function (subscriber) {\n    var obs = obj[observable]();\n\n    if (typeof obs.subscribe !== 'function') {\n      throw new TypeError('Provided object does not correctly implement Symbol.observable');\n    } else {\n      return obs.subscribe(subscriber);\n    }\n  };\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nvar isArrayLike = function (x) {\n  return x && typeof x.length === 'number' && typeof x !== 'function';\n};\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isPromise(value) {\n  return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';\n}\n/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */\n\n\nvar subscribeTo = function (result) {\n  if (!!result && typeof result[observable] === 'function') {\n    return subscribeToObservable(result);\n  } else if (isArrayLike(result)) {\n    return subscribeToArray(result);\n  } else if (isPromise(result)) {\n    return subscribeToPromise(result);\n  } else if (!!result && typeof result[iterator] === 'function') {\n    return subscribeToIterable(result);\n  } else {\n    var value = isObject(result) ? 'an invalid object' : \"'\" + result + \"'\";\n    var msg = \"You provided \" + value + \" where a stream was expected.\" + ' You can provide an Observable, Promise, Array, or Iterable.';\n    throw new TypeError(msg);\n  }\n};\n/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */\n\n\nvar SimpleInnerSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SimpleInnerSubscriber, _super);\n\n  function SimpleInnerSubscriber(parent) {\n    var _this = _super.call(this) || this;\n\n    _this.parent = parent;\n    return _this;\n  }\n\n  SimpleInnerSubscriber.prototype._next = function (value) {\n    this.parent.notifyNext(value);\n  };\n\n  SimpleInnerSubscriber.prototype._error = function (error) {\n    this.parent.notifyError(error);\n    this.unsubscribe();\n  };\n\n  SimpleInnerSubscriber.prototype._complete = function () {\n    this.parent.notifyComplete();\n    this.unsubscribe();\n  };\n\n  return SimpleInnerSubscriber;\n}(Subscriber);\n\nvar SimpleOuterSubscriber = /*@__PURE__*/function (_super) {\n  __extends(SimpleOuterSubscriber, _super);\n\n  function SimpleOuterSubscriber() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {\n    this.destination.next(innerValue);\n  };\n\n  SimpleOuterSubscriber.prototype.notifyError = function (err) {\n    this.destination.error(err);\n  };\n\n  SimpleOuterSubscriber.prototype.notifyComplete = function () {\n    this.destination.complete();\n  };\n\n  return SimpleOuterSubscriber;\n}(Subscriber);\n\nfunction innerSubscribe(result, innerSubscriber) {\n  if (innerSubscriber.closed) {\n    return undefined;\n  }\n\n  if (result instanceof Observable) {\n    return result.subscribe(innerSubscriber);\n  }\n\n  return subscribeTo(result)(innerSubscriber);\n}\n/** PURE_IMPORTS_START  PURE_IMPORTS_END */\n\n\nfunction isDate(value) {\n  return value instanceof Date && !isNaN(+value);\n}\n/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */\n\n\nfunction take(count) {\n  return function (source) {\n    if (count === 0) {\n      return empty$1();\n    } else {\n      return source.lift(new TakeOperator(count));\n    }\n  };\n}\n\nvar TakeOperator = /*@__PURE__*/function () {\n  function TakeOperator(total) {\n    this.total = total;\n\n    if (this.total < 0) {\n      throw new ArgumentOutOfRangeError();\n    }\n  }\n\n  TakeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TakeSubscriber(subscriber, this.total));\n  };\n\n  return TakeOperator;\n}();\n\nvar TakeSubscriber = /*@__PURE__*/function (_super) {\n  __extends(TakeSubscriber, _super);\n\n  function TakeSubscriber(destination, total) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.total = total;\n    _this.count = 0;\n    return _this;\n  }\n\n  TakeSubscriber.prototype._next = function (value) {\n    var total = this.total;\n    var count = ++this.count;\n\n    if (count <= total) {\n      this.destination.next(value);\n\n      if (count === total) {\n        this.destination.complete();\n        this.unsubscribe();\n      }\n    }\n  };\n\n  return TakeSubscriber;\n}(Subscriber);\n/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_innerSubscribe PURE_IMPORTS_END */\n\n\nfunction timeoutWith(due, withObservable, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return function (source) {\n    var absoluteTimeout = isDate(due);\n    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);\n    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));\n  };\n}\n\nvar TimeoutWithOperator = /*@__PURE__*/function () {\n  function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {\n    this.waitFor = waitFor;\n    this.absoluteTimeout = absoluteTimeout;\n    this.withObservable = withObservable;\n    this.scheduler = scheduler;\n  }\n\n  TimeoutWithOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));\n  };\n\n  return TimeoutWithOperator;\n}();\n\nvar TimeoutWithSubscriber = /*@__PURE__*/function (_super) {\n  __extends(TimeoutWithSubscriber, _super);\n\n  function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.absoluteTimeout = absoluteTimeout;\n    _this.waitFor = waitFor;\n    _this.withObservable = withObservable;\n    _this.scheduler = scheduler;\n\n    _this.scheduleTimeout();\n\n    return _this;\n  }\n\n  TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {\n    var withObservable = subscriber.withObservable;\n\n    subscriber._unsubscribeAndRecycle();\n\n    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));\n  };\n\n  TimeoutWithSubscriber.prototype.scheduleTimeout = function () {\n    var action = this.action;\n\n    if (action) {\n      this.action = action.schedule(this, this.waitFor);\n    } else {\n      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));\n    }\n  };\n\n  TimeoutWithSubscriber.prototype._next = function (value) {\n    if (!this.absoluteTimeout) {\n      this.scheduleTimeout();\n    }\n\n    _super.prototype._next.call(this, value);\n  };\n\n  TimeoutWithSubscriber.prototype._unsubscribe = function () {\n    this.action = undefined;\n    this.scheduler = null;\n    this.withObservable = null;\n  };\n\n  return TimeoutWithSubscriber;\n}(SimpleOuterSubscriber);\n/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */\n\n\nfunction timeout(due, scheduler) {\n  if (scheduler === void 0) {\n    scheduler = async;\n  }\n\n  return timeoutWith(due, throwError(new TimeoutError()), scheduler);\n}\n\nfunction configuration(config) {\n  if (this._destroyed) {\n    throw new Error('The WebSocket instance has been destroyed, re-initialize to continue making requests.');\n  }\n\n  const casedScope = this._system === 'ethereum' ? config.scope.toLowerCase() : config.scope; // resolve previous configuration if exists\n\n  const previousConfiguration = this._configurations.get(casedScope);\n\n  previousConfiguration && previousConfiguration.subscription && previousConfiguration.subscription.next();\n  const subscription = new Subject(); // create emitter for transaction\n\n  const emitter = config.watchAddress ? {\n    emitter: createEmitter()\n  } : {};\n\n  this._configurations.set(casedScope, { ...config,\n    ...emitter,\n    subscription\n  });\n\n  this._sendMessage({\n    categoryCode: 'configs',\n    eventCode: 'put',\n    config\n  });\n\n  return new Promise((resolve, reject) => {\n    subscription.pipe(take(1), timeout(5000)).subscribe({\n      next: () => resolve({ ...emitter,\n        details: {\n          config\n        }\n      }),\n      error: error => {\n        const message = error.message === 'Timeout has occurred' ? `Configuration with scope: ${config.scope} has been sent to the Blocknative server, but has not received a reply within 5 seconds.` : error.message;\n\n        if (this._onerror) {\n          this._onerror({\n            message\n          });\n\n          resolve(`Error: ${message}`);\n        } else {\n          reject(message);\n        }\n      }\n    });\n  });\n}\n\nvar version = \"3.4.1\";\n\nfunction sendMessage(msg) {\n  if (this._queuedMessages.length > QUEUE_LIMIT) {\n    throw new Error(`Queue limit of ${QUEUE_LIMIT} messages has been reached.`);\n  }\n\n  this._queuedMessages.push(createEventLog.bind(this)(msg));\n\n  if (!this._processingQueue) {\n    this._processQueue();\n  }\n}\n\nasync function processQueue() {\n  this._processingQueue = true;\n\n  if (!this._connected) {\n    await waitForConnectionOpen.bind(this)();\n  }\n\n  while (this._queuedMessages.length > 0) {\n    // small wait to allow response from server to take affect\n    await wait(1);\n\n    if (this._waitToRetry !== null) {\n      // have been rate limited so wait\n      await this._waitToRetry;\n      this._waitToRetry = null;\n    }\n\n    const msg = this._queuedMessages.shift();\n\n    const delay = this._limitRules.duration / this._limitRules.points * 1000;\n    await wait(delay);\n\n    this._socket.send(msg);\n  }\n\n  this._processingQueue = false;\n  this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n}\n\nfunction handleMessage(msg) {\n  const {\n    status,\n    reason,\n    event,\n    connectionId,\n    serverVersion,\n    retryMs,\n    limitRules,\n    blockedMsg\n  } = JSON.parse(msg.data);\n\n  if (connectionId) {\n    if (typeof window !== 'undefined') {\n      window.localStorage.setItem(this._storageKey, connectionId);\n    }\n\n    this._connectionId = connectionId;\n  } // handle any errors from the server\n\n\n  if (status === 'error') {\n    if (reason.includes('ratelimit') && !reason.match(/IP (PendingSimulation|Notification) ratelimit reached/)) {\n      this._waitToRetry = wait(retryMs);\n      this._limitRules = limitRules; // add blocked msg to the front of the queue\n\n      blockedMsg && this._queuedMessages.unshift(blockedMsg);\n      return;\n    }\n\n    if (reason.includes('not a valid API key')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('network not supported')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    }\n\n    if (reason.includes('maximum allowed amount')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin txid error\n\n\n    if (reason.includes('invalid txid')) {\n      const reason = `${event.transaction.txid} is an invalid txid`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.txid\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum transaction hash error\n\n\n    if (reason.includes('invalid hash')) {\n      const reason = `${event.transaction.hash} is an invalid transaction hash`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          transaction: event.transaction.hash\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle general address error\n\n\n    if (reason.includes('invalid address')) {\n      const reason = `${event.account.address} is an invalid address`;\n\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle bitcoin specific address error\n\n\n    if (reason.includes('not a valid Bitcoin')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle ethereum specific address error\n\n\n    if (reason.includes('not a valid Ethereum')) {\n      if (this._onerror) {\n        this._onerror({\n          message: reason,\n          account: event.account.address\n        });\n\n        return;\n      } else {\n        throw new Error(reason);\n      }\n    } // handle config error\n\n\n    if (event && event.config) {\n      const configuration = this._configurations.get(event.config.scope);\n\n      if (configuration && configuration.subscription) {\n        configuration.subscription.error({\n          message: reason\n        });\n      }\n\n      return;\n    } // throw error that comes back from the server without formatting the message\n\n\n    if (this._onerror) {\n      this._onerror({\n        message: reason\n      });\n\n      return;\n    } else {\n      throw new Error(reason);\n    }\n  }\n\n  if (event && event.config) {\n    const casedScope = this._system === 'ethereum' ? event.config.scope.toLowerCase() : event.config.scope;\n\n    const configuration = this._configurations.get(casedScope);\n\n    if (configuration && configuration.subscription) {\n      configuration.subscription.next();\n    }\n  }\n\n  if (event && event.transaction) {\n    const {\n      transaction,\n      eventCode,\n      contractCall,\n      timeStamp,\n      blockchain: {\n        system,\n        network\n      }\n    } = event; // flatten in to one object\n\n    const newState = this._system === 'ethereum' ? { ...transaction,\n      serverVersion,\n      eventCode,\n      timeStamp,\n      system,\n      network,\n      contractCall\n    } : { ...transaction,\n      serverVersion,\n      eventCode,\n      timeStamp,\n      system,\n      network\n    }; // ignore server echo and unsubscribe messages\n\n    if (serverEcho(eventCode) || transaction.status === 'unsubscribed') {\n      return;\n    } // replace originalHash to match webhook API\n\n\n    if (newState.originalHash) {\n      newState.replaceHash = newState.originalHash;\n      delete newState.originalHash;\n    } // replace status to match webhook API\n\n\n    if (eventCode === 'txSpeedUp' && newState.status !== 'speedup') {\n      newState.status = 'speedup';\n    } // replace status to match webhook API\n\n\n    if (eventCode === 'txCancel' && newState.status !== 'cancel') {\n      newState.status = 'cancel';\n    } // handle change of hash in speedup and cancel events\n\n\n    if (eventCode === 'txSpeedUp' || eventCode === 'txCancel') {\n      this._watchedTransactions = this._watchedTransactions.map(tx => {\n        if (tx.hash === newState.replaceHash) {\n          // reassign hash parameter in transaction queue to new hash or txid\n          tx.hash = transaction.hash || transaction.txid;\n        }\n\n        return tx;\n      });\n    }\n\n    const watchedAddress = transaction.watchedAddress && this._system === 'ethereum' ? transaction.watchedAddress.toLowerCase() : transaction.watchedAddress;\n\n    if (watchedAddress) {\n      const accountObj = this._watchedAccounts.find(ac => ac.address === watchedAddress);\n\n      const accountEmitterResult = accountObj ? last(accountObj.emitters.map(emitter => emitter.emit(newState))) : false;\n\n      const configuration = this._configurations.get(watchedAddress);\n\n      const emitterResult = configuration && configuration.emitter ? configuration.emitter.emit(newState) || accountEmitterResult : accountEmitterResult;\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    } else {\n      const transactionObj = this._watchedTransactions.find(tx => tx.hash === transaction.hash || transaction.txid);\n\n      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);\n\n      this._transactionHandlers.forEach(handler => handler({\n        transaction: newState,\n        emitterResult\n      }));\n    }\n  }\n}\n\nfunction createEventLog(msg) {\n  return JSON.stringify({\n    timeStamp: new Date().toISOString(),\n    dappId: this._dappId,\n    version,\n    appName: this._appName,\n    appVersion: this._appVersion,\n    blockchain: {\n      system: this._system,\n      network: networkName(this._system, this._networkId) || 'local'\n    },\n    ...msg\n  }, msg.categoryCode === 'configs' ? jsonPreserveUndefined : undefined);\n}\n\nfunction waitForConnectionOpen() {\n  return new Promise(resolve => {\n    const interval = setInterval(() => {\n      if (this._connected) {\n        setTimeout(resolve, 100);\n        clearInterval(interval);\n      }\n    });\n  });\n}\n\nfunction validateType(options) {\n  const {\n    name,\n    value,\n    type,\n    optional,\n    customValidation\n  } = options;\n\n  if (!optional && typeof value === 'undefined') {\n    throw new Error(`\"${name}\" is required`);\n  }\n\n  if (typeof value !== 'undefined' && (type === 'array' ? Array.isArray(type) : typeof value !== type)) {\n    throw new Error(`\"${name}\" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);\n  }\n\n  if (typeof value !== 'undefined' && customValidation && !customValidation(value)) {\n    throw new Error(`\"${value}\" is not a valid \"${name}\"`);\n  }\n}\n\nfunction validateOptions(options) {\n  validateType({\n    name: 'sdk options',\n    value: options,\n    type: 'object'\n  });\n  const {\n    dappId,\n    system,\n    name,\n    appVersion,\n    networkId,\n    transactionHandlers,\n    apiUrl,\n    ws,\n    onopen,\n    ondown,\n    onreopen,\n    onerror,\n    onclose,\n    ...otherParams\n  } = options;\n  invalidParams(otherParams, ['dappId', 'system', 'name', 'appVersion', 'networkId', 'transactionHandlers', 'apiUrl', 'ws', 'onopen', 'ondown', 'onreopen', 'onerror', 'onclose'], 'Initialization Options');\n  validateType({\n    name: 'dappId',\n    value: dappId,\n    type: 'string'\n  });\n  validateType({\n    name: 'system',\n    value: system,\n    type: 'string',\n    optional: true,\n    customValidation: validSystem\n  });\n  validateType({\n    name: 'name',\n    value: name,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'appVersion',\n    value: appVersion,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'networkId',\n    value: networkId,\n    type: 'number'\n  });\n  validateType({\n    name: 'transactionHandler',\n    value: transactionHandlers,\n    type: 'array',\n    optional: true\n  });\n\n  if (transactionHandlers) {\n    transactionHandlers.forEach(handler => validateType({\n      name: 'transactionHandler',\n      value: handler,\n      type: 'function'\n    }));\n  }\n\n  validateType({\n    name: 'apiUrl',\n    value: apiUrl,\n    type: 'string',\n    optional: true\n  });\n  validateType({\n    name: 'ws',\n    value: ws,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onopen',\n    value: onopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'ondown',\n    value: ondown,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onreopen',\n    value: onreopen,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onerror',\n    value: onerror,\n    type: 'function',\n    optional: true\n  });\n  validateType({\n    name: 'onclose',\n    value: onclose,\n    type: 'function',\n    optional: true\n  });\n}\n\nfunction validSystem(system) {\n  return !!networks[system];\n}\n\nfunction invalidParams(params, validParams, functionName) {\n  const invalid = Object.keys(params);\n\n  if (invalid.length > 0) {\n    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(', ')}`);\n  }\n}\n\nconst DEFAULT_APP_NAME = 'unknown';\nconst DEFAULT_APP_VERSION = 'unknown';\nconst DEFAULT_SYSTEM = 'ethereum';\n\nclass Blocknative {\n  constructor(options) {\n    validateOptions(options);\n    const {\n      dappId,\n      system = DEFAULT_SYSTEM,\n      name = DEFAULT_APP_NAME,\n      appVersion = DEFAULT_APP_VERSION,\n      networkId,\n      transactionHandlers = [],\n      apiUrl,\n      ws,\n      onopen,\n      ondown,\n      onreopen,\n      onerror,\n      onclose\n    } = options;\n    const socket = new sturdy_websocket__WEBPACK_IMPORTED_MODULE_0__.default(apiUrl || 'wss://api.blocknative.com/v0', ws ? {\n      wsConstructor: ws\n    } : {});\n    socket.onopen = onOpen.bind(this, onopen);\n    socket.ondown = onDown.bind(this, ondown);\n    socket.onreopen = onReopen.bind(this, onreopen);\n    socket.onmessage = handleMessage.bind(this);\n\n    socket.onerror = error => onerror && onerror({\n      message: 'There was a WebSocket error',\n      error\n    });\n\n    socket.onclose = () => {\n      this._pingTimeout && clearInterval(this._pingTimeout);\n      onclose && onclose();\n    };\n\n    const storageKey = crypto_es__WEBPACK_IMPORTED_MODULE_1__.default.SHA1(`${dappId} - ${name}`).toString();\n    const storedConnectionId = typeof window !== 'undefined' && window.localStorage.getItem(storageKey);\n    this._storageKey = storageKey;\n    this._connectionId = storedConnectionId || undefined;\n    this._dappId = dappId;\n    this._system = system;\n    this._networkId = networkId;\n    this._appName = name;\n    this._appVersion = appVersion;\n    this._transactionHandlers = transactionHandlers;\n    this._socket = socket;\n    this._connected = false;\n    this._sendMessage = sendMessage.bind(this);\n    this._watchedTransactions = [];\n    this._watchedAccounts = [];\n    this._configurations = new Map();\n    this._pingTimeout = undefined;\n    this._destroyed = false;\n    this._onerror = onerror;\n    this._queuedMessages = [];\n    this._limitRules = DEFAULT_RATE_LIMIT_RULES;\n    this._waitToRetry = null;\n    this._processingQueue = false;\n    this._processQueue = processQueue.bind(this);\n\n    if (this._socket.ws.on) {\n      this._heartbeat = () => {\n        this._pingTimeout && clearTimeout(this._pingTimeout);\n        this._pingTimeout = setTimeout(() => {\n          // terminate connection if we haven't heard the server ping after server timeout plus conservative latency delay\n          // Sturdy Websocket will handle the new connection logic\n          this._socket.ws.terminate();\n        }, 30000 + 1000);\n      };\n\n      this._socket.ws.on('ping', () => {\n        this._heartbeat && this._heartbeat();\n      });\n    } // public API\n\n\n    this.transaction = transaction.bind(this);\n    this.account = account.bind(this);\n    this.event = event.bind(this);\n    this.unsubscribe = unsubscribe.bind(this);\n    this.configuration = configuration.bind(this);\n\n    this.destroy = () => {\n      this._socket.close();\n\n      this._destroyed = true; // call onclose manually here as SturdyWebSocket doesn't currently work as expected\n      // https://github.com/dphilipson/sturdy-websocket/issues/5\n\n      this._socket.onclose();\n    };\n  }\n\n}\n\nfunction onOpen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  }; // send this message directly rather than put in queue\n\n  this._socket.send(createEventLog.bind(this)(msg));\n\n  this._heartbeat && this._heartbeat();\n  handler && handler();\n}\n\nfunction onDown(handler, closeEvent) {\n  this._connected = false;\n\n  if (handler) {\n    handler(closeEvent);\n  }\n\n  this._pingTimeout && clearTimeout(this._pingTimeout);\n}\n\nasync function onReopen(handler) {\n  this._connected = true;\n  const msg = {\n    categoryCode: 'initialize',\n    eventCode: 'checkDappId',\n    connectionId: this._connectionId\n  };\n\n  this._socket.send(createEventLog.bind(this)(msg)); // re-register all configurations on re-connection\n\n\n  const configurations = Array.from(this._configurations.values()); // register global config first and wait for it to complete\n\n  const globalConfiguration = this._configurations.get('global');\n\n  if (globalConfiguration) {\n    try {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const {\n        emitter,\n        subscription,\n        ...config\n      } = globalConfiguration;\n      await this.configuration(config);\n    } catch (error) {\n      console.warn('Error re-sending global configuration upon reconnection:', error);\n    }\n  }\n\n  const addressConfigurations = configurations.filter(({\n    scope\n  }) => scope !== 'global');\n  addressConfigurations.forEach(enhancedConfig => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {\n      emitter,\n      subscription,\n      ...config\n    } = enhancedConfig;\n\n    this._sendMessage({\n      categoryCode: 'configs',\n      eventCode: 'put',\n      config\n    });\n  }); // re-register all accounts to be watched by server upon\n  // re-connection as they don't get transferred over automatically\n  // to the new connection like tx hashes do\n\n  this._watchedAccounts.forEach(account => {\n    this._sendMessage({\n      eventCode: 'accountAddress',\n      categoryCode: 'watch',\n      account: {\n        address: account.address\n      }\n    });\n  });\n\n  if (handler) {\n    handler();\n  }\n\n  if (this._socket.ws.on) {\n    // need to re-register ping event since new connection\n    this._socket.ws.on('ping', () => {\n      this._heartbeat && this._heartbeat();\n    });\n\n    this._heartbeat();\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Blocknative);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JuYy1zZGsvZGlzdC9lc20vaW5kZXguanM/ZmQzMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBK0M7QUFDZDtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QyxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQSxnSUFBZ0k7O0FBRWhJLCtCQUErQjs7QUFFL0Isa0NBQWtDOztBQUVsQyw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7O0FBR0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0lBQWdJOztBQUVoSSwwRUFBMEU7O0FBRTFFLGtDQUFrQzs7QUFFbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQSx3R0FBd0c7O0FBRXhHLGlHQUFpRzs7QUFFakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBLGtHQUFrRzs7QUFFbEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0gsbURBQW1ELGNBQWM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUIsaUNBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFNBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUNEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsdUNBQXVDLCtCQUErQjtBQUN0RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7QUFDRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2RkFBNkY7O0FBRTdGOztBQUVBO0FBQ0EscUNBQXFDOztBQUVyQztBQUNBO0FBQ0EsR0FBRzs7QUFFSCx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsZ0dBQWdHLGFBQWE7O0FBRTdHO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVgsNEJBQTRCLFFBQVE7QUFDcEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxZQUFZO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSx3QkFBd0IsdUJBQXVCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0Esd0JBQXdCLHVCQUF1Qjs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLHdCQUF3QixzQkFBc0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFNBQVM7O0FBRWQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7OztBQUdMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFD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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLCtEQUFlLFdBQVcsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9ibmMtc2RrL2Rpc3QvZXNtL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN0dXJkeVdlYlNvY2tldCBmcm9tICdzdHVyZHktd2Vic29ja2V0JztcbmltcG9ydCBDcnlwdG9FcyBmcm9tICdjcnlwdG8tZXMnO1xuY29uc3QgbmV0d29ya3MgPSB7XG4gIGJpdGNvaW46IHtcbiAgICAnMSc6ICdtYWluJyxcbiAgICAnMic6ICd0ZXN0bmV0J1xuICB9LFxuICBldGhlcmV1bToge1xuICAgICcxJzogJ21haW4nLFxuICAgICczJzogJ3JvcHN0ZW4nLFxuICAgICc0JzogJ3JpbmtlYnknLFxuICAgICc1JzogJ2dvZXJsaScsXG4gICAgJzQyJzogJ2tvdmFuJyxcbiAgICAnNTYnOiAnYnNjLW1haW4nLFxuICAgICcxMDAnOiAneGRhaSdcbiAgfVxufTtcbmNvbnN0IERFRkFVTFRfUkFURV9MSU1JVF9SVUxFUyA9IHtcbiAgcG9pbnRzOiAxNTAsXG4gIGR1cmF0aW9uOiAxXG59O1xuY29uc3QgUVVFVUVfTElNSVQgPSAxMDAwMDtcblxuZnVuY3Rpb24gY3JlYXRlRW1pdHRlcigpIHtcbiAgcmV0dXJuIHtcbiAgICBsaXN0ZW5lcnM6IHt9LFxuICAgIG9uOiBmdW5jdGlvbiAoZXZlbnRDb2RlLCBsaXN0ZW5lcikge1xuICAgICAgLy8gY2hlY2sgaWYgdmFsaWQgZXZlbnRDb2RlXG4gICAgICBzd2l0Y2ggKGV2ZW50Q29kZSkge1xuICAgICAgICBjYXNlICd0eFNlbnQnOlxuICAgICAgICBjYXNlICd0eFBvb2wnOlxuICAgICAgICBjYXNlICd0eENvbmZpcm1lZCc6XG4gICAgICAgIGNhc2UgJ3R4U3BlZWRVcCc6XG4gICAgICAgIGNhc2UgJ3R4Q2FuY2VsJzpcbiAgICAgICAgY2FzZSAndHhGYWlsZWQnOlxuICAgICAgICBjYXNlICd0eERyb3BwZWQnOlxuICAgICAgICBjYXNlICd0eFJlcXVlc3QnOlxuICAgICAgICBjYXNlICduc2ZGYWlsJzpcbiAgICAgICAgY2FzZSAndHhSZXBlYXQnOlxuICAgICAgICBjYXNlICd0eEF3YWl0aW5nQXBwcm92YWwnOlxuICAgICAgICBjYXNlICd0eENvbmZpcm1SZW1pbmRlcic6XG4gICAgICAgIGNhc2UgJ3R4U2VuZEZhaWwnOlxuICAgICAgICBjYXNlICd0eEVycm9yJzpcbiAgICAgICAgY2FzZSAndHhVbmRlclByaWNlZCc6XG4gICAgICAgIGNhc2UgJ3R4UG9vbFNpbXVsYXRpb24nOlxuICAgICAgICBjYXNlICdhbGwnOlxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2V2ZW50Q29kZX0gaXMgbm90IGEgdmFsaWQgZXZlbnQgY29kZSwgZm9yIGEgbGlzdCBvZiB2YWxpZCBldmVudCBjb2RlcyBzZWU6IGh0dHBzOi8vZG9jcy5ibG9ja25hdGl2ZS5jb20vbm90aWZ5LXNkayNldmVudC1jb2Rlc2ApO1xuICAgICAgfSAvLyBjaGVjayB0aGF0IGxpc3RlbmVyIGlzIGEgZnVuY3Rpb25cblxuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICB9IC8vIGFkZCBsaXN0ZW5lciBmb3IgdGhlIGV2ZW50Q29kZVxuXG5cbiAgICAgIHRoaXMubGlzdGVuZXJzW2V2ZW50Q29kZV0gPSBsaXN0ZW5lcjtcbiAgICB9LFxuICAgIG9mZjogZnVuY3Rpb24gKGV2ZW50Q29kZSkge1xuICAgICAgZGVsZXRlIHRoaXMubGlzdGVuZXJzW2V2ZW50Q29kZV07XG4gICAgfSxcbiAgICBlbWl0OiBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgIGlmICh0aGlzLmxpc3RlbmVyc1tzdGF0ZS5ldmVudENvZGVdKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyc1tzdGF0ZS5ldmVudENvZGVdKHN0YXRlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubGlzdGVuZXJzLmFsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lcnMuYWxsKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5ldHdvcmtOYW1lKGJsb2NrY2hhaW4sIGlkKSB7XG4gIHJldHVybiBuZXR3b3Jrc1tibG9ja2NoYWluXVtpZF07XG59XG5cbmZ1bmN0aW9uIHNlcnZlckVjaG8oZXZlbnRDb2RlKSB7XG4gIHN3aXRjaCAoZXZlbnRDb2RlKSB7XG4gICAgY2FzZSAndHhSZXF1ZXN0JzpcbiAgICBjYXNlICduc2ZGYWlsJzpcbiAgICBjYXNlICd0eFJlcGVhdCc6XG4gICAgY2FzZSAndHhBd2FpdGluZ0FwcHJvdmFsJzpcbiAgICBjYXNlICd0eENvbmZpcm1SZW1pbmRlcic6XG4gICAgY2FzZSAndHhTZW5kRmFpbCc6XG4gICAgY2FzZSAndHhFcnJvcic6XG4gICAgY2FzZSAndHhVbmRlclByaWNlZCc6XG4gICAgY2FzZSAndHhTZW50JzpcbiAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsYXN0KGFycikge1xuICByZXR1cm4gYXJyLnJldmVyc2UoKVswXTtcbn0gLy8gaXNBZGRyZXNzIGFuZCBpc1R4aWQgYXJlIG5vdCBtZWFudCB0byBwZXJmb3JtIHJlYWwgdmFsaWRhdGlvbixcbi8vIGp1c3QgbmVlZHMgdG8gd29yayBvdXQgaWYgaXQgaXMgYW4gYWRkcmVzcyBvciBhIHRyYW5zYWN0aW9uIGlkXG4vLyB0aGUgc2VydmVyIHdpbGwgZG8gbW9yZSB0aG9yb3VnaCB2YWxpZGF0aW9uXG5cblxuZnVuY3Rpb24gaXNBZGRyZXNzKGJsb2NrY2hhaW4sIGFkZHJlc3NPckhhc2gpIHtcbiAgc3dpdGNoIChibG9ja2NoYWluKSB7XG4gICAgY2FzZSAnZXRoZXJldW0nOlxuICAgICAgcmV0dXJuIGFkZHJlc3NPckhhc2gubGVuZ3RoID09PSA0MjtcblxuICAgIGNhc2UgJ2JpdGNvaW4nOlxuICAgICAgcmV0dXJuIGFkZHJlc3NPckhhc2gubGVuZ3RoICE9PSA2NDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNUeGlkKGJsb2NrY2hhaW4sIGFkZHJlc3NPckhhc2gpIHtcbiAgc3dpdGNoIChibG9ja2NoYWluKSB7XG4gICAgY2FzZSAnZXRoZXJldW0nOlxuICAgICAgcmV0dXJuIGFkZHJlc3NPckhhc2gubGVuZ3RoID09PSA2NjtcblxuICAgIGNhc2UgJ2JpdGNvaW4nOlxuICAgICAgcmV0dXJuIGFkZHJlc3NPckhhc2gubGVuZ3RoID09PSA2NDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FpdCh0aW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWUpO1xuICB9KTtcbn1cblxuY29uc3QganNvblByZXNlcnZlVW5kZWZpbmVkID0gKGssIHYpID0+IHYgPT09IHVuZGVmaW5lZCA/ICd1bmRlZmluZWQnIDogdjtcblxuZnVuY3Rpb24gdHJhbnNhY3Rpb24oaGFzaCwgaWQpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgV2ViU29ja2V0IGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCwgcmUtaW5pdGlhbGl6ZSB0byBjb250aW51ZSBtYWtpbmcgcmVxdWVzdHMuJyk7IC8vIGNyZWF0ZSBzdGFydFRpbWUgZm9yIHRyYW5zYWN0aW9uXG5cbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTsgLy8gY3JlYXRlIGVtaXR0ZXIgZm9yIHRyYW5zYWN0aW9uXG5cbiAgY29uc3QgZW1pdHRlciA9IGNyZWF0ZUVtaXR0ZXIoKTsgLy8gY3JlYXRlIGV2ZW50Q29kZSBmb3IgdHJhbnNhY3Rpb25cblxuICBjb25zdCBldmVudENvZGUgPSAndHhTZW50JzsgLy8gcHV0IGluIHF1ZXVlXG5cbiAgdGhpcy5fd2F0Y2hlZFRyYW5zYWN0aW9ucy5wdXNoKHtcbiAgICBoYXNoLFxuICAgIGVtaXR0ZXJcbiAgfSk7XG5cbiAgY29uc3QgdHJhbnNhY3Rpb24gPSB7XG4gICAgW3RoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/ICdoYXNoJyA6ICd0eGlkJ106IGhhc2gsXG4gICAgaWQ6IGlkIHx8IGhhc2gsXG4gICAgc3RhcnRUaW1lLFxuICAgIHN0YXR1czogJ3NlbnQnXG4gIH07XG4gIGNvbnN0IG5ld1N0YXRlID0geyAuLi50cmFuc2FjdGlvbixcbiAgICBldmVudENvZGVcbiAgfTsgLy8gbG9nRXZlbnQgdG8gc2VydmVyXG5cbiAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgIGV2ZW50Q29kZSxcbiAgICBjYXRlZ29yeUNvZGU6ICdhY3RpdmVUcmFuc2FjdGlvbicsXG4gICAgdHJhbnNhY3Rpb25cbiAgfSk7XG5cbiAgY29uc3QgdHJhbnNhY3Rpb25PYmogPSB7XG4gICAgZGV0YWlsczogbmV3U3RhdGUsXG4gICAgZW1pdHRlclxuICB9O1xuXG4gIGZ1bmN0aW9uIGVtaXRTdGF0ZSgpIHtcbiAgICBjb25zdCBlbWl0dGVyUmVzdWx0ID0gZW1pdHRlci5lbWl0KG5ld1N0YXRlKTtcblxuICAgIHRoaXMuX3RyYW5zYWN0aW9uSGFuZGxlcnMuZm9yRWFjaChoYW5kbGVyID0+IGhhbmRsZXIoe1xuICAgICAgdHJhbnNhY3Rpb246IG5ld1N0YXRlLFxuICAgICAgZW1pdHRlclJlc3VsdFxuICAgIH0pKTtcbiAgfSAvLyBlbWl0IGFmdGVyIGRlbGF5IHRvIGFsbG93IGZvciBsaXN0ZW5lciB0byBiZSByZWdpc3RlcmVkXG5cblxuICBzZXRUaW1lb3V0KGVtaXRTdGF0ZS5iaW5kKHRoaXMpLCA1KTtcbiAgcmV0dXJuIHRyYW5zYWN0aW9uT2JqO1xufVxuXG5mdW5jdGlvbiBhY2NvdW50KGFkZHJlc3MpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgV2ViU29ja2V0IGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCwgcmUtaW5pdGlhbGl6ZSB0byBjb250aW51ZSBtYWtpbmcgcmVxdWVzdHMuJyk7IC8vIGxvd2VyY2FzZSB0aGUgYWRkcmVzcyBpZiBFdGhlcmV1bVxuXG4gIGFkZHJlc3MgPSB0aGlzLl9zeXN0ZW0gPT09ICdldGhlcmV1bScgPyBhZGRyZXNzLnRvTG93ZXJDYXNlKCkgOiBhZGRyZXNzOyAvLyBjcmVhdGUgZW1pdHRlciBmb3IgdHJhbnNhY3Rpb25cblxuICBjb25zdCBlbWl0dGVyID0gY3JlYXRlRW1pdHRlcigpOyAvLyBjcmVhdGUgZXZlbnRDb2RlIGZvciB0cmFuc2FjdGlvblxuXG4gIGNvbnN0IGV2ZW50Q29kZSA9ICd3YXRjaCc7XG5cbiAgY29uc3QgZXhpc3RpbmdBZGRyZXNzV2F0Y2hlciA9IHRoaXMuX3dhdGNoZWRBY2NvdW50cy5maW5kKGFjID0+IGFjLmFkZHJlc3MgPT09IGFkZHJlc3MpO1xuXG4gIGlmIChleGlzdGluZ0FkZHJlc3NXYXRjaGVyKSB7XG4gICAgLy8gYWRkIHRvIGV4aXN0aW5nIGVtaXR0ZXJzIGFycmF5XG4gICAgZXhpc3RpbmdBZGRyZXNzV2F0Y2hlci5lbWl0dGVycy5wdXNoKGVtaXR0ZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHB1dCBpbiBhY2NvdW50cyBxdWV1ZVxuICAgIHRoaXMuX3dhdGNoZWRBY2NvdW50cy5wdXNoKHtcbiAgICAgIGFkZHJlc3MsXG4gICAgICBlbWl0dGVyczogW2VtaXR0ZXJdXG4gICAgfSk7XG4gIH0gLy8gbG9nRXZlbnQgdG8gc2VydmVyXG5cblxuICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgZXZlbnRDb2RlLFxuICAgIGNhdGVnb3J5Q29kZTogJ2FjY291bnRBZGRyZXNzJyxcbiAgICBhY2NvdW50OiB7XG4gICAgICBhZGRyZXNzXG4gICAgfVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGVtaXR0ZXIsXG4gICAgZGV0YWlsczoge1xuICAgICAgYWRkcmVzc1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZXZlbnQoZXZlbnRPYmopIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkgdGhyb3cgbmV3IEVycm9yKCdUaGUgV2ViU29ja2V0IGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCwgcmUtaW5pdGlhbGl6ZSB0byBjb250aW51ZSBtYWtpbmcgcmVxdWVzdHMuJyk7XG5cbiAgdGhpcy5fc2VuZE1lc3NhZ2UoZXZlbnRPYmopO1xufVxuXG5mdW5jdGlvbiB1bnN1YnNjcmliZShhZGRyZXNzT3JIYXNoKSB7XG4gIGlmICh0aGlzLl9kZXN0cm95ZWQpIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpO1xuICBjb25zdCBhZGRyZXNzID0gaXNBZGRyZXNzKHRoaXMuX3N5c3RlbSwgYWRkcmVzc09ySGFzaCk7XG4gIGNvbnN0IHR4aWQgPSBpc1R4aWQodGhpcy5fc3lzdGVtLCBhZGRyZXNzT3JIYXNoKTsgLy8gY2hlY2sgaWYgaXQgaXMgYW4gYWRkcmVzcyBvciBhIGhhc2hcblxuICBpZiAoYWRkcmVzcykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRBZGRyZXNzID0gdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8gYWRkcmVzc09ySGFzaC50b0xvd2VyQ2FzZSgpIDogYWRkcmVzc09ySGFzaDsgLy8gcmVtb3ZlIGFkZHJlc3MgZnJvbSBhY2NvdW50c1xuXG4gICAgdGhpcy5fd2F0Y2hlZEFjY291bnRzID0gdGhpcy5fd2F0Y2hlZEFjY291bnRzLmZpbHRlcihhYyA9PiBhYy5hZGRyZXNzICE9PSBub3JtYWxpemVkQWRkcmVzcyk7IC8vIGxvZ0V2ZW50IHRvIHNlcnZlclxuXG4gICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgY2F0ZWdvcnlDb2RlOiAnYWNjb3VudEFkZHJlc3MnLFxuICAgICAgZXZlbnRDb2RlOiAndW53YXRjaCcsXG4gICAgICBhY2NvdW50OiB7XG4gICAgICAgIGFkZHJlc3M6IG5vcm1hbGl6ZWRBZGRyZXNzXG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAodHhpZCkge1xuICAgIC8vIHJlbW92ZSB0cmFuc2FjdGlvbiBmcm9tIHRyYW5zYWN0aW9uc1xuICAgIHRoaXMuX3dhdGNoZWRUcmFuc2FjdGlvbnMgPSB0aGlzLl93YXRjaGVkVHJhbnNhY3Rpb25zLmZpbHRlcih0eCA9PiB0eC5oYXNoICE9PSBhZGRyZXNzT3JIYXNoKTsgLy8gbG9nRXZlbnQgdG8gc2VydmVyXG5cbiAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICBjYXRlZ29yeUNvZGU6ICdhY3RpdmVUcmFuc2FjdGlvbicsXG4gICAgICBldmVudENvZGU6ICd1bndhdGNoJyxcbiAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgIFt0aGlzLl9zeXN0ZW0gPT09ICdldGhlcmV1bScgPyAnaGFzaCcgOiAndHhpZCddOiBhZGRyZXNzT3JIYXNoLFxuICAgICAgICBpZDogYWRkcmVzc09ySGFzaCxcbiAgICAgICAgc3RhdHVzOiAndW5zdWJzY3JpYmVkJ1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgdHJ5aW5nIHRvIHVuc3Vic2NyaWJlICR7YWRkcmVzc09ySGFzaH06IG5vdCBhIHZhbGlkIGFkZHJlc3Mgb3IgdHJhbnNhY3Rpb24gaWQvaGFzaGApO1xuICB9XG59XG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZVxyXG50aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZVxyXG5MaWNlbnNlIGF0IGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVEhJUyBDT0RFIElTIFBST1ZJREVEIE9OIEFOICpBUyBJUyogQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxyXG5LSU5ELCBFSVRIRVIgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgV0lUSE9VVCBMSU1JVEFUSU9OIEFOWSBJTVBMSUVEXHJcbldBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBUSVRMRSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsXHJcbk1FUkNIQU5UQUJMSVRZIE9SIE5PTi1JTkZSSU5HRU1FTlQuXHJcblxyXG5TZWUgdGhlIEFwYWNoZSBWZXJzaW9uIDIuMCBMaWNlbnNlIGZvciBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnNcclxuYW5kIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xuXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCB7XG4gICAgX19wcm90b19fOiBbXVxuICB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBkLl9fcHJvdG9fXyA9IGI7XG4gIH0gfHwgZnVuY3Rpb24gKGQsIGIpIHtcbiAgICBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTtcbiAgfTtcblxuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XG4gIGV4dGVuZFN0YXRpY3MoZCwgYik7XG5cbiAgZnVuY3Rpb24gX18oKSB7XG4gICAgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7XG4gIH1cblxuICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgX2VuYWJsZV9zdXBlcl9ncm9zc19tb2RlX3RoYXRfd2lsbF9jYXVzZV9iYWRfdGhpbmdzID0gZmFsc2U7XG52YXIgY29uZmlnID0ge1xuICBQcm9taXNlOiB1bmRlZmluZWQsXG5cbiAgc2V0IHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcodmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHZhciBlcnJvciA9IC8qQF9fUFVSRV9fKi9uZXcgRXJyb3IoKTtcbiAgICAgIC8qQF9fUFVSRV9fKi9cblxuICAgICAgY29uc29sZS53YXJuKCdERVBSRUNBVEVEISBSeEpTIHdhcyBzZXQgdG8gdXNlIGRlcHJlY2F0ZWQgc3luY2hyb25vdXMgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IgYnkgY29kZSBhdDogXFxuJyArIGVycm9yLnN0YWNrKTtcbiAgICB9XG5cbiAgICBfZW5hYmxlX3N1cGVyX2dyb3NzX21vZGVfdGhhdF93aWxsX2NhdXNlX2JhZF90aGluZ3MgPSB2YWx1ZTtcbiAgfSxcblxuICBnZXQgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZygpIHtcbiAgICByZXR1cm4gX2VuYWJsZV9zdXBlcl9ncm9zc19tb2RlX3RoYXRfd2lsbF9jYXVzZV9iYWRfdGhpbmdzO1xuICB9XG5cbn07XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cbmZ1bmN0aW9uIGhvc3RSZXBvcnRFcnJvcihlcnIpIHtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgZXJyO1xuICB9LCAwKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX2NvbmZpZyxfdXRpbF9ob3N0UmVwb3J0RXJyb3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBlbXB0eSA9IHtcbiAgY2xvc2VkOiB0cnVlLFxuICBuZXh0OiBmdW5jdGlvbiAodmFsdWUpIHt9LFxuICBlcnJvcjogZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0gZWxzZSB7XG4gICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICB9XG4gIH0sXG4gIGNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7fVxufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxudmFyIGlzQXJyYXkgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeCkge1xuICAgIHJldHVybiB4ICYmIHR5cGVvZiB4Lmxlbmd0aCA9PT0gJ251bWJlcic7XG4gIH07XG59KCk7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICByZXR1cm4geCAhPT0gbnVsbCAmJiB0eXBlb2YgeCA9PT0gJ29iamVjdCc7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVW5zdWJzY3JpcHRpb25FcnJvckltcGwoZXJyb3JzKSB7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSBlcnJvcnMgPyBlcnJvcnMubGVuZ3RoICsgXCIgZXJyb3JzIG9jY3VycmVkIGR1cmluZyB1bnN1YnNjcmlwdGlvbjpcXG5cIiArIGVycm9ycy5tYXAoZnVuY3Rpb24gKGVyciwgaSkge1xuICAgICAgcmV0dXJuIGkgKyAxICsgXCIpIFwiICsgZXJyLnRvU3RyaW5nKCk7XG4gICAgfSkuam9pbignXFxuICAnKSA6ICcnO1xuICAgIHRoaXMubmFtZSA9ICdVbnN1YnNjcmlwdGlvbkVycm9yJztcbiAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIFVuc3Vic2NyaXB0aW9uRXJyb3JJbXBsLnByb3RvdHlwZSA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG4gIHJldHVybiBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbDtcbn0oKTtcblxudmFyIFVuc3Vic2NyaXB0aW9uRXJyb3IgPSBVbnN1YnNjcmlwdGlvbkVycm9ySW1wbDtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX3V0aWxfaXNBcnJheSxfdXRpbF9pc09iamVjdCxfdXRpbF9pc0Z1bmN0aW9uLF91dGlsX1Vuc3Vic2NyaXB0aW9uRXJyb3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG52YXIgU3Vic2NyaXB0aW9uID0gLypAX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3Vic2NyaXB0aW9uKHVuc3Vic2NyaWJlKSB7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJlbnRPclBhcmVudHMgPSBudWxsO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuXG4gICAgaWYgKHVuc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLl9jdG9yVW5zdWJzY3JpYmUgPSB0cnVlO1xuICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bnN1YnNjcmliZTtcbiAgICB9XG4gIH1cblxuICBTdWJzY3JpcHRpb24ucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlcnJvcnM7XG5cbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgX2EgPSB0aGlzLFxuICAgICAgICBfcGFyZW50T3JQYXJlbnRzID0gX2EuX3BhcmVudE9yUGFyZW50cyxcbiAgICAgICAgX2N0b3JVbnN1YnNjcmliZSA9IF9hLl9jdG9yVW5zdWJzY3JpYmUsXG4gICAgICAgIF91bnN1YnNjcmliZSA9IF9hLl91bnN1YnNjcmliZSxcbiAgICAgICAgX3N1YnNjcmlwdGlvbnMgPSBfYS5fc3Vic2NyaXB0aW9ucztcblxuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9wYXJlbnRPclBhcmVudHMgPSBudWxsO1xuICAgIHRoaXMuX3N1YnNjcmlwdGlvbnMgPSBudWxsO1xuXG4gICAgaWYgKF9wYXJlbnRPclBhcmVudHMgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcbiAgICAgIF9wYXJlbnRPclBhcmVudHMucmVtb3ZlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAoX3BhcmVudE9yUGFyZW50cyAhPT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IF9wYXJlbnRPclBhcmVudHMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICAgIHZhciBwYXJlbnRfMSA9IF9wYXJlbnRPclBhcmVudHNbaW5kZXhdO1xuICAgICAgICBwYXJlbnRfMS5yZW1vdmUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24oX3Vuc3Vic2NyaWJlKSkge1xuICAgICAgaWYgKF9jdG9yVW5zdWJzY3JpYmUpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIF91bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcnMgPSBlIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvciA/IGZsYXR0ZW5VbnN1YnNjcmlwdGlvbkVycm9ycyhlLmVycm9ycykgOiBbZV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkoX3N1YnNjcmlwdGlvbnMpKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBsZW4gPSBfc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuKSB7XG4gICAgICAgIHZhciBzdWIgPSBfc3Vic2NyaXB0aW9uc1tpbmRleF07XG5cbiAgICAgICAgaWYgKGlzT2JqZWN0KHN1YikpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3ViLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzIHx8IFtdO1xuXG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFVuc3Vic2NyaXB0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZS5lcnJvcnMpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlcnJvcnMpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1YnNjcmlwdGlvbkVycm9yKGVycm9ycyk7XG4gICAgfVxuICB9O1xuXG4gIFN1YnNjcmlwdGlvbi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlYXJkb3duKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbiA9IHRlYXJkb3duO1xuXG4gICAgaWYgKCF0ZWFyZG93bikge1xuICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGVvZiB0ZWFyZG93bikge1xuICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICBzdWJzY3JpcHRpb24gPSBuZXcgU3Vic2NyaXB0aW9uKHRlYXJkb3duKTtcblxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PT0gdGhpcyB8fCBzdWJzY3JpcHRpb24uY2xvc2VkIHx8IHR5cGVvZiBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmICghKHN1YnNjcmlwdGlvbiBpbnN0YW5jZW9mIFN1YnNjcmlwdGlvbikpIHtcbiAgICAgICAgICB2YXIgdG1wID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICBzdWJzY3JpcHRpb24uX3N1YnNjcmlwdGlvbnMgPSBbdG1wXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bnJlY29nbml6ZWQgdGVhcmRvd24gJyArIHRlYXJkb3duICsgJyBhZGRlZCB0byBTdWJzY3JpcHRpb24uJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX3BhcmVudE9yUGFyZW50cyA9IHN1YnNjcmlwdGlvbi5fcGFyZW50T3JQYXJlbnRzO1xuXG4gICAgaWYgKF9wYXJlbnRPclBhcmVudHMgPT09IG51bGwpIHtcbiAgICAgIHN1YnNjcmlwdGlvbi5fcGFyZW50T3JQYXJlbnRzID0gdGhpcztcbiAgICB9IGVsc2UgaWYgKF9wYXJlbnRPclBhcmVudHMgaW5zdGFuY2VvZiBTdWJzY3JpcHRpb24pIHtcbiAgICAgIGlmIChfcGFyZW50T3JQYXJlbnRzID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gICAgICB9XG5cbiAgICAgIHN1YnNjcmlwdGlvbi5fcGFyZW50T3JQYXJlbnRzID0gW19wYXJlbnRPclBhcmVudHMsIHRoaXNdO1xuICAgIH0gZWxzZSBpZiAoX3BhcmVudE9yUGFyZW50cy5pbmRleE9mKHRoaXMpID09PSAtMSkge1xuICAgICAgX3BhcmVudE9yUGFyZW50cy5wdXNoKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3Vic2NyaXB0aW9uO1xuICAgIH1cblxuICAgIHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5fc3Vic2NyaXB0aW9ucztcblxuICAgIGlmIChzdWJzY3JpcHRpb25zID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zID0gW3N1YnNjcmlwdGlvbl07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1YnNjcmlwdGlvbnMucHVzaChzdWJzY3JpcHRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBzdWJzY3JpcHRpb247XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLl9zdWJzY3JpcHRpb25zO1xuXG4gICAgaWYgKHN1YnNjcmlwdGlvbnMpIHtcbiAgICAgIHZhciBzdWJzY3JpcHRpb25JbmRleCA9IHN1YnNjcmlwdGlvbnMuaW5kZXhPZihzdWJzY3JpcHRpb24pO1xuXG4gICAgICBpZiAoc3Vic2NyaXB0aW9uSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHN1YnNjcmlwdGlvbnMuc3BsaWNlKHN1YnNjcmlwdGlvbkluZGV4LCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU3Vic2NyaXB0aW9uLkVNUFRZID0gZnVuY3Rpb24gKGVtcHR5KSB7XG4gICAgZW1wdHkuY2xvc2VkID0gdHJ1ZTtcbiAgICByZXR1cm4gZW1wdHk7XG4gIH0obmV3IFN1YnNjcmlwdGlvbigpKTtcblxuICByZXR1cm4gU3Vic2NyaXB0aW9uO1xufSgpO1xuXG5mdW5jdGlvbiBmbGF0dGVuVW5zdWJzY3JpcHRpb25FcnJvcnMoZXJyb3JzKSB7XG4gIHJldHVybiBlcnJvcnMucmVkdWNlKGZ1bmN0aW9uIChlcnJzLCBlcnIpIHtcbiAgICByZXR1cm4gZXJycy5jb25jYXQoZXJyIGluc3RhbmNlb2YgVW5zdWJzY3JpcHRpb25FcnJvciA/IGVyci5lcnJvcnMgOiBlcnIpO1xuICB9LCBbXSk7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIHJ4U3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nID8gLypAX19QVVJFX18qL1N5bWJvbCgncnhTdWJzY3JpYmVyJykgOiAnQEByeFN1YnNjcmliZXJfJyArIC8qQF9fUFVSRV9fKi9NYXRoLnJhbmRvbSgpO1xufSgpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfdXRpbF9pc0Z1bmN0aW9uLF9PYnNlcnZlcixfU3Vic2NyaXB0aW9uLF9pbnRlcm5hbF9zeW1ib2xfcnhTdWJzY3JpYmVyLF9jb25maWcsX3V0aWxfaG9zdFJlcG9ydEVycm9yIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTdWJzY3JpYmVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFN1YnNjcmliZXIoZGVzdGluYXRpb25Pck5leHQsIGVycm9yLCBjb21wbGV0ZSkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5zeW5jRXJyb3JWYWx1ZSA9IG51bGw7XG4gICAgX3RoaXMuc3luY0Vycm9yVGhyb3duID0gZmFsc2U7XG4gICAgX3RoaXMuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgX3RoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG5cbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBlbXB0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKCFkZXN0aW5hdGlvbk9yTmV4dCkge1xuICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZW1wdHk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRlc3RpbmF0aW9uT3JOZXh0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGlmIChkZXN0aW5hdGlvbk9yTmV4dCBpbnN0YW5jZW9mIFN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIF90aGlzLnN5bmNFcnJvclRocm93YWJsZSA9IGRlc3RpbmF0aW9uT3JOZXh0LnN5bmNFcnJvclRocm93YWJsZTtcbiAgICAgICAgICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb25Pck5leHQ7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbk9yTmV4dC5hZGQoX3RoaXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuZGVzdGluYXRpb24gPSBuZXcgU2FmZVN1YnNjcmliZXIoX3RoaXMsIGRlc3RpbmF0aW9uT3JOZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBfdGhpcy5zeW5jRXJyb3JUaHJvd2FibGUgPSB0cnVlO1xuICAgICAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IG5ldyBTYWZlU3Vic2NyaWJlcihfdGhpcywgZGVzdGluYXRpb25Pck5leHQsIGVycm9yLCBjb21wbGV0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlW3J4U3Vic2NyaWJlcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgU3Vic2NyaWJlci5jcmVhdGUgPSBmdW5jdGlvbiAobmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgdmFyIHN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaWJlcihuZXh0LCBlcnJvciwgY29tcGxldGUpO1xuICAgIHN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG4gICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gIH07XG5cbiAgU3Vic2NyaWJlci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHRoaXMuX25leHQodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICB0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG5cbiAgICAgIHRoaXMuX2Vycm9yKGVycik7XG4gICAgfVxuICB9O1xuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fY29tcGxldGUoKTtcbiAgICB9XG4gIH07XG5cbiAgU3Vic2NyaWJlci5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuXG4gICAgX3N1cGVyLnByb3RvdHlwZS51bnN1YnNjcmliZS5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KHZhbHVlKTtcbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fY29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICBTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmVBbmRSZWN5Y2xlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfcGFyZW50T3JQYXJlbnRzID0gdGhpcy5fcGFyZW50T3JQYXJlbnRzO1xuICAgIHRoaXMuX3BhcmVudE9yUGFyZW50cyA9IG51bGw7XG4gICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXJlbnRPclBhcmVudHMgPSBfcGFyZW50T3JQYXJlbnRzO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBTdWJzY3JpYmVyO1xufShTdWJzY3JpcHRpb24pO1xuXG52YXIgU2FmZVN1YnNjcmliZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKF9zdXBlcikge1xuICBfX2V4dGVuZHMoU2FmZVN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2FmZVN1YnNjcmliZXIoX3BhcmVudFN1YnNjcmliZXIsIG9ic2VydmVyT3JOZXh0LCBlcnJvciwgY29tcGxldGUpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMuX3BhcmVudFN1YnNjcmliZXIgPSBfcGFyZW50U3Vic2NyaWJlcjtcbiAgICB2YXIgbmV4dDtcbiAgICB2YXIgY29udGV4dCA9IF90aGlzO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24ob2JzZXJ2ZXJPck5leHQpKSB7XG4gICAgICBuZXh0ID0gb2JzZXJ2ZXJPck5leHQ7XG4gICAgfSBlbHNlIGlmIChvYnNlcnZlck9yTmV4dCkge1xuICAgICAgbmV4dCA9IG9ic2VydmVyT3JOZXh0Lm5leHQ7XG4gICAgICBlcnJvciA9IG9ic2VydmVyT3JOZXh0LmVycm9yO1xuICAgICAgY29tcGxldGUgPSBvYnNlcnZlck9yTmV4dC5jb21wbGV0ZTtcblxuICAgICAgaWYgKG9ic2VydmVyT3JOZXh0ICE9PSBlbXB0eSkge1xuICAgICAgICBjb250ZXh0ID0gT2JqZWN0LmNyZWF0ZShvYnNlcnZlck9yTmV4dCk7XG5cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oY29udGV4dC51bnN1YnNjcmliZSkpIHtcbiAgICAgICAgICBfdGhpcy5hZGQoY29udGV4dC51bnN1YnNjcmliZS5iaW5kKGNvbnRleHQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQudW5zdWJzY3JpYmUgPSBfdGhpcy51bnN1YnNjcmliZS5iaW5kKF90aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgX3RoaXMuX25leHQgPSBuZXh0O1xuICAgIF90aGlzLl9lcnJvciA9IGVycm9yO1xuICAgIF90aGlzLl9jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmlzU3RvcHBlZCAmJiB0aGlzLl9uZXh0KSB7XG4gICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuXG4gICAgICBpZiAoIWNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nIHx8ICFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgdGhpcy5fX3RyeU9yVW5zdWIodGhpcy5fbmV4dCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fbmV4dCwgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghdGhpcy5pc1N0b3BwZWQpIHtcbiAgICAgIHZhciBfcGFyZW50U3Vic2NyaWJlciA9IHRoaXMuX3BhcmVudFN1YnNjcmliZXI7XG4gICAgICB2YXIgdXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyA9IGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nO1xuXG4gICAgICBpZiAodGhpcy5fZXJyb3IpIHtcbiAgICAgICAgaWYgKCF1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nIHx8ICFfcGFyZW50U3Vic2NyaWJlci5zeW5jRXJyb3JUaHJvd2FibGUpIHtcbiAgICAgICAgICB0aGlzLl9fdHJ5T3JVbnN1Yih0aGlzLl9lcnJvciwgZXJyKTtcblxuICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fdHJ5T3JTZXRFcnJvcihfcGFyZW50U3Vic2NyaWJlciwgdGhpcy5fZXJyb3IsIGVycik7XG5cbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG5cbiAgICAgICAgaWYgKHVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cblxuICAgICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh1c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVmFsdWUgPSBlcnI7XG4gICAgICAgICAgX3BhcmVudFN1YnNjcmliZXIuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICB2YXIgX3BhcmVudFN1YnNjcmliZXIgPSB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyO1xuXG4gICAgICBpZiAodGhpcy5fY29tcGxldGUpIHtcbiAgICAgICAgdmFyIHdyYXBwZWRDb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMuX2NvbXBsZXRlLmNhbGwoX3RoaXMuX2NvbnRleHQpO1xuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcgfHwgIV9wYXJlbnRTdWJzY3JpYmVyLnN5bmNFcnJvclRocm93YWJsZSkge1xuICAgICAgICAgIHRoaXMuX190cnlPclVuc3ViKHdyYXBwZWRDb21wbGV0ZSk7XG5cbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fX3RyeU9yU2V0RXJyb3IoX3BhcmVudFN1YnNjcmliZXIsIHdyYXBwZWRDb21wbGV0ZSk7XG5cbiAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl9fdHJ5T3JVbnN1YiA9IGZ1bmN0aW9uIChmbiwgdmFsdWUpIHtcbiAgICB0cnkge1xuICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG5cbiAgICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU2FmZVN1YnNjcmliZXIucHJvdG90eXBlLl9fdHJ5T3JTZXRFcnJvciA9IGZ1bmN0aW9uIChwYXJlbnQsIGZuLCB2YWx1ZSkge1xuICAgIGlmICghY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGNhbGwnKTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgZm4uY2FsbCh0aGlzLl9jb250ZXh0LCB2YWx1ZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoY29uZmlnLnVzZURlcHJlY2F0ZWRTeW5jaHJvbm91c0Vycm9ySGFuZGxpbmcpIHtcbiAgICAgICAgcGFyZW50LnN5bmNFcnJvclZhbHVlID0gZXJyO1xuICAgICAgICBwYXJlbnQuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0UmVwb3J0RXJyb3IoZXJyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIFNhZmVTdWJzY3JpYmVyLnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wYXJlbnRTdWJzY3JpYmVyID0gdGhpcy5fcGFyZW50U3Vic2NyaWJlcjtcbiAgICB0aGlzLl9jb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9wYXJlbnRTdWJzY3JpYmVyID0gbnVsbDtcblxuICAgIF9wYXJlbnRTdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XG4gIH07XG5cbiAgcmV0dXJuIFNhZmVTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX1N1YnNjcmliZXIgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGNhblJlcG9ydEVycm9yKG9ic2VydmVyKSB7XG4gIHdoaWxlIChvYnNlcnZlcikge1xuICAgIHZhciBfYSA9IG9ic2VydmVyLFxuICAgICAgICBjbG9zZWRfMSA9IF9hLmNsb3NlZCxcbiAgICAgICAgZGVzdGluYXRpb24gPSBfYS5kZXN0aW5hdGlvbixcbiAgICAgICAgaXNTdG9wcGVkID0gX2EuaXNTdG9wcGVkO1xuXG4gICAgaWYgKGNsb3NlZF8xIHx8IGlzU3RvcHBlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24gaW5zdGFuY2VvZiBTdWJzY3JpYmVyKSB7XG4gICAgICBvYnNlcnZlciA9IGRlc3RpbmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9TdWJzY3JpYmVyLF9zeW1ib2xfcnhTdWJzY3JpYmVyLF9PYnNlcnZlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gdG9TdWJzY3JpYmVyKG5leHRPck9ic2VydmVyLCBlcnJvciwgY29tcGxldGUpIHtcbiAgaWYgKG5leHRPck9ic2VydmVyKSB7XG4gICAgaWYgKG5leHRPck9ic2VydmVyIGluc3RhbmNlb2YgU3Vic2NyaWJlcikge1xuICAgICAgcmV0dXJuIG5leHRPck9ic2VydmVyO1xuICAgIH1cblxuICAgIGlmIChuZXh0T3JPYnNlcnZlcltyeFN1YnNjcmliZXJdKSB7XG4gICAgICByZXR1cm4gbmV4dE9yT2JzZXJ2ZXJbcnhTdWJzY3JpYmVyXSgpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbmV4dE9yT2JzZXJ2ZXIgJiYgIWVycm9yICYmICFjb21wbGV0ZSkge1xuICAgIHJldHVybiBuZXcgU3Vic2NyaWJlcihlbXB0eSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFN1YnNjcmliZXIobmV4dE9yT2JzZXJ2ZXIsIGVycm9yLCBjb21wbGV0ZSk7XG59XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUICBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIG9ic2VydmFibGUgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wub2JzZXJ2YWJsZSB8fCAnQEBvYnNlcnZhYmxlJztcbn0oKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBpZGVudGl0eSh4KSB7XG4gIHJldHVybiB4O1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfaWRlbnRpdHkgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIHBpcGVGcm9tQXJyYXkoZm5zKSB7XG4gIGlmIChmbnMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG5cbiAgaWYgKGZucy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZm5zWzBdO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBpcGVkKGlucHV0KSB7XG4gICAgcmV0dXJuIGZucy5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGZuKSB7XG4gICAgICByZXR1cm4gZm4ocHJldik7XG4gICAgfSwgaW5wdXQpO1xuICB9O1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfdXRpbF9jYW5SZXBvcnRFcnJvcixfdXRpbF90b1N1YnNjcmliZXIsX3N5bWJvbF9vYnNlcnZhYmxlLF91dGlsX3BpcGUsX2NvbmZpZyBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIE9ic2VydmFibGUgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYnNlcnZhYmxlKHN1YnNjcmliZSkge1xuICAgIHRoaXMuX2lzU2NhbGFyID0gZmFsc2U7XG5cbiAgICBpZiAoc3Vic2NyaWJlKSB7XG4gICAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gICAgfVxuICB9XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUubGlmdCA9IGZ1bmN0aW9uIChvcGVyYXRvcikge1xuICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgb2JzZXJ2YWJsZS5vcGVyYXRvciA9IG9wZXJhdG9yO1xuICAgIHJldHVybiBvYnNlcnZhYmxlO1xuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKSB7XG4gICAgdmFyIG9wZXJhdG9yID0gdGhpcy5vcGVyYXRvcjtcbiAgICB2YXIgc2luayA9IHRvU3Vic2NyaWJlcihvYnNlcnZlck9yTmV4dCwgZXJyb3IsIGNvbXBsZXRlKTtcblxuICAgIGlmIChvcGVyYXRvcikge1xuICAgICAgc2luay5hZGQob3BlcmF0b3IuY2FsbChzaW5rLCB0aGlzLnNvdXJjZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaW5rLmFkZCh0aGlzLnNvdXJjZSB8fCBjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZyAmJiAhc2luay5zeW5jRXJyb3JUaHJvd2FibGUgPyB0aGlzLl9zdWJzY3JpYmUoc2luaykgOiB0aGlzLl90cnlTdWJzY3JpYmUoc2luaykpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcudXNlRGVwcmVjYXRlZFN5bmNocm9ub3VzRXJyb3JIYW5kbGluZykge1xuICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlKSB7XG4gICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3dhYmxlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKHNpbmsuc3luY0Vycm9yVGhyb3duKSB7XG4gICAgICAgICAgdGhyb3cgc2luay5zeW5jRXJyb3JWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBzaW5rO1xuICB9O1xuXG4gIE9ic2VydmFibGUucHJvdG90eXBlLl90cnlTdWJzY3JpYmUgPSBmdW5jdGlvbiAoc2luaykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3Vic2NyaWJlKHNpbmspO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGNvbmZpZy51c2VEZXByZWNhdGVkU3luY2hyb25vdXNFcnJvckhhbmRsaW5nKSB7XG4gICAgICAgIHNpbmsuc3luY0Vycm9yVGhyb3duID0gdHJ1ZTtcbiAgICAgICAgc2luay5zeW5jRXJyb3JWYWx1ZSA9IGVycjtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhblJlcG9ydEVycm9yKHNpbmspKSB7XG4gICAgICAgIHNpbmsuZXJyb3IoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2FybihlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKG5leHQsIHByb21pc2VDdG9yKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHByb21pc2VDdG9yID0gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpO1xuICAgIHJldHVybiBuZXcgcHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgIHN1YnNjcmlwdGlvbiA9IF90aGlzLnN1YnNjcmliZShmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBuZXh0KHZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG5cbiAgICAgICAgICBpZiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHJlamVjdCwgcmVzb2x2ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuICAgIHJldHVybiBzb3VyY2UgJiYgc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZVtvYnNlcnZhYmxlXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBPYnNlcnZhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcGVyYXRpb25zID0gW107XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgb3BlcmF0aW9uc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cblxuICAgIGlmIChvcGVyYXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBpcGVGcm9tQXJyYXkob3BlcmF0aW9ucykodGhpcyk7XG4gIH07XG5cbiAgT2JzZXJ2YWJsZS5wcm90b3R5cGUudG9Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2VDdG9yKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHByb21pc2VDdG9yID0gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpO1xuICAgIHJldHVybiBuZXcgcHJvbWlzZUN0b3IoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHZhbHVlO1xuXG4gICAgICBfdGhpcy5zdWJzY3JpYmUoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID0geDtcbiAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICBPYnNlcnZhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmUpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoc3Vic2NyaWJlKTtcbiAgfTtcblxuICByZXR1cm4gT2JzZXJ2YWJsZTtcbn0oKTtcblxuZnVuY3Rpb24gZ2V0UHJvbWlzZUN0b3IocHJvbWlzZUN0b3IpIHtcbiAgaWYgKCFwcm9taXNlQ3Rvcikge1xuICAgIHByb21pc2VDdG9yID0gUHJvbWlzZTtcbiAgfVxuXG4gIGlmICghcHJvbWlzZUN0b3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIFByb21pc2UgaW1wbCBmb3VuZCcpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2VDdG9yO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBPYmplY3RVbnN1YnNjcmliZWRFcnJvckltcGwgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPYmplY3RVbnN1YnNjcmliZWRFcnJvckltcGwoKSB7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnb2JqZWN0IHVuc3Vic2NyaWJlZCc7XG4gICAgdGhpcy5uYW1lID0gJ09iamVjdFVuc3Vic2NyaWJlZEVycm9yJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIE9iamVjdFVuc3Vic2NyaWJlZEVycm9ySW1wbC5wcm90b3R5cGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICByZXR1cm4gT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3JJbXBsO1xufSgpO1xuXG52YXIgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IgPSBPYmplY3RVbnN1YnNjcmliZWRFcnJvckltcGw7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9TdWJzY3JpcHRpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuXG52YXIgU3ViamVjdFN1YnNjcmlwdGlvbiA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTdWJqZWN0U3Vic2NyaXB0aW9uLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpcHRpb24oc3ViamVjdCwgc3Vic2NyaWJlcikge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5zdWJqZWN0ID0gc3ViamVjdDtcbiAgICBfdGhpcy5zdWJzY3JpYmVyID0gc3Vic2NyaWJlcjtcbiAgICBfdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBTdWJqZWN0U3Vic2NyaXB0aW9uLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmNsb3NlZCA9IHRydWU7XG4gICAgdmFyIHN1YmplY3QgPSB0aGlzLnN1YmplY3Q7XG4gICAgdmFyIG9ic2VydmVycyA9IHN1YmplY3Qub2JzZXJ2ZXJzO1xuICAgIHRoaXMuc3ViamVjdCA9IG51bGw7XG5cbiAgICBpZiAoIW9ic2VydmVycyB8fCBvYnNlcnZlcnMubGVuZ3RoID09PSAwIHx8IHN1YmplY3QuaXNTdG9wcGVkIHx8IHN1YmplY3QuY2xvc2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN1YnNjcmliZXJJbmRleCA9IG9ic2VydmVycy5pbmRleE9mKHRoaXMuc3Vic2NyaWJlcik7XG5cbiAgICBpZiAoc3Vic2NyaWJlckluZGV4ICE9PSAtMSkge1xuICAgICAgb2JzZXJ2ZXJzLnNwbGljZShzdWJzY3JpYmVySW5kZXgsIDEpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3ViamVjdFN1YnNjcmlwdGlvbjtcbn0oU3Vic2NyaXB0aW9uKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX09ic2VydmFibGUsX1N1YnNjcmliZXIsX1N1YnNjcmlwdGlvbixfdXRpbF9PYmplY3RVbnN1YnNjcmliZWRFcnJvcixfU3ViamVjdFN1YnNjcmlwdGlvbixfaW50ZXJuYWxfc3ltYm9sX3J4U3Vic2NyaWJlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIFN1YmplY3RTdWJzY3JpYmVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFN1YmplY3RTdWJzY3JpYmVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIFN1YmplY3RTdWJzY3JpYmVyKGRlc3RpbmF0aW9uKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZGVzdGluYXRpb24pIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBTdWJqZWN0U3Vic2NyaWJlcjtcbn0oU3Vic2NyaWJlcik7XG5cbnZhciBTdWJqZWN0ID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKFN1YmplY3QsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU3ViamVjdCgpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuXG4gICAgX3RoaXMub2JzZXJ2ZXJzID0gW107XG4gICAgX3RoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgX3RoaXMuaXNTdG9wcGVkID0gZmFsc2U7XG4gICAgX3RoaXMuaGFzRXJyb3IgPSBmYWxzZTtcbiAgICBfdGhpcy50aHJvd25FcnJvciA9IG51bGw7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU3ViamVjdC5wcm90b3R5cGVbcnhTdWJzY3JpYmVyXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmV3IFN1YmplY3RTdWJzY3JpYmVyKHRoaXMpO1xuICB9O1xuXG4gIFN1YmplY3QucHJvdG90eXBlLmxpZnQgPSBmdW5jdGlvbiAob3BlcmF0b3IpIHtcbiAgICB2YXIgc3ViamVjdCA9IG5ldyBBbm9ueW1vdXNTdWJqZWN0KHRoaXMsIHRoaXMpO1xuICAgIHN1YmplY3Qub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICByZXR1cm4gc3ViamVjdDtcbiAgfTtcblxuICBTdWJqZWN0LnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNTdG9wcGVkKSB7XG4gICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICAgIHZhciBjb3B5ID0gb2JzZXJ2ZXJzLnNsaWNlKCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29weVtpXS5uZXh0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgU3ViamVjdC5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICB9XG5cbiAgICB0aGlzLmhhc0Vycm9yID0gdHJ1ZTtcbiAgICB0aGlzLnRocm93bkVycm9yID0gZXJyO1xuICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnM7XG4gICAgdmFyIGxlbiA9IG9ic2VydmVycy5sZW5ndGg7XG4gICAgdmFyIGNvcHkgPSBvYnNlcnZlcnMuc2xpY2UoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvcHlbaV0uZXJyb3IoZXJyKTtcbiAgICB9XG5cbiAgICB0aGlzLm9ic2VydmVycy5sZW5ndGggPSAwO1xuICB9O1xuXG4gIFN1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IE9iamVjdFVuc3Vic2NyaWJlZEVycm9yKCk7XG4gICAgfVxuXG4gICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgIHZhciBvYnNlcnZlcnMgPSB0aGlzLm9ic2VydmVycztcbiAgICB2YXIgbGVuID0gb2JzZXJ2ZXJzLmxlbmd0aDtcbiAgICB2YXIgY29weSA9IG9ic2VydmVycy5zbGljZSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29weVtpXS5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgU3ViamVjdC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICB0aGlzLm9ic2VydmVycyA9IG51bGw7XG4gIH07XG5cbiAgU3ViamVjdC5wcm90b3R5cGUuX3RyeVN1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgaWYgKHRoaXMuY2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgT2JqZWN0VW5zdWJzY3JpYmVkRXJyb3IoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuX3RyeVN1YnNjcmliZS5jYWxsKHRoaXMsIHN1YnNjcmliZXIpO1xuICAgIH1cbiAgfTtcblxuICBTdWJqZWN0LnByb3RvdHlwZS5fc3Vic2NyaWJlID0gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBPYmplY3RVbnN1YnNjcmliZWRFcnJvcigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5oYXNFcnJvcikge1xuICAgICAgc3Vic2NyaWJlci5lcnJvcih0aGlzLnRocm93bkVycm9yKTtcbiAgICAgIHJldHVybiBTdWJzY3JpcHRpb24uRU1QVFk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzU3RvcHBlZCkge1xuICAgICAgc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChzdWJzY3JpYmVyKTtcbiAgICAgIHJldHVybiBuZXcgU3ViamVjdFN1YnNjcmlwdGlvbih0aGlzLCBzdWJzY3JpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgU3ViamVjdC5wcm90b3R5cGUuYXNPYnNlcnZhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYnNlcnZhYmxlID0gbmV3IE9ic2VydmFibGUoKTtcbiAgICBvYnNlcnZhYmxlLnNvdXJjZSA9IHRoaXM7XG4gICAgcmV0dXJuIG9ic2VydmFibGU7XG4gIH07XG5cbiAgU3ViamVjdC5jcmVhdGUgPSBmdW5jdGlvbiAoZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICAgIHJldHVybiBuZXcgQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKTtcbiAgfTtcblxuICByZXR1cm4gU3ViamVjdDtcbn0oT2JzZXJ2YWJsZSk7XG5cbnZhciBBbm9ueW1vdXNTdWJqZWN0ID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEFub255bW91c1N1YmplY3QsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gQW5vbnltb3VzU3ViamVjdChkZXN0aW5hdGlvbiwgc291cmNlKSB7XG4gICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcblxuICAgIF90aGlzLmRlc3RpbmF0aW9uID0gZGVzdGluYXRpb247XG4gICAgX3RoaXMuc291cmNlID0gc291cmNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuXG4gICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLm5leHQpIHtcbiAgICAgIGRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuICAgIH1cbiAgfTtcblxuICBBbm9ueW1vdXNTdWJqZWN0LnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICB2YXIgZGVzdGluYXRpb24gPSB0aGlzLmRlc3RpbmF0aW9uO1xuXG4gICAgaWYgKGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmVycm9yKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLmVycm9yKGVycik7XG4gICAgfVxuICB9O1xuXG4gIEFub255bW91c1N1YmplY3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBkZXN0aW5hdGlvbiA9IHRoaXMuZGVzdGluYXRpb247XG5cbiAgICBpZiAoZGVzdGluYXRpb24gJiYgZGVzdGluYXRpb24uY29tcGxldGUpIHtcbiAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICB9XG4gIH07XG5cbiAgQW5vbnltb3VzU3ViamVjdC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdmFyIHNvdXJjZSA9IHRoaXMuc291cmNlO1xuXG4gICAgaWYgKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc291cmNlLnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFN1YnNjcmlwdGlvbi5FTVBUWTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEFub255bW91c1N1YmplY3Q7XG59KFN1YmplY3QpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaXB0aW9uIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgQWN0aW9uID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEFjdGlvbiwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBBY3Rpb24oc2NoZWR1bGVyLCB3b3JrKSB7XG4gICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gIH1cblxuICBBY3Rpb24ucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBBY3Rpb247XG59KFN1YnNjcmlwdGlvbik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIHRzbGliLF9BY3Rpb24gUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBBc3luY0FjdGlvbiA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhBc3luY0FjdGlvbiwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBBc3luY0FjdGlvbihzY2hlZHVsZXIsIHdvcmspIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBzY2hlZHVsZXIsIHdvcmspIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gICAgX3RoaXMud29yayA9IHdvcms7XG4gICAgX3RoaXMucGVuZGluZyA9IGZhbHNlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5zY2hlZHVsZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmNsb3NlZCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuXG4gICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHNjaGVkdWxlciwgaWQsIGRlbGF5KTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmcgPSB0cnVlO1xuICAgIHRoaXMuZGVsYXkgPSBkZWxheTtcbiAgICB0aGlzLmlkID0gdGhpcy5pZCB8fCB0aGlzLnJlcXVlc3RBc3luY0lkKHNjaGVkdWxlciwgdGhpcy5pZCwgZGVsYXkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFzeW5jQWN0aW9uLnByb3RvdHlwZS5yZXF1ZXN0QXN5bmNJZCA9IGZ1bmN0aW9uIChzY2hlZHVsZXIsIGlkLCBkZWxheSkge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNldEludGVydmFsKHNjaGVkdWxlci5mbHVzaC5iaW5kKHNjaGVkdWxlciwgdGhpcyksIGRlbGF5KTtcbiAgfTtcblxuICBBc3luY0FjdGlvbi5wcm90b3R5cGUucmVjeWNsZUFzeW5jSWQgPSBmdW5jdGlvbiAoc2NoZWR1bGVyLCBpZCwgZGVsYXkpIHtcbiAgICBpZiAoZGVsYXkgPT09IHZvaWQgMCkge1xuICAgICAgZGVsYXkgPSAwO1xuICAgIH1cblxuICAgIGlmIChkZWxheSAhPT0gbnVsbCAmJiB0aGlzLmRlbGF5ID09PSBkZWxheSAmJiB0aGlzLnBlbmRpbmcgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG4gICAgY2xlYXJJbnRlcnZhbChpZCk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICBBc3luY0FjdGlvbi5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgZGVsYXkpIHtcbiAgICBpZiAodGhpcy5jbG9zZWQpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ2V4ZWN1dGluZyBhIGNhbmNlbGxlZCBhY3Rpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcblxuICAgIHZhciBlcnJvciA9IHRoaXMuX2V4ZWN1dGUoc3RhdGUsIGRlbGF5KTtcblxuICAgIGlmIChlcnJvcikge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wZW5kaW5nID09PSBmYWxzZSAmJiB0aGlzLmlkICE9IG51bGwpIHtcbiAgICAgIHRoaXMuaWQgPSB0aGlzLnJlY3ljbGVBc3luY0lkKHRoaXMuc2NoZWR1bGVyLCB0aGlzLmlkLCBudWxsKTtcbiAgICB9XG4gIH07XG5cbiAgQXN5bmNBY3Rpb24ucHJvdG90eXBlLl9leGVjdXRlID0gZnVuY3Rpb24gKHN0YXRlLCBkZWxheSkge1xuICAgIHZhciBlcnJvcmVkID0gZmFsc2U7XG4gICAgdmFyIGVycm9yVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgdGhpcy53b3JrKHN0YXRlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlcnJvcmVkID0gdHJ1ZTtcbiAgICAgIGVycm9yVmFsdWUgPSAhIWUgJiYgZSB8fCBuZXcgRXJyb3IoZSk7XG4gICAgfVxuXG4gICAgaWYgKGVycm9yZWQpIHtcbiAgICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgICAgIHJldHVybiBlcnJvclZhbHVlO1xuICAgIH1cbiAgfTtcblxuICBBc3luY0FjdGlvbi5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpZCA9IHRoaXMuaWQ7XG4gICAgdmFyIHNjaGVkdWxlciA9IHRoaXMuc2NoZWR1bGVyO1xuICAgIHZhciBhY3Rpb25zID0gc2NoZWR1bGVyLmFjdGlvbnM7XG4gICAgdmFyIGluZGV4ID0gYWN0aW9ucy5pbmRleE9mKHRoaXMpO1xuICAgIHRoaXMud29yayA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZSA9IG51bGw7XG4gICAgdGhpcy5wZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBudWxsO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cblxuICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLmlkID0gdGhpcy5yZWN5Y2xlQXN5bmNJZChzY2hlZHVsZXIsIGlkLCBudWxsKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlbGF5ID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gQXN5bmNBY3Rpb247XG59KEFjdGlvbik7XG5cbnZhciBTY2hlZHVsZXIgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY2hlZHVsZXIoU2NoZWR1bGVyQWN0aW9uLCBub3cpIHtcbiAgICBpZiAobm93ID09PSB2b2lkIDApIHtcbiAgICAgIG5vdyA9IFNjaGVkdWxlci5ub3c7XG4gICAgfVxuXG4gICAgdGhpcy5TY2hlZHVsZXJBY3Rpb24gPSBTY2hlZHVsZXJBY3Rpb247XG4gICAgdGhpcy5ub3cgPSBub3c7XG4gIH1cblxuICBTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHdvcmssIGRlbGF5LCBzdGF0ZSkge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyB0aGlzLlNjaGVkdWxlckFjdGlvbih0aGlzLCB3b3JrKS5zY2hlZHVsZShzdGF0ZSwgZGVsYXkpO1xuICB9O1xuXG4gIFNjaGVkdWxlci5ub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG5cbiAgcmV0dXJuIFNjaGVkdWxlcjtcbn0oKTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgdHNsaWIsX1NjaGVkdWxlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIEFzeW5jU2NoZWR1bGVyID0gLypAX19QVVJFX18qL2Z1bmN0aW9uIChfc3VwZXIpIHtcbiAgX19leHRlbmRzKEFzeW5jU2NoZWR1bGVyLCBfc3VwZXIpO1xuXG4gIGZ1bmN0aW9uIEFzeW5jU2NoZWR1bGVyKFNjaGVkdWxlckFjdGlvbiwgbm93KSB7XG4gICAgaWYgKG5vdyA9PT0gdm9pZCAwKSB7XG4gICAgICBub3cgPSBTY2hlZHVsZXIubm93O1xuICAgIH1cblxuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFNjaGVkdWxlckFjdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICYmIEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICE9PSBfdGhpcykge1xuICAgICAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXIuZGVsZWdhdGUubm93KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbm93KCk7XG4gICAgICB9XG4gICAgfSkgfHwgdGhpcztcblxuICAgIF90aGlzLmFjdGlvbnMgPSBbXTtcbiAgICBfdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICBfdGhpcy5zY2hlZHVsZWQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgQXN5bmNTY2hlZHVsZXIucHJvdG90eXBlLnNjaGVkdWxlID0gZnVuY3Rpb24gKHdvcmssIGRlbGF5LCBzdGF0ZSkge1xuICAgIGlmIChkZWxheSA9PT0gdm9pZCAwKSB7XG4gICAgICBkZWxheSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICYmIEFzeW5jU2NoZWR1bGVyLmRlbGVnYXRlICE9PSB0aGlzKSB7XG4gICAgICByZXR1cm4gQXN5bmNTY2hlZHVsZXIuZGVsZWdhdGUuc2NoZWR1bGUod29yaywgZGVsYXksIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuc2NoZWR1bGUuY2FsbCh0aGlzLCB3b3JrLCBkZWxheSwgc3RhdGUpO1xuICAgIH1cbiAgfTtcblxuICBBc3luY1NjaGVkdWxlci5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgdmFyIGFjdGlvbnMgPSB0aGlzLmFjdGlvbnM7XG5cbiAgICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAgIGFjdGlvbnMucHVzaChhY3Rpb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBlcnJvcjtcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoZXJyb3IgPSBhY3Rpb24uZXhlY3V0ZShhY3Rpb24uc3RhdGUsIGFjdGlvbi5kZWxheSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoYWN0aW9uID0gYWN0aW9ucy5zaGlmdCgpKTtcblxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIHdoaWxlIChhY3Rpb24gPSBhY3Rpb25zLnNoaWZ0KCkpIHtcbiAgICAgICAgYWN0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQXN5bmNTY2hlZHVsZXI7XG59KFNjaGVkdWxlcik7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgRU1QVFkgPSAvKkBfX1BVUkVfXyovbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgcmV0dXJuIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbn0pO1xuXG5mdW5jdGlvbiBlbXB0eSQxKHNjaGVkdWxlcikge1xuICByZXR1cm4gc2NoZWR1bGVyID8gZW1wdHlTY2hlZHVsZWQoc2NoZWR1bGVyKSA6IEVNUFRZO1xufVxuXG5mdW5jdGlvbiBlbXB0eVNjaGVkdWxlZChzY2hlZHVsZXIpIHtcbiAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlKGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgcmV0dXJuIHNjaGVkdWxlci5zY2hlZHVsZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc3Vic2NyaWJlci5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9KTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgc3Vic2NyaWJlVG9BcnJheSA9IGZ1bmN0aW9uIChhcnJheSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuICYmICFzdWJzY3JpYmVyLmNsb3NlZDsgaSsrKSB7XG4gICAgICBzdWJzY3JpYmVyLm5leHQoYXJyYXlbaV0pO1xuICAgIH1cblxuICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgfTtcbn07XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9PYnNlcnZhYmxlIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiB0aHJvd0Vycm9yKGVycm9yLCBzY2hlZHVsZXIpIHtcbiAgaWYgKCFzY2hlZHVsZXIpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgIHJldHVybiBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoZnVuY3Rpb24gKHN1YnNjcmliZXIpIHtcbiAgICAgIHJldHVybiBzY2hlZHVsZXIuc2NoZWR1bGUoZGlzcGF0Y2gsIDAsIHtcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBzdWJzY3JpYmVyOiBzdWJzY3JpYmVyXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaChfYSkge1xuICB2YXIgZXJyb3IgPSBfYS5lcnJvcixcbiAgICAgIHN1YnNjcmliZXIgPSBfYS5zdWJzY3JpYmVyO1xuICBzdWJzY3JpYmVyLmVycm9yKGVycm9yKTtcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX0FzeW5jQWN0aW9uLF9Bc3luY1NjaGVkdWxlciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIGFzeW5jU2NoZWR1bGVyID0gLypAX19QVVJFX18qL25ldyBBc3luY1NjaGVkdWxlcihBc3luY0FjdGlvbik7XG52YXIgYXN5bmMgPSBhc3luY1NjaGVkdWxlcjtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9ySW1wbCA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9ySW1wbCgpIHtcbiAgICBFcnJvci5jYWxsKHRoaXMpO1xuICAgIHRoaXMubWVzc2FnZSA9ICdhcmd1bWVudCBvdXQgb2YgcmFuZ2UnO1xuICAgIHRoaXMubmFtZSA9ICdBcmd1bWVudE91dE9mUmFuZ2VFcnJvcic7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBBcmd1bWVudE91dE9mUmFuZ2VFcnJvckltcGwucHJvdG90eXBlID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcbiAgcmV0dXJuIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9ySW1wbDtcbn0oKTtcblxudmFyIEFyZ3VtZW50T3V0T2ZSYW5nZUVycm9yID0gQXJndW1lbnRPdXRPZlJhbmdlRXJyb3JJbXBsO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG52YXIgVGltZW91dEVycm9ySW1wbCA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRpbWVvdXRFcnJvckltcGwoKSB7XG4gICAgRXJyb3IuY2FsbCh0aGlzKTtcbiAgICB0aGlzLm1lc3NhZ2UgPSAnVGltZW91dCBoYXMgb2NjdXJyZWQnO1xuICAgIHRoaXMubmFtZSA9ICdUaW1lb3V0RXJyb3InO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgVGltZW91dEVycm9ySW1wbC5wcm90b3R5cGUgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICByZXR1cm4gVGltZW91dEVycm9ySW1wbDtcbn0oKTtcblxudmFyIFRpbWVvdXRFcnJvciA9IFRpbWVvdXRFcnJvckltcGw7XG4vKiogUFVSRV9JTVBPUlRTX1NUQVJUIF9ob3N0UmVwb3J0RXJyb3IgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG52YXIgc3Vic2NyaWJlVG9Qcm9taXNlID0gZnVuY3Rpb24gKHByb21pc2UpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKCFzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBzdWJzY3JpYmVyLm5leHQodmFsdWUpO1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZXIuZXJyb3IoZXJyKTtcbiAgICB9KS50aGVuKG51bGwsIGhvc3RSZXBvcnRFcnJvcik7XG4gICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gIH07XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGdldFN5bWJvbEl0ZXJhdG9yKCkge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ2Z1bmN0aW9uJyB8fCAhU3ltYm9sLml0ZXJhdG9yKSB7XG4gICAgcmV0dXJuICdAQGl0ZXJhdG9yJztcbiAgfVxuXG4gIHJldHVybiBTeW1ib2wuaXRlcmF0b3I7XG59XG5cbnZhciBpdGVyYXRvciA9IC8qQF9fUFVSRV9fKi9nZXRTeW1ib2xJdGVyYXRvcigpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc3ltYm9sX2l0ZXJhdG9yIFBVUkVfSU1QT1JUU19FTkQgKi9cblxudmFyIHN1YnNjcmliZVRvSXRlcmFibGUgPSBmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdmFyIGl0ZXJhdG9yJDEgPSBpdGVyYWJsZVtpdGVyYXRvcl0oKTtcblxuICAgIGRvIHtcbiAgICAgIHZhciBpdGVtID0gdm9pZCAwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpdGVtID0gaXRlcmF0b3IkMS5uZXh0KCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgc3Vic2NyaWJlci5lcnJvcihlcnIpO1xuICAgICAgICByZXR1cm4gc3Vic2NyaWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW0uZG9uZSkge1xuICAgICAgICBzdWJzY3JpYmVyLmNvbXBsZXRlKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzdWJzY3JpYmVyLm5leHQoaXRlbS52YWx1ZSk7XG5cbiAgICAgIGlmIChzdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3IkMS5yZXR1cm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN1YnNjcmliZXIuYWRkKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yJDEucmV0dXJuKSB7XG4gICAgICAgICAgaXRlcmF0b3IkMS5yZXR1cm4oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1YnNjcmliZXI7XG4gIH07XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc3ltYm9sX29ic2VydmFibGUgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbnZhciBzdWJzY3JpYmVUb09ic2VydmFibGUgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoc3Vic2NyaWJlcikge1xuICAgIHZhciBvYnMgPSBvYmpbb2JzZXJ2YWJsZV0oKTtcblxuICAgIGlmICh0eXBlb2Ygb2JzLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUHJvdmlkZWQgb2JqZWN0IGRvZXMgbm90IGNvcnJlY3RseSBpbXBsZW1lbnQgU3ltYm9sLm9ic2VydmFibGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG9icy5zdWJzY3JpYmUoc3Vic2NyaWJlcik7XG4gICAgfVxuICB9O1xufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG52YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4geCAmJiB0eXBlb2YgeC5sZW5ndGggPT09ICdudW1iZXInICYmIHR5cGVvZiB4ICE9PSAnZnVuY3Rpb24nO1xufTtcbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgIFBVUkVfSU1QT1JUU19FTkQgKi9cblxuXG5mdW5jdGlvbiBpc1Byb21pc2UodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKiBQVVJFX0lNUE9SVFNfU1RBUlQgX3N1YnNjcmliZVRvQXJyYXksX3N1YnNjcmliZVRvUHJvbWlzZSxfc3Vic2NyaWJlVG9JdGVyYWJsZSxfc3Vic2NyaWJlVG9PYnNlcnZhYmxlLF9pc0FycmF5TGlrZSxfaXNQcm9taXNlLF9pc09iamVjdCxfc3ltYm9sX2l0ZXJhdG9yLF9zeW1ib2xfb2JzZXJ2YWJsZSBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIHN1YnNjcmliZVRvID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICBpZiAoISFyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdFtvYnNlcnZhYmxlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzdWJzY3JpYmVUb09ic2VydmFibGUocmVzdWx0KTtcbiAgfSBlbHNlIGlmIChpc0FycmF5TGlrZShyZXN1bHQpKSB7XG4gICAgcmV0dXJuIHN1YnNjcmliZVRvQXJyYXkocmVzdWx0KTtcbiAgfSBlbHNlIGlmIChpc1Byb21pc2UocmVzdWx0KSkge1xuICAgIHJldHVybiBzdWJzY3JpYmVUb1Byb21pc2UocmVzdWx0KTtcbiAgfSBlbHNlIGlmICghIXJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0W2l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBzdWJzY3JpYmVUb0l0ZXJhYmxlKHJlc3VsdCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHZhbHVlID0gaXNPYmplY3QocmVzdWx0KSA/ICdhbiBpbnZhbGlkIG9iamVjdCcgOiBcIidcIiArIHJlc3VsdCArIFwiJ1wiO1xuICAgIHZhciBtc2cgPSBcIllvdSBwcm92aWRlZCBcIiArIHZhbHVlICsgXCIgd2hlcmUgYSBzdHJlYW0gd2FzIGV4cGVjdGVkLlwiICsgJyBZb3UgY2FuIHByb3ZpZGUgYW4gT2JzZXJ2YWJsZSwgUHJvbWlzZSwgQXJyYXksIG9yIEl0ZXJhYmxlLic7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtc2cpO1xuICB9XG59O1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlcixfT2JzZXJ2YWJsZSxfdXRpbF9zdWJzY3JpYmVUbyBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxudmFyIFNpbXBsZUlubmVyU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTaW1wbGVJbm5lclN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2ltcGxlSW5uZXJTdWJzY3JpYmVyKHBhcmVudCkge1xuICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG5cbiAgICBfdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgU2ltcGxlSW5uZXJTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMucGFyZW50Lm5vdGlmeU5leHQodmFsdWUpO1xuICB9O1xuXG4gIFNpbXBsZUlubmVyU3Vic2NyaWJlci5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdGhpcy5wYXJlbnQubm90aWZ5RXJyb3IoZXJyb3IpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICBTaW1wbGVJbm5lclN1YnNjcmliZXIucHJvdG90eXBlLl9jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnBhcmVudC5ub3RpZnlDb21wbGV0ZSgpO1xuICAgIHRoaXMudW5zdWJzY3JpYmUoKTtcbiAgfTtcblxuICByZXR1cm4gU2ltcGxlSW5uZXJTdWJzY3JpYmVyO1xufShTdWJzY3JpYmVyKTtcblxudmFyIFNpbXBsZU91dGVyU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhTaW1wbGVPdXRlclN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gU2ltcGxlT3V0ZXJTdWJzY3JpYmVyKCkge1xuICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIFNpbXBsZU91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5TmV4dCA9IGZ1bmN0aW9uIChpbm5lclZhbHVlKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5uZXh0KGlubmVyVmFsdWUpO1xuICB9O1xuXG4gIFNpbXBsZU91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5lcnJvcihlcnIpO1xuICB9O1xuXG4gIFNpbXBsZU91dGVyU3Vic2NyaWJlci5wcm90b3R5cGUubm90aWZ5Q29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0aW5hdGlvbi5jb21wbGV0ZSgpO1xuICB9O1xuXG4gIHJldHVybiBTaW1wbGVPdXRlclN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuXG5mdW5jdGlvbiBpbm5lclN1YnNjcmliZShyZXN1bHQsIGlubmVyU3Vic2NyaWJlcikge1xuICBpZiAoaW5uZXJTdWJzY3JpYmVyLmNsb3NlZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgIHJldHVybiByZXN1bHQuc3Vic2NyaWJlKGlubmVyU3Vic2NyaWJlcik7XG4gIH1cblxuICByZXR1cm4gc3Vic2NyaWJlVG8ocmVzdWx0KShpbm5lclN1YnNjcmliZXIpO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCAgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTigrdmFsdWUpO1xufVxuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfU3Vic2NyaWJlcixfdXRpbF9Bcmd1bWVudE91dE9mUmFuZ2VFcnJvcixfb2JzZXJ2YWJsZV9lbXB0eSBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gdGFrZShjb3VudCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGVtcHR5JDEoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBUYWtlT3BlcmF0b3IoY291bnQpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBUYWtlT3BlcmF0b3IgPSAvKkBfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUYWtlT3BlcmF0b3IodG90YWwpIHtcbiAgICB0aGlzLnRvdGFsID0gdG90YWw7XG5cbiAgICBpZiAodGhpcy50b3RhbCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBBcmd1bWVudE91dE9mUmFuZ2VFcnJvcigpO1xuICAgIH1cbiAgfVxuXG4gIFRha2VPcGVyYXRvci5wcm90b3R5cGUuY2FsbCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gc291cmNlLnN1YnNjcmliZShuZXcgVGFrZVN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy50b3RhbCkpO1xuICB9O1xuXG4gIHJldHVybiBUYWtlT3BlcmF0b3I7XG59KCk7XG5cbnZhciBUYWtlU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUYWtlU3Vic2NyaWJlciwgX3N1cGVyKTtcblxuICBmdW5jdGlvbiBUYWtlU3Vic2NyaWJlcihkZXN0aW5hdGlvbiwgdG90YWwpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcblxuICAgIF90aGlzLnRvdGFsID0gdG90YWw7XG4gICAgX3RoaXMuY291bnQgPSAwO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIFRha2VTdWJzY3JpYmVyLnByb3RvdHlwZS5fbmV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHZhciB0b3RhbCA9IHRoaXMudG90YWw7XG4gICAgdmFyIGNvdW50ID0gKyt0aGlzLmNvdW50O1xuXG4gICAgaWYgKGNvdW50IDw9IHRvdGFsKSB7XG4gICAgICB0aGlzLmRlc3RpbmF0aW9uLm5leHQodmFsdWUpO1xuXG4gICAgICBpZiAoY291bnQgPT09IHRvdGFsKSB7XG4gICAgICAgIHRoaXMuZGVzdGluYXRpb24uY29tcGxldGUoKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVGFrZVN1YnNjcmliZXI7XG59KFN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCB0c2xpYixfc2NoZWR1bGVyX2FzeW5jLF91dGlsX2lzRGF0ZSxfaW5uZXJTdWJzY3JpYmUgUFVSRV9JTVBPUlRTX0VORCAqL1xuXG5cbmZ1bmN0aW9uIHRpbWVvdXRXaXRoKGR1ZSwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikge1xuICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHtcbiAgICBzY2hlZHVsZXIgPSBhc3luYztcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgdmFyIGFic29sdXRlVGltZW91dCA9IGlzRGF0ZShkdWUpO1xuICAgIHZhciB3YWl0Rm9yID0gYWJzb2x1dGVUaW1lb3V0ID8gK2R1ZSAtIHNjaGVkdWxlci5ub3coKSA6IE1hdGguYWJzKGR1ZSk7XG4gICAgcmV0dXJuIHNvdXJjZS5saWZ0KG5ldyBUaW1lb3V0V2l0aE9wZXJhdG9yKHdhaXRGb3IsIGFic29sdXRlVGltZW91dCwgd2l0aE9ic2VydmFibGUsIHNjaGVkdWxlcikpO1xuICB9O1xufVxuXG52YXIgVGltZW91dFdpdGhPcGVyYXRvciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRpbWVvdXRXaXRoT3BlcmF0b3Iod2FpdEZvciwgYWJzb2x1dGVUaW1lb3V0LCB3aXRoT2JzZXJ2YWJsZSwgc2NoZWR1bGVyKSB7XG4gICAgdGhpcy53YWl0Rm9yID0gd2FpdEZvcjtcbiAgICB0aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICB0aGlzLndpdGhPYnNlcnZhYmxlID0gd2l0aE9ic2VydmFibGU7XG4gICAgdGhpcy5zY2hlZHVsZXIgPSBzY2hlZHVsZXI7XG4gIH1cblxuICBUaW1lb3V0V2l0aE9wZXJhdG9yLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKHN1YnNjcmliZXIsIHNvdXJjZSkge1xuICAgIHJldHVybiBzb3VyY2Uuc3Vic2NyaWJlKG5ldyBUaW1lb3V0V2l0aFN1YnNjcmliZXIoc3Vic2NyaWJlciwgdGhpcy5hYnNvbHV0ZVRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGhpcy53aXRoT2JzZXJ2YWJsZSwgdGhpcy5zY2hlZHVsZXIpKTtcbiAgfTtcblxuICByZXR1cm4gVGltZW91dFdpdGhPcGVyYXRvcjtcbn0oKTtcblxudmFyIFRpbWVvdXRXaXRoU3Vic2NyaWJlciA9IC8qQF9fUFVSRV9fKi9mdW5jdGlvbiAoX3N1cGVyKSB7XG4gIF9fZXh0ZW5kcyhUaW1lb3V0V2l0aFN1YnNjcmliZXIsIF9zdXBlcik7XG5cbiAgZnVuY3Rpb24gVGltZW91dFdpdGhTdWJzY3JpYmVyKGRlc3RpbmF0aW9uLCBhYnNvbHV0ZVRpbWVvdXQsIHdhaXRGb3IsIHdpdGhPYnNlcnZhYmxlLCBzY2hlZHVsZXIpIHtcbiAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBkZXN0aW5hdGlvbikgfHwgdGhpcztcblxuICAgIF90aGlzLmFic29sdXRlVGltZW91dCA9IGFic29sdXRlVGltZW91dDtcbiAgICBfdGhpcy53YWl0Rm9yID0gd2FpdEZvcjtcbiAgICBfdGhpcy53aXRoT2JzZXJ2YWJsZSA9IHdpdGhPYnNlcnZhYmxlO1xuICAgIF90aGlzLnNjaGVkdWxlciA9IHNjaGVkdWxlcjtcblxuICAgIF90aGlzLnNjaGVkdWxlVGltZW91dCgpO1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgVGltZW91dFdpdGhTdWJzY3JpYmVyLmRpc3BhdGNoVGltZW91dCA9IGZ1bmN0aW9uIChzdWJzY3JpYmVyKSB7XG4gICAgdmFyIHdpdGhPYnNlcnZhYmxlID0gc3Vic2NyaWJlci53aXRoT2JzZXJ2YWJsZTtcblxuICAgIHN1YnNjcmliZXIuX3Vuc3Vic2NyaWJlQW5kUmVjeWNsZSgpO1xuXG4gICAgc3Vic2NyaWJlci5hZGQoaW5uZXJTdWJzY3JpYmUod2l0aE9ic2VydmFibGUsIG5ldyBTaW1wbGVJbm5lclN1YnNjcmliZXIoc3Vic2NyaWJlcikpKTtcbiAgfTtcblxuICBUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLnNjaGVkdWxlVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWN0aW9uID0gdGhpcy5hY3Rpb247XG5cbiAgICBpZiAoYWN0aW9uKSB7XG4gICAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbi5zY2hlZHVsZSh0aGlzLCB0aGlzLndhaXRGb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZCh0aGlzLmFjdGlvbiA9IHRoaXMuc2NoZWR1bGVyLnNjaGVkdWxlKFRpbWVvdXRXaXRoU3Vic2NyaWJlci5kaXNwYXRjaFRpbWVvdXQsIHRoaXMud2FpdEZvciwgdGhpcykpO1xuICAgIH1cbiAgfTtcblxuICBUaW1lb3V0V2l0aFN1YnNjcmliZXIucHJvdG90eXBlLl9uZXh0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKCF0aGlzLmFic29sdXRlVGltZW91dCkge1xuICAgICAgdGhpcy5zY2hlZHVsZVRpbWVvdXQoKTtcbiAgICB9XG5cbiAgICBfc3VwZXIucHJvdG90eXBlLl9uZXh0LmNhbGwodGhpcywgdmFsdWUpO1xuICB9O1xuXG4gIFRpbWVvdXRXaXRoU3Vic2NyaWJlci5wcm90b3R5cGUuX3Vuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYWN0aW9uID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuc2NoZWR1bGVyID0gbnVsbDtcbiAgICB0aGlzLndpdGhPYnNlcnZhYmxlID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gVGltZW91dFdpdGhTdWJzY3JpYmVyO1xufShTaW1wbGVPdXRlclN1YnNjcmliZXIpO1xuLyoqIFBVUkVfSU1QT1JUU19TVEFSVCBfc2NoZWR1bGVyX2FzeW5jLF91dGlsX1RpbWVvdXRFcnJvcixfdGltZW91dFdpdGgsX29ic2VydmFibGVfdGhyb3dFcnJvciBQVVJFX0lNUE9SVFNfRU5EICovXG5cblxuZnVuY3Rpb24gdGltZW91dChkdWUsIHNjaGVkdWxlcikge1xuICBpZiAoc2NoZWR1bGVyID09PSB2b2lkIDApIHtcbiAgICBzY2hlZHVsZXIgPSBhc3luYztcbiAgfVxuXG4gIHJldHVybiB0aW1lb3V0V2l0aChkdWUsIHRocm93RXJyb3IobmV3IFRpbWVvdXRFcnJvcigpKSwgc2NoZWR1bGVyKTtcbn1cblxuZnVuY3Rpb24gY29uZmlndXJhdGlvbihjb25maWcpIHtcbiAgaWYgKHRoaXMuX2Rlc3Ryb3llZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIFdlYlNvY2tldCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQsIHJlLWluaXRpYWxpemUgdG8gY29udGludWUgbWFraW5nIHJlcXVlc3RzLicpO1xuICB9XG5cbiAgY29uc3QgY2FzZWRTY29wZSA9IHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IGNvbmZpZy5zY29wZS50b0xvd2VyQ2FzZSgpIDogY29uZmlnLnNjb3BlOyAvLyByZXNvbHZlIHByZXZpb3VzIGNvbmZpZ3VyYXRpb24gaWYgZXhpc3RzXG5cbiAgY29uc3QgcHJldmlvdXNDb25maWd1cmF0aW9uID0gdGhpcy5fY29uZmlndXJhdGlvbnMuZ2V0KGNhc2VkU2NvcGUpO1xuXG4gIHByZXZpb3VzQ29uZmlndXJhdGlvbiAmJiBwcmV2aW91c0NvbmZpZ3VyYXRpb24uc3Vic2NyaXB0aW9uICYmIHByZXZpb3VzQ29uZmlndXJhdGlvbi5zdWJzY3JpcHRpb24ubmV4dCgpO1xuICBjb25zdCBzdWJzY3JpcHRpb24gPSBuZXcgU3ViamVjdCgpOyAvLyBjcmVhdGUgZW1pdHRlciBmb3IgdHJhbnNhY3Rpb25cblxuICBjb25zdCBlbWl0dGVyID0gY29uZmlnLndhdGNoQWRkcmVzcyA/IHtcbiAgICBlbWl0dGVyOiBjcmVhdGVFbWl0dGVyKClcbiAgfSA6IHt9O1xuXG4gIHRoaXMuX2NvbmZpZ3VyYXRpb25zLnNldChjYXNlZFNjb3BlLCB7IC4uLmNvbmZpZyxcbiAgICAuLi5lbWl0dGVyLFxuICAgIHN1YnNjcmlwdGlvblxuICB9KTtcblxuICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgY2F0ZWdvcnlDb2RlOiAnY29uZmlncycsXG4gICAgZXZlbnRDb2RlOiAncHV0JyxcbiAgICBjb25maWdcbiAgfSk7XG5cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzdWJzY3JpcHRpb24ucGlwZSh0YWtlKDEpLCB0aW1lb3V0KDUwMDApKS5zdWJzY3JpYmUoe1xuICAgICAgbmV4dDogKCkgPT4gcmVzb2x2ZSh7IC4uLmVtaXR0ZXIsXG4gICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICBjb25maWdcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgICBlcnJvcjogZXJyb3IgPT4ge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZSA9PT0gJ1RpbWVvdXQgaGFzIG9jY3VycmVkJyA/IGBDb25maWd1cmF0aW9uIHdpdGggc2NvcGU6ICR7Y29uZmlnLnNjb3BlfSBoYXMgYmVlbiBzZW50IHRvIHRoZSBCbG9ja25hdGl2ZSBzZXJ2ZXIsIGJ1dCBoYXMgbm90IHJlY2VpdmVkIGEgcmVwbHkgd2l0aGluIDUgc2Vjb25kcy5gIDogZXJyb3IubWVzc2FnZTtcblxuICAgICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmVzb2x2ZShgRXJyb3I6ICR7bWVzc2FnZX1gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWplY3QobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG59XG5cbnZhciB2ZXJzaW9uID0gXCIzLjQuMVwiO1xuXG5mdW5jdGlvbiBzZW5kTWVzc2FnZShtc2cpIHtcbiAgaWYgKHRoaXMuX3F1ZXVlZE1lc3NhZ2VzLmxlbmd0aCA+IFFVRVVFX0xJTUlUKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBRdWV1ZSBsaW1pdCBvZiAke1FVRVVFX0xJTUlUfSBtZXNzYWdlcyBoYXMgYmVlbiByZWFjaGVkLmApO1xuICB9XG5cbiAgdGhpcy5fcXVldWVkTWVzc2FnZXMucHVzaChjcmVhdGVFdmVudExvZy5iaW5kKHRoaXMpKG1zZykpO1xuXG4gIGlmICghdGhpcy5fcHJvY2Vzc2luZ1F1ZXVlKSB7XG4gICAgdGhpcy5fcHJvY2Vzc1F1ZXVlKCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc1F1ZXVlKCkge1xuICB0aGlzLl9wcm9jZXNzaW5nUXVldWUgPSB0cnVlO1xuXG4gIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgYXdhaXQgd2FpdEZvckNvbm5lY3Rpb25PcGVuLmJpbmQodGhpcykoKTtcbiAgfVxuXG4gIHdoaWxlICh0aGlzLl9xdWV1ZWRNZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgLy8gc21hbGwgd2FpdCB0byBhbGxvdyByZXNwb25zZSBmcm9tIHNlcnZlciB0byB0YWtlIGFmZmVjdFxuICAgIGF3YWl0IHdhaXQoMSk7XG5cbiAgICBpZiAodGhpcy5fd2FpdFRvUmV0cnkgIT09IG51bGwpIHtcbiAgICAgIC8vIGhhdmUgYmVlbiByYXRlIGxpbWl0ZWQgc28gd2FpdFxuICAgICAgYXdhaXQgdGhpcy5fd2FpdFRvUmV0cnk7XG4gICAgICB0aGlzLl93YWl0VG9SZXRyeSA9IG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgbXNnID0gdGhpcy5fcXVldWVkTWVzc2FnZXMuc2hpZnQoKTtcblxuICAgIGNvbnN0IGRlbGF5ID0gdGhpcy5fbGltaXRSdWxlcy5kdXJhdGlvbiAvIHRoaXMuX2xpbWl0UnVsZXMucG9pbnRzICogMTAwMDtcbiAgICBhd2FpdCB3YWl0KGRlbGF5KTtcblxuICAgIHRoaXMuX3NvY2tldC5zZW5kKG1zZyk7XG4gIH1cblxuICB0aGlzLl9wcm9jZXNzaW5nUXVldWUgPSBmYWxzZTtcbiAgdGhpcy5fbGltaXRSdWxlcyA9IERFRkFVTFRfUkFURV9MSU1JVF9SVUxFUztcbn1cblxuZnVuY3Rpb24gaGFuZGxlTWVzc2FnZShtc2cpIHtcbiAgY29uc3Qge1xuICAgIHN0YXR1cyxcbiAgICByZWFzb24sXG4gICAgZXZlbnQsXG4gICAgY29ubmVjdGlvbklkLFxuICAgIHNlcnZlclZlcnNpb24sXG4gICAgcmV0cnlNcyxcbiAgICBsaW1pdFJ1bGVzLFxuICAgIGJsb2NrZWRNc2dcbiAgfSA9IEpTT04ucGFyc2UobXNnLmRhdGEpO1xuXG4gIGlmIChjb25uZWN0aW9uSWQpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0aGlzLl9zdG9yYWdlS2V5LCBjb25uZWN0aW9uSWQpO1xuICAgIH1cblxuICAgIHRoaXMuX2Nvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgfSAvLyBoYW5kbGUgYW55IGVycm9ycyBmcm9tIHRoZSBzZXJ2ZXJcblxuXG4gIGlmIChzdGF0dXMgPT09ICdlcnJvcicpIHtcbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdyYXRlbGltaXQnKSAmJiAhcmVhc29uLm1hdGNoKC9JUCAoUGVuZGluZ1NpbXVsYXRpb258Tm90aWZpY2F0aW9uKSByYXRlbGltaXQgcmVhY2hlZC8pKSB7XG4gICAgICB0aGlzLl93YWl0VG9SZXRyeSA9IHdhaXQocmV0cnlNcyk7XG4gICAgICB0aGlzLl9saW1pdFJ1bGVzID0gbGltaXRSdWxlczsgLy8gYWRkIGJsb2NrZWQgbXNnIHRvIHRoZSBmcm9udCBvZiB0aGUgcXVldWVcblxuICAgICAgYmxvY2tlZE1zZyAmJiB0aGlzLl9xdWV1ZWRNZXNzYWdlcy51bnNoaWZ0KGJsb2NrZWRNc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ25vdCBhIHZhbGlkIEFQSSBrZXknKSkge1xuICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ25ldHdvcmsgbm90IHN1cHBvcnRlZCcpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHJlYXNvbi5pbmNsdWRlcygnbWF4aW11bSBhbGxvd2VkIGFtb3VudCcpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgYml0Y29pbiB0eGlkIGVycm9yXG5cblxuICAgIGlmIChyZWFzb24uaW5jbHVkZXMoJ2ludmFsaWQgdHhpZCcpKSB7XG4gICAgICBjb25zdCByZWFzb24gPSBgJHtldmVudC50cmFuc2FjdGlvbi50eGlkfSBpcyBhbiBpbnZhbGlkIHR4aWRgO1xuXG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgdHJhbnNhY3Rpb246IGV2ZW50LnRyYW5zYWN0aW9uLnR4aWRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgZXRoZXJldW0gdHJhbnNhY3Rpb24gaGFzaCBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdpbnZhbGlkIGhhc2gnKSkge1xuICAgICAgY29uc3QgcmVhc29uID0gYCR7ZXZlbnQudHJhbnNhY3Rpb24uaGFzaH0gaXMgYW4gaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoYDtcblxuICAgICAgaWYgKHRoaXMuX29uZXJyb3IpIHtcbiAgICAgICAgdGhpcy5fb25lcnJvcih7XG4gICAgICAgICAgbWVzc2FnZTogcmVhc29uLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiBldmVudC50cmFuc2FjdGlvbi5oYXNoXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH0gLy8gaGFuZGxlIGdlbmVyYWwgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdpbnZhbGlkIGFkZHJlc3MnKSkge1xuICAgICAgY29uc3QgcmVhc29uID0gYCR7ZXZlbnQuYWNjb3VudC5hZGRyZXNzfSBpcyBhbiBpbnZhbGlkIGFkZHJlc3NgO1xuXG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgYWNjb3VudDogZXZlbnQuYWNjb3VudC5hZGRyZXNzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH0gLy8gaGFuZGxlIGJpdGNvaW4gc3BlY2lmaWMgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdub3QgYSB2YWxpZCBCaXRjb2luJykpIHtcbiAgICAgIGlmICh0aGlzLl9vbmVycm9yKSB7XG4gICAgICAgIHRoaXMuX29uZXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IHJlYXNvbixcbiAgICAgICAgICBhY2NvdW50OiBldmVudC5hY2NvdW50LmFkZHJlc3NcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlYXNvbik7XG4gICAgICB9XG4gICAgfSAvLyBoYW5kbGUgZXRoZXJldW0gc3BlY2lmaWMgYWRkcmVzcyBlcnJvclxuXG5cbiAgICBpZiAocmVhc29uLmluY2x1ZGVzKCdub3QgYSB2YWxpZCBFdGhlcmV1bScpKSB7XG4gICAgICBpZiAodGhpcy5fb25lcnJvcikge1xuICAgICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb24sXG4gICAgICAgICAgYWNjb3VudDogZXZlbnQuYWNjb3VudC5hZGRyZXNzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZWFzb24pO1xuICAgICAgfVxuICAgIH0gLy8gaGFuZGxlIGNvbmZpZyBlcnJvclxuXG5cbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQuY29uZmlnKSB7XG4gICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5fY29uZmlndXJhdGlvbnMuZ2V0KGV2ZW50LmNvbmZpZy5zY29wZSk7XG5cbiAgICAgIGlmIChjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uc3Vic2NyaXB0aW9uLmVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiByZWFzb25cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHRocm93IGVycm9yIHRoYXQgY29tZXMgYmFjayBmcm9tIHRoZSBzZXJ2ZXIgd2l0aG91dCBmb3JtYXR0aW5nIHRoZSBtZXNzYWdlXG5cblxuICAgIGlmICh0aGlzLl9vbmVycm9yKSB7XG4gICAgICB0aGlzLl9vbmVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogcmVhc29uXG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IocmVhc29uKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXZlbnQgJiYgZXZlbnQuY29uZmlnKSB7XG4gICAgY29uc3QgY2FzZWRTY29wZSA9IHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IGV2ZW50LmNvbmZpZy5zY29wZS50b0xvd2VyQ2FzZSgpIDogZXZlbnQuY29uZmlnLnNjb3BlO1xuXG4gICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX2NvbmZpZ3VyYXRpb25zLmdldChjYXNlZFNjb3BlKTtcblxuICAgIGlmIChjb25maWd1cmF0aW9uICYmIGNvbmZpZ3VyYXRpb24uc3Vic2NyaXB0aW9uKSB7XG4gICAgICBjb25maWd1cmF0aW9uLnN1YnNjcmlwdGlvbi5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV2ZW50ICYmIGV2ZW50LnRyYW5zYWN0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICBldmVudENvZGUsXG4gICAgICBjb250cmFjdENhbGwsXG4gICAgICB0aW1lU3RhbXAsXG4gICAgICBibG9ja2NoYWluOiB7XG4gICAgICAgIHN5c3RlbSxcbiAgICAgICAgbmV0d29ya1xuICAgICAgfVxuICAgIH0gPSBldmVudDsgLy8gZmxhdHRlbiBpbiB0byBvbmUgb2JqZWN0XG5cbiAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMuX3N5c3RlbSA9PT0gJ2V0aGVyZXVtJyA/IHsgLi4udHJhbnNhY3Rpb24sXG4gICAgICBzZXJ2ZXJWZXJzaW9uLFxuICAgICAgZXZlbnRDb2RlLFxuICAgICAgdGltZVN0YW1wLFxuICAgICAgc3lzdGVtLFxuICAgICAgbmV0d29yayxcbiAgICAgIGNvbnRyYWN0Q2FsbFxuICAgIH0gOiB7IC4uLnRyYW5zYWN0aW9uLFxuICAgICAgc2VydmVyVmVyc2lvbixcbiAgICAgIGV2ZW50Q29kZSxcbiAgICAgIHRpbWVTdGFtcCxcbiAgICAgIHN5c3RlbSxcbiAgICAgIG5ldHdvcmtcbiAgICB9OyAvLyBpZ25vcmUgc2VydmVyIGVjaG8gYW5kIHVuc3Vic2NyaWJlIG1lc3NhZ2VzXG5cbiAgICBpZiAoc2VydmVyRWNobyhldmVudENvZGUpIHx8IHRyYW5zYWN0aW9uLnN0YXR1cyA9PT0gJ3Vuc3Vic2NyaWJlZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIHJlcGxhY2Ugb3JpZ2luYWxIYXNoIHRvIG1hdGNoIHdlYmhvb2sgQVBJXG5cblxuICAgIGlmIChuZXdTdGF0ZS5vcmlnaW5hbEhhc2gpIHtcbiAgICAgIG5ld1N0YXRlLnJlcGxhY2VIYXNoID0gbmV3U3RhdGUub3JpZ2luYWxIYXNoO1xuICAgICAgZGVsZXRlIG5ld1N0YXRlLm9yaWdpbmFsSGFzaDtcbiAgICB9IC8vIHJlcGxhY2Ugc3RhdHVzIHRvIG1hdGNoIHdlYmhvb2sgQVBJXG5cblxuICAgIGlmIChldmVudENvZGUgPT09ICd0eFNwZWVkVXAnICYmIG5ld1N0YXRlLnN0YXR1cyAhPT0gJ3NwZWVkdXAnKSB7XG4gICAgICBuZXdTdGF0ZS5zdGF0dXMgPSAnc3BlZWR1cCc7XG4gICAgfSAvLyByZXBsYWNlIHN0YXR1cyB0byBtYXRjaCB3ZWJob29rIEFQSVxuXG5cbiAgICBpZiAoZXZlbnRDb2RlID09PSAndHhDYW5jZWwnICYmIG5ld1N0YXRlLnN0YXR1cyAhPT0gJ2NhbmNlbCcpIHtcbiAgICAgIG5ld1N0YXRlLnN0YXR1cyA9ICdjYW5jZWwnO1xuICAgIH0gLy8gaGFuZGxlIGNoYW5nZSBvZiBoYXNoIGluIHNwZWVkdXAgYW5kIGNhbmNlbCBldmVudHNcblxuXG4gICAgaWYgKGV2ZW50Q29kZSA9PT0gJ3R4U3BlZWRVcCcgfHwgZXZlbnRDb2RlID09PSAndHhDYW5jZWwnKSB7XG4gICAgICB0aGlzLl93YXRjaGVkVHJhbnNhY3Rpb25zID0gdGhpcy5fd2F0Y2hlZFRyYW5zYWN0aW9ucy5tYXAodHggPT4ge1xuICAgICAgICBpZiAodHguaGFzaCA9PT0gbmV3U3RhdGUucmVwbGFjZUhhc2gpIHtcbiAgICAgICAgICAvLyByZWFzc2lnbiBoYXNoIHBhcmFtZXRlciBpbiB0cmFuc2FjdGlvbiBxdWV1ZSB0byBuZXcgaGFzaCBvciB0eGlkXG4gICAgICAgICAgdHguaGFzaCA9IHRyYW5zYWN0aW9uLmhhc2ggfHwgdHJhbnNhY3Rpb24udHhpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0eDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHdhdGNoZWRBZGRyZXNzID0gdHJhbnNhY3Rpb24ud2F0Y2hlZEFkZHJlc3MgJiYgdGhpcy5fc3lzdGVtID09PSAnZXRoZXJldW0nID8gdHJhbnNhY3Rpb24ud2F0Y2hlZEFkZHJlc3MudG9Mb3dlckNhc2UoKSA6IHRyYW5zYWN0aW9uLndhdGNoZWRBZGRyZXNzO1xuXG4gICAgaWYgKHdhdGNoZWRBZGRyZXNzKSB7XG4gICAgICBjb25zdCBhY2NvdW50T2JqID0gdGhpcy5fd2F0Y2hlZEFjY291bnRzLmZpbmQoYWMgPT4gYWMuYWRkcmVzcyA9PT0gd2F0Y2hlZEFkZHJlc3MpO1xuXG4gICAgICBjb25zdCBhY2NvdW50RW1pdHRlclJlc3VsdCA9IGFjY291bnRPYmogPyBsYXN0KGFjY291bnRPYmouZW1pdHRlcnMubWFwKGVtaXR0ZXIgPT4gZW1pdHRlci5lbWl0KG5ld1N0YXRlKSkpIDogZmFsc2U7XG5cbiAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9jb25maWd1cmF0aW9ucy5nZXQod2F0Y2hlZEFkZHJlc3MpO1xuXG4gICAgICBjb25zdCBlbWl0dGVyUmVzdWx0ID0gY29uZmlndXJhdGlvbiAmJiBjb25maWd1cmF0aW9uLmVtaXR0ZXIgPyBjb25maWd1cmF0aW9uLmVtaXR0ZXIuZW1pdChuZXdTdGF0ZSkgfHwgYWNjb3VudEVtaXR0ZXJSZXN1bHQgOiBhY2NvdW50RW1pdHRlclJlc3VsdDtcblxuICAgICAgdGhpcy5fdHJhbnNhY3Rpb25IYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZSxcbiAgICAgICAgZW1pdHRlclJlc3VsdFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0cmFuc2FjdGlvbk9iaiA9IHRoaXMuX3dhdGNoZWRUcmFuc2FjdGlvbnMuZmluZCh0eCA9PiB0eC5oYXNoID09PSB0cmFuc2FjdGlvbi5oYXNoIHx8IHRyYW5zYWN0aW9uLnR4aWQpO1xuXG4gICAgICBjb25zdCBlbWl0dGVyUmVzdWx0ID0gdHJhbnNhY3Rpb25PYmogJiYgdHJhbnNhY3Rpb25PYmouZW1pdHRlci5lbWl0KG5ld1N0YXRlKTtcblxuICAgICAgdGhpcy5fdHJhbnNhY3Rpb25IYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gaGFuZGxlcih7XG4gICAgICAgIHRyYW5zYWN0aW9uOiBuZXdTdGF0ZSxcbiAgICAgICAgZW1pdHRlclJlc3VsdFxuICAgICAgfSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVFdmVudExvZyhtc2cpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICB0aW1lU3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICBkYXBwSWQ6IHRoaXMuX2RhcHBJZCxcbiAgICB2ZXJzaW9uLFxuICAgIGFwcE5hbWU6IHRoaXMuX2FwcE5hbWUsXG4gICAgYXBwVmVyc2lvbjogdGhpcy5fYXBwVmVyc2lvbixcbiAgICBibG9ja2NoYWluOiB7XG4gICAgICBzeXN0ZW06IHRoaXMuX3N5c3RlbSxcbiAgICAgIG5ldHdvcms6IG5ldHdvcmtOYW1lKHRoaXMuX3N5c3RlbSwgdGhpcy5fbmV0d29ya0lkKSB8fCAnbG9jYWwnXG4gICAgfSxcbiAgICAuLi5tc2dcbiAgfSwgbXNnLmNhdGVnb3J5Q29kZSA9PT0gJ2NvbmZpZ3MnID8ganNvblByZXNlcnZlVW5kZWZpbmVkIDogdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gd2FpdEZvckNvbm5lY3Rpb25PcGVuKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwKTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGUob3B0aW9ucykge1xuICBjb25zdCB7XG4gICAgbmFtZSxcbiAgICB2YWx1ZSxcbiAgICB0eXBlLFxuICAgIG9wdGlvbmFsLFxuICAgIGN1c3RvbVZhbGlkYXRpb25cbiAgfSA9IG9wdGlvbnM7XG5cbiAgaWYgKCFvcHRpb25hbCAmJiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7bmFtZX1cIiBpcyByZXF1aXJlZGApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGUgPT09ICdhcnJheScgPyBBcnJheS5pc0FycmF5KHR5cGUpIDogdHlwZW9mIHZhbHVlICE9PSB0eXBlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBvZiB0eXBlOiAke3R5cGV9LCByZWNlaXZlZCB0eXBlOiAke3R5cGVvZiB2YWx1ZX0gZnJvbSB2YWx1ZTogJHt2YWx1ZX1gKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnICYmIGN1c3RvbVZhbGlkYXRpb24gJiYgIWN1c3RvbVZhbGlkYXRpb24odmFsdWUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7dmFsdWV9XCIgaXMgbm90IGEgdmFsaWQgXCIke25hbWV9XCJgKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU9wdGlvbnMob3B0aW9ucykge1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdzZGsgb3B0aW9ucycsXG4gICAgdmFsdWU6IG9wdGlvbnMsXG4gICAgdHlwZTogJ29iamVjdCdcbiAgfSk7XG4gIGNvbnN0IHtcbiAgICBkYXBwSWQsXG4gICAgc3lzdGVtLFxuICAgIG5hbWUsXG4gICAgYXBwVmVyc2lvbixcbiAgICBuZXR3b3JrSWQsXG4gICAgdHJhbnNhY3Rpb25IYW5kbGVycyxcbiAgICBhcGlVcmwsXG4gICAgd3MsXG4gICAgb25vcGVuLFxuICAgIG9uZG93bixcbiAgICBvbnJlb3BlbixcbiAgICBvbmVycm9yLFxuICAgIG9uY2xvc2UsXG4gICAgLi4ub3RoZXJQYXJhbXNcbiAgfSA9IG9wdGlvbnM7XG4gIGludmFsaWRQYXJhbXMob3RoZXJQYXJhbXMsIFsnZGFwcElkJywgJ3N5c3RlbScsICduYW1lJywgJ2FwcFZlcnNpb24nLCAnbmV0d29ya0lkJywgJ3RyYW5zYWN0aW9uSGFuZGxlcnMnLCAnYXBpVXJsJywgJ3dzJywgJ29ub3BlbicsICdvbmRvd24nLCAnb25yZW9wZW4nLCAnb25lcnJvcicsICdvbmNsb3NlJ10sICdJbml0aWFsaXphdGlvbiBPcHRpb25zJyk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ2RhcHBJZCcsXG4gICAgdmFsdWU6IGRhcHBJZCxcbiAgICB0eXBlOiAnc3RyaW5nJ1xuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnc3lzdGVtJyxcbiAgICB2YWx1ZTogc3lzdGVtLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlLFxuICAgIGN1c3RvbVZhbGlkYXRpb246IHZhbGlkU3lzdGVtXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICduYW1lJyxcbiAgICB2YWx1ZTogbmFtZSxcbiAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYXBwVmVyc2lvbicsXG4gICAgdmFsdWU6IGFwcFZlcnNpb24sXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ25ldHdvcmtJZCcsXG4gICAgdmFsdWU6IG5ldHdvcmtJZCxcbiAgICB0eXBlOiAnbnVtYmVyJ1xuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAndHJhbnNhY3Rpb25IYW5kbGVyJyxcbiAgICB2YWx1ZTogdHJhbnNhY3Rpb25IYW5kbGVycyxcbiAgICB0eXBlOiAnYXJyYXknLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuXG4gIGlmICh0cmFuc2FjdGlvbkhhbmRsZXJzKSB7XG4gICAgdHJhbnNhY3Rpb25IYW5kbGVycy5mb3JFYWNoKGhhbmRsZXIgPT4gdmFsaWRhdGVUeXBlKHtcbiAgICAgIG5hbWU6ICd0cmFuc2FjdGlvbkhhbmRsZXInLFxuICAgICAgdmFsdWU6IGhhbmRsZXIsXG4gICAgICB0eXBlOiAnZnVuY3Rpb24nXG4gICAgfSkpO1xuICB9XG5cbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnYXBpVXJsJyxcbiAgICB2YWx1ZTogYXBpVXJsLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICd3cycsXG4gICAgdmFsdWU6IHdzLFxuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgb3B0aW9uYWw6IHRydWVcbiAgfSk7XG4gIHZhbGlkYXRlVHlwZSh7XG4gICAgbmFtZTogJ29ub3BlbicsXG4gICAgdmFsdWU6IG9ub3BlbixcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdvbmRvd24nLFxuICAgIHZhbHVlOiBvbmRvd24sXG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBvcHRpb25hbDogdHJ1ZVxuICB9KTtcbiAgdmFsaWRhdGVUeXBlKHtcbiAgICBuYW1lOiAnb25yZW9wZW4nLFxuICAgIHZhbHVlOiBvbnJlb3BlbixcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdvbmVycm9yJyxcbiAgICB2YWx1ZTogb25lcnJvcixcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xuICB2YWxpZGF0ZVR5cGUoe1xuICAgIG5hbWU6ICdvbmNsb3NlJyxcbiAgICB2YWx1ZTogb25jbG9zZSxcbiAgICB0eXBlOiAnZnVuY3Rpb24nLFxuICAgIG9wdGlvbmFsOiB0cnVlXG4gIH0pO1xufVxuXG5mdW5jdGlvbiB2YWxpZFN5c3RlbShzeXN0ZW0pIHtcbiAgcmV0dXJuICEhbmV0d29ya3Nbc3lzdGVtXTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZFBhcmFtcyhwYXJhbXMsIHZhbGlkUGFyYW1zLCBmdW5jdGlvbk5hbWUpIHtcbiAgY29uc3QgaW52YWxpZCA9IE9iamVjdC5rZXlzKHBhcmFtcyk7XG5cbiAgaWYgKGludmFsaWQubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHtpbnZhbGlkWzBdfSBpcyBub3QgYSB2YWxpZCBwYXJhbWV0ZXIgZm9yICR7ZnVuY3Rpb25OYW1lfSwgbXVzdCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWxpZCBwYXJhbWV0ZXJzOiAke3ZhbGlkUGFyYW1zLmpvaW4oJywgJyl9YCk7XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9BUFBfTkFNRSA9ICd1bmtub3duJztcbmNvbnN0IERFRkFVTFRfQVBQX1ZFUlNJT04gPSAndW5rbm93bic7XG5jb25zdCBERUZBVUxUX1NZU1RFTSA9ICdldGhlcmV1bSc7XG5cbmNsYXNzIEJsb2NrbmF0aXZlIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhbGlkYXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBkYXBwSWQsXG4gICAgICBzeXN0ZW0gPSBERUZBVUxUX1NZU1RFTSxcbiAgICAgIG5hbWUgPSBERUZBVUxUX0FQUF9OQU1FLFxuICAgICAgYXBwVmVyc2lvbiA9IERFRkFVTFRfQVBQX1ZFUlNJT04sXG4gICAgICBuZXR3b3JrSWQsXG4gICAgICB0cmFuc2FjdGlvbkhhbmRsZXJzID0gW10sXG4gICAgICBhcGlVcmwsXG4gICAgICB3cyxcbiAgICAgIG9ub3BlbixcbiAgICAgIG9uZG93bixcbiAgICAgIG9ucmVvcGVuLFxuICAgICAgb25lcnJvcixcbiAgICAgIG9uY2xvc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBzb2NrZXQgPSBuZXcgU3R1cmR5V2ViU29ja2V0KGFwaVVybCB8fCAnd3NzOi8vYXBpLmJsb2NrbmF0aXZlLmNvbS92MCcsIHdzID8ge1xuICAgICAgd3NDb25zdHJ1Y3Rvcjogd3NcbiAgICB9IDoge30pO1xuICAgIHNvY2tldC5vbm9wZW4gPSBvbk9wZW4uYmluZCh0aGlzLCBvbm9wZW4pO1xuICAgIHNvY2tldC5vbmRvd24gPSBvbkRvd24uYmluZCh0aGlzLCBvbmRvd24pO1xuICAgIHNvY2tldC5vbnJlb3BlbiA9IG9uUmVvcGVuLmJpbmQodGhpcywgb25yZW9wZW4pO1xuICAgIHNvY2tldC5vbm1lc3NhZ2UgPSBoYW5kbGVNZXNzYWdlLmJpbmQodGhpcyk7XG5cbiAgICBzb2NrZXQub25lcnJvciA9IGVycm9yID0+IG9uZXJyb3IgJiYgb25lcnJvcih7XG4gICAgICBtZXNzYWdlOiAnVGhlcmUgd2FzIGEgV2ViU29ja2V0IGVycm9yJyxcbiAgICAgIGVycm9yXG4gICAgfSk7XG5cbiAgICBzb2NrZXQub25jbG9zZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX3BpbmdUaW1lb3V0ICYmIGNsZWFySW50ZXJ2YWwodGhpcy5fcGluZ1RpbWVvdXQpO1xuICAgICAgb25jbG9zZSAmJiBvbmNsb3NlKCk7XG4gICAgfTtcblxuICAgIGNvbnN0IHN0b3JhZ2VLZXkgPSBDcnlwdG9Fcy5TSEExKGAke2RhcHBJZH0gLSAke25hbWV9YCkudG9TdHJpbmcoKTtcbiAgICBjb25zdCBzdG9yZWRDb25uZWN0aW9uSWQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlLmdldEl0ZW0oc3RvcmFnZUtleSk7XG4gICAgdGhpcy5fc3RvcmFnZUtleSA9IHN0b3JhZ2VLZXk7XG4gICAgdGhpcy5fY29ubmVjdGlvbklkID0gc3RvcmVkQ29ubmVjdGlvbklkIHx8IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kYXBwSWQgPSBkYXBwSWQ7XG4gICAgdGhpcy5fc3lzdGVtID0gc3lzdGVtO1xuICAgIHRoaXMuX25ldHdvcmtJZCA9IG5ldHdvcmtJZDtcbiAgICB0aGlzLl9hcHBOYW1lID0gbmFtZTtcbiAgICB0aGlzLl9hcHBWZXJzaW9uID0gYXBwVmVyc2lvbjtcbiAgICB0aGlzLl90cmFuc2FjdGlvbkhhbmRsZXJzID0gdHJhbnNhY3Rpb25IYW5kbGVycztcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gICAgdGhpcy5fc2VuZE1lc3NhZ2UgPSBzZW5kTWVzc2FnZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3dhdGNoZWRUcmFuc2FjdGlvbnMgPSBbXTtcbiAgICB0aGlzLl93YXRjaGVkQWNjb3VudHMgPSBbXTtcbiAgICB0aGlzLl9jb25maWd1cmF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9waW5nVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9vbmVycm9yID0gb25lcnJvcjtcbiAgICB0aGlzLl9xdWV1ZWRNZXNzYWdlcyA9IFtdO1xuICAgIHRoaXMuX2xpbWl0UnVsZXMgPSBERUZBVUxUX1JBVEVfTElNSVRfUlVMRVM7XG4gICAgdGhpcy5fd2FpdFRvUmV0cnkgPSBudWxsO1xuICAgIHRoaXMuX3Byb2Nlc3NpbmdRdWV1ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3Byb2Nlc3NRdWV1ZSA9IHByb2Nlc3NRdWV1ZS5iaW5kKHRoaXMpO1xuXG4gICAgaWYgKHRoaXMuX3NvY2tldC53cy5vbikge1xuICAgICAgdGhpcy5faGVhcnRiZWF0ID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9waW5nVGltZW91dCAmJiBjbGVhclRpbWVvdXQodGhpcy5fcGluZ1RpbWVvdXQpO1xuICAgICAgICB0aGlzLl9waW5nVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIC8vIHRlcm1pbmF0ZSBjb25uZWN0aW9uIGlmIHdlIGhhdmVuJ3QgaGVhcmQgdGhlIHNlcnZlciBwaW5nIGFmdGVyIHNlcnZlciB0aW1lb3V0IHBsdXMgY29uc2VydmF0aXZlIGxhdGVuY3kgZGVsYXlcbiAgICAgICAgICAvLyBTdHVyZHkgV2Vic29ja2V0IHdpbGwgaGFuZGxlIHRoZSBuZXcgY29ubmVjdGlvbiBsb2dpY1xuICAgICAgICAgIHRoaXMuX3NvY2tldC53cy50ZXJtaW5hdGUoKTtcbiAgICAgICAgfSwgMzAwMDAgKyAxMDAwKTtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX3NvY2tldC53cy5vbigncGluZycsICgpID0+IHtcbiAgICAgICAgdGhpcy5faGVhcnRiZWF0ICYmIHRoaXMuX2hlYXJ0YmVhdCgpO1xuICAgICAgfSk7XG4gICAgfSAvLyBwdWJsaWMgQVBJXG5cblxuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYWNjb3VudCA9IGFjY291bnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLmV2ZW50ID0gZXZlbnQuYmluZCh0aGlzKTtcbiAgICB0aGlzLnVuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zb2NrZXQuY2xvc2UoKTtcblxuICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTsgLy8gY2FsbCBvbmNsb3NlIG1hbnVhbGx5IGhlcmUgYXMgU3R1cmR5V2ViU29ja2V0IGRvZXNuJ3QgY3VycmVudGx5IHdvcmsgYXMgZXhwZWN0ZWRcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kcGhpbGlwc29uL3N0dXJkeS13ZWJzb2NrZXQvaXNzdWVzLzVcblxuICAgICAgdGhpcy5fc29ja2V0Lm9uY2xvc2UoKTtcbiAgICB9O1xuICB9XG5cbn1cblxuZnVuY3Rpb24gb25PcGVuKGhhbmRsZXIpIHtcbiAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgY29uc3QgbXNnID0ge1xuICAgIGNhdGVnb3J5Q29kZTogJ2luaXRpYWxpemUnLFxuICAgIGV2ZW50Q29kZTogJ2NoZWNrRGFwcElkJyxcbiAgICBjb25uZWN0aW9uSWQ6IHRoaXMuX2Nvbm5lY3Rpb25JZFxuICB9OyAvLyBzZW5kIHRoaXMgbWVzc2FnZSBkaXJlY3RseSByYXRoZXIgdGhhbiBwdXQgaW4gcXVldWVcblxuICB0aGlzLl9zb2NrZXQuc2VuZChjcmVhdGVFdmVudExvZy5iaW5kKHRoaXMpKG1zZykpO1xuXG4gIHRoaXMuX2hlYXJ0YmVhdCAmJiB0aGlzLl9oZWFydGJlYXQoKTtcbiAgaGFuZGxlciAmJiBoYW5kbGVyKCk7XG59XG5cbmZ1bmN0aW9uIG9uRG93bihoYW5kbGVyLCBjbG9zZUV2ZW50KSB7XG4gIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuXG4gIGlmIChoYW5kbGVyKSB7XG4gICAgaGFuZGxlcihjbG9zZUV2ZW50KTtcbiAgfVxuXG4gIHRoaXMuX3BpbmdUaW1lb3V0ICYmIGNsZWFyVGltZW91dCh0aGlzLl9waW5nVGltZW91dCk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG9uUmVvcGVuKGhhbmRsZXIpIHtcbiAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgY29uc3QgbXNnID0ge1xuICAgIGNhdGVnb3J5Q29kZTogJ2luaXRpYWxpemUnLFxuICAgIGV2ZW50Q29kZTogJ2NoZWNrRGFwcElkJyxcbiAgICBjb25uZWN0aW9uSWQ6IHRoaXMuX2Nvbm5lY3Rpb25JZFxuICB9O1xuXG4gIHRoaXMuX3NvY2tldC5zZW5kKGNyZWF0ZUV2ZW50TG9nLmJpbmQodGhpcykobXNnKSk7IC8vIHJlLXJlZ2lzdGVyIGFsbCBjb25maWd1cmF0aW9ucyBvbiByZS1jb25uZWN0aW9uXG5cblxuICBjb25zdCBjb25maWd1cmF0aW9ucyA9IEFycmF5LmZyb20odGhpcy5fY29uZmlndXJhdGlvbnMudmFsdWVzKCkpOyAvLyByZWdpc3RlciBnbG9iYWwgY29uZmlnIGZpcnN0IGFuZCB3YWl0IGZvciBpdCB0byBjb21wbGV0ZVxuXG4gIGNvbnN0IGdsb2JhbENvbmZpZ3VyYXRpb24gPSB0aGlzLl9jb25maWd1cmF0aW9ucy5nZXQoJ2dsb2JhbCcpO1xuXG4gIGlmIChnbG9iYWxDb25maWd1cmF0aW9uKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW1pdHRlcixcbiAgICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgICAuLi5jb25maWdcbiAgICAgIH0gPSBnbG9iYWxDb25maWd1cmF0aW9uO1xuICAgICAgYXdhaXQgdGhpcy5jb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUud2FybignRXJyb3IgcmUtc2VuZGluZyBnbG9iYWwgY29uZmlndXJhdGlvbiB1cG9uIHJlY29ubmVjdGlvbjonLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgYWRkcmVzc0NvbmZpZ3VyYXRpb25zID0gY29uZmlndXJhdGlvbnMuZmlsdGVyKCh7XG4gICAgc2NvcGVcbiAgfSkgPT4gc2NvcGUgIT09ICdnbG9iYWwnKTtcbiAgYWRkcmVzc0NvbmZpZ3VyYXRpb25zLmZvckVhY2goZW5oYW5jZWRDb25maWcgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBjb25zdCB7XG4gICAgICBlbWl0dGVyLFxuICAgICAgc3Vic2NyaXB0aW9uLFxuICAgICAgLi4uY29uZmlnXG4gICAgfSA9IGVuaGFuY2VkQ29uZmlnO1xuXG4gICAgdGhpcy5fc2VuZE1lc3NhZ2Uoe1xuICAgICAgY2F0ZWdvcnlDb2RlOiAnY29uZmlncycsXG4gICAgICBldmVudENvZGU6ICdwdXQnLFxuICAgICAgY29uZmlnXG4gICAgfSk7XG4gIH0pOyAvLyByZS1yZWdpc3RlciBhbGwgYWNjb3VudHMgdG8gYmUgd2F0Y2hlZCBieSBzZXJ2ZXIgdXBvblxuICAvLyByZS1jb25uZWN0aW9uIGFzIHRoZXkgZG9uJ3QgZ2V0IHRyYW5zZmVycmVkIG92ZXIgYXV0b21hdGljYWxseVxuICAvLyB0byB0aGUgbmV3IGNvbm5lY3Rpb24gbGlrZSB0eCBoYXNoZXMgZG9cblxuICB0aGlzLl93YXRjaGVkQWNjb3VudHMuZm9yRWFjaChhY2NvdW50ID0+IHtcbiAgICB0aGlzLl9zZW5kTWVzc2FnZSh7XG4gICAgICBldmVudENvZGU6ICdhY2NvdW50QWRkcmVzcycsXG4gICAgICBjYXRlZ29yeUNvZGU6ICd3YXRjaCcsXG4gICAgICBhY2NvdW50OiB7XG4gICAgICAgIGFkZHJlc3M6IGFjY291bnQuYWRkcmVzc1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBpZiAoaGFuZGxlcikge1xuICAgIGhhbmRsZXIoKTtcbiAgfVxuXG4gIGlmICh0aGlzLl9zb2NrZXQud3Mub24pIHtcbiAgICAvLyBuZWVkIHRvIHJlLXJlZ2lzdGVyIHBpbmcgZXZlbnQgc2luY2UgbmV3IGNvbm5lY3Rpb25cbiAgICB0aGlzLl9zb2NrZXQud3Mub24oJ3BpbmcnLCAoKSA9PiB7XG4gICAgICB0aGlzLl9oZWFydGJlYXQgJiYgdGhpcy5faGVhcnRiZWF0KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9oZWFydGJlYXQoKTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBCbG9ja25hdGl2ZTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bnc-sdk/dist/esm/index.js\n");

/***/ }),

/***/ "./node_modules/bowser/es5.js":
/*!************************************!*\
  !*** ./node_modules/bowser/es5.js ***!
  \************************************/
/***/ (function(module) {

eval("!function(e,t){ true?module.exports=t():0}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=90)}({17:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||\"\"},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||\"\"},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case\"NT\":return\"NT\";case\"XP\":return\"XP\";case\"NT 5.0\":return\"2000\";case\"NT 5.1\":return\"XP\";case\"NT 5.2\":return\"2003\";case\"NT 6.0\":return\"Vista\";case\"NT 6.1\":return\"7\";case\"NT 6.2\":return\"8\";case\"NT 6.3\":return\"8.1\";case\"NT 10.0\":return\"10\";default:return}},e.getMacOSVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return\"Leopard\";case 6:return\"Snow Leopard\";case 7:return\"Lion\";case 8:return\"Mountain Lion\";case 9:return\"Mavericks\";case 10:return\"Yosemite\";case 11:return\"El Capitan\";case 12:return\"Sierra\";case 13:return\"High Sierra\";case 14:return\"Mojave\";case 15:return\"Catalina\";default:return}},e.getAndroidVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?\"Cupcake\":1===t[0]&&t[1]>=6?\"Donut\":2===t[0]&&t[1]<2?\"Eclair\":2===t[0]&&2===t[1]?\"Froyo\":2===t[0]&&t[1]>2?\"Gingerbread\":3===t[0]?\"Honeycomb\":4===t[0]&&t[1]<1?\"Ice Cream Sandwich\":4===t[0]&&t[1]<4?\"Jelly Bean\":4===t[0]&&t[1]>=4?\"KitKat\":5===t[0]?\"Lollipop\":6===t[0]?\"Marshmallow\":7===t[0]?\"Nougat\":8===t[0]?\"Oreo\":9===t[0]?\"Pie\":void 0},e.getVersionPrecision=function(e){return e.split(\".\").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(\".0\");return e.map(n.split(\".\"),(function(e){return new Array(20-e.length).join(\"0\")+e})).reverse()}));for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1}else if(u[0][a]<u[1][a])return-1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];\"object\"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||\"\"},e}();t.default=i,e.exports=t.default},18:function(e,t,r){\"use strict\";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={\"Amazon Silk\":\"amazon_silk\",\"Android Browser\":\"android\",Bada:\"bada\",BlackBerry:\"blackberry\",Chrome:\"chrome\",Chromium:\"chromium\",Electron:\"electron\",Epiphany:\"epiphany\",Firefox:\"firefox\",Focus:\"focus\",Generic:\"generic\",\"Google Search\":\"google_search\",Googlebot:\"googlebot\",\"Internet Explorer\":\"ie\",\"K-Meleon\":\"k_meleon\",Maxthon:\"maxthon\",\"Microsoft Edge\":\"edge\",\"MZ Browser\":\"mz\",\"NAVER Whale Browser\":\"naver\",Opera:\"opera\",\"Opera Coast\":\"opera_coast\",PhantomJS:\"phantomjs\",Puffin:\"puffin\",QupZilla:\"qupzilla\",QQ:\"qq\",QQLite:\"qqlite\",Safari:\"safari\",Sailfish:\"sailfish\",\"Samsung Internet for Android\":\"samsung_internet\",SeaMonkey:\"seamonkey\",Sleipnir:\"sleipnir\",Swing:\"swing\",Tizen:\"tizen\",\"UC Browser\":\"uc\",Vivaldi:\"vivaldi\",\"WebOS Browser\":\"webos\",WeChat:\"wechat\",\"Yandex Browser\":\"yandex\",Roku:\"roku\"};t.BROWSER_MAP={amazon_silk:\"Amazon Silk\",android:\"Android Browser\",bada:\"Bada\",blackberry:\"BlackBerry\",chrome:\"Chrome\",chromium:\"Chromium\",electron:\"Electron\",epiphany:\"Epiphany\",firefox:\"Firefox\",focus:\"Focus\",generic:\"Generic\",googlebot:\"Googlebot\",google_search:\"Google Search\",ie:\"Internet Explorer\",k_meleon:\"K-Meleon\",maxthon:\"Maxthon\",edge:\"Microsoft Edge\",mz:\"MZ Browser\",naver:\"NAVER Whale Browser\",opera:\"Opera\",opera_coast:\"Opera Coast\",phantomjs:\"PhantomJS\",puffin:\"Puffin\",qupzilla:\"QupZilla\",qq:\"QQ Browser\",qqlite:\"QQ Browser Lite\",safari:\"Safari\",sailfish:\"Sailfish\",samsung_internet:\"Samsung Internet for Android\",seamonkey:\"SeaMonkey\",sleipnir:\"Sleipnir\",swing:\"Swing\",tizen:\"Tizen\",uc:\"UC Browser\",vivaldi:\"Vivaldi\",webos:\"WebOS Browser\",wechat:\"WeChat\",yandex:\"Yandex Browser\"};t.PLATFORMS_MAP={tablet:\"tablet\",mobile:\"mobile\",desktop:\"desktop\",tv:\"tv\"};t.OS_MAP={WindowsPhone:\"Windows Phone\",Windows:\"Windows\",MacOS:\"macOS\",iOS:\"iOS\",Android:\"Android\",WebOS:\"WebOS\",BlackBerry:\"BlackBerry\",Bada:\"Bada\",Tizen:\"Tizen\",Linux:\"Linux\",ChromeOS:\"Chrome OS\",PlayStation4:\"PlayStation 4\",Roku:\"Roku\"};t.ENGINE_MAP={EdgeHTML:\"EdgeHTML\",Blink:\"Blink\",Trident:\"Trident\",Presto:\"Presto\",Gecko:\"Gecko\",WebKit:\"WebKit\"}},90:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),\"string\"!=typeof e)throw new Error(\"UserAgent should be a string\");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:\"BROWSER_MAP\",get:function(){return s.BROWSER_MAP}},{key:\"ENGINE_MAP\",get:function(){return s.ENGINE_MAP}},{key:\"OS_MAP\",get:function(){return s.OS_MAP}},{key:\"PLATFORMS_MAP\",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default},91:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||\"\"===e)throw new Error(\"UserAgent parameter can't be empty\");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||\"\":this.getBrowser().name||\"\"},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||\"\":t||\"\"},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||\"\":t||\"\"},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||\"\":this.getEngine().name||\"\"},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];\"string\"==typeof a?(i[t]=a,s+=1):\"object\"==typeof a&&(r[t]=a,n+=1)})),n>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if(\"string\"==typeof i)return\">\"===e[0]||\"<\"===e[0]?(r=e.substr(1),\"=\"===e[1]?(n=!0,r=e.substr(2)):t=[],\">\"===e[0]?t.push(1):t.push(-1)):\"=\"===e[0]?r=e.substr(1):\"~\"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\\/(\\d+(\\.?_?\\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:\"Googlebot\"},r=i.default.getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\\/|opios/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(/(?:opr|opios)[\\s/](\\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:\"Samsung Internet for Android\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:\"NAVER Whale Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\\s/](\\d+(?:\\.\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:\"MZ Browser\"},r=i.default.getFirstMatch(/(?:MZBrowser)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:\"Focus\"},r=i.default.getFirstMatch(/(?:focus)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:\"Swing\"},r=i.default.getFirstMatch(/(?:swing)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:\"Opera Coast\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\\/\\d+(?:.?_?\\d+)+/i],describe:function(e){var t={name:\"Opera Touch\"},r=i.default.getFirstMatch(/(?:opt)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:\"Yandex Browser\"},r=i.default.getFirstMatch(/(?:yabrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:\"UC Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:\"Maxthon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:\"Epiphany\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:\"Puffin\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:\"Sleipnir\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:\"K-Meleon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:\"WeChat\"},r=i.default.getFirstMatch(/(?:micromessenger)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?\"QQ Browser Lite\":\"QQ Browser\"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:\"Internet Explorer\"},r=i.default.getFirstMatch(/(?:msie |rv:)(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\\sedg\\//i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getFirstMatch(/\\sedg\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:\"Vivaldi\"},r=i.default.getFirstMatch(/vivaldi\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:\"SeaMonkey\"},r=i.default.getFirstMatch(/seamonkey\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:\"Sailfish\"},r=i.default.getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:\"Amazon Silk\"},r=i.default.getFirstMatch(/silk\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:\"PhantomJS\"},r=i.default.getFirstMatch(/phantomjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:\"SlimerJS\"},r=i.default.getFirstMatch(/slimerjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t={name:\"BlackBerry\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:\"WebOS Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:\"Bada\"},r=i.default.getFirstMatch(/dolfin\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:\"Tizen\"},r=i.default.getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:\"QupZilla\"},r=i.default.getFirstMatch(/(?:qupzilla)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:\"Firefox\"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:\"Electron\"},r=i.default.getFirstMatch(/(?:electron)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:\"Miui\"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:\"Chromium\"},r=i.default.getFirstMatch(/(?:chromium)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:\"Chrome\"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:\"Google Search\"},r=i.default.getFirstMatch(/(?:GSA)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:\"Android Browser\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:\"PlayStation 4\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:\"Safari\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search(\"\\\\(\")?/^(.*)\\/(.*)[ \\t]\\((.*)/:/^(.*)\\/(.*) /;return{name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default},93:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\\/DVP-(\\d+\\.\\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i,e),r=i.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\\/)(\\d[\\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\\d+(\\.?_?\\d+)+)/i,e).replace(/[_\\s]/g,\".\"),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i,e).replace(/[_\\s]/g,\".\");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\\s/-](\\d+(\\.\\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\\/(\\d+(\\.\\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\\d+\\/(\\d+([_\\s]\\d+)*)/i,e)||i.default.getFirstMatch(/\\bbb(\\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default},94:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return{type:\"bot\",vendor:\"Google\"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&\"Nova\",r={type:s.PLATFORMS_MAP.mobile,vendor:\"Huawei\"};return t&&(r.model=t),r}},{test:[/nexus\\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Nexus\"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\",model:\"Kindle Fire HD 7\"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:\"Apple\",model:t}}},{test:[/nexus\\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Nexus\"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"blackberry\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"BlackBerry\"}}},{test:function(e){return\"bada\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"windows phone\"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Microsoft\"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(\".\")[0]);return\"android\"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return\"android\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"macos\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:\"Apple\"}}},{test:function(e){return\"windows\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"linux\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"playstation 4\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return\"roku\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default},95:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return\"microsoft edge\"===e.getBrowserName(!0)},describe:function(e){if(/\\sedg\\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\\/(\\d+(\\.?_?\\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\\/537\\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default}})}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jvd3Nlci9lczUuanM/MzM3ZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlLEtBQWlELG9CQUFvQixDQUEyRyxDQUFDLGtCQUFrQixtQkFBbUIsU0FBUyxjQUFjLDRCQUE0QixZQUFZLHFCQUFxQiwyREFBMkQsdUNBQXVDLHFDQUFxQyxvQkFBb0IsRUFBRSxpQkFBaUIsNEZBQTRGLGVBQWUsd0NBQXdDLFNBQVMsRUFBRSxtQkFBbUIsOEJBQThCLHFEQUFxRCwwQkFBMEIsNkNBQTZDLHNCQUFzQiw2REFBNkQsWUFBWSxlQUFlLFNBQVMsaUJBQWlCLGlDQUFpQyxpQkFBaUIsWUFBWSxVQUFVLHNCQUFzQixtQkFBbUIsaURBQWlELGtCQUFrQixFQUFFLG1CQUFtQixhQUFhLGlDQUFpQyx5QkFBeUIsY0FBYyxxQ0FBcUMsaUJBQWlCLCtCQUErQixnQ0FBZ0MsaUJBQWlCLCtCQUErQix1Q0FBdUMsc0JBQXNCLHFDQUFxQyxVQUFVLG9CQUFvQixvQkFBb0IsMEJBQTBCLHdCQUF3QiwwQkFBMEIsMkJBQTJCLHVCQUF1Qix1QkFBdUIseUJBQXlCLHlCQUF5QixnQkFBZ0IsbUNBQW1DLGdEQUFnRCx5QkFBeUIsR0FBRyxvQ0FBb0MsdUJBQXVCLDRCQUE0QixvQkFBb0IsNkJBQTZCLHlCQUF5Qix5QkFBeUIsMkJBQTJCLHVCQUF1Qiw0QkFBNEIsdUJBQXVCLHlCQUF5QixnQkFBZ0IscUNBQXFDLGdEQUFnRCx5QkFBeUIsR0FBRyx3WUFBd1ksbUNBQW1DLDJCQUEyQixtQ0FBbUMsbUJBQW1CLHlHQUF5RywrREFBK0QsdUNBQXVDLDBDQUEwQyxhQUFhLEdBQUcsZ0NBQWdDLEtBQUssRUFBRSw0QkFBNEIsc0JBQXNCLGtCQUFrQixLQUFLLGtDQUFrQyxxQkFBcUIsV0FBVyw0REFBNEQsUUFBUSxXQUFXLHFCQUFxQixTQUFTLHNCQUFzQixRQUFRLDhEQUE4RCxtQkFBbUIsSUFBSSxNQUFNLFdBQVcsb0JB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RSw4Q0FBOEMsT0FBTyx5QkFBeUIsMERBQTBELDJCQUEyQixFQUFFLGlDQUFpQyxFQUFFIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Jvd3Nlci9lczUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24oZSx0KXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz10KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLmJvd3Nlcj10KCk6ZS5ib3dzZXI9dCgpfSh0aGlzLChmdW5jdGlvbigpe3JldHVybiBmdW5jdGlvbihlKXt2YXIgdD17fTtmdW5jdGlvbiByKG4pe2lmKHRbbl0pcmV0dXJuIHRbbl0uZXhwb3J0czt2YXIgaT10W25dPXtpOm4sbDohMSxleHBvcnRzOnt9fTtyZXR1cm4gZVtuXS5jYWxsKGkuZXhwb3J0cyxpLGkuZXhwb3J0cyxyKSxpLmw9ITAsaS5leHBvcnRzfXJldHVybiByLm09ZSxyLmM9dCxyLmQ9ZnVuY3Rpb24oZSx0LG4pe3IubyhlLHQpfHxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHtlbnVtZXJhYmxlOiEwLGdldDpufSl9LHIucj1mdW5jdGlvbihlKXtcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfSxyLnQ9ZnVuY3Rpb24oZSx0KXtpZigxJnQmJihlPXIoZSkpLDgmdClyZXR1cm4gZTtpZig0JnQmJlwib2JqZWN0XCI9PXR5cGVvZiBlJiZlJiZlLl9fZXNNb2R1bGUpcmV0dXJuIGU7dmFyIG49T2JqZWN0LmNyZWF0ZShudWxsKTtpZihyLnIobiksT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sXCJkZWZhdWx0XCIse2VudW1lcmFibGU6ITAsdmFsdWU6ZX0pLDImdCYmXCJzdHJpbmdcIiE9dHlwZW9mIGUpZm9yKHZhciBpIGluIGUpci5kKG4saSxmdW5jdGlvbih0KXtyZXR1cm4gZVt0XX0uYmluZChudWxsLGkpKTtyZXR1cm4gbn0sci5uPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUuX19lc01vZHVsZT9mdW5jdGlvbigpe3JldHVybiBlLmRlZmF1bHR9OmZ1bmN0aW9uKCl7cmV0dXJuIGV9O3JldHVybiByLmQodCxcImFcIix0KSx0fSxyLm89ZnVuY3Rpb24oZSx0KXtyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCl9LHIucD1cIlwiLHIoci5zPTkwKX0oezE3OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbj1yKDE4KSxpPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe31yZXR1cm4gZS5nZXRGaXJzdE1hdGNoPWZ1bmN0aW9uKGUsdCl7dmFyIHI9dC5tYXRjaChlKTtyZXR1cm4gciYmci5sZW5ndGg+MCYmclsxXXx8XCJcIn0sZS5nZXRTZWNvbmRNYXRjaD1mdW5jdGlvbihlLHQpe3ZhciByPXQubWF0Y2goZSk7cmV0dXJuIHImJnIubGVuZ3RoPjEmJnJbMl18fFwiXCJ9LGUubWF0Y2hBbmRSZXR1cm5Db25zdD1mdW5jdGlvbihlLHQscil7aWYoZS50ZXN0KHQpKXJldHVybiByfSxlLmdldFdpbmRvd3NWZXJzaW9uTmFtZT1mdW5jdGlvbihlKXtzd2l0Y2goZSl7Y2FzZVwiTlRcIjpyZXR1cm5cIk5UXCI7Y2FzZVwiWFBcIjpyZXR1cm5cIlhQXCI7Y2FzZVwiTlQgNS4wXCI6cmV0dXJuXCIyMDAwXCI7Y2FzZVwiTlQgNS4xXCI6cmV0dXJuXCJYUFwiO2Nhc2VcIk5UIDUuMlwiOnJldHVyblwiMjAwM1wiO2Nhc2VcIk5UIDYuMFwiOnJldHVyblwiVmlzdGFcIjtjYXNlXCJOVCA2LjFcIjpyZXR1cm5cIjdcIjtjYXNlXCJOVCA2LjJcIjpyZXR1cm5cIjhcIjtjYXNlXCJOVCA2LjNcIjpyZXR1cm5cIjguMVwiO2Nhc2VcIk5UIDEwLjBcIjpyZXR1cm5cIjEwXCI7ZGVmYXVsdDpyZXR1cm59fSxlLmdldE1hY09TVmVyc2lvbk5hbWU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zcGxpdChcIi5cIikuc3BsaWNlKDAsMikubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZSwxMCl8fDB9KSk7aWYodC5wdXNoKDApLDEwPT09dFswXSlzd2l0Y2godFsxXSl7Y2FzZSA1OnJldHVyblwiTGVvcGFyZFwiO2Nhc2UgNjpyZXR1cm5cIlNub3cgTGVvcGFyZFwiO2Nhc2UgNzpyZXR1cm5cIkxpb25cIjtjYXNlIDg6cmV0dXJuXCJNb3VudGFpbiBMaW9uXCI7Y2FzZSA5OnJldHVyblwiTWF2ZXJpY2tzXCI7Y2FzZSAxMDpyZXR1cm5cIllvc2VtaXRlXCI7Y2FzZSAxMTpyZXR1cm5cIkVsIENhcGl0YW5cIjtjYXNlIDEyOnJldHVyblwiU2llcnJhXCI7Y2FzZSAxMzpyZXR1cm5cIkhpZ2ggU2llcnJhXCI7Y2FzZSAxNDpyZXR1cm5cIk1vamF2ZVwiO2Nhc2UgMTU6cmV0dXJuXCJDYXRhbGluYVwiO2RlZmF1bHQ6cmV0dXJufX0sZS5nZXRBbmRyb2lkVmVyc2lvbk5hbWU9ZnVuY3Rpb24oZSl7dmFyIHQ9ZS5zcGxpdChcIi5cIikuc3BsaWNlKDAsMikubWFwKChmdW5jdGlvbihlKXtyZXR1cm4gcGFyc2VJbnQoZSwxMCl8fDB9KSk7aWYodC5wdXNoKDApLCEoMT09PXRbMF0mJnRbMV08NSkpcmV0dXJuIDE9PT10WzBdJiZ0WzFdPDY/XCJDdXBjYWtlXCI6MT09PXRbMF0mJnRbMV0+PTY/XCJEb251dFwiOjI9PT10WzBdJiZ0WzFdPDI/XCJFY2xhaXJcIjoyPT09dFswXSYmMj09PXRbMV0/XCJGcm95b1wiOjI9PT10WzBdJiZ0WzFdPjI/XCJHaW5nZXJicmVhZFwiOjM9PT10WzBdP1wiSG9uZXljb21iXCI6ND09PXRbMF0mJnRbMV08MT9cIkljZSBDcmVhbSBTYW5kd2ljaFwiOjQ9PT10WzBdJiZ0WzFdPDQ/XCJKZWxseSBCZWFuXCI6ND09PXRbMF0mJnRbMV0+PTQ/XCJLaXRLYXRcIjo1PT09dFswXT9cIkxvbGxpcG9wXCI6Nj09PXRbMF0/XCJNYXJzaG1hbGxvd1wiOjc9PT10WzBdP1wiTm91Z2F0XCI6OD09PXRbMF0/XCJPcmVvXCI6OT09PXRbMF0/XCJQaWVcIjp2b2lkIDB9LGUuZ2V0VmVyc2lvblByZWNpc2lvbj1mdW5jdGlvbihlKXtyZXR1cm4gZS5zcGxpdChcIi5cIikubGVuZ3RofSxlLmNvbXBhcmVWZXJzaW9ucz1mdW5jdGlvbih0LHIsbil7dm9pZCAwPT09biYmKG49ITEpO3ZhciBpPWUuZ2V0VmVyc2lvblByZWNpc2lvbih0KSxzPWUuZ2V0VmVyc2lvblByZWNpc2lvbihyKSxhPU1hdGgubWF4KGkscyksbz0wLHU9ZS5tYXAoW3Qscl0sKGZ1bmN0aW9uKHQpe3ZhciByPWEtZS5nZXRWZXJzaW9uUHJlY2lzaW9uKHQpLG49dCtuZXcgQXJyYXkocisxKS5qb2luKFwiLjBcIik7cmV0dXJuIGUubWFwKG4uc3BsaXQoXCIuXCIpLChmdW5jdGlvbihlKXtyZXR1cm4gbmV3IEFycmF5KDIwLWUubGVuZ3RoKS5qb2luKFwiMFwiKStlfSkpLnJldmVyc2UoKX0pKTtmb3IobiYmKG89YS1NYXRoLm1pbihpLHMpKSxhLT0xO2E+PW87KXtpZih1WzBdW2FdPnVbMV1bYV0pcmV0dXJuIDE7aWYodVswXVthXT09PXVbMV1bYV0pe2lmKGE9PT1vKXJldHVybiAwO2EtPTF9ZWxzZSBpZih1WzBdW2FdPHVbMV1bYV0pcmV0dXJuLTF9fSxlLm1hcD1mdW5jdGlvbihlLHQpe3ZhciByLG49W107aWYoQXJyYXkucHJvdG90eXBlLm1hcClyZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKGUsdCk7Zm9yKHI9MDtyPGUubGVuZ3RoO3IrPTEpbi5wdXNoKHQoZVtyXSkpO3JldHVybiBufSxlLmZpbmQ9ZnVuY3Rpb24oZSx0KXt2YXIgcixuO2lmKEFycmF5LnByb3RvdHlwZS5maW5kKXJldHVybiBBcnJheS5wcm90b3R5cGUuZmluZC5jYWxsKGUsdCk7Zm9yKHI9MCxuPWUubGVuZ3RoO3I8bjtyKz0xKXt2YXIgaT1lW3JdO2lmKHQoaSxyKSlyZXR1cm4gaX19LGUuYXNzaWduPWZ1bmN0aW9uKGUpe2Zvcih2YXIgdCxyLG49ZSxpPWFyZ3VtZW50cy5sZW5ndGgscz1uZXcgQXJyYXkoaT4xP2ktMTowKSxhPTE7YTxpO2ErKylzW2EtMV09YXJndW1lbnRzW2FdO2lmKE9iamVjdC5hc3NpZ24pcmV0dXJuIE9iamVjdC5hc3NpZ24uYXBwbHkoT2JqZWN0LFtlXS5jb25jYXQocykpO3ZhciBvPWZ1bmN0aW9uKCl7dmFyIGU9c1t0XTtcIm9iamVjdFwiPT10eXBlb2YgZSYmbnVsbCE9PWUmJk9iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe25bdF09ZVt0XX0pKX07Zm9yKHQ9MCxyPXMubGVuZ3RoO3Q8cjt0Kz0xKW8oKTtyZXR1cm4gZX0sZS5nZXRCcm93c2VyQWxpYXM9ZnVuY3Rpb24oZSl7cmV0dXJuIG4uQlJPV1NFUl9BTElBU0VTX01BUFtlXX0sZS5nZXRCcm93c2VyVHlwZUJ5QWxpYXM9ZnVuY3Rpb24oZSl7cmV0dXJuIG4uQlJPV1NFUl9NQVBbZV18fFwiXCJ9LGV9KCk7dC5kZWZhdWx0PWksZS5leHBvcnRzPXQuZGVmYXVsdH0sMTg6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LkVOR0lORV9NQVA9dC5PU19NQVA9dC5QTEFURk9STVNfTUFQPXQuQlJPV1NFUl9NQVA9dC5CUk9XU0VSX0FMSUFTRVNfTUFQPXZvaWQgMDt0LkJST1dTRVJfQUxJQVNFU19NQVA9e1wiQW1hem9uIFNpbGtcIjpcImFtYXpvbl9zaWxrXCIsXCJBbmRyb2lkIEJyb3dzZXJcIjpcImFuZHJvaWRcIixCYWRhOlwiYmFkYVwiLEJsYWNrQmVycnk6XCJibGFja2JlcnJ5XCIsQ2hyb21lOlwiY2hyb21lXCIsQ2hyb21pdW06XCJjaHJvbWl1bVwiLEVsZWN0cm9uOlwiZWxlY3Ryb25cIixFcGlwaGFueTpcImVwaXBoYW55XCIsRmlyZWZveDpcImZpcmVmb3hcIixGb2N1czpcImZvY3VzXCIsR2VuZXJpYzpcImdlbmVyaWNcIixcIkdvb2dsZSBTZWFyY2hcIjpcImdvb2dsZV9zZWFyY2hcIixHb29nbGVib3Q6XCJnb29nbGVib3RcIixcIkludGVybmV0IEV4cGxvcmVyXCI6XCJpZVwiLFwiSy1NZWxlb25cIjpcImtfbWVsZW9uXCIsTWF4dGhvbjpcIm1heHRob25cIixcIk1pY3Jvc29mdCBFZGdlXCI6XCJlZGdlXCIsXCJNWiBCcm93c2VyXCI6XCJtelwiLFwiTkFWRVIgV2hhbGUgQnJvd3NlclwiOlwibmF2ZXJcIixPcGVyYTpcIm9wZXJhXCIsXCJPcGVyYSBDb2FzdFwiOlwib3BlcmFfY29hc3RcIixQaGFudG9tSlM6XCJwaGFudG9tanNcIixQdWZmaW46XCJwdWZmaW5cIixRdXBaaWxsYTpcInF1cHppbGxhXCIsUVE6XCJxcVwiLFFRTGl0ZTpcInFxbGl0ZVwiLFNhZmFyaTpcInNhZmFyaVwiLFNhaWxmaXNoOlwic2FpbGZpc2hcIixcIlNhbXN1bmcgSW50ZXJuZXQgZm9yIEFuZHJvaWRcIjpcInNhbXN1bmdfaW50ZXJuZXRcIixTZWFNb25rZXk6XCJzZWFtb25rZXlcIixTbGVpcG5pcjpcInNsZWlwbmlyXCIsU3dpbmc6XCJzd2luZ1wiLFRpemVuOlwidGl6ZW5cIixcIlVDIEJyb3dzZXJcIjpcInVjXCIsVml2YWxkaTpcInZpdmFsZGlcIixcIldlYk9TIEJyb3dzZXJcIjpcIndlYm9zXCIsV2VDaGF0Olwid2VjaGF0XCIsXCJZYW5kZXggQnJvd3NlclwiOlwieWFuZGV4XCIsUm9rdTpcInJva3VcIn07dC5CUk9XU0VSX01BUD17YW1hem9uX3NpbGs6XCJBbWF6b24gU2lsa1wiLGFuZHJvaWQ6XCJBbmRyb2lkIEJyb3dzZXJcIixiYWRhOlwiQmFkYVwiLGJsYWNrYmVycnk6XCJCbGFja0JlcnJ5XCIsY2hyb21lOlwiQ2hyb21lXCIsY2hyb21pdW06XCJDaHJvbWl1bVwiLGVsZWN0cm9uOlwiRWxlY3Ryb25cIixlcGlwaGFueTpcIkVwaXBoYW55XCIsZmlyZWZveDpcIkZpcmVmb3hcIixmb2N1czpcIkZvY3VzXCIsZ2VuZXJpYzpcIkdlbmVyaWNcIixnb29nbGVib3Q6XCJHb29nbGVib3RcIixnb29nbGVfc2VhcmNoOlwiR29vZ2xlIFNlYXJjaFwiLGllOlwiSW50ZXJuZXQgRXhwbG9yZXJcIixrX21lbGVvbjpcIkstTWVsZW9uXCIsbWF4dGhvbjpcIk1heHRob25cIixlZGdlOlwiTWljcm9zb2Z0IEVkZ2VcIixtejpcIk1aIEJyb3dzZXJcIixuYXZlcjpcIk5BVkVSIFdoYWxlIEJyb3dzZXJcIixvcGVyYTpcIk9wZXJhXCIsb3BlcmFfY29hc3Q6XCJPcGVyYSBDb2FzdFwiLHBoYW50b21qczpcIlBoYW50b21KU1wiLHB1ZmZpbjpcIlB1ZmZpblwiLHF1cHppbGxhOlwiUXVwWmlsbGFcIixxcTpcIlFRIEJyb3dzZXJcIixxcWxpdGU6XCJRUSBCcm93c2VyIExpdGVcIixzYWZhcmk6XCJTYWZhcmlcIixzYWlsZmlzaDpcIlNhaWxmaXNoXCIsc2Ftc3VuZ19pbnRlcm5ldDpcIlNhbXN1bmcgSW50ZXJuZXQgZm9yIEFuZHJvaWRcIixzZWFtb25rZXk6XCJTZWFNb25rZXlcIixzbGVpcG5pcjpcIlNsZWlwbmlyXCIsc3dpbmc6XCJTd2luZ1wiLHRpemVuOlwiVGl6ZW5cIix1YzpcIlVDIEJyb3dzZXJcIix2aXZhbGRpOlwiVml2YWxkaVwiLHdlYm9zOlwiV2ViT1MgQnJvd3NlclwiLHdlY2hhdDpcIldlQ2hhdFwiLHlhbmRleDpcIllhbmRleCBCcm93c2VyXCJ9O3QuUExBVEZPUk1TX01BUD17dGFibGV0OlwidGFibGV0XCIsbW9iaWxlOlwibW9iaWxlXCIsZGVza3RvcDpcImRlc2t0b3BcIix0djpcInR2XCJ9O3QuT1NfTUFQPXtXaW5kb3dzUGhvbmU6XCJXaW5kb3dzIFBob25lXCIsV2luZG93czpcIldpbmRvd3NcIixNYWNPUzpcIm1hY09TXCIsaU9TOlwiaU9TXCIsQW5kcm9pZDpcIkFuZHJvaWRcIixXZWJPUzpcIldlYk9TXCIsQmxhY2tCZXJyeTpcIkJsYWNrQmVycnlcIixCYWRhOlwiQmFkYVwiLFRpemVuOlwiVGl6ZW5cIixMaW51eDpcIkxpbnV4XCIsQ2hyb21lT1M6XCJDaHJvbWUgT1NcIixQbGF5U3RhdGlvbjQ6XCJQbGF5U3RhdGlvbiA0XCIsUm9rdTpcIlJva3VcIn07dC5FTkdJTkVfTUFQPXtFZGdlSFRNTDpcIkVkZ2VIVE1MXCIsQmxpbms6XCJCbGlua1wiLFRyaWRlbnQ6XCJUcmlkZW50XCIsUHJlc3RvOlwiUHJlc3RvXCIsR2Vja286XCJHZWNrb1wiLFdlYktpdDpcIldlYktpdFwifX0sOTA6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGk9KG49cig5MSkpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxzPXIoMTgpO2Z1bmN0aW9uIGEoZSx0KXtmb3IodmFyIHI9MDtyPHQubGVuZ3RoO3IrKyl7dmFyIG49dFtyXTtuLmVudW1lcmFibGU9bi5lbnVtZXJhYmxlfHwhMSxuLmNvbmZpZ3VyYWJsZT0hMCxcInZhbHVlXCJpbiBuJiYobi53cml0YWJsZT0hMCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbi5rZXksbil9fXZhciBvPWZ1bmN0aW9uKCl7ZnVuY3Rpb24gZSgpe312YXIgdCxyLG47cmV0dXJuIGUuZ2V0UGFyc2VyPWZ1bmN0aW9uKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9ITEpLFwic3RyaW5nXCIhPXR5cGVvZiBlKXRocm93IG5ldyBFcnJvcihcIlVzZXJBZ2VudCBzaG91bGQgYmUgYSBzdHJpbmdcIik7cmV0dXJuIG5ldyBpLmRlZmF1bHQoZSx0KX0sZS5wYXJzZT1mdW5jdGlvbihlKXtyZXR1cm4gbmV3IGkuZGVmYXVsdChlKS5nZXRSZXN1bHQoKX0sdD1lLG49W3trZXk6XCJCUk9XU0VSX01BUFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLkJST1dTRVJfTUFQfX0se2tleTpcIkVOR0lORV9NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5FTkdJTkVfTUFQfX0se2tleTpcIk9TX01BUFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLk9TX01BUH19LHtrZXk6XCJQTEFURk9STVNfTUFQXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuUExBVEZPUk1TX01BUH19XSwocj1udWxsKSYmYSh0LnByb3RvdHlwZSxyKSxuJiZhKHQsbiksZX0oKTt0LmRlZmF1bHQ9byxlLmV4cG9ydHM9dC5kZWZhdWx0fSw5MTpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG49dShyKDkyKSksaT11KHIoOTMpKSxzPXUocig5NCkpLGE9dShyKDk1KSksbz11KHIoMTcpKTtmdW5jdGlvbiB1KGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX12YXIgZD1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoZSx0KXtpZih2b2lkIDA9PT10JiYodD0hMSksbnVsbD09ZXx8XCJcIj09PWUpdGhyb3cgbmV3IEVycm9yKFwiVXNlckFnZW50IHBhcmFtZXRlciBjYW4ndCBiZSBlbXB0eVwiKTt0aGlzLl91YT1lLHRoaXMucGFyc2VkUmVzdWx0PXt9LCEwIT09dCYmdGhpcy5wYXJzZSgpfXZhciB0PWUucHJvdG90eXBlO3JldHVybiB0LmdldFVBPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3VhfSx0LnRlc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGUudGVzdCh0aGlzLl91YSl9LHQucGFyc2VCcm93c2VyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyPXt9O3ZhciB0PW8uZGVmYXVsdC5maW5kKG4uZGVmYXVsdCwoZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC50ZXN0KXJldHVybiB0LnRlc3QoZSk7aWYodC50ZXN0IGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuIHQudGVzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZS50ZXN0KHQpfSkpO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyB0ZXN0IGZ1bmN0aW9uIGlzIG5vdCB2YWxpZFwiKX0pKTtyZXR1cm4gdCYmKHRoaXMucGFyc2VkUmVzdWx0LmJyb3dzZXI9dC5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSx0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyfSx0LmdldEJyb3dzZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcj90aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyOnRoaXMucGFyc2VCcm93c2VyKCl9LHQuZ2V0QnJvd3Nlck5hbWU9ZnVuY3Rpb24oZSl7cmV0dXJuIGU/U3RyaW5nKHRoaXMuZ2V0QnJvd3NlcigpLm5hbWUpLnRvTG93ZXJDYXNlKCl8fFwiXCI6dGhpcy5nZXRCcm93c2VyKCkubmFtZXx8XCJcIn0sdC5nZXRCcm93c2VyVmVyc2lvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEJyb3dzZXIoKS52ZXJzaW9ufSx0LmdldE9TPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VkUmVzdWx0Lm9zP3RoaXMucGFyc2VkUmVzdWx0Lm9zOnRoaXMucGFyc2VPUygpfSx0LnBhcnNlT1M9ZnVuY3Rpb24oKXt2YXIgZT10aGlzO3RoaXMucGFyc2VkUmVzdWx0Lm9zPXt9O3ZhciB0PW8uZGVmYXVsdC5maW5kKGkuZGVmYXVsdCwoZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC50ZXN0KXJldHVybiB0LnRlc3QoZSk7aWYodC50ZXN0IGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuIHQudGVzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZS50ZXN0KHQpfSkpO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyB0ZXN0IGZ1bmN0aW9uIGlzIG5vdCB2YWxpZFwiKX0pKTtyZXR1cm4gdCYmKHRoaXMucGFyc2VkUmVzdWx0Lm9zPXQuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksdGhpcy5wYXJzZWRSZXN1bHQub3N9LHQuZ2V0T1NOYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXMuZ2V0T1MoKS5uYW1lO3JldHVybiBlP1N0cmluZyh0KS50b0xvd2VyQ2FzZSgpfHxcIlwiOnR8fFwiXCJ9LHQuZ2V0T1NWZXJzaW9uPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0T1MoKS52ZXJzaW9ufSx0LmdldFBsYXRmb3JtPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VkUmVzdWx0LnBsYXRmb3JtP3RoaXMucGFyc2VkUmVzdWx0LnBsYXRmb3JtOnRoaXMucGFyc2VQbGF0Zm9ybSgpfSx0LmdldFBsYXRmb3JtVHlwZT1mdW5jdGlvbihlKXt2b2lkIDA9PT1lJiYoZT0hMSk7dmFyIHQ9dGhpcy5nZXRQbGF0Zm9ybSgpLnR5cGU7cmV0dXJuIGU/U3RyaW5nKHQpLnRvTG93ZXJDYXNlKCl8fFwiXCI6dHx8XCJcIn0sdC5wYXJzZVBsYXRmb3JtPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybT17fTt2YXIgdD1vLmRlZmF1bHQuZmluZChzLmRlZmF1bHQsKGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGVzdClyZXR1cm4gdC50ZXN0KGUpO2lmKHQudGVzdCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiB0LnRlc3Quc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUudGVzdCh0KX0pKTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgdGVzdCBmdW5jdGlvbiBpcyBub3QgdmFsaWRcIil9KSk7cmV0dXJuIHQmJih0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybT10LmRlc2NyaWJlKHRoaXMuZ2V0VUEoKSkpLHRoaXMucGFyc2VkUmVzdWx0LnBsYXRmb3JtfSx0LmdldEVuZ2luZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5lbmdpbmU/dGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lOnRoaXMucGFyc2VFbmdpbmUoKX0sdC5nZXRFbmdpbmVOYW1lPWZ1bmN0aW9uKGUpe3JldHVybiBlP1N0cmluZyh0aGlzLmdldEVuZ2luZSgpLm5hbWUpLnRvTG93ZXJDYXNlKCl8fFwiXCI6dGhpcy5nZXRFbmdpbmUoKS5uYW1lfHxcIlwifSx0LnBhcnNlRW5naW5lPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnBhcnNlZFJlc3VsdC5lbmdpbmU9e307dmFyIHQ9by5kZWZhdWx0LmZpbmQoYS5kZWZhdWx0LChmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRlc3QpcmV0dXJuIHQudGVzdChlKTtpZih0LnRlc3QgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm4gdC50ZXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRlc3QodCl9KSk7dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpfSkpO3JldHVybiB0JiYodGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lPXQuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksdGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lfSx0LnBhcnNlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VCcm93c2VyKCksdGhpcy5wYXJzZU9TKCksdGhpcy5wYXJzZVBsYXRmb3JtKCksdGhpcy5wYXJzZUVuZ2luZSgpLHRoaXN9LHQuZ2V0UmVzdWx0PWZ1bmN0aW9uKCl7cmV0dXJuIG8uZGVmYXVsdC5hc3NpZ24oe30sdGhpcy5wYXJzZWRSZXN1bHQpfSx0LnNhdGlzZmllcz1mdW5jdGlvbihlKXt2YXIgdD10aGlzLHI9e30sbj0wLGk9e30scz0wO2lmKE9iamVjdC5rZXlzKGUpLmZvckVhY2goKGZ1bmN0aW9uKHQpe3ZhciBhPWVbdF07XCJzdHJpbmdcIj09dHlwZW9mIGE/KGlbdF09YSxzKz0xKTpcIm9iamVjdFwiPT10eXBlb2YgYSYmKHJbdF09YSxuKz0xKX0pKSxuPjApe3ZhciBhPU9iamVjdC5rZXlzKHIpLHU9by5kZWZhdWx0LmZpbmQoYSwoZnVuY3Rpb24oZSl7cmV0dXJuIHQuaXNPUyhlKX0pKTtpZih1KXt2YXIgZD10aGlzLnNhdGlzZmllcyhyW3VdKTtpZih2b2lkIDAhPT1kKXJldHVybiBkfXZhciBjPW8uZGVmYXVsdC5maW5kKGEsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmlzUGxhdGZvcm0oZSl9KSk7aWYoYyl7dmFyIGY9dGhpcy5zYXRpc2ZpZXMocltjXSk7aWYodm9pZCAwIT09ZilyZXR1cm4gZn19aWYocz4wKXt2YXIgbD1PYmplY3Qua2V5cyhpKSxoPW8uZGVmYXVsdC5maW5kKGwsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmlzQnJvd3NlcihlLCEwKX0pKTtpZih2b2lkIDAhPT1oKXJldHVybiB0aGlzLmNvbXBhcmVWZXJzaW9uKGlbaF0pfX0sdC5pc0Jyb3dzZXI9ZnVuY3Rpb24oZSx0KXt2b2lkIDA9PT10JiYodD0hMSk7dmFyIHI9dGhpcy5nZXRCcm93c2VyTmFtZSgpLnRvTG93ZXJDYXNlKCksbj1lLnRvTG93ZXJDYXNlKCksaT1vLmRlZmF1bHQuZ2V0QnJvd3NlclR5cGVCeUFsaWFzKG4pO3JldHVybiB0JiZpJiYobj1pLnRvTG93ZXJDYXNlKCkpLG49PT1yfSx0LmNvbXBhcmVWZXJzaW9uPWZ1bmN0aW9uKGUpe3ZhciB0PVswXSxyPWUsbj0hMSxpPXRoaXMuZ2V0QnJvd3NlclZlcnNpb24oKTtpZihcInN0cmluZ1wiPT10eXBlb2YgaSlyZXR1cm5cIj5cIj09PWVbMF18fFwiPFwiPT09ZVswXT8ocj1lLnN1YnN0cigxKSxcIj1cIj09PWVbMV0/KG49ITAscj1lLnN1YnN0cigyKSk6dD1bXSxcIj5cIj09PWVbMF0/dC5wdXNoKDEpOnQucHVzaCgtMSkpOlwiPVwiPT09ZVswXT9yPWUuc3Vic3RyKDEpOlwiflwiPT09ZVswXSYmKG49ITAscj1lLnN1YnN0cigxKSksdC5pbmRleE9mKG8uZGVmYXVsdC5jb21wYXJlVmVyc2lvbnMoaSxyLG4pKT4tMX0sdC5pc09TPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmdldE9TTmFtZSghMCk9PT1TdHJpbmcoZSkudG9Mb3dlckNhc2UoKX0sdC5pc1BsYXRmb3JtPWZ1bmN0aW9uKGUpe3JldHVybiB0aGlzLmdldFBsYXRmb3JtVHlwZSghMCk9PT1TdHJpbmcoZSkudG9Mb3dlckNhc2UoKX0sdC5pc0VuZ2luZT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRFbmdpbmVOYW1lKCEwKT09PVN0cmluZyhlKS50b0xvd2VyQ2FzZSgpfSx0LmlzPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIHZvaWQgMD09PXQmJih0PSExKSx0aGlzLmlzQnJvd3NlcihlLHQpfHx0aGlzLmlzT1MoZSl8fHRoaXMuaXNQbGF0Zm9ybShlKX0sdC5zb21lPWZ1bmN0aW9uKGUpe3ZhciB0PXRoaXM7cmV0dXJuIHZvaWQgMD09PWUmJihlPVtdKSxlLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmlzKGUpfSkpfSxlfSgpO3QuZGVmYXVsdD1kLGUuZXhwb3J0cz10LmRlZmF1bHR9LDkyOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn07dmFyIHM9L3ZlcnNpb25cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksYT1be3Rlc3Q6Wy9nb29nbGVib3QvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJHb29nbGVib3RcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZ29vZ2xlYm90XFwvKFxcZCsoXFwuXFxkKykpL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvb3BlcmEvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJPcGVyYVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpvcGVyYSlbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvb3ByXFwvfG9waW9zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiT3BlcmFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86b3ByfG9waW9zKVtcXHMvXShcXFMrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL1NhbXN1bmdCcm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2Ftc3VuZyBJbnRlcm5ldCBmb3IgQW5kcm9pZFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpTYW1zdW5nQnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvV2hhbGUvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJOQVZFUiBXaGFsZSBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OndoYWxlKVtcXHMvXShcXGQrKD86XFwuXFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL01aQnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1aIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86TVpCcm93c2VyKVtcXHMvXShcXGQrKD86XFwuXFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2ZvY3VzL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRm9jdXNcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86Zm9jdXMpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc3dpbmcvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTd2luZ1wifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpzd2luZylbXFxzL10oXFxkKyg/OlxcLlxcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9jb2FzdC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk9wZXJhIENvYXN0XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmNvYXN0KVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9vcHRcXC9cXGQrKD86Lj9fP1xcZCspKy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk9wZXJhIFRvdWNoXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om9wdClbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsveWFicm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiWWFuZGV4IEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86eWFicm93c2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy91Y2Jyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJVQyBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnVjYnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvTWF4dGhvbnxteGlvcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1heHRob25cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86TWF4dGhvbnxteGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZXBpcGhhbnkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJFcGlwaGFueVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzplcGlwaGFueSlbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvcHVmZmluL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUHVmZmluXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnB1ZmZpbilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2xlaXBuaXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTbGVpcG5pclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpzbGVpcG5pcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvay1tZWxlb24vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJLLU1lbGVvblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzprLW1lbGVvbilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvbWljcm9tZXNzZW5nZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJXZUNoYXRcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86bWljcm9tZXNzZW5nZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3FxYnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTovcXFicm93c2VybGl0ZS9pLnRlc3QoZSk/XCJRUSBCcm93c2VyIExpdGVcIjpcIlFRIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86cXFicm93c2VybGl0ZXxxcWJyb3dzZXIpWy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL21zaWV8dHJpZGVudC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkludGVybmV0IEV4cGxvcmVyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om1zaWUgfHJ2OikoXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvXFxzZWRnXFwvL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTWljcm9zb2Z0IEVkZ2VcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvXFxzZWRnXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2VkZyhbZWFdfGlvcykvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNaWNyb3NvZnQgRWRnZVwifSxyPWkuZGVmYXVsdC5nZXRTZWNvbmRNYXRjaCgvZWRnKFtlYV18aW9zKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy92aXZhbGRpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiVml2YWxkaVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC92aXZhbGRpXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NlYW1vbmtleS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNlYU1vbmtleVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9zZWFtb25rZXlcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2FpbGZpc2gvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTYWlsZmlzaFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9zYWlsZmlzaFxccz9icm93c2VyXFwvKFxcZCsoXFwuXFxkKyk/KS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NpbGsvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJBbWF6b24gU2lsa1wifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9zaWxrXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3BoYW50b20vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJQaGFudG9tSlNcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvcGhhbnRvbWpzXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NsaW1lcmpzL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2xpbWVySlNcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2xpbWVyanNcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvYmxhY2tiZXJyeXxcXGJiYlxcZCsvaSwvcmltXFxzdGFibGV0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQmxhY2tCZXJyeVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9ibGFja2JlcnJ5W1xcZF0rXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbLyh3ZWJ8aHB3KVtvMF1zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiV2ViT1MgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC93KD86ZWIpP1tvMF1zYnJvd3NlclxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9iYWRhL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQmFkYVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9kb2xmaW5cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvdGl6ZW4vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJUaXplblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp0aXplblxccz8pP2Jyb3dzZXJcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvcXVwemlsbGEvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJRdXBaaWxsYVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpxdXB6aWxsYSlbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZmlyZWZveHxpY2V3ZWFzZWx8Znhpb3MvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJGaXJlZm94XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9lbGVjdHJvbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkVsZWN0cm9uXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmVsZWN0cm9uKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9NaXVpQnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1pdWlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86TWl1aUJyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2Nocm9taXVtL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQ2hyb21pdW1cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86Y2hyb21pdW0pW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2Nocm9tZXxjcmlvc3xjcm1vL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQ2hyb21lXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmNocm9tZXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9HU0EvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJHb29nbGUgU2VhcmNoXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OkdTQSlcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PSFlLnRlc3QoL2xpa2UgYW5kcm9pZC9pKSxyPWUudGVzdCgvYW5kcm9pZC9pKTtyZXR1cm4gdCYmcn0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJBbmRyb2lkIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3BsYXlzdGF0aW9uIDQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJQbGF5U3RhdGlvbiA0XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zYWZhcml8YXBwbGV3ZWJraXQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTYWZhcmlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbLy4qL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PS0xIT09ZS5zZWFyY2goXCJcXFxcKFwiKT8vXiguKilcXC8oLiopWyBcXHRdXFwoKC4qKS86L14oLiopXFwvKC4qKSAvO3JldHVybntuYW1lOmkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHQsZSksdmVyc2lvbjppLmRlZmF1bHQuZ2V0U2Vjb25kTWF0Y2godCxlKX19fV07dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH0sOTM6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGk9KG49cigxNykpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxzPXIoMTgpO3ZhciBhPVt7dGVzdDpbL1Jva3VcXC9EVlAvXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvUm9rdVxcL0RWUC0oXFxkK1xcLlxcZCspL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuUm9rdSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy93aW5kb3dzIHBob25lL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC93aW5kb3dzIHBob25lICg/Om9zKT9cXHM/KFxcZCsoXFwuXFxkKykqKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLldpbmRvd3NQaG9uZSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy93aW5kb3dzIC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvV2luZG93cyAoKE5UfFhQKSggXFxkXFxkPy5cXGQpPykvaSxlKSxyPWkuZGVmYXVsdC5nZXRXaW5kb3dzVmVyc2lvbk5hbWUodCk7cmV0dXJue25hbWU6cy5PU19NQVAuV2luZG93cyx2ZXJzaW9uOnQsdmVyc2lvbk5hbWU6cn19fSx7dGVzdDpbL01hY2ludG9zaCguKj8pIEZ4aU9TKC4qPylcXC8vXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLk9TX01BUC5pT1N9LHI9aS5kZWZhdWx0LmdldFNlY29uZE1hdGNoKC8oVmVyc2lvblxcLykoXFxkW1xcZC5dKykvLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL21hY2ludG9zaC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvbWFjIG9zIHggKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpLnJlcGxhY2UoL1tfXFxzXS9nLFwiLlwiKSxyPWkuZGVmYXVsdC5nZXRNYWNPU1ZlcnNpb25OYW1lKHQpLG49e25hbWU6cy5PU19NQVAuTWFjT1MsdmVyc2lvbjp0fTtyZXR1cm4gciYmKG4udmVyc2lvbk5hbWU9ciksbn19LHt0ZXN0OlsvKGlwb2R8aXBob25lfGlwYWQpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9vcyAoXFxkKyhbX1xcc11cXGQrKSopIGxpa2UgbWFjIG9zIHgvaSxlKS5yZXBsYWNlKC9bX1xcc10vZyxcIi5cIik7cmV0dXJue25hbWU6cy5PU19NQVAuaU9TLHZlcnNpb246dH19fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD0hZS50ZXN0KC9saWtlIGFuZHJvaWQvaSkscj1lLnRlc3QoL2FuZHJvaWQvaSk7cmV0dXJuIHQmJnJ9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9hbmRyb2lkW1xccy8tXShcXGQrKFxcLlxcZCspKikvaSxlKSxyPWkuZGVmYXVsdC5nZXRBbmRyb2lkVmVyc2lvbk5hbWUodCksbj17bmFtZTpzLk9TX01BUC5BbmRyb2lkLHZlcnNpb246dH07cmV0dXJuIHImJihuLnZlcnNpb25OYW1lPXIpLG59fSx7dGVzdDpbLyh3ZWJ8aHB3KVtvMF1zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp3ZWJ8aHB3KVtvMF1zXFwvKFxcZCsoXFwuXFxkKykqKS9pLGUpLHI9e25hbWU6cy5PU19NQVAuV2ViT1N9O3JldHVybiB0JiZ0Lmxlbmd0aCYmKHIudmVyc2lvbj10KSxyfX0se3Rlc3Q6Wy9ibGFja2JlcnJ5fFxcYmJiXFxkKy9pLC9yaW1cXHN0YWJsZXQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3JpbVxcc3RhYmxldFxcc29zXFxzKFxcZCsoXFwuXFxkKykqKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYmxhY2tiZXJyeVxcZCtcXC8oXFxkKyhbX1xcc11cXGQrKSopL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9cXGJiYihcXGQrKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLkJsYWNrQmVycnksdmVyc2lvbjp0fX19LHt0ZXN0OlsvYmFkYS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYmFkYVxcLyhcXGQrKFxcLlxcZCspKikvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5CYWRhLHZlcnNpb246dH19fSx7dGVzdDpbL3RpemVuL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC90aXplblsvXFxzXShcXGQrKFxcLlxcZCspKikvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5UaXplbix2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy9saW51eC9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybntuYW1lOnMuT1NfTUFQLkxpbnV4fX19LHt0ZXN0OlsvQ3JPUy9dLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue25hbWU6cy5PU19NQVAuQ2hyb21lT1N9fX0se3Rlc3Q6Wy9QbGF5U3RhdGlvbiA0L10sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1BsYXlTdGF0aW9uIDRbL1xcc10oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuUGxheVN0YXRpb240LHZlcnNpb246dH19fV07dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH0sOTQ6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGk9KG49cigxNykpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxzPXIoMTgpO3ZhciBhPVt7dGVzdDpbL2dvb2dsZWJvdC9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOlwiYm90XCIsdmVuZG9yOlwiR29vZ2xlXCJ9fX0se3Rlc3Q6Wy9odWF3ZWkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyhjYW4tbDAxKS9pLGUpJiZcIk5vdmFcIixyPXt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiSHVhd2VpXCJ9O3JldHVybiB0JiYoci5tb2RlbD10KSxyfX0se3Rlc3Q6Wy9uZXh1c1xccyooPzo3fDh8OXwxMCkuKi9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXQsdmVuZG9yOlwiTmV4dXNcIn19fSx7dGVzdDpbL2lwYWQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIkFwcGxlXCIsbW9kZWw6XCJpUGFkXCJ9fX0se3Rlc3Q6Wy9NYWNpbnRvc2goLio/KSBGeGlPUyguKj8pXFwvL10sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIkFwcGxlXCIsbW9kZWw6XCJpUGFkXCJ9fX0se3Rlc3Q6Wy9rZnR0IGJ1aWxkL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBbWF6b25cIixtb2RlbDpcIktpbmRsZSBGaXJlIEhEIDdcIn19fSx7dGVzdDpbL3NpbGsvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIkFtYXpvblwifX19LHt0ZXN0OlsvdGFibGV0KD8hIHBjKS9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXR9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9ZS50ZXN0KC9pcG9kfGlwaG9uZS9pKSxyPWUudGVzdCgvbGlrZSAoaXBvZHxpcGhvbmUpL2kpO3JldHVybiB0JiYhcn0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyhpcG9kfGlwaG9uZSkvaSxlKTtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIkFwcGxlXCIsbW9kZWw6dH19fSx7dGVzdDpbL25leHVzXFxzKlswLTZdLiovaSwvZ2FsYXh5IG5leHVzL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJOZXh1c1wifX19LHt0ZXN0OlsvW14tXW1vYmkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwiYmxhY2tiZXJyeVwiPT09ZS5nZXRCcm93c2VyTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJCbGFja0JlcnJ5XCJ9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJiYWRhXCI9PT1lLmdldEJyb3dzZXJOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwid2luZG93cyBwaG9uZVwiPT09ZS5nZXRCcm93c2VyTmFtZSgpfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiTWljcm9zb2Z0XCJ9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9TnVtYmVyKFN0cmluZyhlLmdldE9TVmVyc2lvbigpKS5zcGxpdChcIi5cIilbMF0pO3JldHVyblwiYW5kcm9pZFwiPT09ZS5nZXRPU05hbWUoITApJiZ0Pj0zfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXR9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJhbmRyb2lkXCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZX19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIm1hY29zXCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLmRlc2t0b3AsdmVuZG9yOlwiQXBwbGVcIn19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIndpbmRvd3NcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAuZGVza3RvcH19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cImxpbnV4XCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLmRlc2t0b3B9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJwbGF5c3RhdGlvbiA0XCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnR2fX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwicm9rdVwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50dn19fV07dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH0sOTU6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuLGk9KG49cigxNykpJiZuLl9fZXNNb2R1bGU/bjp7ZGVmYXVsdDpufSxzPXIoMTgpO3ZhciBhPVt7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIm1pY3Jvc29mdCBlZGdlXCI9PT1lLmdldEJyb3dzZXJOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7aWYoL1xcc2VkZ1xcLy9pLnRlc3QoZSkpcmV0dXJue25hbWU6cy5FTkdJTkVfTUFQLkJsaW5rfTt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZWRnZVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm57bmFtZTpzLkVOR0lORV9NQVAuRWRnZUhUTUwsdmVyc2lvbjp0fX19LHt0ZXN0OlsvdHJpZGVudC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuVHJpZGVudH0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdHJpZGVudFxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuIGUudGVzdCgvcHJlc3RvL2kpfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuUHJlc3RvfSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9wcmVzdG9cXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PWUudGVzdCgvZ2Vja28vaSkscj1lLnRlc3QoL2xpa2UgZ2Vja28vaSk7cmV0dXJuIHQmJiFyfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuR2Vja299LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2dlY2tvXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbLyhhcHBsZSk/d2Via2l0XFwvNTM3XFwuMzYvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpzLkVOR0lORV9NQVAuQmxpbmt9fX0se3Rlc3Q6Wy8oYXBwbGUpP3dlYmtpdC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpzLkVOR0lORV9NQVAuV2ViS2l0fSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC93ZWJraXRcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19XTt0LmRlZmF1bHQ9YSxlLmV4cG9ydHM9dC5kZWZhdWx0fX0pfSkpOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bowser/es5.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/aes.js":
/*!*******************************************!*\
  !*** ./node_modules/crypto-es/lib/aes.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AESAlgo\": function() { return /* binding */ AESAlgo; },\n/* harmony export */   \"AES\": function() { return /* binding */ AES; }\n/* harmony export */ });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\n// Lookup tables\nconst _SBOX = [];\nconst INV_SBOX = [];\nconst _SUB_MIX_0 = [];\nconst _SUB_MIX_1 = [];\nconst _SUB_MIX_2 = [];\nconst _SUB_MIX_3 = [];\nconst INV_SUB_MIX_0 = [];\nconst INV_SUB_MIX_1 = [];\nconst INV_SUB_MIX_2 = [];\nconst INV_SUB_MIX_3 = [];\n\n// Compute lookup tables\n\n// Compute double table\nconst d = [];\nfor (let i = 0; i < 256; i += 1) {\n  if (i < 128) {\n    d[i] = i << 1;\n  } else {\n    d[i] = (i << 1) ^ 0x11b;\n  }\n}\n\n// Walk GF(2^8)\nlet x = 0;\nlet xi = 0;\nfor (let i = 0; i < 256; i += 1) {\n  // Compute sbox\n  let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n  sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n  _SBOX[x] = sx;\n  INV_SBOX[sx] = x;\n\n  // Compute multiplication\n  const x2 = d[x];\n  const x4 = d[x2];\n  const x8 = d[x4];\n\n  // Compute sub bytes, mix columns tables\n  let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n  _SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n  _SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n  _SUB_MIX_2[x] = (t << 8) | (t >>> 24);\n  _SUB_MIX_3[x] = t;\n\n  // Compute inv sub bytes, inv mix columns tables\n  t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n  INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n  INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n  INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);\n  INV_SUB_MIX_3[sx] = t;\n\n  // Compute next counter\n  if (!x) {\n    xi = 1;\n    x = xi;\n  } else {\n    x = x2 ^ d[d[d[x8 ^ x2]]];\n    xi ^= d[d[xi]];\n  }\n}\n\n// Precomputed Rcon lookup\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n/**\n * AES block cipher algorithm.\n */\nclass AESAlgo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.BlockCipher {\n  _doReset() {\n    let t;\n\n    // Skip reset of nRounds has been set before and key did not change\n    if (this._nRounds && this._keyPriorReset === this._key) {\n      return;\n    }\n\n    // Shortcuts\n    this._keyPriorReset = this._key;\n    const key = this._keyPriorReset;\n    const keyWords = key.words;\n    const keySize = key.sigBytes / 4;\n\n    // Compute number of rounds\n    this._nRounds = keySize + 6;\n    const nRounds = this._nRounds;\n\n    // Compute number of key schedule rows\n    const ksRows = (nRounds + 1) * 4;\n\n    // Compute key schedule\n    this._keySchedule = [];\n    const keySchedule = this._keySchedule;\n    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {\n      if (ksRow < keySize) {\n        keySchedule[ksRow] = keyWords[ksRow];\n      } else {\n        t = keySchedule[ksRow - 1];\n\n        if (!(ksRow % keySize)) {\n          // Rot word\n          t = (t << 8) | (t >>> 24);\n\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n\n          // Mix Rcon\n          t ^= RCON[(ksRow / keySize) | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n        }\n\n        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n      }\n    }\n\n    // Compute inv key schedule\n    this._invKeySchedule = [];\n    const invKeySchedule = this._invKeySchedule;\n    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {\n      const ksRow = ksRows - invKsRow;\n\n      if (invKsRow % 4) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]]\n          ^ INV_SUB_MIX_1[_SBOX[(t >>> 16) & 0xff]]\n          ^ INV_SUB_MIX_2[_SBOX[(t >>> 8) & 0xff]]\n          ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];\n      }\n    }\n  }\n\n  encryptBlock(M, offset) {\n    this._doCryptBlock(\n      M, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX,\n    );\n  }\n\n  decryptBlock(M, offset) {\n    const _M = M;\n\n    // Swap 2nd and 4th rows\n    let t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n\n    this._doCryptBlock(\n      _M,\n      offset,\n      this._invKeySchedule,\n      INV_SUB_MIX_0,\n      INV_SUB_MIX_1,\n      INV_SUB_MIX_2,\n      INV_SUB_MIX_3,\n      INV_SBOX,\n    );\n\n    // Inv swap 2nd and 4th rows\n    t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n  }\n\n  _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n    const _M = M;\n\n    // Shortcut\n    const nRounds = this._nRounds;\n\n    // Get input, add round key\n    let s0 = _M[offset] ^ keySchedule[0];\n    let s1 = _M[offset + 1] ^ keySchedule[1];\n    let s2 = _M[offset + 2] ^ keySchedule[2];\n    let s3 = _M[offset + 3] ^ keySchedule[3];\n\n    // Key schedule row counter\n    let ksRow = 4;\n\n    // Rounds\n    for (let round = 1; round < nRounds; round += 1) {\n      // Shift rows, sub bytes, mix columns, add round key\n      const t0 = SUB_MIX_0[s0 >>> 24]\n        ^ SUB_MIX_1[(s1 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s2 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s3 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t1 = SUB_MIX_0[s1 >>> 24]\n        ^ SUB_MIX_1[(s2 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s3 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s0 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t2 = SUB_MIX_0[s2 >>> 24]\n        ^ SUB_MIX_1[(s3 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s0 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s1 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t3 = SUB_MIX_0[s3 >>> 24]\n        ^ SUB_MIX_1[(s0 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s1 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s2 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n\n      // Update state\n      s0 = t0;\n      s1 = t1;\n      s2 = t2;\n      s3 = t3;\n    }\n\n    // Shift rows, sub bytes, add round key\n    const t0 = (\n      (SBOX[s0 >>> 24] << 24)\n        | (SBOX[(s1 >>> 16) & 0xff] << 16)\n        | (SBOX[(s2 >>> 8) & 0xff] << 8)\n        | SBOX[s3 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t1 = (\n      (SBOX[s1 >>> 24] << 24)\n        | (SBOX[(s2 >>> 16) & 0xff] << 16)\n        | (SBOX[(s3 >>> 8) & 0xff] << 8)\n        | SBOX[s0 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t2 = (\n      (SBOX[s2 >>> 24] << 24)\n        | (SBOX[(s3 >>> 16) & 0xff] << 16)\n        | (SBOX[(s0 >>> 8) & 0xff] << 8)\n        | SBOX[s1 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t3 = (\n      (SBOX[s3 >>> 24] << 24)\n        | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n\n    // Set output\n    _M[offset] = t0;\n    _M[offset + 1] = t1;\n    _M[offset + 2] = t2;\n    _M[offset + 3] = t3;\n  }\n}\nAESAlgo.keySize = 256 / 32;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n */\nconst AES = _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.BlockCipher._createHelper(AESAlgo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvYWVzLmpzP2VhYWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLHNCQUFzQix3REFBVztBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGdCQUFnQjtBQUN2QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sWUFBWSxzRUFBeUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9hZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCbG9ja0NpcGhlcixcbn0gZnJvbSAnLi9jaXBoZXItY29yZS5qcyc7XG5cbi8vIExvb2t1cCB0YWJsZXNcbmNvbnN0IF9TQk9YID0gW107XG5jb25zdCBJTlZfU0JPWCA9IFtdO1xuY29uc3QgX1NVQl9NSVhfMCA9IFtdO1xuY29uc3QgX1NVQl9NSVhfMSA9IFtdO1xuY29uc3QgX1NVQl9NSVhfMiA9IFtdO1xuY29uc3QgX1NVQl9NSVhfMyA9IFtdO1xuY29uc3QgSU5WX1NVQl9NSVhfMCA9IFtdO1xuY29uc3QgSU5WX1NVQl9NSVhfMSA9IFtdO1xuY29uc3QgSU5WX1NVQl9NSVhfMiA9IFtdO1xuY29uc3QgSU5WX1NVQl9NSVhfMyA9IFtdO1xuXG4vLyBDb21wdXRlIGxvb2t1cCB0YWJsZXNcblxuLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcbmNvbnN0IGQgPSBbXTtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpICs9IDEpIHtcbiAgaWYgKGkgPCAxMjgpIHtcbiAgICBkW2ldID0gaSA8PCAxO1xuICB9IGVsc2Uge1xuICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xuICB9XG59XG5cbi8vIFdhbGsgR0YoMl44KVxubGV0IHggPSAwO1xubGV0IHhpID0gMDtcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpICs9IDEpIHtcbiAgLy8gQ29tcHV0ZSBzYm94XG4gIGxldCBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XG4gIF9TQk9YW3hdID0gc3g7XG4gIElOVl9TQk9YW3N4XSA9IHg7XG5cbiAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuICBjb25zdCB4MiA9IGRbeF07XG4gIGNvbnN0IHg0ID0gZFt4Ml07XG4gIGNvbnN0IHg4ID0gZFt4NF07XG5cbiAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuICBsZXQgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG4gIF9TVUJfTUlYXzBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gIF9TVUJfTUlYXzFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuICBfU1VCX01JWF8yW3hdID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuICBfU1VCX01JWF8zW3hdID0gdDtcblxuICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcbiAgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcbiAgSU5WX1NVQl9NSVhfMFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG4gIElOVl9TVUJfTUlYXzFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcbiAgSU5WX1NVQl9NSVhfMltzeF0gPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG4gIElOVl9TVUJfTUlYXzNbc3hdID0gdDtcblxuICAvLyBDb21wdXRlIG5leHQgY291bnRlclxuICBpZiAoIXgpIHtcbiAgICB4aSA9IDE7XG4gICAgeCA9IHhpO1xuICB9IGVsc2Uge1xuICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG4gICAgeGkgXj0gZFtkW3hpXV07XG4gIH1cbn1cblxuLy8gUHJlY29tcHV0ZWQgUmNvbiBsb29rdXBcbmNvbnN0IFJDT04gPSBbMHgwMCwgMHgwMSwgMHgwMiwgMHgwNCwgMHgwOCwgMHgxMCwgMHgyMCwgMHg0MCwgMHg4MCwgMHgxYiwgMHgzNl07XG5cbi8qKlxuICogQUVTIGJsb2NrIGNpcGhlciBhbGdvcml0aG0uXG4gKi9cbmV4cG9ydCBjbGFzcyBBRVNBbGdvIGV4dGVuZHMgQmxvY2tDaXBoZXIge1xuICBfZG9SZXNldCgpIHtcbiAgICBsZXQgdDtcblxuICAgIC8vIFNraXAgcmVzZXQgb2YgblJvdW5kcyBoYXMgYmVlbiBzZXQgYmVmb3JlIGFuZCBrZXkgZGlkIG5vdCBjaGFuZ2VcbiAgICBpZiAodGhpcy5fblJvdW5kcyAmJiB0aGlzLl9rZXlQcmlvclJlc2V0ID09PSB0aGlzLl9rZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICB0aGlzLl9rZXlQcmlvclJlc2V0ID0gdGhpcy5fa2V5O1xuICAgIGNvbnN0IGtleSA9IHRoaXMuX2tleVByaW9yUmVzZXQ7XG4gICAgY29uc3Qga2V5V29yZHMgPSBrZXkud29yZHM7XG4gICAgY29uc3Qga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7XG5cbiAgICAvLyBDb21wdXRlIG51bWJlciBvZiByb3VuZHNcbiAgICB0aGlzLl9uUm91bmRzID0ga2V5U2l6ZSArIDY7XG4gICAgY29uc3QgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7XG5cbiAgICAvLyBDb21wdXRlIG51bWJlciBvZiBrZXkgc2NoZWR1bGUgcm93c1xuICAgIGNvbnN0IGtzUm93cyA9IChuUm91bmRzICsgMSkgKiA0O1xuXG4gICAgLy8gQ29tcHV0ZSBrZXkgc2NoZWR1bGVcbiAgICB0aGlzLl9rZXlTY2hlZHVsZSA9IFtdO1xuICAgIGNvbnN0IGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGU7XG4gICAgZm9yIChsZXQga3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3cgKz0gMSkge1xuICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlXb3Jkc1trc1Jvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSAxXTtcblxuICAgICAgICBpZiAoIShrc1JvdyAlIGtleVNpemUpKSB7XG4gICAgICAgICAgLy8gUm90IHdvcmRcbiAgICAgICAgICB0ID0gKHQgPDwgOCkgfCAodCA+Pj4gMjQpO1xuXG4gICAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgICB0ID0gKF9TQk9YW3QgPj4+IDI0XSA8PCAyNClcbiAgICAgICAgICAgIHwgKF9TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNilcbiAgICAgICAgICAgIHwgKF9TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpXG4gICAgICAgICAgICB8IF9TQk9YW3QgJiAweGZmXTtcblxuICAgICAgICAgIC8vIE1peCBSY29uXG4gICAgICAgICAgdCBePSBSQ09OWyhrc1JvdyAvIGtleVNpemUpIHwgMF0gPDwgMjQ7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09PSA0KSB7XG4gICAgICAgICAgLy8gU3ViIHdvcmRcbiAgICAgICAgICB0ID0gKF9TQk9YW3QgPj4+IDI0XSA8PCAyNClcbiAgICAgICAgICAgIHwgKF9TQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNilcbiAgICAgICAgICAgIHwgKF9TQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpXG4gICAgICAgICAgICB8IF9TQk9YW3QgJiAweGZmXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVNjaGVkdWxlW2tzUm93IC0ga2V5U2l6ZV0gXiB0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXB1dGUgaW52IGtleSBzY2hlZHVsZVxuICAgIHRoaXMuX2ludktleVNjaGVkdWxlID0gW107XG4gICAgY29uc3QgaW52S2V5U2NoZWR1bGUgPSB0aGlzLl9pbnZLZXlTY2hlZHVsZTtcbiAgICBmb3IgKGxldCBpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdyArPSAxKSB7XG4gICAgICBjb25zdCBrc1JvdyA9IGtzUm93cyAtIGludktzUm93O1xuXG4gICAgICBpZiAoaW52S3NSb3cgJSA0KSB7XG4gICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSA0XTtcbiAgICAgIH1cblxuICAgICAgaWYgKGludktzUm93IDwgNCB8fCBrc1JvdyA8PSA0KSB7XG4gICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBJTlZfU1VCX01JWF8wW19TQk9YW3QgPj4+IDI0XV1cbiAgICAgICAgICBeIElOVl9TVUJfTUlYXzFbX1NCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdXVxuICAgICAgICAgIF4gSU5WX1NVQl9NSVhfMltfU0JPWFsodCA+Pj4gOCkgJiAweGZmXV1cbiAgICAgICAgICBeIElOVl9TVUJfTUlYXzNbX1NCT1hbdCAmIDB4ZmZdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBlbmNyeXB0QmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgdGhpcy5fZG9DcnlwdEJsb2NrKFxuICAgICAgTSwgb2Zmc2V0LCB0aGlzLl9rZXlTY2hlZHVsZSwgX1NVQl9NSVhfMCwgX1NVQl9NSVhfMSwgX1NVQl9NSVhfMiwgX1NVQl9NSVhfMywgX1NCT1gsXG4gICAgKTtcbiAgfVxuXG4gIGRlY3J5cHRCbG9jayhNLCBvZmZzZXQpIHtcbiAgICBjb25zdCBfTSA9IE07XG5cbiAgICAvLyBTd2FwIDJuZCBhbmQgNHRoIHJvd3NcbiAgICBsZXQgdCA9IF9NW29mZnNldCArIDFdO1xuICAgIF9NW29mZnNldCArIDFdID0gX01bb2Zmc2V0ICsgM107XG4gICAgX01bb2Zmc2V0ICsgM10gPSB0O1xuXG4gICAgdGhpcy5fZG9DcnlwdEJsb2NrKFxuICAgICAgX00sXG4gICAgICBvZmZzZXQsXG4gICAgICB0aGlzLl9pbnZLZXlTY2hlZHVsZSxcbiAgICAgIElOVl9TVUJfTUlYXzAsXG4gICAgICBJTlZfU1VCX01JWF8xLFxuICAgICAgSU5WX1NVQl9NSVhfMixcbiAgICAgIElOVl9TVUJfTUlYXzMsXG4gICAgICBJTlZfU0JPWCxcbiAgICApO1xuXG4gICAgLy8gSW52IHN3YXAgMm5kIGFuZCA0dGggcm93c1xuICAgIHQgPSBfTVtvZmZzZXQgKyAxXTtcbiAgICBfTVtvZmZzZXQgKyAxXSA9IF9NW29mZnNldCArIDNdO1xuICAgIF9NW29mZnNldCArIDNdID0gdDtcbiAgfVxuXG4gIF9kb0NyeXB0QmxvY2soTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XG4gICAgY29uc3QgX00gPSBNO1xuXG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBuUm91bmRzID0gdGhpcy5fblJvdW5kcztcblxuICAgIC8vIEdldCBpbnB1dCwgYWRkIHJvdW5kIGtleVxuICAgIGxldCBzMCA9IF9NW29mZnNldF0gXiBrZXlTY2hlZHVsZVswXTtcbiAgICBsZXQgczEgPSBfTVtvZmZzZXQgKyAxXSBeIGtleVNjaGVkdWxlWzFdO1xuICAgIGxldCBzMiA9IF9NW29mZnNldCArIDJdIF4ga2V5U2NoZWR1bGVbMl07XG4gICAgbGV0IHMzID0gX01bb2Zmc2V0ICsgM10gXiBrZXlTY2hlZHVsZVszXTtcblxuICAgIC8vIEtleSBzY2hlZHVsZSByb3cgY291bnRlclxuICAgIGxldCBrc1JvdyA9IDQ7XG5cbiAgICAvLyBSb3VuZHNcbiAgICBmb3IgKGxldCByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQgKz0gMSkge1xuICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBtaXggY29sdW1ucywgYWRkIHJvdW5kIGtleVxuICAgICAgY29uc3QgdDAgPSBTVUJfTUlYXzBbczAgPj4+IDI0XVxuICAgICAgICBeIFNVQl9NSVhfMVsoczEgPj4+IDE2KSAmIDB4ZmZdXG4gICAgICAgIF4gU1VCX01JWF8yWyhzMiA+Pj4gOCkgJiAweGZmXVxuICAgICAgICBeIFNVQl9NSVhfM1tzMyAmIDB4ZmZdXG4gICAgICAgIF4ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAga3NSb3cgKz0gMTtcbiAgICAgIGNvbnN0IHQxID0gU1VCX01JWF8wW3MxID4+PiAyNF1cbiAgICAgICAgXiBTVUJfTUlYXzFbKHMyID4+PiAxNikgJiAweGZmXVxuICAgICAgICBeIFNVQl9NSVhfMlsoczMgPj4+IDgpICYgMHhmZl1cbiAgICAgICAgXiBTVUJfTUlYXzNbczAgJiAweGZmXVxuICAgICAgICBeIGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICAgIGtzUm93ICs9IDE7XG4gICAgICBjb25zdCB0MiA9IFNVQl9NSVhfMFtzMiA+Pj4gMjRdXG4gICAgICAgIF4gU1VCX01JWF8xWyhzMyA+Pj4gMTYpICYgMHhmZl1cbiAgICAgICAgXiBTVUJfTUlYXzJbKHMwID4+PiA4KSAmIDB4ZmZdXG4gICAgICAgIF4gU1VCX01JWF8zW3MxICYgMHhmZl1cbiAgICAgICAgXiBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAgICBrc1JvdyArPSAxO1xuICAgICAgY29uc3QgdDMgPSBTVUJfTUlYXzBbczMgPj4+IDI0XVxuICAgICAgICBeIFNVQl9NSVhfMVsoczAgPj4+IDE2KSAmIDB4ZmZdXG4gICAgICAgIF4gU1VCX01JWF8yWyhzMSA+Pj4gOCkgJiAweGZmXVxuICAgICAgICBeIFNVQl9NSVhfM1tzMiAmIDB4ZmZdXG4gICAgICAgIF4ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgICAga3NSb3cgKz0gMTtcblxuICAgICAgLy8gVXBkYXRlIHN0YXRlXG4gICAgICBzMCA9IHQwO1xuICAgICAgczEgPSB0MTtcbiAgICAgIHMyID0gdDI7XG4gICAgICBzMyA9IHQzO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgYWRkIHJvdW5kIGtleVxuICAgIGNvbnN0IHQwID0gKFxuICAgICAgKFNCT1hbczAgPj4+IDI0XSA8PCAyNClcbiAgICAgICAgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KVxuICAgICAgICB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KVxuICAgICAgICB8IFNCT1hbczMgJiAweGZmXVxuICAgICkgXiBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAga3NSb3cgKz0gMTtcbiAgICBjb25zdCB0MSA9IChcbiAgICAgIChTQk9YW3MxID4+PiAyNF0gPDwgMjQpXG4gICAgICAgIHwgKFNCT1hbKHMyID4+PiAxNikgJiAweGZmXSA8PCAxNilcbiAgICAgICAgfCAoU0JPWFsoczMgPj4+IDgpICYgMHhmZl0gPDwgOClcbiAgICAgICAgfCBTQk9YW3MwICYgMHhmZl1cbiAgICApIF4ga2V5U2NoZWR1bGVba3NSb3ddO1xuICAgIGtzUm93ICs9IDE7XG4gICAgY29uc3QgdDIgPSAoXG4gICAgICAoU0JPWFtzMiA+Pj4gMjRdIDw8IDI0KVxuICAgICAgICB8IChTQk9YWyhzMyA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpXG4gICAgICAgIHwgKFNCT1hbKHMwID4+PiA4KSAmIDB4ZmZdIDw8IDgpXG4gICAgICAgIHwgU0JPWFtzMSAmIDB4ZmZdXG4gICAgKSBeIGtleVNjaGVkdWxlW2tzUm93XTtcbiAgICBrc1JvdyArPSAxO1xuICAgIGNvbnN0IHQzID0gKFxuICAgICAgKFNCT1hbczMgPj4+IDI0XSA8PCAyNClcbiAgICAgICAgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXVxuICAgICkgXiBrZXlTY2hlZHVsZVtrc1Jvd107XG4gICAga3NSb3cgKz0gMTtcblxuICAgIC8vIFNldCBvdXRwdXRcbiAgICBfTVtvZmZzZXRdID0gdDA7XG4gICAgX01bb2Zmc2V0ICsgMV0gPSB0MTtcbiAgICBfTVtvZmZzZXQgKyAyXSA9IHQyO1xuICAgIF9NW29mZnNldCArIDNdID0gdDM7XG4gIH1cbn1cbkFFU0FsZ28ua2V5U2l6ZSA9IDI1NiAvIDMyO1xuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcbiAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IEFFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQUVTQWxnbyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/aes.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/cipher-core.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-es/lib/cipher-core.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Cipher\": function() { return /* binding */ Cipher; },\n/* harmony export */   \"StreamCipher\": function() { return /* binding */ StreamCipher; },\n/* harmony export */   \"BlockCipherMode\": function() { return /* binding */ BlockCipherMode; },\n/* harmony export */   \"CBC\": function() { return /* binding */ CBC; },\n/* harmony export */   \"Pkcs7\": function() { return /* binding */ Pkcs7; },\n/* harmony export */   \"BlockCipher\": function() { return /* binding */ BlockCipher; },\n/* harmony export */   \"CipherParams\": function() { return /* binding */ CipherParams; },\n/* harmony export */   \"OpenSSLFormatter\": function() { return /* binding */ OpenSSLFormatter; },\n/* harmony export */   \"SerializableCipher\": function() { return /* binding */ SerializableCipher; },\n/* harmony export */   \"OpenSSLKdf\": function() { return /* binding */ OpenSSLKdf; },\n/* harmony export */   \"PasswordBasedCipher\": function() { return /* binding */ PasswordBasedCipher; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _enc_base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./enc-base64.js */ \"./node_modules/crypto-es/lib/enc-base64.js\");\n/* harmony import */ var _evpkdf_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./evpkdf.js */ \"./node_modules/crypto-es/lib/evpkdf.js\");\n/* eslint-disable no-use-before-define */\n\n\n\n\n\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\nclass Cipher extends _core_js__WEBPACK_IMPORTED_MODULE_0__.BufferedBlockAlgorithm {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n    this.cfg = Object.assign(new _core_js__WEBPACK_IMPORTED_MODULE_0__.Base(), cfg);\n\n    // Store transform mode and key\n    this._xformMode = xformMode;\n    this._key = key;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = (key) => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n      return SerializableCipher;\n    };\n\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      },\n    };\n  }\n\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-cipher logic\n    this._doReset();\n  }\n\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate);\n\n    // Process available blocks\n    return this._process();\n  }\n\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    }\n\n    // Perform concrete-cipher logic\n    const finalProcessedData = this._doFinalize();\n\n    return finalProcessedData;\n  }\n}\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\nclass StreamCipher extends Cipher {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 1;\n  }\n\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * Abstract base block cipher mode template.\n */\nclass BlockCipherMode extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Base {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n}\n\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Choose mixing block\n  if (iv) {\n    block = iv;\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  }\n\n  // XOR blocks\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\nclass CBC extends BlockCipherMode {\n}\n/**\n * CBC encryptor.\n */\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // XOR and encrypt\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\n/**\n * CBC decryptor.\n */\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    // Decrypt and XOR\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n\n/**\n * PKCS #5/7 padding strategy.\n */\nconst Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);\n\n    // Create padding word\n    const paddingWord = (nPaddingBytes << 24)\n      | (nPaddingBytes << 16)\n      | (nPaddingBytes << 8)\n      | nPaddingBytes;\n\n    // Create padding\n    const paddingWords = [];\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n    const padding = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create(paddingWords, nPaddingBytes);\n\n    // Add padding\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\nclass BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign(\n      {\n        mode: CBC,\n        padding: Pkcs7,\n      },\n      cfg,\n    ));\n\n    this.blockSize = 128 / 32;\n  }\n\n  reset() {\n    let modeCreator;\n\n    // Reset cipher\n    super.reset.call(this);\n\n    // Shortcuts\n    const { cfg } = this;\n    const { iv, mode } = cfg;\n\n    // Reset block mode\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      modeCreator = mode.createDecryptor;\n      // Keep at least one block in the buffer for unpadding\n      this._minBufferSize = 1;\n    }\n\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n\n  _doFinalize() {\n    let finalProcessedBlocks;\n\n    // Shortcut\n    const { padding } = this.cfg;\n\n    // Finalize\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize);\n\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n\n      // Unpad data\n      padding.unpad(finalProcessedBlocks);\n    }\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\nclass CipherParams extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Base {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n\n    this.mixIn(cipherParams);\n  }\n\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n}\n\n/**\n * OpenSSL formatting strategy.\n */\nconst OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray;\n\n    // Shortcuts\n    const { ciphertext, salt } = cipherParams;\n\n    // Format\n    if (salt) {\n      wordArray = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(_enc_base64_js__WEBPACK_IMPORTED_MODULE_1__.Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt;\n\n    // Parse base64\n    const ciphertext = _enc_base64_js__WEBPACK_IMPORTED_MODULE_1__.Base64.parse(openSSLStr);\n\n    // Shortcut\n    const ciphertextWords = ciphertext.words;\n\n    // Test for salt\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create(ciphertextWords.slice(2, 4));\n\n      // Remove salt from ciphertext\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({ ciphertext, salt });\n  },\n};\n\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\nclass SerializableCipher extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Base {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new _core_js__WEBPACK_IMPORTED_MODULE_0__.Base(), this.cfg, cfg);\n\n    // Encrypt\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message);\n\n    // Shortcut\n    const cipherCfg = encryptor.cfg;\n\n    // Create and return serializable cipher params\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format,\n    });\n  }\n\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new _core_js__WEBPACK_IMPORTED_MODULE_0__.Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Decrypt\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n\n    return plaintext;\n  }\n\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n    return ciphertext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\nSerializableCipher.cfg = Object.assign(\n  new _core_js__WEBPACK_IMPORTED_MODULE_0__.Base(),\n  { format: OpenSSLFormatter },\n);\n\n/**\n * OpenSSL key derivation function.\n */\nconst OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt;\n\n    // Generate random salt\n    if (!_salt) {\n      _salt = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.random(64 / 8);\n    }\n\n    // Derive key and IV\n    const key = _evpkdf_js__WEBPACK_IMPORTED_MODULE_2__.EvpKDFAlgo.create({ keySize: keySize + ivSize }).compute(password, _salt);\n\n    // Separate key and IV\n    const iv = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4;\n\n    // Return params\n    return CipherParams.create({ key, iv, salt: _salt });\n  },\n};\n\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\nclass PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new _core_js__WEBPACK_IMPORTED_MODULE_0__.Base(), this.cfg, cfg);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Encrypt\n    const ciphertext = SerializableCipher.encrypt\n      .call(this, cipher, message, derivedParams.key, _cfg);\n\n    // Mix in derived params\n    ciphertext.mixIn(derivedParams);\n\n    return ciphertext;\n  }\n\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new _core_js__WEBPACK_IMPORTED_MODULE_0__.Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf\n      .execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Decrypt\n    const plaintext = SerializableCipher.decrypt\n      .call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n\n    return plaintext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvY2lwaGVyLWNvcmUuanM/NTVlZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOztBQU1tQjtBQUNzQjtBQUNBOztBQUV6QztBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDTyxxQkFBcUIsNERBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0EsaUNBQWlDLDBDQUFJOztBQUVyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxrQkFBa0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLGtCQUFrQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQSxP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QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtDQUFrQztBQUNoRDtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLDBDQUFJOztBQUV2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLElBQUk7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLGtCQUFrQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL2NpcGhlci1jb3JlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tdXNlLWJlZm9yZS1kZWZpbmUgKi9cblxuaW1wb3J0IHtcbiAgQmFzZSxcbiAgV29yZEFycmF5LFxuICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLFxufSBmcm9tICcuL2NvcmUuanMnO1xuaW1wb3J0IHsgQmFzZTY0IH0gZnJvbSAnLi9lbmMtYmFzZTY0LmpzJztcbmltcG9ydCB7IEV2cEtERkFsZ28gfSBmcm9tICcuL2V2cGtkZi5qcyc7XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBjaXBoZXIgdGVtcGxhdGUuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhpcyBjaXBoZXIncyBrZXkgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG4gKiBAcHJvcGVydHkge251bWJlcn0gaXZTaXplIFRoaXMgY2lwaGVyJ3MgSVYgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG4gKiBAcHJvcGVydHkge251bWJlcn0gX0VOQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGVuY3J5cHRpb24gbW9kZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfREVDX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxuICovXG5leHBvcnQgY2xhc3MgQ2lwaGVyIGV4dGVuZHMgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0geGZvcm1Nb2RlIEVpdGhlciB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHRyYW5zb3JtYXRpb24gbW9kZSBjb25zdGFudC5cbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlKFxuICAgKiAgICAgICBDcnlwdG9KUy5hbGdvLkFFUy5fRU5DX1hGT1JNX01PREUsIGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfVxuICAgKiAgICAgKTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKHhmb3JtTW9kZSwga2V5LCBjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgICAqL1xuICAgIHRoaXMuY2ZnID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZSgpLCBjZmcpO1xuXG4gICAgLy8gU3RvcmUgdHJhbnNmb3JtIG1vZGUgYW5kIGtleVxuICAgIHRoaXMuX3hmb3JtTW9kZSA9IHhmb3JtTW9kZTtcbiAgICB0aGlzLl9rZXkgPSBrZXk7XG5cbiAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBlbmNyeXB0aW9uIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlRW5jcnlwdG9yKGtleSwgY2ZnKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBkZWNyeXB0aW9uIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBlbmNyeXB0IGFuZCBkZWNyeXB0IHNob3J0Y3V0IGZ1bmN0aW9ucy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgQUVTID0gQ3J5cHRvSlMubGliLkNpcGhlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uQUVTKTtcbiAgICovXG4gIHN0YXRpYyBfY3JlYXRlSGVscGVyKFN1YkNpcGhlcikge1xuICAgIGNvbnN0IHNlbGVjdENpcGhlclN0cmF0ZWd5ID0gKGtleSkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBQYXNzd29yZEJhc2VkQ2lwaGVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFNlcmlhbGl6YWJsZUNpcGhlcjtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChTdWJDaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKTtcbiAgICAgIH0sXG5cbiAgICAgIGRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpIHtcbiAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZGVjcnlwdChTdWJDaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhpcyBjaXBoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjaXBoZXIucmVzZXQoKTtcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG4gICAgc3VwZXIucmVzZXQuY2FsbCh0aGlzKTtcblxuICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXG4gICAgdGhpcy5fZG9SZXNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIHByb2Nlc3NpbmcuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2VzcygnZGF0YScpO1xuICAgKiAgICAgY29uc3QgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3Mod29yZEFycmF5KTtcbiAgICovXG4gIHByb2Nlc3MoZGF0YVVwZGF0ZSkge1xuICAgIC8vIEFwcGVuZFxuICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcblxuICAgIC8vIFByb2Nlc3MgYXZhaWxhYmxlIGJsb2Nrc1xuICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKCk7XG4gIH1cblxuICAvKipcbiAgICogRmluYWxpemVzIHRoZSBlbmNyeXB0aW9uIG9yIGRlY3J5cHRpb24gcHJvY2Vzcy5cbiAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBmaW5hbCBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3QgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XG4gICAqICAgICBjb25zdCBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcbiAgICogICAgIGNvbnN0IGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuICAgKi9cbiAgZmluYWxpemUoZGF0YVVwZGF0ZSkge1xuICAgIC8vIEZpbmFsIGRhdGEgdXBkYXRlXG4gICAgaWYgKGRhdGFVcGRhdGUpIHtcbiAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuICAgIGNvbnN0IGZpbmFsUHJvY2Vzc2VkRGF0YSA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XG4gIH1cbn1cbkNpcGhlci5fRU5DX1hGT1JNX01PREUgPSAxO1xuQ2lwaGVyLl9ERUNfWEZPUk1fTU9ERSA9IDI7XG5DaXBoZXIua2V5U2l6ZSA9IDEyOCAvIDMyO1xuQ2lwaGVyLml2U2l6ZSA9IDEyOCAvIDMyO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2Ugc3RyZWFtIGNpcGhlciB0ZW1wbGF0ZS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplXG4gKlxuICogICAgIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxICgzMiBiaXRzKVxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtQ2lwaGVyIGV4dGVuZHMgQ2lwaGVyIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgdGhpcy5ibG9ja1NpemUgPSAxO1xuICB9XG5cbiAgX2RvRmluYWxpemUoKSB7XG4gICAgLy8gUHJvY2VzcyBwYXJ0aWFsIGJsb2Nrc1xuICAgIGNvbnN0IGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG4gICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuICB9XG59XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgbW9kZSB0ZW1wbGF0ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrQ2lwaGVyTW9kZSBleHRlbmRzIEJhc2Uge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG1vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYud29yZHMpO1xuICAgKi9cbiAgY29uc3RydWN0b3IoY2lwaGVyLCBpdikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XG4gICAgdGhpcy5faXYgPSBpdjtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZW5jcnlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRW5jcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2KSB7XG4gICAgcmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRGVjcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuICAgKi9cbiAgc3RhdGljIGNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2KSB7XG4gICAgcmV0dXJuIHRoaXMuRGVjcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB4b3JCbG9jayh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpIHtcbiAgY29uc3QgX3dvcmRzID0gd29yZHM7XG4gIGxldCBibG9jaztcblxuICAvLyBTaG9ydGN1dFxuICBjb25zdCBpdiA9IHRoaXMuX2l2O1xuXG4gIC8vIENob29zZSBtaXhpbmcgYmxvY2tcbiAgaWYgKGl2KSB7XG4gICAgYmxvY2sgPSBpdjtcblxuICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3NcbiAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcbiAgfSBlbHNlIHtcbiAgICBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcbiAgfVxuXG4gIC8vIFhPUiBibG9ja3NcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkgKz0gMSkge1xuICAgIF93b3Jkc1tvZmZzZXQgKyBpXSBePSBibG9ja1tpXTtcbiAgfVxufVxuXG4vKipcbiAqIENpcGhlciBCbG9jayBDaGFpbmluZyBtb2RlLlxuICovXG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBDQkMgbW9kZS5cbiAqL1xuZXhwb3J0IGNsYXNzIENCQyBleHRlbmRzIEJsb2NrQ2lwaGVyTW9kZSB7XG59XG4vKipcbiAqIENCQyBlbmNyeXB0b3IuXG4gKi9cbkNCQy5FbmNyeXB0b3IgPSBjbGFzcyBleHRlbmRzIENCQyB7XG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG4gICAqL1xuICBwcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcbiAgICBjb25zdCB7IGJsb2NrU2l6ZSB9ID0gY2lwaGVyO1xuXG4gICAgLy8gWE9SIGFuZCBlbmNyeXB0XG4gICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xuICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cbiAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcbiAgICB0aGlzLl9wcmV2QmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG4gIH1cbn07XG4vKipcbiAqIENCQyBkZWNyeXB0b3IuXG4gKi9cbkNCQy5EZWNyeXB0b3IgPSBjbGFzcyBleHRlbmRzIENCQyB7XG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG4gICAqL1xuICBwcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcbiAgICBjb25zdCB7IGJsb2NrU2l6ZSB9ID0gY2lwaGVyO1xuXG4gICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG4gICAgY29uc3QgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXG4gICAgLy8gRGVjcnlwdCBhbmQgWE9SXG4gICAgY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcbiAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cbiAgICAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXG4gICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xuICB9XG59O1xuXG4vKipcbiAqIFBLQ1MgIzUvNyBwYWRkaW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgUGtjczcgPSB7XG4gIC8qKlxuICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gcGFkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy5wYWQod29yZEFycmF5LCA0KTtcbiAgICovXG4gIHBhZChkYXRhLCBibG9ja1NpemUpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcbiAgICBjb25zdCBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSAoZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzKTtcblxuICAgIC8vIENyZWF0ZSBwYWRkaW5nIHdvcmRcbiAgICBjb25zdCBwYWRkaW5nV29yZCA9IChuUGFkZGluZ0J5dGVzIDw8IDI0KVxuICAgICAgfCAoblBhZGRpbmdCeXRlcyA8PCAxNilcbiAgICAgIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOClcbiAgICAgIHwgblBhZGRpbmdCeXRlcztcblxuICAgIC8vIENyZWF0ZSBwYWRkaW5nXG4gICAgY29uc3QgcGFkZGluZ1dvcmRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcbiAgICAgIHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IFdvcmRBcnJheS5jcmVhdGUocGFkZGluZ1dvcmRzLCBuUGFkZGluZ0J5dGVzKTtcblxuICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgZGF0YS5jb25jYXQocGFkZGluZyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVucGFkcyBkYXRhIHRoYXQgaGFkIGJlZW4gcGFkZGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcudW5wYWQod29yZEFycmF5KTtcbiAgICovXG4gIHVucGFkKGRhdGEpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcbiAgICBjb25zdCBuUGFkZGluZ0J5dGVzID0gX2RhdGEud29yZHNbKF9kYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuICAgIC8vIFJlbW92ZSBwYWRkaW5nXG4gICAgX2RhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcbiAgfSxcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgdGVtcGxhdGUuXG4gKlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZVxuICpcbiAqICAgIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcbiAqL1xuZXhwb3J0IGNsYXNzIEJsb2NrQ2lwaGVyIGV4dGVuZHMgQ2lwaGVyIHtcbiAgY29uc3RydWN0b3IoeGZvcm1Nb2RlLCBrZXksIGNmZykge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB0byB1c2UuIERlZmF1bHQ6IENCQ1xuICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IFBrY3M3XG4gICAgICovXG4gICAgc3VwZXIoeGZvcm1Nb2RlLCBrZXksIE9iamVjdC5hc3NpZ24oXG4gICAgICB7XG4gICAgICAgIG1vZGU6IENCQyxcbiAgICAgICAgcGFkZGluZzogUGtjczcsXG4gICAgICB9LFxuICAgICAgY2ZnLFxuICAgICkpO1xuXG4gICAgdGhpcy5ibG9ja1NpemUgPSAxMjggLyAzMjtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIGxldCBtb2RlQ3JlYXRvcjtcblxuICAgIC8vIFJlc2V0IGNpcGhlclxuICAgIHN1cGVyLnJlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCB7IGNmZyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGl2LCBtb2RlIH0gPSBjZmc7XG5cbiAgICAvLyBSZXNldCBibG9jayBtb2RlXG4gICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PT0gdGhpcy5jb25zdHJ1Y3Rvci5fRU5DX1hGT1JNX01PREUpIHtcbiAgICAgIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVFbmNyeXB0b3I7XG4gICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcbiAgICAgIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVEZWNyeXB0b3I7XG4gICAgICAvLyBLZWVwIGF0IGxlYXN0IG9uZSBibG9jayBpbiB0aGUgYnVmZmVyIGZvciB1bnBhZGRpbmdcbiAgICAgIHRoaXMuX21pbkJ1ZmZlclNpemUgPSAxO1xuICAgIH1cblxuICAgIHRoaXMuX21vZGUgPSBtb2RlQ3JlYXRvci5jYWxsKG1vZGUsIHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcbiAgICB0aGlzLl9tb2RlLl9fY3JlYXRvciA9IG1vZGVDcmVhdG9yO1xuICB9XG5cbiAgX2RvUHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpIHtcbiAgICB0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KTtcbiAgfVxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIGxldCBmaW5hbFByb2Nlc3NlZEJsb2NrcztcblxuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgeyBwYWRkaW5nIH0gPSB0aGlzLmNmZztcblxuICAgIC8vIEZpbmFsaXplXG4gICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PT0gdGhpcy5jb25zdHJ1Y3Rvci5fRU5DX1hGT1JNX01PREUpIHtcbiAgICAgIC8vIFBhZCBkYXRhXG4gICAgICBwYWRkaW5nLnBhZCh0aGlzLl9kYXRhLCB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG4gICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcbiAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuICAgICAgLy8gUHJvY2VzcyBmaW5hbCBibG9ja3NcbiAgICAgIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG4gICAgICAvLyBVbnBhZCBkYXRhXG4gICAgICBwYWRkaW5nLnVucGFkKGZpbmFsUHJvY2Vzc2VkQmxvY2tzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY2lwaGVyIHBhcmFtZXRlcnMuXG4gKlxuICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxuICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGtleSBUaGUga2V5IHRvIHRoaXMgY2lwaGVydGV4dC5cbiAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cbiAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuICogQHByb3BlcnR5IHtDaXBoZXJ9IGFsZ29yaXRobSBUaGUgY2lwaGVyIGFsZ29yaXRobS5cbiAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgYmxvY2sgc2l6ZSBvZiB0aGUgY2lwaGVyLlxuICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlclxuICogICAgVGhlIGRlZmF1bHQgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBjbGFzcyBDaXBoZXJQYXJhbXMgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNpcGhlclBhcmFtcyBBbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIHBvc3NpYmxlIGNpcGhlciBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmxpYi5DaXBoZXJQYXJhbXMuY3JlYXRlKHtcbiAgICogICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5LFxuICAgKiAgICAgICAgIGtleToga2V5V29yZEFycmF5LFxuICAgKiAgICAgICAgIGl2OiBpdldvcmRBcnJheSxcbiAgICogICAgICAgICBzYWx0OiBzYWx0V29yZEFycmF5LFxuICAgKiAgICAgICAgIGFsZ29yaXRobTogQ3J5cHRvSlMuYWxnby5BRVMsXG4gICAqICAgICAgICAgbW9kZTogQ3J5cHRvSlMubW9kZS5DQkMsXG4gICAqICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBLQ1M3LFxuICAgKiAgICAgICAgIGJsb2NrU2l6ZTogNCxcbiAgICogICAgICAgICBmb3JtYXR0ZXI6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMXG4gICAqICAgICB9KTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNpcGhlclBhcmFtcykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLm1peEluKGNpcGhlclBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtGb3JtYXR9IGZvcm1hdHRlciAoT3B0aW9uYWwpIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgY2lwaGVyIHBhcmFtcy5cbiAgICpcbiAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zICsgJyc7XG4gICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKCk7XG4gICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcbiAgICovXG4gIHRvU3RyaW5nKGZvcm1hdHRlcikge1xuICAgIHJldHVybiAoZm9ybWF0dGVyIHx8IHRoaXMuZm9ybWF0dGVyKS5zdHJpbmdpZnkodGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBPcGVuU1NMIGZvcm1hdHRpbmcgc3RyYXRlZ3kuXG4gKi9cbmV4cG9ydCBjb25zdCBPcGVuU1NMRm9ybWF0dGVyID0ge1xuICAvKipcbiAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIG9wZW5TU0xTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcbiAgICovXG4gIHN0cmluZ2lmeShjaXBoZXJQYXJhbXMpIHtcbiAgICBsZXQgd29yZEFycmF5O1xuXG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgeyBjaXBoZXJ0ZXh0LCBzYWx0IH0gPSBjaXBoZXJQYXJhbXM7XG5cbiAgICAvLyBGb3JtYXRcbiAgICBpZiAoc2FsdCkge1xuICAgICAgd29yZEFycmF5ID0gV29yZEFycmF5LmNyZWF0ZShbMHg1MzYxNmM3NCwgMHg2NTY0NWY1Zl0pLmNvbmNhdChzYWx0KS5jb25jYXQoY2lwaGVydGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmRBcnJheSA9IGNpcGhlcnRleHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcGVuU1NMU3RyIFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xuICAgKi9cbiAgcGFyc2Uob3BlblNTTFN0cikge1xuICAgIGxldCBzYWx0O1xuXG4gICAgLy8gUGFyc2UgYmFzZTY0XG4gICAgY29uc3QgY2lwaGVydGV4dCA9IEJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTtcblxuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgY2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3JkcztcblxuICAgIC8vIFRlc3QgZm9yIHNhbHRcbiAgICBpZiAoY2lwaGVydGV4dFdvcmRzWzBdID09PSAweDUzNjE2Yzc0ICYmIGNpcGhlcnRleHRXb3Jkc1sxXSA9PT0gMHg2NTY0NWY1Zikge1xuICAgICAgLy8gRXh0cmFjdCBzYWx0XG4gICAgICBzYWx0ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiwgNCkpO1xuXG4gICAgICAvLyBSZW1vdmUgc2FsdCBmcm9tIGNpcGhlcnRleHRcbiAgICAgIGNpcGhlcnRleHRXb3Jkcy5zcGxpY2UoMCwgNCk7XG4gICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xuICAgIH1cblxuICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dCwgc2FsdCB9KTtcbiAgfSxcbn07XG5cbi8qKlxuICogQSBjaXBoZXIgd3JhcHBlciB0aGF0IHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNlcmlhbGl6YWJsZUNpcGhlciBleHRlbmRzIEJhc2Uge1xuICAvKipcbiAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXJcbiAgICogICAgICAgLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSk7XG4gICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXJcbiAgICogICAgICAgLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYgfSk7XG4gICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXJcbiAgICogICAgICAgLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG4gICAqL1xuICBzdGF0aWMgZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG4gICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG4gICAgY29uc3QgX2NmZyA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2UoKSwgdGhpcy5jZmcsIGNmZyk7XG5cbiAgICAvLyBFbmNyeXB0XG4gICAgY29uc3QgZW5jcnlwdG9yID0gY2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksIF9jZmcpO1xuICAgIGNvbnN0IGNpcGhlcnRleHQgPSBlbmNyeXB0b3IuZmluYWxpemUobWVzc2FnZSk7XG5cbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGNpcGhlckNmZyA9IGVuY3J5cHRvci5jZmc7XG5cbiAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtc1xuICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtcbiAgICAgIGNpcGhlcnRleHQsXG4gICAgICBrZXksXG4gICAgICBpdjogY2lwaGVyQ2ZnLml2LFxuICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXG4gICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcbiAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxuICAgICAgYmxvY2tTaXplOiBlbmNyeXB0b3IuYmxvY2tTaXplLFxuICAgICAgZm9ybWF0dGVyOiBfY2ZnLmZvcm1hdCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyXG4gICAqICAgICAgIC5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksXG4gICAqICAgICAgICAgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG4gICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlclxuICAgKiAgICAgICAuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywga2V5LFxuICAgKiAgICAgICAgIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuICAgKi9cbiAgc3RhdGljIGRlY3J5cHQoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuICAgIGxldCBfY2lwaGVydGV4dCA9IGNpcGhlcnRleHQ7XG5cbiAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcbiAgICBjb25zdCBfY2ZnID0gT2JqZWN0LmFzc2lnbihuZXcgQmFzZSgpLCB0aGlzLmNmZywgY2ZnKTtcblxuICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuICAgIF9jaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoX2NpcGhlcnRleHQsIF9jZmcuZm9ybWF0KTtcblxuICAgIC8vIERlY3J5cHRcbiAgICBjb25zdCBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgX2NmZykuZmluYWxpemUoX2NpcGhlcnRleHQuY2lwaGVydGV4dCk7XG5cbiAgICByZXR1cm4gcGxhaW50ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXG4gICAqIGVsc2UgYXNzdW1lZCBDaXBoZXJQYXJhbXMgYWxyZWFkeSBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IHVuY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuICAgKiBAcGFyYW0ge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZSB0byBwYXJzZSBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG4gICAqXG4gICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXJcbiAgICogICAgICAgLl9wYXJzZShjaXBoZXJ0ZXh0U3RyaW5nT3JQYXJhbXMsIGZvcm1hdCk7XG4gICAqL1xuICBzdGF0aWMgX3BhcnNlKGNpcGhlcnRleHQsIGZvcm1hdCkge1xuICAgIGlmICh0eXBlb2YgY2lwaGVydGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuICB9XG59XG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqXG4gKiBAcHJvcGVydHkge0Zvcm1hdHRlcn0gZm9ybWF0XG4gKlxuICogICAgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCBjaXBoZXIgcGFyYW0gb2JqZWN0cyB0byBhbmQgZnJvbSBhIHN0cmluZy5cbiAqICAgIERlZmF1bHQ6IE9wZW5TU0xcbiAqL1xuU2VyaWFsaXphYmxlQ2lwaGVyLmNmZyA9IE9iamVjdC5hc3NpZ24oXG4gIG5ldyBCYXNlKCksXG4gIHsgZm9ybWF0OiBPcGVuU1NMRm9ybWF0dGVyIH0sXG4pO1xuXG4vKipcbiAqIE9wZW5TU0wga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBjb25zdCBPcGVuU1NMS2RmID0ge1xuICAvKipcbiAgICogRGVyaXZlcyBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGRlcml2ZSBmcm9tLlxuICAgKiBAcGFyYW0ge251bWJlcn0ga2V5U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUga2V5IHRvIGdlbmVyYXRlLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaXZTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBJViB0byBnZW5lcmF0ZS5cbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0XG4gICAqICAgICAoT3B0aW9uYWwpIEEgNjQtYml0IHNhbHQgdG8gdXNlLiBJZiBvbWl0dGVkLCBhIHNhbHQgd2lsbCBiZSBnZW5lcmF0ZWQgcmFuZG9tbHkuXG4gICAqXG4gICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdCB3aXRoIHRoZSBrZXksIElWLCBhbmQgc2FsdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyKTtcbiAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMiwgJ3NhbHRzYWx0Jyk7XG4gICAqL1xuICBleGVjdXRlKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcbiAgICBsZXQgX3NhbHQgPSBzYWx0O1xuXG4gICAgLy8gR2VuZXJhdGUgcmFuZG9tIHNhbHRcbiAgICBpZiAoIV9zYWx0KSB7XG4gICAgICBfc2FsdCA9IFdvcmRBcnJheS5yYW5kb20oNjQgLyA4KTtcbiAgICB9XG5cbiAgICAvLyBEZXJpdmUga2V5IGFuZCBJVlxuICAgIGNvbnN0IGtleSA9IEV2cEtERkFsZ28uY3JlYXRlKHsga2V5U2l6ZToga2V5U2l6ZSArIGl2U2l6ZSB9KS5jb21wdXRlKHBhc3N3b3JkLCBfc2FsdCk7XG5cbiAgICAvLyBTZXBhcmF0ZSBrZXkgYW5kIElWXG4gICAgY29uc3QgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XG4gICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cbiAgICAvLyBSZXR1cm4gcGFyYW1zXG4gICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBrZXksIGl2LCBzYWx0OiBfc2FsdCB9KTtcbiAgfSxcbn07XG5cbi8qKlxuICogQSBzZXJpYWxpemFibGUgY2lwaGVyIHdyYXBwZXIgdGhhdCBkZXJpdmVzIHRoZSBrZXkgZnJvbSBhIHBhc3N3b3JkLFxuICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cbiAqL1xuZXhwb3J0IGNsYXNzIFBhc3N3b3JkQmFzZWRDaXBoZXIgZXh0ZW5kcyBTZXJpYWxpemFibGVDaXBoZXIge1xuICAvKipcbiAgICogRW5jcnlwdHMgYSBtZXNzYWdlIHVzaW5nIGEgcGFzc3dvcmQuXG4gICAqXG4gICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyXG4gICAqICAgICAgIC5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcbiAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXJcbiAgICogICAgICAgLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICovXG4gIHN0YXRpYyBlbmNyeXB0KGNpcGhlciwgbWVzc2FnZSwgcGFzc3dvcmQsIGNmZykge1xuICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuICAgIGNvbnN0IF9jZmcgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlKCksIHRoaXMuY2ZnLCBjZmcpO1xuXG4gICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG4gICAgY29uc3QgZGVyaXZlZFBhcmFtcyA9IF9jZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcblxuICAgIC8vIEFkZCBJViB0byBjb25maWdcbiAgICBfY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuICAgIC8vIEVuY3J5cHRcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHRcbiAgICAgIC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIF9jZmcpO1xuXG4gICAgLy8gTWl4IGluIGRlcml2ZWQgcGFyYW1zXG4gICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcblxuICAgIHJldHVybiBjaXBoZXJ0ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxuICAgKlxuICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cbiAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyXG4gICAqICAgICAgIC5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCAncGFzc3dvcmQnLFxuICAgKiAgICAgICAgIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcbiAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlclxuICAgKiAgICAgICAuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJyxcbiAgICogICAgICAgICB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG4gICAqL1xuICBzdGF0aWMgZGVjcnlwdChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcbiAgICBsZXQgX2NpcGhlcnRleHQgPSBjaXBoZXJ0ZXh0O1xuXG4gICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG4gICAgY29uc3QgX2NmZyA9IE9iamVjdC5hc3NpZ24obmV3IEJhc2UoKSwgdGhpcy5jZmcsIGNmZyk7XG5cbiAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcbiAgICBfY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKF9jaXBoZXJ0ZXh0LCBfY2ZnLmZvcm1hdCk7XG5cbiAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcbiAgICBjb25zdCBkZXJpdmVkUGFyYW1zID0gX2NmZy5rZGZcbiAgICAgIC5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSwgX2NpcGhlcnRleHQuc2FsdCk7XG5cbiAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG4gICAgX2NmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cbiAgICAvLyBEZWNyeXB0XG4gICAgY29uc3QgcGxhaW50ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHRcbiAgICAgIC5jYWxsKHRoaXMsIGNpcGhlciwgX2NpcGhlcnRleHQsIGRlcml2ZWRQYXJhbXMua2V5LCBfY2ZnKTtcblxuICAgIHJldHVybiBwbGFpbnRleHQ7XG4gIH1cbn1cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICpcbiAqIEBwcm9wZXJ0eSB7S0RGfSBrZGZcbiAqICAgICBUaGUga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gdG8gdXNlIHRvIGdlbmVyYXRlIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuXG4gKiAgICAgRGVmYXVsdDogT3BlblNTTFxuICovXG5QYXNzd29yZEJhc2VkQ2lwaGVyLmNmZyA9IE9iamVjdC5hc3NpZ24oU2VyaWFsaXphYmxlQ2lwaGVyLmNmZywgeyBrZGY6IE9wZW5TU0xLZGYgfSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/cipher-core.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/core.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-es/lib/core.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Base\": function() { return /* binding */ Base; },\n/* harmony export */   \"WordArray\": function() { return /* binding */ WordArray; },\n/* harmony export */   \"Hex\": function() { return /* binding */ Hex; },\n/* harmony export */   \"Latin1\": function() { return /* binding */ Latin1; },\n/* harmony export */   \"Utf8\": function() { return /* binding */ Utf8; },\n/* harmony export */   \"BufferedBlockAlgorithm\": function() { return /* binding */ BufferedBlockAlgorithm; },\n/* harmony export */   \"Hasher\": function() { return /* binding */ Hasher; },\n/* harmony export */   \"HMAC\": function() { return /* binding */ HMAC; }\n/* harmony export */ });\n/* eslint-disable no-use-before-define */\n\n/**\n * Base class for inheritance.\n */\nclass Base {\n  /**\n   * Extends this object and runs the init method.\n   * Arguments to create() will be passed to init().\n   *\n   * @return {Object} The new object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var instance = MyType.create();\n   */\n  static create(...args) {\n    return new this(...args);\n  }\n\n  /**\n   * Copies properties into this object.\n   *\n   * @param {Object} properties The properties to mix in.\n   *\n   * @example\n   *\n   *     MyType.mixIn({\n   *         field: 'value'\n   *     });\n   */\n  mixIn(properties) {\n    return Object.assign(this, properties);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = instance.clone();\n   */\n  clone() {\n    const clone = new this.constructor();\n    Object.assign(clone, this);\n    return clone;\n  }\n}\n\n/**\n * An array of 32-bit words.\n *\n * @property {Array} words The array of 32-bit words.\n * @property {number} sigBytes The number of significant bytes in this word array.\n */\nclass WordArray extends Base {\n  /**\n   * Initializes a newly created word array.\n   *\n   * @param {Array} words (Optional) An array of 32-bit words.\n   * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.create();\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n   */\n  constructor(words = [], sigBytes = words.length * 4) {\n    super();\n\n    let typedArray = words;\n    // Convert buffers to uint8\n    if (typedArray instanceof ArrayBuffer) {\n      typedArray = new Uint8Array(typedArray);\n    }\n\n    // Convert other array views to uint8\n    if (\n      typedArray instanceof Int8Array\n      || typedArray instanceof Uint8ClampedArray\n      || typedArray instanceof Int16Array\n      || typedArray instanceof Uint16Array\n      || typedArray instanceof Int32Array\n      || typedArray instanceof Uint32Array\n      || typedArray instanceof Float32Array\n      || typedArray instanceof Float64Array\n    ) {\n      typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n    }\n\n    // Handle Uint8Array\n    if (typedArray instanceof Uint8Array) {\n      // Shortcut\n      const typedArrayByteLength = typedArray.byteLength;\n\n      // Extract bytes\n      const _words = [];\n      for (let i = 0; i < typedArrayByteLength; i += 1) {\n        _words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n      }\n\n      // Initialize this word array\n      this.words = _words;\n      this.sigBytes = typedArrayByteLength;\n    } else {\n      // Else call normal init\n      this.words = words;\n      this.sigBytes = sigBytes;\n    }\n  }\n\n  /**\n   * Creates a word array filled with random bytes.\n   *\n   * @param {number} nBytes The number of random bytes to generate.\n   *\n   * @return {WordArray} The random word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.random(16);\n   */\n  static random(nBytes) {\n    const words = [];\n\n    const r = (m_w) => {\n      let _m_w = m_w;\n      let _m_z = 0x3ade68b1;\n      const mask = 0xffffffff;\n\n      return () => {\n        _m_z = (0x9069 * (_m_z & 0xFFFF) + (_m_z >> 0x10)) & mask;\n        _m_w = (0x4650 * (_m_w & 0xFFFF) + (_m_w >> 0x10)) & mask;\n        let result = ((_m_z << 0x10) + _m_w) & mask;\n        result /= 0x100000000;\n        result += 0.5;\n        return result * (Math.random() > 0.5 ? 1 : -1);\n      };\n    };\n\n    for (let i = 0, rcache; i < nBytes; i += 4) {\n      const _r = r((rcache || Math.random()) * 0x100000000);\n\n      rcache = _r() * 0x3ade67b7;\n      words.push((_r() * 0x100000000) | 0);\n    }\n\n    return new WordArray(words, nBytes);\n  }\n\n  /**\n   * Converts this word array to a string.\n   *\n   * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n   *\n   * @return {string} The stringified word array.\n   *\n   * @example\n   *\n   *     var string = wordArray + '';\n   *     var string = wordArray.toString();\n   *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n   */\n  toString(encoder = Hex) {\n    return encoder.stringify(this);\n  }\n\n  /**\n   * Concatenates a word array to this word array.\n   *\n   * @param {WordArray} wordArray The word array to append.\n   *\n   * @return {WordArray} This word array.\n   *\n   * @example\n   *\n   *     wordArray1.concat(wordArray2);\n   */\n  concat(wordArray) {\n    // Shortcuts\n    const thisWords = this.words;\n    const thatWords = wordArray.words;\n    const thisSigBytes = this.sigBytes;\n    const thatSigBytes = wordArray.sigBytes;\n\n    // Clamp excess bits\n    this.clamp();\n\n    // Concat\n    if (thisSigBytes % 4) {\n      // Copy one byte at a time\n      for (let i = 0; i < thatSigBytes; i += 1) {\n        const thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n        thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n      }\n    } else {\n      // Copy one word at a time\n      for (let i = 0; i < thatSigBytes; i += 4) {\n        thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n      }\n    }\n    this.sigBytes += thatSigBytes;\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Removes insignificant bits.\n   *\n   * @example\n   *\n   *     wordArray.clamp();\n   */\n  clamp() {\n    // Shortcuts\n    const { words, sigBytes } = this;\n\n    // Clamp\n    words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n    words.length = Math.ceil(sigBytes / 4);\n  }\n\n  /**\n   * Creates a copy of this word array.\n   *\n   * @return {WordArray} The clone.\n   *\n   * @example\n   *\n   *     var clone = wordArray.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone.words = this.words.slice(0);\n\n    return clone;\n  }\n}\n\n/**\n * Hex encoding strategy.\n */\nconst Hex = {\n  /**\n   * Converts a word array to a hex string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The hex string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const hexChars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      hexChars.push((bite >>> 4).toString(16));\n      hexChars.push((bite & 0x0f).toString(16));\n    }\n\n    return hexChars.join('');\n  },\n\n  /**\n   * Converts a hex string to a word array.\n   *\n   * @param {string} hexStr The hex string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n   */\n  parse(hexStr) {\n    // Shortcut\n    const hexStrLength = hexStr.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < hexStrLength; i += 2) {\n      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n    }\n\n    return new WordArray(words, hexStrLength / 2);\n  },\n};\n\n/**\n * Latin1 encoding strategy.\n */\nconst Latin1 = {\n  /**\n   * Converts a word array to a Latin1 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Latin1 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const latin1Chars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      latin1Chars.push(String.fromCharCode(bite));\n    }\n\n    return latin1Chars.join('');\n  },\n\n  /**\n   * Converts a Latin1 string to a word array.\n   *\n   * @param {string} latin1Str The Latin1 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n   */\n  parse(latin1Str) {\n    // Shortcut\n    const latin1StrLength = latin1Str.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i += 1) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n    }\n\n    return new WordArray(words, latin1StrLength);\n  },\n};\n\n/**\n * UTF-8 encoding strategy.\n */\nconst Utf8 = {\n  /**\n   * Converts a word array to a UTF-8 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-8 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    try {\n      return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n    } catch (e) {\n      throw new Error('Malformed UTF-8 data');\n    }\n  },\n\n  /**\n   * Converts a UTF-8 string to a word array.\n   *\n   * @param {string} utf8Str The UTF-8 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n   */\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  },\n};\n\n/**\n * Abstract buffered block algorithm template.\n *\n * The property blockSize must be implemented in a concrete subtype.\n *\n * @property {number} _minBufferSize\n *\n *     The number of blocks that should be kept unprocessed in the buffer. Default: 0\n */\nclass BufferedBlockAlgorithm extends Base {\n  constructor() {\n    super();\n    this._minBufferSize = 0;\n  }\n\n  /**\n   * Resets this block algorithm's data buffer to its initial state.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm.reset();\n   */\n  reset() {\n    // Initial values\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n\n  /**\n   * Adds new data to this block algorithm's buffer.\n   *\n   * @param {WordArray|string} data\n   *\n   *     The data to append. Strings are converted to a WordArray using UTF-8.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm._append('data');\n   *     bufferedBlockAlgorithm._append(wordArray);\n   */\n  _append(data) {\n    let m_data = data;\n\n    // Convert string to WordArray, else assume WordArray already\n    if (typeof m_data === 'string') {\n      m_data = Utf8.parse(m_data);\n    }\n\n    // Append\n    this._data.concat(m_data);\n    this._nDataBytes += m_data.sigBytes;\n  }\n\n  /**\n   * Processes available data blocks.\n   *\n   * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n   *\n   * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n   *\n   * @return {WordArray} The processed data.\n   *\n   * @example\n   *\n   *     var processedData = bufferedBlockAlgorithm._process();\n   *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n   */\n  _process(doFlush) {\n    let processedWords;\n\n    // Shortcuts\n    const { _data: data, blockSize } = this;\n    const dataWords = data.words;\n    const dataSigBytes = data.sigBytes;\n    const blockSizeBytes = blockSize * 4;\n\n    // Count blocks ready\n    let nBlocksReady = dataSigBytes / blockSizeBytes;\n    if (doFlush) {\n      // Round up to include partial blocks\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      // Round down to include only full blocks,\n      // less the number of blocks that must remain in the buffer\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n\n    // Count words ready\n    const nWordsReady = nBlocksReady * blockSize;\n\n    // Count bytes ready\n    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n    // Process blocks\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += blockSize) {\n        // Perform concrete-algorithm logic\n        this._doProcessBlock(dataWords, offset);\n      }\n\n      // Remove processed words\n      processedWords = dataWords.splice(0, nWordsReady);\n      data.sigBytes -= nBytesReady;\n    }\n\n    // Return processed words\n    return new WordArray(processedWords, nBytesReady);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = bufferedBlockAlgorithm.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone._data = this._data.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Abstract hasher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n */\nclass Hasher extends BufferedBlockAlgorithm {\n  constructor(cfg) {\n    super();\n\n    this.blockSize = 512 / 32;\n\n    /**\n     * Configuration options.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates a shortcut function to a hasher's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to create a helper for.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHelper(SubHasher) {\n    return (message, cfg) => new SubHasher(cfg).finalize(message);\n  }\n\n  /**\n   * Creates a shortcut function to the HMAC's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to use in this HMAC helper.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHmacHelper(SubHasher) {\n    return (message, key) => new HMAC(SubHasher, key).finalize(message);\n  }\n\n  /**\n   * Resets this hasher to its initial state.\n   *\n   * @example\n   *\n   *     hasher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-hasher logic\n    this._doReset();\n  }\n\n  /**\n   * Updates this hasher with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {Hasher} This hasher.\n   *\n   * @example\n   *\n   *     hasher.update('message');\n   *     hasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    // Append\n    this._append(messageUpdate);\n\n    // Update the hash\n    this._process();\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the hash computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @example\n   *\n   *     var hash = hasher.finalize();\n   *     var hash = hasher.finalize('message');\n   *     var hash = hasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Final message update\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n\n    // Perform concrete-hasher logic\n    const hash = this._doFinalize();\n\n    return hash;\n  }\n}\n\n/**\n * HMAC algorithm.\n */\nclass HMAC extends Base {\n  /**\n   * Initializes a newly created HMAC.\n   *\n   * @param {Hasher} SubHasher The hash algorithm to use.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @example\n   *\n   *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n   */\n  constructor(SubHasher, key) {\n    super();\n\n    const hasher = new SubHasher();\n    this._hasher = hasher;\n\n    // Convert string to WordArray, else assume WordArray already\n    let _key = key;\n    if (typeof _key === 'string') {\n      _key = Utf8.parse(_key);\n    }\n\n    // Shortcuts\n    const hasherBlockSize = hasher.blockSize;\n    const hasherBlockSizeBytes = hasherBlockSize * 4;\n\n    // Allow arbitrary length keys\n    if (_key.sigBytes > hasherBlockSizeBytes) {\n      _key = hasher.finalize(key);\n    }\n\n    // Clamp excess bits\n    _key.clamp();\n\n    // Clone key for inner and outer pads\n    const oKey = _key.clone();\n    this._oKey = oKey;\n    const iKey = _key.clone();\n    this._iKey = iKey;\n\n    // Shortcuts\n    const oKeyWords = oKey.words;\n    const iKeyWords = iKey.words;\n\n    // XOR keys with pad constants\n    for (let i = 0; i < hasherBlockSize; i += 1) {\n      oKeyWords[i] ^= 0x5c5c5c5c;\n      iKeyWords[i] ^= 0x36363636;\n    }\n    oKey.sigBytes = hasherBlockSizeBytes;\n    iKey.sigBytes = hasherBlockSizeBytes;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Resets this HMAC to its initial state.\n   *\n   * @example\n   *\n   *     hmacHasher.reset();\n   */\n  reset() {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Reset\n    hasher.reset();\n    hasher.update(this._iKey);\n  }\n\n  /**\n   * Updates this HMAC with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {HMAC} This HMAC instance.\n   *\n   * @example\n   *\n   *     hmacHasher.update('message');\n   *     hmacHasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    this._hasher.update(messageUpdate);\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the HMAC computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @example\n   *\n   *     var hmac = hmacHasher.finalize();\n   *     var hmac = hmacHasher.finalize('message');\n   *     var hmac = hmacHasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Compute HMAC\n    const innerHash = hasher.finalize(messageUpdate);\n    hasher.reset();\n    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n    return hmac;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvY29yZS5qcz81NWRiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE1BQU07QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsMEJBQTBCO0FBQy9DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0EsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvY29yZS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgaW5oZXJpdGFuY2UuXG4gKi9cbmV4cG9ydCBjbGFzcyBCYXNlIHtcbiAgLyoqXG4gICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxuICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgTXlUeXBlLm1peEluKHtcbiAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xuICAgKiAgICAgfSk7XG4gICAqL1xuICBtaXhJbihwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcGVydGllcyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gVGhlIGNsb25lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNsb25lID0gaW5zdGFuY2UuY2xvbmUoKTtcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcbiAgICBPYmplY3QuYXNzaWduKGNsb25lLCB0aGlzKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG4gKlxuICogQHByb3BlcnR5IHtBcnJheX0gd29yZHMgVGhlIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzaWdCeXRlcyBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoaXMgd29yZCBhcnJheS5cbiAqL1xuZXhwb3J0IGNsYXNzIFdvcmRBcnJheSBleHRlbmRzIEJhc2Uge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIChPcHRpb25hbCkgQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xuICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSk7XG4gICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKHdvcmRzID0gW10sIHNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogNCkge1xuICAgIHN1cGVyKCk7XG5cbiAgICBsZXQgdHlwZWRBcnJheSA9IHdvcmRzO1xuICAgIC8vIENvbnZlcnQgYnVmZmVycyB0byB1aW50OFxuICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KTtcbiAgICB9XG5cbiAgICAvLyBDb252ZXJ0IG90aGVyIGFycmF5IHZpZXdzIHRvIHVpbnQ4XG4gICAgaWYgKFxuICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheVxuICAgICAgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5XG4gICAgICB8fCB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheVxuICAgICAgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5XG4gICAgICB8fCB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheVxuICAgICAgfHwgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5XG4gICAgICB8fCB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5XG4gICAgICB8fCB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5XG4gICAgKSB7XG4gICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheS5idWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5ieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgVWludDhBcnJheVxuICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgICAgLy8gU2hvcnRjdXRcbiAgICAgIGNvbnN0IHR5cGVkQXJyYXlCeXRlTGVuZ3RoID0gdHlwZWRBcnJheS5ieXRlTGVuZ3RoO1xuXG4gICAgICAvLyBFeHRyYWN0IGJ5dGVzXG4gICAgICBjb25zdCBfd29yZHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHlwZWRBcnJheUJ5dGVMZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBfd29yZHNbaSA+Pj4gMl0gfD0gdHlwZWRBcnJheVtpXSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEluaXRpYWxpemUgdGhpcyB3b3JkIGFycmF5XG4gICAgICB0aGlzLndvcmRzID0gX3dvcmRzO1xuICAgICAgdGhpcy5zaWdCeXRlcyA9IHR5cGVkQXJyYXlCeXRlTGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFbHNlIGNhbGwgbm9ybWFsIGluaXRcbiAgICAgIHRoaXMud29yZHMgPSB3b3JkcztcbiAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSByYW5kb20gd29yZCBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkucmFuZG9tKDE2KTtcbiAgICovXG4gIHN0YXRpYyByYW5kb20obkJ5dGVzKSB7XG4gICAgY29uc3Qgd29yZHMgPSBbXTtcblxuICAgIGNvbnN0IHIgPSAobV93KSA9PiB7XG4gICAgICBsZXQgX21fdyA9IG1fdztcbiAgICAgIGxldCBfbV96ID0gMHgzYWRlNjhiMTtcbiAgICAgIGNvbnN0IG1hc2sgPSAweGZmZmZmZmZmO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBfbV96ID0gKDB4OTA2OSAqIChfbV96ICYgMHhGRkZGKSArIChfbV96ID4+IDB4MTApKSAmIG1hc2s7XG4gICAgICAgIF9tX3cgPSAoMHg0NjUwICogKF9tX3cgJiAweEZGRkYpICsgKF9tX3cgPj4gMHgxMCkpICYgbWFzaztcbiAgICAgICAgbGV0IHJlc3VsdCA9ICgoX21feiA8PCAweDEwKSArIF9tX3cpICYgbWFzaztcbiAgICAgICAgcmVzdWx0IC89IDB4MTAwMDAwMDAwO1xuICAgICAgICByZXN1bHQgKz0gMC41O1xuICAgICAgICByZXR1cm4gcmVzdWx0ICogKE1hdGgucmFuZG9tKCkgPiAwLjUgPyAxIDogLTEpO1xuICAgICAgfTtcbiAgICB9O1xuXG4gICAgZm9yIChsZXQgaSA9IDAsIHJjYWNoZTsgaSA8IG5CeXRlczsgaSArPSA0KSB7XG4gICAgICBjb25zdCBfciA9IHIoKHJjYWNoZSB8fCBNYXRoLnJhbmRvbSgpKSAqIDB4MTAwMDAwMDAwKTtcblxuICAgICAgcmNhY2hlID0gX3IoKSAqIDB4M2FkZTY3Yjc7XG4gICAgICB3b3Jkcy5wdXNoKChfcigpICogMHgxMDAwMDAwMDApIHwgMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkod29yZHMsIG5CeXRlcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyB3b3JkIGFycmF5IHRvIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG4gICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKCk7XG4gICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcbiAgICovXG4gIHRvU3RyaW5nKGVuY29kZXIgPSBIZXgpIHtcbiAgICByZXR1cm4gZW5jb2Rlci5zdHJpbmdpZnkodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoaXMgd29yZCBhcnJheS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuICAgKi9cbiAgY29uY2F0KHdvcmRBcnJheSkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG4gICAgY29uc3QgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuICAgIGNvbnN0IHRoaXNTaWdCeXRlcyA9IHRoaXMuc2lnQnl0ZXM7XG4gICAgY29uc3QgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG4gICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcbiAgICB0aGlzLmNsYW1wKCk7XG5cbiAgICAvLyBDb25jYXRcbiAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xuICAgICAgLy8gQ29weSBvbmUgYnl0ZSBhdCBhIHRpbWVcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcbiAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENvcHkgb25lIHdvcmQgYXQgYSB0aW1lXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSArPSA0KSB7XG4gICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdID0gdGhhdFdvcmRzW2kgPj4+IDJdO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcblxuICAgIC8vIENoYWluYWJsZVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgd29yZEFycmF5LmNsYW1wKCk7XG4gICAqL1xuICBjbGFtcCgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCB7IHdvcmRzLCBzaWdCeXRlcyB9ID0gdGhpcztcblxuICAgIC8vIENsYW1wXG4gICAgd29yZHNbc2lnQnl0ZXMgPj4+IDJdICY9IDB4ZmZmZmZmZmYgPDwgKDMyIC0gKHNpZ0J5dGVzICUgNCkgKiA4KTtcbiAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGNsb25lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5cbi8qKlxuICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgSGV4ID0ge1xuICAvKipcbiAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG4gICAqL1xuICBzdHJpbmdpZnkod29yZEFycmF5KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgeyB3b3Jkcywgc2lnQnl0ZXMgfSA9IHdvcmRBcnJheTtcblxuICAgIC8vIENvbnZlcnRcbiAgICBjb25zdCBoZXhDaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMSkge1xuICAgICAgY29uc3QgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICBoZXhDaGFycy5wdXNoKChiaXRlID4+PiA0KS50b1N0cmluZygxNikpO1xuICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSAmIDB4MGYpLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaGV4U3RyIFRoZSBoZXggc3RyaW5nLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xuICAgKi9cbiAgcGFyc2UoaGV4U3RyKSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuXG4gICAgLy8gQ29udmVydFxuICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFdvcmRBcnJheSh3b3JkcywgaGV4U3RyTGVuZ3RoIC8gMik7XG4gIH0sXG59O1xuXG4vKipcbiAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cbiAqL1xuZXhwb3J0IGNvbnN0IExhdGluMSA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgKi9cbiAgc3RyaW5naWZ5KHdvcmRBcnJheSkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHsgd29yZHMsIHNpZ0J5dGVzIH0gPSB3b3JkQXJyYXk7XG5cbiAgICAvLyBDb252ZXJ0XG4gICAgY29uc3QgbGF0aW4xQ2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuICAgICAgbGF0aW4xQ2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGJpdGUpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXRpbjFTdHIgVGhlIExhdGluMSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XG4gICAqL1xuICBwYXJzZShsYXRpbjFTdHIpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XG5cbiAgICAvLyBDb252ZXJ0XG4gICAgY29uc3Qgd29yZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XG4gIH0sXG59O1xuXG4vKipcbiAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgVXRmOCA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgKi9cbiAgc3RyaW5naWZ5KHdvcmRBcnJheSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShMYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSkpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1dGY4U3RyIFRoZSBVVEYtOCBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcbiAgICovXG4gIHBhcnNlKHV0ZjhTdHIpIHtcbiAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuICB9LFxufTtcblxuLyoqXG4gKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXG4gKlxuICogVGhlIHByb3BlcnR5IGJsb2NrU2l6ZSBtdXN0IGJlIGltcGxlbWVudGVkIGluIGEgY29uY3JldGUgc3VidHlwZS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gX21pbkJ1ZmZlclNpemVcbiAqXG4gKiAgICAgVGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBzaG91bGQgYmUga2VwdCB1bnByb2Nlc3NlZCBpbiB0aGUgYnVmZmVyLiBEZWZhdWx0OiAwXG4gKi9cbmV4cG9ydCBjbGFzcyBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtIGV4dGVuZHMgQmFzZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fbWluQnVmZmVyU2l6ZSA9IDA7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XG4gICAqL1xuICByZXNldCgpIHtcbiAgICAvLyBJbml0aWFsIHZhbHVlc1xuICAgIHRoaXMuX2RhdGEgPSBuZXcgV29yZEFycmF5KCk7XG4gICAgdGhpcy5fbkRhdGFCeXRlcyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhXG4gICAqXG4gICAqICAgICBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xuICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG4gICAqL1xuICBfYXBwZW5kKGRhdGEpIHtcbiAgICBsZXQgbV9kYXRhID0gZGF0YTtcblxuICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcbiAgICBpZiAodHlwZW9mIG1fZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG1fZGF0YSA9IFV0ZjgucGFyc2UobV9kYXRhKTtcbiAgICB9XG5cbiAgICAvLyBBcHBlbmRcbiAgICB0aGlzLl9kYXRhLmNvbmNhdChtX2RhdGEpO1xuICAgIHRoaXMuX25EYXRhQnl0ZXMgKz0gbV9kYXRhLnNpZ0J5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGludm9rZXMgX2RvUHJvY2Vzc0Jsb2NrKG9mZnNldCksIHdoaWNoIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYSBjb25jcmV0ZSBzdWJ0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG4gICAqL1xuICBfcHJvY2Vzcyhkb0ZsdXNoKSB7XG4gICAgbGV0IHByb2Nlc3NlZFdvcmRzO1xuXG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgeyBfZGF0YTogZGF0YSwgYmxvY2tTaXplIH0gPSB0aGlzO1xuICAgIGNvbnN0IGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG4gICAgY29uc3QgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcbiAgICBjb25zdCBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cbiAgICAvLyBDb3VudCBibG9ja3MgcmVhZHlcbiAgICBsZXQgbkJsb2Nrc1JlYWR5ID0gZGF0YVNpZ0J5dGVzIC8gYmxvY2tTaXplQnl0ZXM7XG4gICAgaWYgKGRvRmx1c2gpIHtcbiAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3NcbiAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSb3VuZCBkb3duIHRvIGluY2x1ZGUgb25seSBmdWxsIGJsb2NrcyxcbiAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXG4gICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLm1heCgobkJsb2Nrc1JlYWR5IHwgMCkgLSB0aGlzLl9taW5CdWZmZXJTaXplLCAwKTtcbiAgICB9XG5cbiAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuICAgIGNvbnN0IG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogYmxvY2tTaXplO1xuXG4gICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcbiAgICBjb25zdCBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcblxuICAgIC8vIFByb2Nlc3MgYmxvY2tzXG4gICAgaWYgKG5Xb3Jkc1JlYWR5KSB7XG4gICAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xuICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuICAgICAgICB0aGlzLl9kb1Byb2Nlc3NCbG9jayhkYXRhV29yZHMsIG9mZnNldCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBwcm9jZXNzZWQgd29yZHNcbiAgICAgIHByb2Nlc3NlZFdvcmRzID0gZGF0YVdvcmRzLnNwbGljZSgwLCBuV29yZHNSZWFkeSk7XG4gICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xuICAgIH1cblxuICAgIC8vIFJldHVybiBwcm9jZXNzZWQgd29yZHNcbiAgICByZXR1cm4gbmV3IFdvcmRBcnJheShwcm9jZXNzZWRXb3JkcywgbkJ5dGVzUmVhZHkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcbiAgICovXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gc3VwZXIuY2xvbmUuY2FsbCh0aGlzKTtcbiAgICBjbG9uZS5fZGF0YSA9IHRoaXMuX2RhdGEuY2xvbmUoKTtcblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuXG4vKipcbiAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cbiAqXG4gKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplXG4gKlxuICogICAgIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXNoZXIgZXh0ZW5kcyBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtIHtcbiAgY29uc3RydWN0b3IoY2ZnKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuYmxvY2tTaXplID0gNTEyIC8gMzI7XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICovXG4gICAgdGhpcy5jZmcgPSBPYmplY3QuYXNzaWduKG5ldyBCYXNlKCksIGNmZyk7XG5cbiAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtIYXNoZXJ9IFN1Ykhhc2hlciBUaGUgaGFzaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG4gICAqXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuICAgKi9cbiAgc3RhdGljIF9jcmVhdGVIZWxwZXIoU3ViSGFzaGVyKSB7XG4gICAgcmV0dXJuIChtZXNzYWdlLCBjZmcpID0+IG5ldyBTdWJIYXNoZXIoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0hhc2hlcn0gU3ViSGFzaGVyIFRoZSBoYXNoZXIgdG8gdXNlIGluIHRoaXMgSE1BQyBoZWxwZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG4gICAqL1xuICBzdGF0aWMgX2NyZWF0ZUhtYWNIZWxwZXIoU3ViSGFzaGVyKSB7XG4gICAgcmV0dXJuIChtZXNzYWdlLCBrZXkpID0+IG5ldyBITUFDKFN1Ykhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBoYXNoZXIucmVzZXQoKTtcbiAgICovXG4gIHJlc2V0KCkge1xuICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG4gICAgc3VwZXIucmVzZXQuY2FsbCh0aGlzKTtcblxuICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG4gICAgdGhpcy5fZG9SZXNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSBUaGUgbWVzc2FnZSB0byBhcHBlbmQuXG4gICAqXG4gICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBoYXNoZXIudXBkYXRlKCdtZXNzYWdlJyk7XG4gICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG4gICAqL1xuICB1cGRhdGUobWVzc2FnZVVwZGF0ZSkge1xuICAgIC8vIEFwcGVuZFxuICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblxuICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuICAgIC8vIENoYWluYWJsZVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmFsaXplcyB0aGUgaGFzaCBjb21wdXRhdGlvbi5cbiAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKCk7XG4gICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcbiAgICovXG4gIGZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpIHtcbiAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuICAgIGlmIChtZXNzYWdlVXBkYXRlKSB7XG4gICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcbiAgICBjb25zdCBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cbn1cblxuLyoqXG4gKiBITUFDIGFsZ29yaXRobS5cbiAqL1xuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBITUFDLlxuICAgKlxuICAgKiBAcGFyYW0ge0hhc2hlcn0gU3ViSGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGhtYWNIYXNoZXIgPSBDcnlwdG9KUy5hbGdvLkhNQUMuY3JlYXRlKENyeXB0b0pTLmFsZ28uU0hBMjU2LCBrZXkpO1xuICAgKi9cbiAgY29uc3RydWN0b3IoU3ViSGFzaGVyLCBrZXkpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgY29uc3QgaGFzaGVyID0gbmV3IFN1Ykhhc2hlcigpO1xuICAgIHRoaXMuX2hhc2hlciA9IGhhc2hlcjtcblxuICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcbiAgICBsZXQgX2tleSA9IGtleTtcbiAgICBpZiAodHlwZW9mIF9rZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICBfa2V5ID0gVXRmOC5wYXJzZShfa2V5KTtcbiAgICB9XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBoYXNoZXJCbG9ja1NpemUgPSBoYXNoZXIuYmxvY2tTaXplO1xuICAgIGNvbnN0IGhhc2hlckJsb2NrU2l6ZUJ5dGVzID0gaGFzaGVyQmxvY2tTaXplICogNDtcblxuICAgIC8vIEFsbG93IGFyYml0cmFyeSBsZW5ndGgga2V5c1xuICAgIGlmIChfa2V5LnNpZ0J5dGVzID4gaGFzaGVyQmxvY2tTaXplQnl0ZXMpIHtcbiAgICAgIF9rZXkgPSBoYXNoZXIuZmluYWxpemUoa2V5KTtcbiAgICB9XG5cbiAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuICAgIF9rZXkuY2xhbXAoKTtcblxuICAgIC8vIENsb25lIGtleSBmb3IgaW5uZXIgYW5kIG91dGVyIHBhZHNcbiAgICBjb25zdCBvS2V5ID0gX2tleS5jbG9uZSgpO1xuICAgIHRoaXMuX29LZXkgPSBvS2V5O1xuICAgIGNvbnN0IGlLZXkgPSBfa2V5LmNsb25lKCk7XG4gICAgdGhpcy5faUtleSA9IGlLZXk7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBvS2V5V29yZHMgPSBvS2V5LndvcmRzO1xuICAgIGNvbnN0IGlLZXlXb3JkcyA9IGlLZXkud29yZHM7XG5cbiAgICAvLyBYT1Iga2V5cyB3aXRoIHBhZCBjb25zdGFudHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhhc2hlckJsb2NrU2l6ZTsgaSArPSAxKSB7XG4gICAgICBvS2V5V29yZHNbaV0gXj0gMHg1YzVjNWM1YztcbiAgICAgIGlLZXlXb3Jkc1tpXSBePSAweDM2MzYzNjM2O1xuICAgIH1cbiAgICBvS2V5LnNpZ0J5dGVzID0gaGFzaGVyQmxvY2tTaXplQnl0ZXM7XG4gICAgaUtleS5zaWdCeXRlcyA9IGhhc2hlckJsb2NrU2l6ZUJ5dGVzO1xuXG4gICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG4gICAgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGlzIEhNQUMgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBobWFjSGFzaGVyLnJlc2V0KCk7XG4gICAqL1xuICByZXNldCgpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuICAgIC8vIFJlc2V0XG4gICAgaGFzaGVyLnJlc2V0KCk7XG4gICAgaGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgSE1BQyB3aXRoIGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cbiAgICpcbiAgICogQHJldHVybiB7SE1BQ30gVGhpcyBITUFDIGluc3RhbmNlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgaG1hY0hhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcbiAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG4gICAqL1xuICB1cGRhdGUobWVzc2FnZVVwZGF0ZSkge1xuICAgIHRoaXMuX2hhc2hlci51cGRhdGUobWVzc2FnZVVwZGF0ZSk7XG5cbiAgICAvLyBDaGFpbmFibGVcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5hbGl6ZXMgdGhlIEhNQUMgY29tcHV0YXRpb24uXG4gICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoKTtcbiAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG4gICAqL1xuICBmaW5hbGl6ZShtZXNzYWdlVXBkYXRlKSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cbiAgICAvLyBDb21wdXRlIEhNQUNcbiAgICBjb25zdCBpbm5lckhhc2ggPSBoYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7XG4gICAgaGFzaGVyLnJlc2V0KCk7XG4gICAgY29uc3QgaG1hYyA9IGhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO1xuXG4gICAgcmV0dXJuIGhtYWM7XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/core.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/enc-base64.js":
/*!**************************************************!*\
  !*** ./node_modules/crypto-es/lib/enc-base64.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Base64\": function() { return /* binding */ Base64; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\nconst parseLoop = (base64Str, base64StrLength, reverseMap) => {\n  const words = [];\n  let nBytes = 0;\n  for (let i = 0; i < base64StrLength; i += 1) {\n    if (i % 4) {\n      const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n      const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n      const bitsCombined = bits1 | bits2;\n      words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n      nBytes += 1;\n    }\n  }\n  return _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create(words, nBytes);\n};\n\n/**\n * Base64 encoding strategy.\n */\nconst Base64 = {\n  /**\n   * Converts a word array to a Base64 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Base64 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const base64String = CryptoJS.enc.Base64.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n    const map = this._map;\n\n    // Clamp excess bits\n    wordArray.clamp();\n\n    // Convert\n    const base64Chars = [];\n    for (let i = 0; i < sigBytes; i += 3) {\n      const byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n      const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n      const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n      for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j += 1) {\n        base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n      }\n    }\n\n    // Add padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      while (base64Chars.length % 4) {\n        base64Chars.push(paddingChar);\n      }\n    }\n\n    return base64Chars.join('');\n  },\n\n  /**\n   * Converts a Base64 string to a word array.\n   *\n   * @param {string} base64Str The Base64 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Base64.parse(base64String);\n   */\n  parse(base64Str) {\n    // Shortcuts\n    let base64StrLength = base64Str.length;\n    const map = this._map;\n    let reverseMap = this._reverseMap;\n\n    if (!reverseMap) {\n      this._reverseMap = [];\n      reverseMap = this._reverseMap;\n      for (let j = 0; j < map.length; j += 1) {\n        reverseMap[map.charCodeAt(j)] = j;\n      }\n    }\n\n    // Ignore padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      const paddingIndex = base64Str.indexOf(paddingChar);\n      if (paddingIndex !== -1) {\n        base64StrLength = paddingIndex;\n      }\n    }\n\n    // Convert\n    return parseLoop(base64Str, base64StrLength, reverseMap);\n  },\n\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZW5jLWJhc2U2NC5qcz85OTMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBRW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHNEQUFnQjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGtCQUFrQjtBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZW5jLWJhc2U2NC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFdvcmRBcnJheSxcbn0gZnJvbSAnLi9jb3JlLmpzJztcblxuY29uc3QgcGFyc2VMb29wID0gKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKSA9PiB7XG4gIGNvbnN0IHdvcmRzID0gW107XG4gIGxldCBuQnl0ZXMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJhc2U2NFN0ckxlbmd0aDsgaSArPSAxKSB7XG4gICAgaWYgKGkgJSA0KSB7XG4gICAgICBjb25zdCBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuICAgICAgY29uc3QgYml0czIgPSByZXZlcnNlTWFwW2Jhc2U2NFN0ci5jaGFyQ29kZUF0KGkpXSA+Pj4gKDYgLSAoaSAlIDQpICogMik7XG4gICAgICBjb25zdCBiaXRzQ29tYmluZWQgPSBiaXRzMSB8IGJpdHMyO1xuICAgICAgd29yZHNbbkJ5dGVzID4+PiAyXSB8PSBiaXRzQ29tYmluZWQgPDwgKDI0IC0gKG5CeXRlcyAlIDQpICogOCk7XG4gICAgICBuQnl0ZXMgKz0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIG5CeXRlcyk7XG59O1xuXG4vKipcbiAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cbiAqL1xuZXhwb3J0IGNvbnN0IEJhc2U2NCA9IHtcbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG4gICAqL1xuICBzdHJpbmdpZnkod29yZEFycmF5KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgeyB3b3Jkcywgc2lnQnl0ZXMgfSA9IHdvcmRBcnJheTtcbiAgICBjb25zdCBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG4gICAgLy8gQ29udmVydFxuICAgIGNvbnN0IGJhc2U2NENoYXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG4gICAgICBjb25zdCBieXRlMSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICBjb25zdCBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG4gICAgICBjb25zdCBieXRlMyA9ICh3b3Jkc1soaSArIDIpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMikgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cbiAgICAgIGNvbnN0IHRyaXBsZXQgPSAoYnl0ZTEgPDwgMTYpIHwgKGJ5dGUyIDw8IDgpIHwgYnl0ZTM7XG5cbiAgICAgIGZvciAobGV0IGogPSAwOyAoaiA8IDQpICYmIChpICsgaiAqIDAuNzUgPCBzaWdCeXRlcyk7IGogKz0gMSkge1xuICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgY29uc3QgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcbiAgICBpZiAocGFkZGluZ0NoYXIpIHtcbiAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG4gICAgICAgIGJhc2U2NENoYXJzLnB1c2gocGFkZGluZ0NoYXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcbiAgfSxcblxuICAvKipcbiAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3Qgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuICAgKi9cbiAgcGFyc2UoYmFzZTY0U3RyKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgbGV0IGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG4gICAgY29uc3QgbWFwID0gdGhpcy5fbWFwO1xuICAgIGxldCByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcblxuICAgIGlmICghcmV2ZXJzZU1hcCkge1xuICAgICAgdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuICAgICAgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXA7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICByZXZlcnNlTWFwW21hcC5jaGFyQ29kZUF0KGopXSA9IGo7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWdub3JlIHBhZGRpbmdcbiAgICBjb25zdCBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuICAgIGlmIChwYWRkaW5nQ2hhcikge1xuICAgICAgY29uc3QgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbnZlcnRcbiAgICByZXR1cm4gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKTtcbiAgfSxcblxuICBfbWFwOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/enc-base64.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/enc-utf16.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-es/lib/enc-utf16.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Utf16BE\": function() { return /* binding */ Utf16BE; },\n/* harmony export */   \"Utf16\": function() { return /* binding */ Utf16; },\n/* harmony export */   \"Utf16LE\": function() { return /* binding */ Utf16LE; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\nconst swapEndian = word => ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);\n\n/**\n * UTF-16 BE encoding strategy.\n */\nconst Utf16BE = {\n  /**\n   * Converts a word array to a UTF-16 BE string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-16 BE string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const utf16String = CryptoJS.enc.Utf16.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const utf16Chars = [];\n    for (let i = 0; i < sigBytes; i += 2) {\n      const codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;\n      utf16Chars.push(String.fromCharCode(codePoint));\n    }\n\n    return utf16Chars.join('');\n  },\n\n  /**\n   * Converts a UTF-16 BE string to a word array.\n   *\n   * @param {string} utf16Str The UTF-16 BE string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Utf16.parse(utf16String);\n   */\n  parse(utf16Str) {\n    // Shortcut\n    const utf16StrLength = utf16Str.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < utf16StrLength; i += 1) {\n      words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);\n    }\n\n    return _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create(words, utf16StrLength * 2);\n  },\n};\nconst Utf16 = Utf16BE;\n\n/**\n * UTF-16 LE encoding strategy.\n */\nconst Utf16LE = {\n  /**\n   * Converts a word array to a UTF-16 LE string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-16 LE string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const utf16Chars = [];\n    for (let i = 0; i < sigBytes; i += 2) {\n      const codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);\n      utf16Chars.push(String.fromCharCode(codePoint));\n    }\n\n    return utf16Chars.join('');\n  },\n\n  /**\n   * Converts a UTF-16 LE string to a word array.\n   *\n   * @param {string} utf16Str The UTF-16 LE string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);\n   */\n  parse(utf16Str) {\n    // Shortcut\n    const utf16StrLength = utf16Str.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < utf16StrLength; i += 1) {\n      words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));\n    }\n\n    return _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create(words, utf16StrLength * 2);\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZW5jLXV0ZjE2LmpzPzU0N2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUVtQjs7QUFFbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7O0FBRTdCO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBOztBQUVBLFdBQVcsc0RBQWdCO0FBQzNCLEdBQUc7QUFDSDtBQUNPOztBQUVQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCOztBQUU3QjtBQUNBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixvQkFBb0I7QUFDdkM7QUFDQTs7QUFFQSxXQUFXLHNEQUFnQjtBQUMzQixHQUFHO0FBQ0giLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9lbmMtdXRmMTYuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBXb3JkQXJyYXksXG59IGZyb20gJy4vY29yZS5qcyc7XG5cbmNvbnN0IHN3YXBFbmRpYW4gPSB3b3JkID0+ICgod29yZCA8PCA4KSAmIDB4ZmYwMGZmMDApIHwgKCh3b3JkID4+PiA4KSAmIDB4MDBmZjAwZmYpO1xuXG4vKipcbiAqIFVURi0xNiBCRSBlbmNvZGluZyBzdHJhdGVneS5cbiAqL1xuZXhwb3J0IGNvbnN0IFV0ZjE2QkUgPSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgQkUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCB1dGYxNlN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGYxNi5zdHJpbmdpZnkod29yZEFycmF5KTtcbiAgICovXG4gIHN0cmluZ2lmeSh3b3JkQXJyYXkpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCB7IHdvcmRzLCBzaWdCeXRlcyB9ID0gd29yZEFycmF5O1xuXG4gICAgLy8gQ29udmVydFxuICAgIGNvbnN0IHV0ZjE2Q2hhcnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcbiAgICAgIGNvbnN0IGNvZGVQb2ludCA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDE2IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmZmZjtcbiAgICAgIHV0ZjE2Q2hhcnMucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGVQb2ludCkpO1xuICAgIH1cblxuICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIFVURi0xNiBCRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmMTZTdHIgVGhlIFVURi0xNiBCRSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNi5wYXJzZSh1dGYxNlN0cmluZyk7XG4gICAqL1xuICBwYXJzZSh1dGYxNlN0cikge1xuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XG5cbiAgICAvLyBDb252ZXJ0XG4gICAgY29uc3Qgd29yZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHdvcmRzW2kgPj4+IDFdIHw9IHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgKDE2IC0gKGkgJSAyKSAqIDE2KTtcbiAgICB9XG5cbiAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcbiAgfSxcbn07XG5leHBvcnQgY29uc3QgVXRmMTYgPSBVdGYxNkJFO1xuXG4vKipcbiAqIFVURi0xNiBMRSBlbmNvZGluZyBzdHJhdGVneS5cbiAqL1xuZXhwb3J0IGNvbnN0IFV0ZjE2TEUgPSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgTEUgc3RyaW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCB1dGYxNlN0ciA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuICAgKi9cbiAgc3RyaW5naWZ5KHdvcmRBcnJheSkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHsgd29yZHMsIHNpZ0J5dGVzIH0gPSB3b3JkQXJyYXk7XG5cbiAgICAvLyBDb252ZXJ0XG4gICAgY29uc3QgdXRmMTZDaGFycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xuICAgICAgY29uc3QgY29kZVBvaW50ID0gc3dhcEVuZGlhbigod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmYpO1xuICAgICAgdXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHV0ZjE2Q2hhcnMuam9pbignJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVVRGLTE2IExFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IExFIHN0cmluZy5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3Qgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUucGFyc2UodXRmMTZTdHIpO1xuICAgKi9cbiAgcGFyc2UodXRmMTZTdHIpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IHV0ZjE2U3RyTGVuZ3RoID0gdXRmMTZTdHIubGVuZ3RoO1xuXG4gICAgLy8gQ29udmVydFxuICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB3b3Jkc1tpID4+PiAxXSB8PSBzd2FwRW5kaWFuKHV0ZjE2U3RyLmNoYXJDb2RlQXQoaSkgPDwgKDE2IC0gKGkgJSAyKSAqIDE2KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XG4gIH0sXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/enc-utf16.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/evpkdf.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/evpkdf.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"EvpKDFAlgo\": function() { return /* binding */ EvpKDFAlgo; },\n/* harmony export */   \"EvpKDF\": function() { return /* binding */ EvpKDF; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"./node_modules/crypto-es/lib/md5.js\");\n\n\n\n/**\n * This key derivation function is meant to conform with EVP_BytesToKey.\n * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n */\nclass EvpKDFAlgo extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.EvpKDF.create();\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      new _core_js__WEBPACK_IMPORTED_MODULE_0__.Base(),\n      {\n        keySize: 128 / 32,\n        hasher: _md5_js__WEBPACK_IMPORTED_MODULE_1__.MD5Algo,\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Derives a key from a password.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    let block;\n\n    // Shortcut\n    const { cfg } = this;\n\n    // Init hasher\n    const hasher = cfg.hasher.create();\n\n    // Initial values\n    const derivedKey = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create();\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      if (block) {\n        hasher.update(block);\n      }\n      block = hasher.update(password).finalize(salt);\n      hasher.reset();\n\n      // Iterations\n      for (let i = 1; i < iterations; i += 1) {\n        block = hasher.finalize(block);\n        hasher.reset();\n      }\n\n      derivedKey.concat(block);\n    }\n    derivedKey.sigBytes = keySize * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Derives a key from a password.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.EvpKDF(password, salt);\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n */\nconst EvpKDF = (password, salt, cfg) => EvpKDFAlgo.create(cfg).compute(password, salt);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZXZwa2RmLmpzP2QxOTAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUdtQjtBQUNnQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUIsMENBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGFBQWE7QUFDL0Qsa0RBQWtELCtCQUErQjtBQUNqRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekIsa0JBQWtCLE9BQU87QUFDekI7QUFDQTtBQUNBLFVBQVUsMENBQUk7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCLDRDQUFPO0FBQ3ZCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsTUFBTTs7QUFFakI7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixzREFBZ0I7O0FBRXZDO0FBQ0E7QUFDQSxXQUFXLHNCQUFzQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsT0FBTztBQUNsQjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsYUFBYTtBQUMvRCxrREFBa0QsK0JBQStCO0FBQ2pGO0FBQ08iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9ldnBrZGYuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCYXNlLFxuICBXb3JkQXJyYXksXG59IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQgeyBNRDVBbGdvIH0gZnJvbSAnLi9tZDUuanMnO1xuXG4vKipcbiAqIFRoaXMga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gaXMgbWVhbnQgdG8gY29uZm9ybSB3aXRoIEVWUF9CeXRlc1RvS2V5LlxuICogd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcbiAqL1xuZXhwb3J0IGNsYXNzIEV2cEtERkFsZ28gZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIGNvbnN0IGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSgpO1xuICAgKiAgICAgY29uc3Qga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCB9KTtcbiAgICogICAgIGNvbnN0IGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG4gICAqL1xuICBjb25zdHJ1Y3RvcihjZmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcbiAgICAgKiBAcHJvcGVydHkge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoIGFsZ29yaXRobSB0byB1c2UuIERlZmF1bHQ6IE1ENVxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdGVyYXRpb25zIFRoZSBudW1iZXIgb2YgaXRlcmF0aW9ucyB0byBwZXJmb3JtLiBEZWZhdWx0OiAxXG4gICAgICovXG4gICAgdGhpcy5jZmcgPSBPYmplY3QuYXNzaWduKFxuICAgICAgbmV3IEJhc2UoKSxcbiAgICAgIHtcbiAgICAgICAga2V5U2l6ZTogMTI4IC8gMzIsXG4gICAgICAgIGhhc2hlcjogTUQ1QWxnbyxcbiAgICAgICAgaXRlcmF0aW9uczogMSxcbiAgICAgIH0sXG4gICAgICBjZmcsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cbiAgICpcbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG4gICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG4gICAqXG4gICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3Qga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuICAgKi9cbiAgY29tcHV0ZShwYXNzd29yZCwgc2FsdCkge1xuICAgIGxldCBibG9jaztcblxuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgeyBjZmcgfSA9IHRoaXM7XG5cbiAgICAvLyBJbml0IGhhc2hlclxuICAgIGNvbnN0IGhhc2hlciA9IGNmZy5oYXNoZXIuY3JlYXRlKCk7XG5cbiAgICAvLyBJbml0aWFsIHZhbHVlc1xuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBXb3JkQXJyYXkuY3JlYXRlKCk7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBkZXJpdmVkS2V5V29yZHMgPSBkZXJpdmVkS2V5LndvcmRzO1xuICAgIGNvbnN0IHsga2V5U2l6ZSwgaXRlcmF0aW9ucyB9ID0gY2ZnO1xuXG4gICAgLy8gR2VuZXJhdGUga2V5XG4gICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG4gICAgICBpZiAoYmxvY2spIHtcbiAgICAgICAgaGFzaGVyLnVwZGF0ZShibG9jayk7XG4gICAgICB9XG4gICAgICBibG9jayA9IGhhc2hlci51cGRhdGUocGFzc3dvcmQpLmZpbmFsaXplKHNhbHQpO1xuICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cbiAgICAgIC8vIEl0ZXJhdGlvbnNcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSArPSAxKSB7XG4gICAgICAgIGJsb2NrID0gaGFzaGVyLmZpbmFsaXplKGJsb2NrKTtcbiAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcbiAgICB9XG4gICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG4gICAgcmV0dXJuIGRlcml2ZWRLZXk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXJpdmVzIGEga2V5IGZyb20gYSBwYXNzd29yZC5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCBBIHNhbHQuXG4gKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQpO1xuICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcbiAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XG4gKi9cbmV4cG9ydCBjb25zdCBFdnBLREYgPSAocGFzc3dvcmQsIHNhbHQsIGNmZykgPT4gRXZwS0RGQWxnby5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/evpkdf.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/format-hex.js":
/*!**************************************************!*\
  !*** ./node_modules/crypto-es/lib/format-hex.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HexFormatter\": function() { return /* binding */ HexFormatter; }\n/* harmony export */ });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\n\nconst HexFormatter = {\n  /**\n   * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The hexadecimally encoded string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    return cipherParams.ciphertext.toString(_core_js__WEBPACK_IMPORTED_MODULE_1__.Hex);\n  },\n\n  /**\n   * Converts a hexadecimally encoded ciphertext string to a cipher params object.\n   *\n   * @param {string} input The hexadecimally encoded string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.Hex.parse(hexString);\n   */\n  parse(input) {\n    const ciphertext = _core_js__WEBPACK_IMPORTED_MODULE_1__.Hex.parse(input);\n    return _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.CipherParams.create({ ciphertext });\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZm9ybWF0LWhleC5qcz84OGJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUUwQjtBQUdQOztBQUVaO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMseUNBQUc7QUFDL0MsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBUztBQUNoQyxXQUFXLGdFQUFtQixFQUFFLGFBQWE7QUFDN0MsR0FBRztBQUNIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvZm9ybWF0LWhleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENpcGhlclBhcmFtcyxcbn0gZnJvbSAnLi9jaXBoZXItY29yZS5qcyc7XG5pbXBvcnQge1xuICBIZXgsXG59IGZyb20gJy4vY29yZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBIZXhGb3JtYXR0ZXIgPSB7XG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgY2lwaGVydGV4dCBvZiBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuICAgKi9cbiAgc3RyaW5naWZ5KGNpcGhlclBhcmFtcykge1xuICAgIHJldHVybiBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dC50b1N0cmluZyhIZXgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBjaXBoZXJ0ZXh0IHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQgVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5wYXJzZShoZXhTdHJpbmcpO1xuICAgKi9cbiAgcGFyc2UoaW5wdXQpIHtcbiAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gSGV4LnBhcnNlKGlucHV0KTtcbiAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQgfSk7XG4gIH0sXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/format-hex.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/hmac.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-es/lib/hmac.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HMAC\": function() { return /* reexport safe */ _core_js__WEBPACK_IMPORTED_MODULE_0__.HMAC; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvaG1hYy5qcz9kMzg4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBRW1CIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvaG1hYy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7XG4gIEhNQUMsXG59IGZyb20gJy4vY29yZS5qcyc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/hmac.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-es/lib/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _x64_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./x64-core.js */ \"./node_modules/crypto-es/lib/x64-core.js\");\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n/* harmony import */ var _enc_utf16_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./enc-utf16.js */ \"./node_modules/crypto-es/lib/enc-utf16.js\");\n/* harmony import */ var _enc_base64_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./enc-base64.js */ \"./node_modules/crypto-es/lib/enc-base64.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hmac.js */ \"./node_modules/crypto-es/lib/hmac.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./md5.js */ \"./node_modules/crypto-es/lib/md5.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sha1.js */ \"./node_modules/crypto-es/lib/sha1.js\");\n/* harmony import */ var _sha224_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sha224.js */ \"./node_modules/crypto-es/lib/sha224.js\");\n/* harmony import */ var _sha256_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sha256.js */ \"./node_modules/crypto-es/lib/sha256.js\");\n/* harmony import */ var _sha384_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./sha384.js */ \"./node_modules/crypto-es/lib/sha384.js\");\n/* harmony import */ var _sha512_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sha512.js */ \"./node_modules/crypto-es/lib/sha512.js\");\n/* harmony import */ var _sha3_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sha3.js */ \"./node_modules/crypto-es/lib/sha3.js\");\n/* harmony import */ var _ripemd160_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ripemd160.js */ \"./node_modules/crypto-es/lib/ripemd160.js\");\n/* harmony import */ var _pbkdf2_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./pbkdf2.js */ \"./node_modules/crypto-es/lib/pbkdf2.js\");\n/* harmony import */ var _evpkdf_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./evpkdf.js */ \"./node_modules/crypto-es/lib/evpkdf.js\");\n/* harmony import */ var _aes_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./aes.js */ \"./node_modules/crypto-es/lib/aes.js\");\n/* harmony import */ var _tripledes_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./tripledes.js */ \"./node_modules/crypto-es/lib/tripledes.js\");\n/* harmony import */ var _rabbit_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./rabbit.js */ \"./node_modules/crypto-es/lib/rabbit.js\");\n/* harmony import */ var _rabbit_legacy_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./rabbit-legacy.js */ \"./node_modules/crypto-es/lib/rabbit-legacy.js\");\n/* harmony import */ var _rc4_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./rc4.js */ \"./node_modules/crypto-es/lib/rc4.js\");\n/* harmony import */ var _mode_cfb_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./mode-cfb.js */ \"./node_modules/crypto-es/lib/mode-cfb.js\");\n/* harmony import */ var _mode_ctr_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./mode-ctr.js */ \"./node_modules/crypto-es/lib/mode-ctr.js\");\n/* harmony import */ var _mode_ctr_gladman_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./mode-ctr-gladman.js */ \"./node_modules/crypto-es/lib/mode-ctr-gladman.js\");\n/* harmony import */ var _mode_ecb_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./mode-ecb.js */ \"./node_modules/crypto-es/lib/mode-ecb.js\");\n/* harmony import */ var _mode_ofb_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./mode-ofb.js */ \"./node_modules/crypto-es/lib/mode-ofb.js\");\n/* harmony import */ var _pad_ansix923_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./pad-ansix923.js */ \"./node_modules/crypto-es/lib/pad-ansix923.js\");\n/* harmony import */ var _pad_iso10126_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./pad-iso10126.js */ \"./node_modules/crypto-es/lib/pad-iso10126.js\");\n/* harmony import */ var _pad_iso97971_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./pad-iso97971.js */ \"./node_modules/crypto-es/lib/pad-iso97971.js\");\n/* harmony import */ var _pad_nopadding_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./pad-nopadding.js */ \"./node_modules/crypto-es/lib/pad-nopadding.js\");\n/* harmony import */ var _pad_zeropadding_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./pad-zeropadding.js */ \"./node_modules/crypto-es/lib/pad-zeropadding.js\");\n/* harmony import */ var _format_hex_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./format-hex.js */ \"./node_modules/crypto-es/lib/format-hex.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  lib: {\n    Base: _core_js__WEBPACK_IMPORTED_MODULE_0__.Base,\n    WordArray: _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray,\n    BufferedBlockAlgorithm: _core_js__WEBPACK_IMPORTED_MODULE_0__.BufferedBlockAlgorithm,\n    Hasher: _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher,\n    Cipher: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__.Cipher,\n    StreamCipher: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__.StreamCipher,\n    BlockCipherMode: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__.BlockCipherMode,\n    BlockCipher: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__.BlockCipher,\n    CipherParams: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__.CipherParams,\n    SerializableCipher: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__.SerializableCipher,\n    PasswordBasedCipher: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__.PasswordBasedCipher,\n  },\n\n  x64: {\n    Word: _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word,\n    WordArray: _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64WordArray,\n  },\n\n  enc: {\n    Hex: _core_js__WEBPACK_IMPORTED_MODULE_0__.Hex,\n    Latin1: _core_js__WEBPACK_IMPORTED_MODULE_0__.Latin1,\n    Utf8: _core_js__WEBPACK_IMPORTED_MODULE_0__.Utf8,\n    Utf16: _enc_utf16_js__WEBPACK_IMPORTED_MODULE_3__.Utf16,\n    Utf16BE: _enc_utf16_js__WEBPACK_IMPORTED_MODULE_3__.Utf16BE,\n    Utf16LE: _enc_utf16_js__WEBPACK_IMPORTED_MODULE_3__.Utf16LE,\n    Base64: _enc_base64_js__WEBPACK_IMPORTED_MODULE_4__.Base64,\n  },\n\n  algo: {\n    HMAC: _hmac_js__WEBPACK_IMPORTED_MODULE_5__.HMAC,\n    MD5: _md5_js__WEBPACK_IMPORTED_MODULE_6__.MD5Algo,\n    SHA1: _sha1_js__WEBPACK_IMPORTED_MODULE_7__.SHA1Algo,\n    SHA224: _sha224_js__WEBPACK_IMPORTED_MODULE_8__.SHA224Algo,\n    SHA256: _sha256_js__WEBPACK_IMPORTED_MODULE_9__.SHA256Algo,\n    SHA384: _sha384_js__WEBPACK_IMPORTED_MODULE_10__.SHA384Algo,\n    SHA512: _sha512_js__WEBPACK_IMPORTED_MODULE_11__.SHA512Algo,\n    SHA3: _sha3_js__WEBPACK_IMPORTED_MODULE_12__.SHA3Algo,\n    RIPEMD160: _ripemd160_js__WEBPACK_IMPORTED_MODULE_13__.RIPEMD160Algo,\n\n    PBKDF2: _pbkdf2_js__WEBPACK_IMPORTED_MODULE_14__.PBKDF2Algo,\n    EvpKDF: _evpkdf_js__WEBPACK_IMPORTED_MODULE_15__.EvpKDFAlgo,\n\n    AES: _aes_js__WEBPACK_IMPORTED_MODULE_16__.AESAlgo,\n    DES: _tripledes_js__WEBPACK_IMPORTED_MODULE_17__.DESAlgo,\n    TripleDES: _tripledes_js__WEBPACK_IMPORTED_MODULE_17__.TripleDESAlgo,\n    Rabbit: _rabbit_js__WEBPACK_IMPORTED_MODULE_18__.RabbitAlgo,\n    RabbitLegacy: _rabbit_legacy_js__WEBPACK_IMPORTED_MODULE_19__.RabbitLegacyAlgo,\n    RC4: _rc4_js__WEBPACK_IMPORTED_MODULE_20__.RC4Algo,\n    RC4Drop: _rc4_js__WEBPACK_IMPORTED_MODULE_20__.RC4DropAlgo,\n  },\n\n  mode: {\n    CBC: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__.CBC,\n    CFB: _mode_cfb_js__WEBPACK_IMPORTED_MODULE_21__.CFB,\n    CTR: _mode_ctr_js__WEBPACK_IMPORTED_MODULE_22__.CTR,\n    CTRGladman: _mode_ctr_gladman_js__WEBPACK_IMPORTED_MODULE_23__.CTRGladman,\n    ECB: _mode_ecb_js__WEBPACK_IMPORTED_MODULE_24__.ECB,\n    OFB: _mode_ofb_js__WEBPACK_IMPORTED_MODULE_25__.OFB,\n  },\n\n  pad: {\n    Pkcs7: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__.Pkcs7,\n    AnsiX923: _pad_ansix923_js__WEBPACK_IMPORTED_MODULE_26__.AnsiX923,\n    Iso10126: _pad_iso10126_js__WEBPACK_IMPORTED_MODULE_27__.Iso10126,\n    Iso97971: _pad_iso97971_js__WEBPACK_IMPORTED_MODULE_28__.Iso97971,\n    NoPadding: _pad_nopadding_js__WEBPACK_IMPORTED_MODULE_29__.NoPadding,\n    ZeroPadding: _pad_zeropadding_js__WEBPACK_IMPORTED_MODULE_30__.ZeroPadding,\n  },\n\n  format: {\n    OpenSSL: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__.OpenSSLFormatter,\n    Hex: _format_hex_js__WEBPACK_IMPORTED_MODULE_31__.HexFormatter,\n  },\n\n  kdf: {\n    OpenSSL: _cipher_core_js__WEBPACK_IMPORTED_MODULE_2__.OpenSSLKdf,\n  },\n\n  MD5: _md5_js__WEBPACK_IMPORTED_MODULE_6__.MD5,\n  HmacMD5: _md5_js__WEBPACK_IMPORTED_MODULE_6__.HmacMD5,\n  SHA1: _sha1_js__WEBPACK_IMPORTED_MODULE_7__.SHA1,\n  HmacSHA1: _sha1_js__WEBPACK_IMPORTED_MODULE_7__.HmacSHA1,\n  SHA224: _sha224_js__WEBPACK_IMPORTED_MODULE_8__.SHA224,\n  HmacSHA224: _sha224_js__WEBPACK_IMPORTED_MODULE_8__.HmacSHA224,\n  SHA256: _sha256_js__WEBPACK_IMPORTED_MODULE_9__.SHA256,\n  HmacSHA256: _sha256_js__WEBPACK_IMPORTED_MODULE_9__.HmacSHA256,\n  SHA384: _sha384_js__WEBPACK_IMPORTED_MODULE_10__.SHA384,\n  HmacSHA384: _sha384_js__WEBPACK_IMPORTED_MODULE_10__.HmacSHA384,\n  SHA512: _sha512_js__WEBPACK_IMPORTED_MODULE_11__.SHA512,\n  HmacSHA512: _sha512_js__WEBPACK_IMPORTED_MODULE_11__.HmacSHA512,\n  SHA3: _sha3_js__WEBPACK_IMPORTED_MODULE_12__.SHA3,\n  HmacSHA3: _sha3_js__WEBPACK_IMPORTED_MODULE_12__.HmacSHA3,\n  RIPEMD160: _ripemd160_js__WEBPACK_IMPORTED_MODULE_13__.RIPEMD160,\n  HmacRIPEMD160: _ripemd160_js__WEBPACK_IMPORTED_MODULE_13__.HmacRIPEMD160,\n\n  PBKDF2: _pbkdf2_js__WEBPACK_IMPORTED_MODULE_14__.PBKDF2,\n  EvpKDF: _evpkdf_js__WEBPACK_IMPORTED_MODULE_15__.EvpKDF,\n\n  AES: _aes_js__WEBPACK_IMPORTED_MODULE_16__.AES,\n  DES: _tripledes_js__WEBPACK_IMPORTED_MODULE_17__.DES,\n  TripleDES: _tripledes_js__WEBPACK_IMPORTED_MODULE_17__.TripleDES,\n  Rabbit: _rabbit_js__WEBPACK_IMPORTED_MODULE_18__.Rabbit,\n  RabbitLegacy: _rabbit_legacy_js__WEBPACK_IMPORTED_MODULE_19__.RabbitLegacy,\n  RC4: _rc4_js__WEBPACK_IMPORTED_MODULE_20__.RC4,\n  RC4Drop: _rc4_js__WEBPACK_IMPORTED_MODULE_20__.RC4Drop,\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvaW5kZXguanM/Y2I0OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFRbUI7QUFJSTtBQWFHOztBQUUrQjtBQUNoQjtBQUNSO0FBQ2dCO0FBQ0k7QUFDUTtBQUNBO0FBQ0E7QUFDQTtBQUNSO0FBQ29CO0FBQ3hCO0FBQ0E7QUFDVDtBQU1oQjtBQUN5QjtBQUNtQjtBQU1sRDtBQUNrQjtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ1M7QUFDQTtBQUNBO0FBQ0U7QUFDSTtBQUNKOztBQUUvQywrREFBZTtBQUNmO0FBQ0EsUUFBUTtBQUNSLGFBQWE7QUFDYiwwQkFBMEI7QUFDMUIsVUFBVTtBQUNWLFVBQVU7QUFDVixnQkFBZ0I7QUFDaEIsbUJBQW1CO0FBQ25CLGVBQWU7QUFDZixnQkFBZ0I7QUFDaEIsc0JBQXNCO0FBQ3RCLHVCQUF1QjtBQUN2QixHQUFHOztBQUVIO0FBQ0EsVUFBVSxpREFBTztBQUNqQixlQUFlLHNEQUFZO0FBQzNCLEdBQUc7O0FBRUg7QUFDQSxPQUFPO0FBQ1AsVUFBVTtBQUNWLFFBQVE7QUFDUixTQUFTO0FBQ1QsV0FBVztBQUNYLFdBQVc7QUFDWCxVQUFVO0FBQ1YsR0FBRzs7QUFFSDtBQUNBLFFBQVE7QUFDUixTQUFTLDRDQUFPO0FBQ2hCLFVBQVUsOENBQVE7QUFDbEIsWUFBWSxrREFBVTtBQUN0QixZQUFZLGtEQUFVO0FBQ3RCLFlBQVksbURBQVU7QUFDdEIsWUFBWSxtREFBVTtBQUN0QixVQUFVLCtDQUFRO0FBQ2xCLGVBQWUseURBQWE7O0FBRTVCLFlBQVksbURBQVU7QUFDdEIsWUFBWSxtREFBVTs7QUFFdEIsU0FBUyw2Q0FBTztBQUNoQixTQUFTLG1EQUFPO0FBQ2hCLGVBQWUseURBQWE7QUFDNUIsWUFBWSxtREFBVTtBQUN0QixrQkFBa0IsZ0VBQWdCO0FBQ2xDLFNBQVMsNkNBQU87QUFDaEIsYUFBYSxpREFBVztBQUN4QixHQUFHOztBQUVIO0FBQ0EsT0FBTztBQUNQLE9BQU87QUFDUCxPQUFPO0FBQ1AsY0FBYztBQUNkLE9BQU87QUFDUCxPQUFPO0FBQ1AsR0FBRzs7QUFFSDtBQUNBLFNBQVM7QUFDVCxZQUFZO0FBQ1osWUFBWTtBQUNaLFlBQVk7QUFDWixhQUFhO0FBQ2IsZUFBZTtBQUNmLEdBQUc7O0FBRUg7QUFDQSxhQUFhLDZEQUFnQjtBQUM3QixTQUFTLHlEQUFZO0FBQ3JCLEdBQUc7O0FBRUg7QUFDQSxhQUFhLHVEQUFVO0FBQ3ZCLEdBQUc7O0FBRUgsS0FBSztBQUNMLFNBQVM7QUFDVCxNQUFNO0FBQ04sVUFBVTtBQUNWLFFBQVE7QUFDUixZQUFZO0FBQ1osUUFBUTtBQUNSLFlBQVk7QUFDWixRQUFRO0FBQ1IsWUFBWTtBQUNaLFFBQVE7QUFDUixZQUFZO0FBQ1osTUFBTTtBQUNOLFVBQVU7QUFDVixXQUFXO0FBQ1gsZUFBZTs7QUFFZixRQUFRO0FBQ1IsUUFBUTs7QUFFUixLQUFLO0FBQ0wsS0FBSztBQUNMLFdBQVc7QUFDWCxRQUFRO0FBQ1IsY0FBYztBQUNkLEtBQUs7QUFDTCxTQUFTO0FBQ1QsQ0FBQyxFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCYXNlLFxuICBXb3JkQXJyYXksXG4gIEhleCxcbiAgTGF0aW4xLFxuICBVdGY4LFxuICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLFxuICBIYXNoZXIsXG59IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQge1xuICBYNjRXb3JkLFxuICBYNjRXb3JkQXJyYXksXG59IGZyb20gJy4veDY0LWNvcmUuanMnO1xuaW1wb3J0IHtcbiAgQ2lwaGVyLFxuICBTdHJlYW1DaXBoZXIsXG4gIEJsb2NrQ2lwaGVyTW9kZSxcbiAgQ0JDLFxuICBQa2NzNyxcbiAgQmxvY2tDaXBoZXIsXG4gIENpcGhlclBhcmFtcyxcbiAgT3BlblNTTEZvcm1hdHRlcixcbiAgU2VyaWFsaXphYmxlQ2lwaGVyLFxuICBPcGVuU1NMS2RmLFxuICBQYXNzd29yZEJhc2VkQ2lwaGVyLFxufSBmcm9tICcuL2NpcGhlci1jb3JlLmpzJztcblxuaW1wb3J0IHsgVXRmMTYsIFV0ZjE2QkUsIFV0ZjE2TEUgfSBmcm9tICcuL2VuYy11dGYxNi5qcyc7XG5pbXBvcnQgeyBCYXNlNjQgfSBmcm9tICcuL2VuYy1iYXNlNjQuanMnO1xuaW1wb3J0IHsgSE1BQyB9IGZyb20gJy4vaG1hYy5qcyc7XG5pbXBvcnQgeyBNRDVBbGdvLCBNRDUsIEhtYWNNRDUgfSBmcm9tICcuL21kNS5qcyc7XG5pbXBvcnQgeyBTSEExQWxnbywgU0hBMSwgSG1hY1NIQTEgfSBmcm9tICcuL3NoYTEuanMnO1xuaW1wb3J0IHsgU0hBMjI0QWxnbywgU0hBMjI0LCBIbWFjU0hBMjI0IH0gZnJvbSAnLi9zaGEyMjQuanMnO1xuaW1wb3J0IHsgU0hBMjU2QWxnbywgU0hBMjU2LCBIbWFjU0hBMjU2IH0gZnJvbSAnLi9zaGEyNTYuanMnO1xuaW1wb3J0IHsgU0hBMzg0QWxnbywgU0hBMzg0LCBIbWFjU0hBMzg0IH0gZnJvbSAnLi9zaGEzODQuanMnO1xuaW1wb3J0IHsgU0hBNTEyQWxnbywgU0hBNTEyLCBIbWFjU0hBNTEyIH0gZnJvbSAnLi9zaGE1MTIuanMnO1xuaW1wb3J0IHsgU0hBM0FsZ28sIFNIQTMsIEhtYWNTSEEzIH0gZnJvbSAnLi9zaGEzLmpzJztcbmltcG9ydCB7IFJJUEVNRDE2MEFsZ28sIFJJUEVNRDE2MCwgSG1hY1JJUEVNRDE2MCB9IGZyb20gJy4vcmlwZW1kMTYwLmpzJztcbmltcG9ydCB7IFBCS0RGMkFsZ28sIFBCS0RGMiB9IGZyb20gJy4vcGJrZGYyLmpzJztcbmltcG9ydCB7IEV2cEtERkFsZ28sIEV2cEtERiB9IGZyb20gJy4vZXZwa2RmLmpzJztcbmltcG9ydCB7IEFFU0FsZ28sIEFFUyB9IGZyb20gJy4vYWVzLmpzJztcbmltcG9ydCB7XG4gIERFU0FsZ28sXG4gIERFUyxcbiAgVHJpcGxlREVTQWxnbyxcbiAgVHJpcGxlREVTLFxufSBmcm9tICcuL3RyaXBsZWRlcy5qcyc7XG5pbXBvcnQgeyBSYWJiaXRBbGdvLCBSYWJiaXQgfSBmcm9tICcuL3JhYmJpdC5qcyc7XG5pbXBvcnQgeyBSYWJiaXRMZWdhY3lBbGdvLCBSYWJiaXRMZWdhY3kgfSBmcm9tICcuL3JhYmJpdC1sZWdhY3kuanMnO1xuaW1wb3J0IHtcbiAgUkM0QWxnbyxcbiAgUkM0LFxuICBSQzREcm9wQWxnbyxcbiAgUkM0RHJvcCxcbn0gZnJvbSAnLi9yYzQuanMnO1xuaW1wb3J0IHsgQ0ZCIH0gZnJvbSAnLi9tb2RlLWNmYi5qcyc7XG5pbXBvcnQgeyBDVFIgfSBmcm9tICcuL21vZGUtY3RyLmpzJztcbmltcG9ydCB7IENUUkdsYWRtYW4gfSBmcm9tICcuL21vZGUtY3RyLWdsYWRtYW4uanMnO1xuaW1wb3J0IHsgRUNCIH0gZnJvbSAnLi9tb2RlLWVjYi5qcyc7XG5pbXBvcnQgeyBPRkIgfSBmcm9tICcuL21vZGUtb2ZiLmpzJztcbmltcG9ydCB7IEFuc2lYOTIzIH0gZnJvbSAnLi9wYWQtYW5zaXg5MjMuanMnO1xuaW1wb3J0IHsgSXNvMTAxMjYgfSBmcm9tICcuL3BhZC1pc28xMDEyNi5qcyc7XG5pbXBvcnQgeyBJc285Nzk3MSB9IGZyb20gJy4vcGFkLWlzbzk3OTcxLmpzJztcbmltcG9ydCB7IE5vUGFkZGluZyB9IGZyb20gJy4vcGFkLW5vcGFkZGluZy5qcyc7XG5pbXBvcnQgeyBaZXJvUGFkZGluZyB9IGZyb20gJy4vcGFkLXplcm9wYWRkaW5nLmpzJztcbmltcG9ydCB7IEhleEZvcm1hdHRlciB9IGZyb20gJy4vZm9ybWF0LWhleC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbGliOiB7XG4gICAgQmFzZSxcbiAgICBXb3JkQXJyYXksXG4gICAgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSxcbiAgICBIYXNoZXIsXG4gICAgQ2lwaGVyLFxuICAgIFN0cmVhbUNpcGhlcixcbiAgICBCbG9ja0NpcGhlck1vZGUsXG4gICAgQmxvY2tDaXBoZXIsXG4gICAgQ2lwaGVyUGFyYW1zLFxuICAgIFNlcmlhbGl6YWJsZUNpcGhlcixcbiAgICBQYXNzd29yZEJhc2VkQ2lwaGVyLFxuICB9LFxuXG4gIHg2NDoge1xuICAgIFdvcmQ6IFg2NFdvcmQsXG4gICAgV29yZEFycmF5OiBYNjRXb3JkQXJyYXksXG4gIH0sXG5cbiAgZW5jOiB7XG4gICAgSGV4LFxuICAgIExhdGluMSxcbiAgICBVdGY4LFxuICAgIFV0ZjE2LFxuICAgIFV0ZjE2QkUsXG4gICAgVXRmMTZMRSxcbiAgICBCYXNlNjQsXG4gIH0sXG5cbiAgYWxnbzoge1xuICAgIEhNQUMsXG4gICAgTUQ1OiBNRDVBbGdvLFxuICAgIFNIQTE6IFNIQTFBbGdvLFxuICAgIFNIQTIyNDogU0hBMjI0QWxnbyxcbiAgICBTSEEyNTY6IFNIQTI1NkFsZ28sXG4gICAgU0hBMzg0OiBTSEEzODRBbGdvLFxuICAgIFNIQTUxMjogU0hBNTEyQWxnbyxcbiAgICBTSEEzOiBTSEEzQWxnbyxcbiAgICBSSVBFTUQxNjA6IFJJUEVNRDE2MEFsZ28sXG5cbiAgICBQQktERjI6IFBCS0RGMkFsZ28sXG4gICAgRXZwS0RGOiBFdnBLREZBbGdvLFxuXG4gICAgQUVTOiBBRVNBbGdvLFxuICAgIERFUzogREVTQWxnbyxcbiAgICBUcmlwbGVERVM6IFRyaXBsZURFU0FsZ28sXG4gICAgUmFiYml0OiBSYWJiaXRBbGdvLFxuICAgIFJhYmJpdExlZ2FjeTogUmFiYml0TGVnYWN5QWxnbyxcbiAgICBSQzQ6IFJDNEFsZ28sXG4gICAgUkM0RHJvcDogUkM0RHJvcEFsZ28sXG4gIH0sXG5cbiAgbW9kZToge1xuICAgIENCQyxcbiAgICBDRkIsXG4gICAgQ1RSLFxuICAgIENUUkdsYWRtYW4sXG4gICAgRUNCLFxuICAgIE9GQixcbiAgfSxcblxuICBwYWQ6IHtcbiAgICBQa2NzNyxcbiAgICBBbnNpWDkyMyxcbiAgICBJc28xMDEyNixcbiAgICBJc285Nzk3MSxcbiAgICBOb1BhZGRpbmcsXG4gICAgWmVyb1BhZGRpbmcsXG4gIH0sXG5cbiAgZm9ybWF0OiB7XG4gICAgT3BlblNTTDogT3BlblNTTEZvcm1hdHRlcixcbiAgICBIZXg6IEhleEZvcm1hdHRlcixcbiAgfSxcblxuICBrZGY6IHtcbiAgICBPcGVuU1NMOiBPcGVuU1NMS2RmLFxuICB9LFxuXG4gIE1ENSxcbiAgSG1hY01ENSxcbiAgU0hBMSxcbiAgSG1hY1NIQTEsXG4gIFNIQTIyNCxcbiAgSG1hY1NIQTIyNCxcbiAgU0hBMjU2LFxuICBIbWFjU0hBMjU2LFxuICBTSEEzODQsXG4gIEhtYWNTSEEzODQsXG4gIFNIQTUxMixcbiAgSG1hY1NIQTUxMixcbiAgU0hBMyxcbiAgSG1hY1NIQTMsXG4gIFJJUEVNRDE2MCxcbiAgSG1hY1JJUEVNRDE2MCxcblxuICBQQktERjIsXG4gIEV2cEtERixcblxuICBBRVMsXG4gIERFUyxcbiAgVHJpcGxlREVTLFxuICBSYWJiaXQsXG4gIFJhYmJpdExlZ2FjeSxcbiAgUkM0LFxuICBSQzREcm9wLFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/index.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/md5.js":
/*!*******************************************!*\
  !*** ./node_modules/crypto-es/lib/md5.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MD5Algo\": function() { return /* binding */ MD5Algo; },\n/* harmony export */   \"MD5\": function() { return /* binding */ MD5; },\n/* harmony export */   \"HmacMD5\": function() { return /* binding */ HmacMD5; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\n// Constants table\nconst T = [];\n\n// Compute constants\nfor (let i = 0; i < 64; i += 1) {\n  T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n}\n\nconst FF = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & c) | (~b & d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst GG = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & d) | (c & ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst HH = (a, b, c, d, x, s, t) => {\n  const n = a + (b ^ c ^ d) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst II = (a, b, c, d, x, s, t) => {\n  const n = a + (c ^ (b | ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\n/**\n * MD5 hash algorithm.\n */\nclass MD5Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher {\n  _doReset() {\n    this._hash = new _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray([\n      0x67452301,\n      0xefcdab89,\n      0x98badcfe,\n      0x10325476,\n    ]);\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Swap endian\n    for (let i = 0; i < 16; i += 1) {\n      // Shortcuts\n      const offset_i = offset + i;\n      const M_offset_i = M[offset_i];\n\n      _M[offset_i] = (\n        (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff)\n          | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)\n      );\n    }\n\n    // Shortcuts\n    const H = this._hash.words;\n\n    const M_offset_0 = _M[offset + 0];\n    const M_offset_1 = _M[offset + 1];\n    const M_offset_2 = _M[offset + 2];\n    const M_offset_3 = _M[offset + 3];\n    const M_offset_4 = _M[offset + 4];\n    const M_offset_5 = _M[offset + 5];\n    const M_offset_6 = _M[offset + 6];\n    const M_offset_7 = _M[offset + 7];\n    const M_offset_8 = _M[offset + 8];\n    const M_offset_9 = _M[offset + 9];\n    const M_offset_10 = _M[offset + 10];\n    const M_offset_11 = _M[offset + 11];\n    const M_offset_12 = _M[offset + 12];\n    const M_offset_13 = _M[offset + 13];\n    const M_offset_14 = _M[offset + 14];\n    const M_offset_15 = _M[offset + 15];\n\n    // Working varialbes\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n\n    // Computation\n    a = FF(a, b, c, d, M_offset_0, 7, T[0]);\n    d = FF(d, a, b, c, M_offset_1, 12, T[1]);\n    c = FF(c, d, a, b, M_offset_2, 17, T[2]);\n    b = FF(b, c, d, a, M_offset_3, 22, T[3]);\n    a = FF(a, b, c, d, M_offset_4, 7, T[4]);\n    d = FF(d, a, b, c, M_offset_5, 12, T[5]);\n    c = FF(c, d, a, b, M_offset_6, 17, T[6]);\n    b = FF(b, c, d, a, M_offset_7, 22, T[7]);\n    a = FF(a, b, c, d, M_offset_8, 7, T[8]);\n    d = FF(d, a, b, c, M_offset_9, 12, T[9]);\n    c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n    b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n    a = FF(a, b, c, d, M_offset_12, 7, T[12]);\n    d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n    c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n    b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n    a = GG(a, b, c, d, M_offset_1, 5, T[16]);\n    d = GG(d, a, b, c, M_offset_6, 9, T[17]);\n    c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n    b = GG(b, c, d, a, M_offset_0, 20, T[19]);\n    a = GG(a, b, c, d, M_offset_5, 5, T[20]);\n    d = GG(d, a, b, c, M_offset_10, 9, T[21]);\n    c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n    b = GG(b, c, d, a, M_offset_4, 20, T[23]);\n    a = GG(a, b, c, d, M_offset_9, 5, T[24]);\n    d = GG(d, a, b, c, M_offset_14, 9, T[25]);\n    c = GG(c, d, a, b, M_offset_3, 14, T[26]);\n    b = GG(b, c, d, a, M_offset_8, 20, T[27]);\n    a = GG(a, b, c, d, M_offset_13, 5, T[28]);\n    d = GG(d, a, b, c, M_offset_2, 9, T[29]);\n    c = GG(c, d, a, b, M_offset_7, 14, T[30]);\n    b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n    a = HH(a, b, c, d, M_offset_5, 4, T[32]);\n    d = HH(d, a, b, c, M_offset_8, 11, T[33]);\n    c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n    b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n    a = HH(a, b, c, d, M_offset_1, 4, T[36]);\n    d = HH(d, a, b, c, M_offset_4, 11, T[37]);\n    c = HH(c, d, a, b, M_offset_7, 16, T[38]);\n    b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n    a = HH(a, b, c, d, M_offset_13, 4, T[40]);\n    d = HH(d, a, b, c, M_offset_0, 11, T[41]);\n    c = HH(c, d, a, b, M_offset_3, 16, T[42]);\n    b = HH(b, c, d, a, M_offset_6, 23, T[43]);\n    a = HH(a, b, c, d, M_offset_9, 4, T[44]);\n    d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n    c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n    b = HH(b, c, d, a, M_offset_2, 23, T[47]);\n\n    a = II(a, b, c, d, M_offset_0, 6, T[48]);\n    d = II(d, a, b, c, M_offset_7, 10, T[49]);\n    c = II(c, d, a, b, M_offset_14, 15, T[50]);\n    b = II(b, c, d, a, M_offset_5, 21, T[51]);\n    a = II(a, b, c, d, M_offset_12, 6, T[52]);\n    d = II(d, a, b, c, M_offset_3, 10, T[53]);\n    c = II(c, d, a, b, M_offset_10, 15, T[54]);\n    b = II(b, c, d, a, M_offset_1, 21, T[55]);\n    a = II(a, b, c, d, M_offset_8, 6, T[56]);\n    d = II(d, a, b, c, M_offset_15, 10, T[57]);\n    c = II(c, d, a, b, M_offset_6, 15, T[58]);\n    b = II(b, c, d, a, M_offset_13, 21, T[59]);\n    a = II(a, b, c, d, M_offset_4, 6, T[60]);\n    d = II(d, a, b, c, M_offset_11, 10, T[61]);\n    c = II(c, d, a, b, M_offset_2, 15, T[62]);\n    b = II(b, c, d, a, M_offset_9, 21, T[63]);\n\n    // Intermediate hash value\n    H[0] = (H[0] + a) | 0;\n    H[1] = (H[1] + b) | 0;\n    H[2] = (H[2] + c) | 0;\n    H[3] = (H[3] + d) | 0;\n  }\n  /* eslint-ensable no-param-reassign */\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n\n    const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n    const nBitsTotalL = nBitsTotal;\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n      (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00)\n    );\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n      (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00)\n    );\n\n    data.sigBytes = (dataWords.length + 1) * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const hash = this._hash;\n    const H = hash.words;\n\n    // Swap endian\n    for (let i = 0; i < 4; i += 1) {\n      // Shortcut\n      const H_i = H[i];\n\n      H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff)\n        | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n    }\n\n    // Return final computed hash\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.MD5('message');\n *     var hash = CryptoJS.MD5(wordArray);\n */\nconst MD5 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHelper(MD5Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacMD5(message, key);\n */\nconst HmacMD5 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHmacHelper(MD5Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbWQ1LmpzPzFiYjAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUdtQjs7QUFFbkI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLHNCQUFzQiw0Q0FBTTtBQUNuQztBQUNBLHFCQUFxQiwrQ0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxZQUFZLDBEQUFvQjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQkFBZ0IsOERBQXdCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbWQ1LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgV29yZEFycmF5LFxuICBIYXNoZXIsXG59IGZyb20gJy4vY29yZS5qcyc7XG5cbi8vIENvbnN0YW50cyB0YWJsZVxuY29uc3QgVCA9IFtdO1xuXG4vLyBDb21wdXRlIGNvbnN0YW50c1xuZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSArPSAxKSB7XG4gIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG59XG5cbmNvbnN0IEZGID0gKGEsIGIsIGMsIGQsIHgsIHMsIHQpID0+IHtcbiAgY29uc3QgbiA9IGEgKyAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIHggKyB0O1xuICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xufTtcblxuY29uc3QgR0cgPSAoYSwgYiwgYywgZCwgeCwgcywgdCkgPT4ge1xuICBjb25zdCBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG4gIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XG59O1xuXG5jb25zdCBISCA9IChhLCBiLCBjLCBkLCB4LCBzLCB0KSA9PiB7XG4gIGNvbnN0IG4gPSBhICsgKGIgXiBjIF4gZCkgKyB4ICsgdDtcbiAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcbn07XG5cbmNvbnN0IElJID0gKGEsIGIsIGMsIGQsIHgsIHMsIHQpID0+IHtcbiAgY29uc3QgbiA9IGEgKyAoYyBeIChiIHwgfmQpKSArIHggKyB0O1xuICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xufTtcblxuLyoqXG4gKiBNRDUgaGFzaCBhbGdvcml0aG0uXG4gKi9cbmV4cG9ydCBjbGFzcyBNRDVBbGdvIGV4dGVuZHMgSGFzaGVyIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkoW1xuICAgICAgMHg2NzQ1MjMwMSxcbiAgICAgIDB4ZWZjZGFiODksXG4gICAgICAweDk4YmFkY2ZlLFxuICAgICAgMHgxMDMyNTQ3NixcbiAgICBdKTtcbiAgfVxuXG4gIF9kb1Byb2Nlc3NCbG9jayhNLCBvZmZzZXQpIHtcbiAgICBjb25zdCBfTSA9IE07XG5cbiAgICAvLyBTd2FwIGVuZGlhblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICBjb25zdCBvZmZzZXRfaSA9IG9mZnNldCArIGk7XG4gICAgICBjb25zdCBNX29mZnNldF9pID0gTVtvZmZzZXRfaV07XG5cbiAgICAgIF9NW29mZnNldF9pXSA9IChcbiAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSB8IChNX29mZnNldF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgICB8ICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAmIDB4ZmYwMGZmMDApXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG4gICAgY29uc3QgTV9vZmZzZXRfMCA9IF9NW29mZnNldCArIDBdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzEgPSBfTVtvZmZzZXQgKyAxXTtcbiAgICBjb25zdCBNX29mZnNldF8yID0gX01bb2Zmc2V0ICsgMl07XG4gICAgY29uc3QgTV9vZmZzZXRfMyA9IF9NW29mZnNldCArIDNdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzQgPSBfTVtvZmZzZXQgKyA0XTtcbiAgICBjb25zdCBNX29mZnNldF81ID0gX01bb2Zmc2V0ICsgNV07XG4gICAgY29uc3QgTV9vZmZzZXRfNiA9IF9NW29mZnNldCArIDZdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzcgPSBfTVtvZmZzZXQgKyA3XTtcbiAgICBjb25zdCBNX29mZnNldF84ID0gX01bb2Zmc2V0ICsgOF07XG4gICAgY29uc3QgTV9vZmZzZXRfOSA9IF9NW29mZnNldCArIDldO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzEwID0gX01bb2Zmc2V0ICsgMTBdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzExID0gX01bb2Zmc2V0ICsgMTFdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzEyID0gX01bb2Zmc2V0ICsgMTJdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzEzID0gX01bb2Zmc2V0ICsgMTNdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzE0ID0gX01bb2Zmc2V0ICsgMTRdO1xuICAgIGNvbnN0IE1fb2Zmc2V0XzE1ID0gX01bb2Zmc2V0ICsgMTVdO1xuXG4gICAgLy8gV29ya2luZyB2YXJpYWxiZXNcbiAgICBsZXQgYSA9IEhbMF07XG4gICAgbGV0IGIgPSBIWzFdO1xuICAgIGxldCBjID0gSFsyXTtcbiAgICBsZXQgZCA9IEhbM107XG5cbiAgICAvLyBDb21wdXRhdGlvblxuICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCA3LCBUWzBdKTtcbiAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgMTIsIFRbMV0pO1xuICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAxNywgVFsyXSk7XG4gICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzMsIDIyLCBUWzNdKTtcbiAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgNywgVFs0XSk7XG4gICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsIDEyLCBUWzVdKTtcbiAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgMTcsIFRbNl0pO1xuICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF83LCAyMiwgVFs3XSk7XG4gICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsIDcsIFRbOF0pO1xuICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAxMiwgVFs5XSk7XG4gICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNywgVFsxMF0pO1xuICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcbiAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDcsIFRbMTJdKTtcbiAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG4gICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNywgVFsxNF0pO1xuICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xNSwgMjIsIFRbMTVdKTtcblxuICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCA1LCBUWzE2XSk7XG4gICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsIDksIFRbMTddKTtcbiAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG4gICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzAsIDIwLCBUWzE5XSk7XG4gICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsIDUsIFRbMjBdKTtcbiAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksIFRbMjFdKTtcbiAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE0LCBUWzIyXSk7XG4gICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsIDIwLCBUWzIzXSk7XG4gICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzksIDUsIFRbMjRdKTtcbiAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTQsIDksIFRbMjVdKTtcbiAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgMTQsIFRbMjZdKTtcbiAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgMjAsIFRbMjddKTtcbiAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDUsIFRbMjhdKTtcbiAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMiwgOSwgVFsyOV0pO1xuICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF83LCAxNCwgVFszMF0pO1xuICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF81LCA0LCBUWzMyXSk7XG4gICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzgsIDExLCBUWzMzXSk7XG4gICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xNCwgMjMsIFRbMzVdKTtcbiAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMSwgNCwgVFszNl0pO1xuICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF80LCAxMSwgVFszN10pO1xuICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF83LCAxNiwgVFszOF0pO1xuICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcbiAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTMsIDQsIFRbNDBdKTtcbiAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgMTEsIFRbNDFdKTtcbiAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMywgMTYsIFRbNDJdKTtcbiAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfNiwgMjMsIFRbNDNdKTtcbiAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgNCwgVFs0NF0pO1xuICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcbiAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTUsIDE2LCBUWzQ2XSk7XG4gICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzIsIDIzLCBUWzQ3XSk7XG5cbiAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgNiwgVFs0OF0pO1xuICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF83LCAxMCwgVFs0OV0pO1xuICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcbiAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfNSwgMjEsIFRbNTFdKTtcbiAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsIFRbNTJdKTtcbiAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMywgMTAsIFRbNTNdKTtcbiAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE1LCBUWzU0XSk7XG4gICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEsIDIxLCBUWzU1XSk7XG4gICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsIDYsIFRbNTZdKTtcbiAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTUsIDEwLCBUWzU3XSk7XG4gICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzYsIDE1LCBUWzU4XSk7XG4gICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEzLCAyMSwgVFs1OV0pO1xuICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF80LCA2LCBUWzYwXSk7XG4gICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzExLCAxMCwgVFs2MV0pO1xuICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAxNSwgVFs2Ml0pO1xuICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF85LCAyMSwgVFs2M10pO1xuXG4gICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcbiAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG4gICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcbiAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG4gIH1cbiAgLyogZXNsaW50LWVuc2FibGUgbm8tcGFyYW0tcmVhc3NpZ24gKi9cblxuICBfZG9GaW5hbGl6ZSgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG4gICAgY29uc3QgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuICAgIGNvbnN0IG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG4gICAgLy8gQWRkIHBhZGRpbmdcbiAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIChuQml0c0xlZnQgJSAzMikpO1xuXG4gICAgY29uc3QgbkJpdHNUb3RhbEggPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG4gICAgY29uc3QgbkJpdHNUb3RhbEwgPSBuQml0c1RvdGFsO1xuICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gKFxuICAgICAgKCgobkJpdHNUb3RhbEggPDwgOCkgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKVxuICAgICAgICB8ICgoKG5CaXRzVG90YWxIIDw8IDI0KSB8IChuQml0c1RvdGFsSCA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgICApO1xuICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuICAgICAgKCgobkJpdHNUb3RhbEwgPDwgOCkgfCAobkJpdHNUb3RhbEwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKVxuICAgICAgICB8ICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgICApO1xuXG4gICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG4gICAgLy8gSGFzaCBmaW5hbCBibG9ja3NcbiAgICB0aGlzLl9wcm9jZXNzKCk7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBoYXNoID0gdGhpcy5faGFzaDtcbiAgICBjb25zdCBIID0gaGFzaC53b3JkcztcblxuICAgIC8vIFN3YXAgZW5kaWFuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0XG4gICAgICBjb25zdCBIX2kgPSBIW2ldO1xuXG4gICAgICBIW2ldID0gKCgoSF9pIDw8IDgpIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpXG4gICAgICAgIHwgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG4gKi9cbmV4cG9ydCBjb25zdCBNRDUgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihNRDVBbGdvKTtcblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IEhtYWNNRDUgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoTUQ1QWxnbyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/md5.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/mode-cfb.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-es/lib/mode-cfb.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CFB\": function() { return /* binding */ CFB; }\n/* harmony export */ });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\nfunction generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {\n  const _words = words;\n  let keystream;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Generate keystream\n  if (iv) {\n    keystream = iv.slice(0);\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    keystream = this._prevBlock;\n  }\n  cipher.encryptBlock(keystream, 0);\n\n  // Encrypt\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= keystream[i];\n  }\n}\n\n/**\n * Cipher Feedback block mode.\n */\nclass CFB extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.BlockCipherMode {\n}\nCFB.Encryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\nCFB.Decryptor = class extends CFB {\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1jZmIuanM/MzU1YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUUwQjs7QUFFMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLGtCQUFrQiw0REFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZOztBQUV2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZOztBQUV2QjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1jZmIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBCbG9ja0NpcGhlck1vZGUsXG59IGZyb20gJy4vY2lwaGVyLWNvcmUuanMnO1xuXG5mdW5jdGlvbiBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQod29yZHMsIG9mZnNldCwgYmxvY2tTaXplLCBjaXBoZXIpIHtcbiAgY29uc3QgX3dvcmRzID0gd29yZHM7XG4gIGxldCBrZXlzdHJlYW07XG5cbiAgLy8gU2hvcnRjdXRcbiAgY29uc3QgaXYgPSB0aGlzLl9pdjtcblxuICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cbiAgaWYgKGl2KSB7XG4gICAga2V5c3RyZWFtID0gaXYuc2xpY2UoMCk7XG5cbiAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG4gICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG4gIH0gZWxzZSB7XG4gICAga2V5c3RyZWFtID0gdGhpcy5fcHJldkJsb2NrO1xuICB9XG4gIGNpcGhlci5lbmNyeXB0QmxvY2soa2V5c3RyZWFtLCAwKTtcblxuICAvLyBFbmNyeXB0XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpICs9IDEpIHtcbiAgICBfd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuICB9XG59XG5cbi8qKlxuICogQ2lwaGVyIEZlZWRiYWNrIGJsb2NrIG1vZGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBDRkIgZXh0ZW5kcyBCbG9ja0NpcGhlck1vZGUge1xufVxuQ0ZCLkVuY3J5cHRvciA9IGNsYXNzIGV4dGVuZHMgQ0ZCIHtcbiAgcHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG4gICAgY29uc3QgeyBibG9ja1NpemUgfSA9IGNpcGhlcjtcblxuICAgIGdlbmVyYXRlS2V5c3RyZWFtQW5kRW5jcnlwdC5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSwgY2lwaGVyKTtcblxuICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuICAgIHRoaXMuX3ByZXZCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcbiAgfVxufTtcbkNGQi5EZWNyeXB0b3IgPSBjbGFzcyBleHRlbmRzIENGQiB7XG4gIHByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuICAgIGNvbnN0IHsgYmxvY2tTaXplIH0gPSBjaXBoZXI7XG5cbiAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcbiAgICBjb25zdCB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cbiAgICBnZW5lcmF0ZUtleXN0cmVhbUFuZEVuY3J5cHQuY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUsIGNpcGhlcik7XG5cbiAgICAvLyBUaGlzIGJsb2NrIGJlY29tZXMgdGhlIHByZXZpb3VzIGJsb2NrXG4gICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xuICB9XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/mode-cfb.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/mode-ctr-gladman.js":
/*!********************************************************!*\
  !*** ./node_modules/crypto-es/lib/mode-ctr-gladman.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CTRGladman\": function() { return /* binding */ CTRGladman; }\n/* harmony export */ });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\nconst incWord = (word) => {\n  let _word = word;\n\n  if (((word >> 24) & 0xff) === 0xff) { // overflow\n    let b1 = (word >> 16) & 0xff;\n    let b2 = (word >> 8) & 0xff;\n    let b3 = word & 0xff;\n\n    if (b1 === 0xff) { // overflow b1\n      b1 = 0;\n      if (b2 === 0xff) {\n        b2 = 0;\n        if (b3 === 0xff) {\n          b3 = 0;\n        } else {\n          b3 += 1;\n        }\n      } else {\n        b2 += 1;\n      }\n    } else {\n      b1 += 1;\n    }\n\n    _word = 0;\n    _word += (b1 << 16);\n    _word += (b2 << 8);\n    _word += b3;\n  } else {\n    _word += (0x01 << 24);\n  }\n  return _word;\n};\n\nconst incCounter = (counter) => {\n  const _counter = counter;\n  _counter[0] = incWord(_counter[0]);\n\n  if (_counter[0] === 0) {\n    // encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8\n    _counter[1] = incWord(_counter[1]);\n  }\n  return _counter;\n};\n\n/** @preserve\n * Counter block mode compatible with  Dr Brian Gladman fileenc.c\n * derived from CryptoJS.mode.CTR\n * Jan Hruby jhruby.web@gmail.com\n */\nclass CTRGladman extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.BlockCipherMode {\n}\nCTRGladman.Encryptor = class extends CTRGladman {\n  processBlock(words, offset) {\n    const _words = words;\n\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n    const iv = this._iv;\n    let counter = this._counter;\n\n    // Generate keystream\n    if (iv) {\n      this._counter = iv.slice(0);\n      counter = this._counter;\n\n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n\n    incCounter(counter);\n\n    const keystream = counter.slice(0);\n    cipher.encryptBlock(keystream, 0);\n\n    // Encrypt\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n};\nCTRGladman.Decryptor = CTRGladman.Encryptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1jdHItZ2xhZG1hbi5qcz9lNTM4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBRTBCOztBQUUxQjtBQUNBOztBQUVBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUJBQXlCLDREQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9tb2RlLWN0ci1nbGFkbWFuLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmxvY2tDaXBoZXJNb2RlLFxufSBmcm9tICcuL2NpcGhlci1jb3JlLmpzJztcblxuY29uc3QgaW5jV29yZCA9ICh3b3JkKSA9PiB7XG4gIGxldCBfd29yZCA9IHdvcmQ7XG5cbiAgaWYgKCgod29yZCA+PiAyNCkgJiAweGZmKSA9PT0gMHhmZikgeyAvLyBvdmVyZmxvd1xuICAgIGxldCBiMSA9ICh3b3JkID4+IDE2KSAmIDB4ZmY7XG4gICAgbGV0IGIyID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgIGxldCBiMyA9IHdvcmQgJiAweGZmO1xuXG4gICAgaWYgKGIxID09PSAweGZmKSB7IC8vIG92ZXJmbG93IGIxXG4gICAgICBiMSA9IDA7XG4gICAgICBpZiAoYjIgPT09IDB4ZmYpIHtcbiAgICAgICAgYjIgPSAwO1xuICAgICAgICBpZiAoYjMgPT09IDB4ZmYpIHtcbiAgICAgICAgICBiMyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYjMgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYjIgKz0gMTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYjEgKz0gMTtcbiAgICB9XG5cbiAgICBfd29yZCA9IDA7XG4gICAgX3dvcmQgKz0gKGIxIDw8IDE2KTtcbiAgICBfd29yZCArPSAoYjIgPDwgOCk7XG4gICAgX3dvcmQgKz0gYjM7XG4gIH0gZWxzZSB7XG4gICAgX3dvcmQgKz0gKDB4MDEgPDwgMjQpO1xuICB9XG4gIHJldHVybiBfd29yZDtcbn07XG5cbmNvbnN0IGluY0NvdW50ZXIgPSAoY291bnRlcikgPT4ge1xuICBjb25zdCBfY291bnRlciA9IGNvdW50ZXI7XG4gIF9jb3VudGVyWzBdID0gaW5jV29yZChfY291bnRlclswXSk7XG5cbiAgaWYgKF9jb3VudGVyWzBdID09PSAwKSB7XG4gICAgLy8gZW5jcl9kYXRhIGluIGZpbGVlbmMuYyBmcm9tICBEciBCcmlhbiBHbGFkbWFuJ3MgY291bnRzIG9ubHkgd2l0aCBEV09SRCBqIDwgOFxuICAgIF9jb3VudGVyWzFdID0gaW5jV29yZChfY291bnRlclsxXSk7XG4gIH1cbiAgcmV0dXJuIF9jb3VudGVyO1xufTtcblxuLyoqIEBwcmVzZXJ2ZVxuICogQ291bnRlciBibG9jayBtb2RlIGNvbXBhdGlibGUgd2l0aCAgRHIgQnJpYW4gR2xhZG1hbiBmaWxlZW5jLmNcbiAqIGRlcml2ZWQgZnJvbSBDcnlwdG9KUy5tb2RlLkNUUlxuICogSmFuIEhydWJ5IGpocnVieS53ZWJAZ21haWwuY29tXG4gKi9cbmV4cG9ydCBjbGFzcyBDVFJHbGFkbWFuIGV4dGVuZHMgQmxvY2tDaXBoZXJNb2RlIHtcbn1cbkNUUkdsYWRtYW4uRW5jcnlwdG9yID0gY2xhc3MgZXh0ZW5kcyBDVFJHbGFkbWFuIHtcbiAgcHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpIHtcbiAgICBjb25zdCBfd29yZHMgPSB3b3JkcztcblxuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcbiAgICBjb25zdCB7IGJsb2NrU2l6ZSB9ID0gY2lwaGVyO1xuICAgIGNvbnN0IGl2ID0gdGhpcy5faXY7XG4gICAgbGV0IGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyO1xuXG4gICAgLy8gR2VuZXJhdGUga2V5c3RyZWFtXG4gICAgaWYgKGl2KSB7XG4gICAgICB0aGlzLl9jb3VudGVyID0gaXYuc2xpY2UoMCk7XG4gICAgICBjb3VudGVyID0gdGhpcy5fY291bnRlcjtcblxuICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaW5jQ291bnRlcihjb3VudGVyKTtcblxuICAgIGNvbnN0IGtleXN0cmVhbSA9IGNvdW50ZXIuc2xpY2UoMCk7XG4gICAgY2lwaGVyLmVuY3J5cHRCbG9jayhrZXlzdHJlYW0sIDApO1xuXG4gICAgLy8gRW5jcnlwdFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpICs9IDEpIHtcbiAgICAgIF93b3Jkc1tvZmZzZXQgKyBpXSBePSBrZXlzdHJlYW1baV07XG4gICAgfVxuICB9XG59O1xuQ1RSR2xhZG1hbi5EZWNyeXB0b3IgPSBDVFJHbGFkbWFuLkVuY3J5cHRvcjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/mode-ctr-gladman.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/mode-ctr.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-es/lib/mode-ctr.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CTR\": function() { return /* binding */ CTR; }\n/* harmony export */ });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n/**\n * Counter block mode.\n */\n\n\nclass CTR extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.BlockCipherMode {\n}\nCTR.Encryptor = class extends CTR {\n  processBlock(words, offset) {\n    const _words = words;\n\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n    const iv = this._iv;\n    let counter = this._counter;\n\n    // Generate keystream\n    if (iv) {\n      this._counter = iv.slice(0);\n      counter = this._counter;\n\n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n    const keystream = counter.slice(0);\n    cipher.encryptBlock(keystream, 0);\n\n    // Increment counter\n    counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;\n\n    // Encrypt\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n};\nCTR.Decryptor = CTR.Encryptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1jdHIuanM/Yjg1OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUcwQjs7QUFFbkIsa0JBQWtCLDREQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1jdHIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvdW50ZXIgYmxvY2sgbW9kZS5cbiAqL1xuaW1wb3J0IHtcbiAgQmxvY2tDaXBoZXJNb2RlLFxufSBmcm9tICcuL2NpcGhlci1jb3JlLmpzJztcblxuZXhwb3J0IGNsYXNzIENUUiBleHRlbmRzIEJsb2NrQ2lwaGVyTW9kZSB7XG59XG5DVFIuRW5jcnlwdG9yID0gY2xhc3MgZXh0ZW5kcyBDVFIge1xuICBwcm9jZXNzQmxvY2sod29yZHMsIG9mZnNldCkge1xuICAgIGNvbnN0IF93b3JkcyA9IHdvcmRzO1xuXG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xuICAgIGNvbnN0IHsgYmxvY2tTaXplIH0gPSBjaXBoZXI7XG4gICAgY29uc3QgaXYgPSB0aGlzLl9pdjtcbiAgICBsZXQgY291bnRlciA9IHRoaXMuX2NvdW50ZXI7XG5cbiAgICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW1cbiAgICBpZiAoaXYpIHtcbiAgICAgIHRoaXMuX2NvdW50ZXIgPSBpdi5zbGljZSgwKTtcbiAgICAgIGNvdW50ZXIgPSB0aGlzLl9jb3VudGVyO1xuXG4gICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG4gICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3Qga2V5c3RyZWFtID0gY291bnRlci5zbGljZSgwKTtcbiAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XG5cbiAgICAvLyBJbmNyZW1lbnQgY291bnRlclxuICAgIGNvdW50ZXJbYmxvY2tTaXplIC0gMV0gPSAoY291bnRlcltibG9ja1NpemUgLSAxXSArIDEpIHwgMDtcblxuICAgIC8vIEVuY3J5cHRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSArPSAxKSB7XG4gICAgICBfd29yZHNbb2Zmc2V0ICsgaV0gXj0ga2V5c3RyZWFtW2ldO1xuICAgIH1cbiAgfVxufTtcbkNUUi5EZWNyeXB0b3IgPSBDVFIuRW5jcnlwdG9yO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/mode-ctr.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/mode-ecb.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-es/lib/mode-ecb.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ECB\": function() { return /* binding */ ECB; }\n/* harmony export */ });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n/**\n * Electronic Codebook block mode.\n */\n\n\nclass ECB extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.BlockCipherMode {\n}\nECB.Encryptor = class extends ECB {\n  processBlock(words, offset) {\n    this._cipher.encryptBlock(words, offset);\n  }\n};\nECB.Decryptor = class extends ECB {\n  processBlock(words, offset) {\n    this._cipher.decryptBlock(words, offset);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1lY2IuanM/MjZjZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUcwQjs7QUFFbkIsa0JBQWtCLDREQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9tb2RlLWVjYi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogRWxlY3Ryb25pYyBDb2RlYm9vayBibG9jayBtb2RlLlxuICovXG5pbXBvcnQge1xuICBCbG9ja0NpcGhlck1vZGUsXG59IGZyb20gJy4vY2lwaGVyLWNvcmUuanMnO1xuXG5leHBvcnQgY2xhc3MgRUNCIGV4dGVuZHMgQmxvY2tDaXBoZXJNb2RlIHtcbn1cbkVDQi5FbmNyeXB0b3IgPSBjbGFzcyBleHRlbmRzIEVDQiB7XG4gIHByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgdGhpcy5fY2lwaGVyLmVuY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcbiAgfVxufTtcbkVDQi5EZWNyeXB0b3IgPSBjbGFzcyBleHRlbmRzIEVDQiB7XG4gIHByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KSB7XG4gICAgdGhpcy5fY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/mode-ecb.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/mode-ofb.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-es/lib/mode-ofb.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"OFB\": function() { return /* binding */ OFB; }\n/* harmony export */ });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n/**\n * Output Feedback block mode.\n */\n\n\nclass OFB extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.BlockCipherMode {\n}\nOFB.Encryptor = class extends OFB {\n  processBlock(words, offset) {\n    const _words = words;\n\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n    const iv = this._iv;\n    let keystream = this._keystream;\n\n    // Generate keystream\n    if (iv) {\n      this._keystream = iv.slice(0);\n      keystream = this._keystream;\n\n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n    cipher.encryptBlock(keystream, 0);\n\n    // Encrypt\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n};\nOFB.Decryptor = OFB.Encryptor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvbW9kZS1vZmIuanM/YzI1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUcwQjs7QUFFbkIsa0JBQWtCLDREQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9tb2RlLW9mYi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogT3V0cHV0IEZlZWRiYWNrIGJsb2NrIG1vZGUuXG4gKi9cbmltcG9ydCB7XG4gIEJsb2NrQ2lwaGVyTW9kZSxcbn0gZnJvbSAnLi9jaXBoZXItY29yZS5qcyc7XG5cbmV4cG9ydCBjbGFzcyBPRkIgZXh0ZW5kcyBCbG9ja0NpcGhlck1vZGUge1xufVxuT0ZCLkVuY3J5cHRvciA9IGNsYXNzIGV4dGVuZHMgT0ZCIHtcbiAgcHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpIHtcbiAgICBjb25zdCBfd29yZHMgPSB3b3JkcztcblxuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcbiAgICBjb25zdCB7IGJsb2NrU2l6ZSB9ID0gY2lwaGVyO1xuICAgIGNvbnN0IGl2ID0gdGhpcy5faXY7XG4gICAgbGV0IGtleXN0cmVhbSA9IHRoaXMuX2tleXN0cmVhbTtcblxuICAgIC8vIEdlbmVyYXRlIGtleXN0cmVhbVxuICAgIGlmIChpdikge1xuICAgICAgdGhpcy5fa2V5c3RyZWFtID0gaXYuc2xpY2UoMCk7XG4gICAgICBrZXlzdHJlYW0gPSB0aGlzLl9rZXlzdHJlYW07XG5cbiAgICAgIC8vIFJlbW92ZSBJViBmb3Igc3Vic2VxdWVudCBibG9ja3NcbiAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKGtleXN0cmVhbSwgMCk7XG5cbiAgICAvLyBFbmNyeXB0XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkgKz0gMSkge1xuICAgICAgX3dvcmRzW29mZnNldCArIGldIF49IGtleXN0cmVhbVtpXTtcbiAgICB9XG4gIH1cbn07XG5PRkIuRGVjcnlwdG9yID0gT0ZCLkVuY3J5cHRvcjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/mode-ofb.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pad-ansix923.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-es/lib/pad-ansix923.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AnsiX923\": function() { return /* binding */ AnsiX923; }\n/* harmony export */ });\n/**\n * ANSI X.923 padding strategy.\n */\nconst AnsiX923 = {\n  pad(data, blockSize) {\n    const _data = data;\n\n    // Shortcuts\n    const dataSigBytes = _data.sigBytes;\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (dataSigBytes % blockSizeBytes);\n\n    // Compute last byte position\n    const lastBytePos = dataSigBytes + nPaddingBytes - 1;\n\n    // Pad\n    _data.clamp();\n    _data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);\n    _data.sigBytes += nPaddingBytes;\n  },\n\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGFkLWFuc2l4OTIzLmpzP2NiZjciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3BhZC1hbnNpeDkyMy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQU5TSSBYLjkyMyBwYWRkaW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgQW5zaVg5MjMgPSB7XG4gIHBhZChkYXRhLCBibG9ja1NpemUpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBkYXRhU2lnQnl0ZXMgPSBfZGF0YS5zaWdCeXRlcztcbiAgICBjb25zdCBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cbiAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG4gICAgY29uc3QgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gKGRhdGFTaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzKTtcblxuICAgIC8vIENvbXB1dGUgbGFzdCBieXRlIHBvc2l0aW9uXG4gICAgY29uc3QgbGFzdEJ5dGVQb3MgPSBkYXRhU2lnQnl0ZXMgKyBuUGFkZGluZ0J5dGVzIC0gMTtcblxuICAgIC8vIFBhZFxuICAgIF9kYXRhLmNsYW1wKCk7XG4gICAgX2RhdGEud29yZHNbbGFzdEJ5dGVQb3MgPj4+IDJdIHw9IG5QYWRkaW5nQnl0ZXMgPDwgKDI0IC0gKGxhc3RCeXRlUG9zICUgNCkgKiA4KTtcbiAgICBfZGF0YS5zaWdCeXRlcyArPSBuUGFkZGluZ0J5dGVzO1xuICB9LFxuXG4gIHVucGFkKGRhdGEpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcbiAgICBjb25zdCBuUGFkZGluZ0J5dGVzID0gX2RhdGEud29yZHNbKF9kYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuICAgIC8vIFJlbW92ZSBwYWRkaW5nXG4gICAgX2RhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcbiAgfSxcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pad-ansix923.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pad-iso10126.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-es/lib/pad-iso10126.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Iso10126\": function() { return /* binding */ Iso10126; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\n/**\n * ISO 10126 padding strategy.\n */\nconst Iso10126 = {\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);\n\n    // Pad\n    data\n      .concat(_core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.random(nPaddingBytes - 1))\n      .concat(_core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create([nPaddingBytes << 24], 1));\n  },\n\n  unpad(data) {\n    const _data = data;\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGFkLWlzbzEwMTI2LmpzP2ZjMGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsc0RBQWdCO0FBQzlCLGNBQWMsc0RBQWdCO0FBQzlCLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3BhZC1pc28xMDEyNi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFdvcmRBcnJheSxcbn0gZnJvbSAnLi9jb3JlLmpzJztcblxuLyoqXG4gKiBJU08gMTAxMjYgcGFkZGluZyBzdHJhdGVneS5cbiAqL1xuZXhwb3J0IGNvbnN0IElzbzEwMTI2ID0ge1xuICBwYWQoZGF0YSwgYmxvY2tTaXplKSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cbiAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG4gICAgY29uc3QgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gKGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcyk7XG5cbiAgICAvLyBQYWRcbiAgICBkYXRhXG4gICAgICAuY29uY2F0KFdvcmRBcnJheS5yYW5kb20oblBhZGRpbmdCeXRlcyAtIDEpKVxuICAgICAgLmNvbmNhdChXb3JkQXJyYXkuY3JlYXRlKFtuUGFkZGluZ0J5dGVzIDw8IDI0XSwgMSkpO1xuICB9LFxuXG4gIHVucGFkKGRhdGEpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7XG4gICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG4gICAgY29uc3QgblBhZGRpbmdCeXRlcyA9IF9kYXRhLndvcmRzWyhfZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cbiAgICAvLyBSZW1vdmUgcGFkZGluZ1xuICAgIF9kYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG4gIH0sXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pad-iso10126.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pad-iso97971.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-es/lib/pad-iso97971.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Iso97971\": function() { return /* binding */ Iso97971; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _pad_zeropadding_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pad-zeropadding.js */ \"./node_modules/crypto-es/lib/pad-zeropadding.js\");\n\n\n\n/**\n * ISO/IEC 9797-1 Padding Method 2.\n */\nconst Iso97971 = {\n  pad(data, blockSize) {\n    // Add 0x80 byte\n    data.concat(_core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create([0x80000000], 1));\n\n    // Zero pad the rest\n    _pad_zeropadding_js__WEBPACK_IMPORTED_MODULE_1__.ZeroPadding.pad(data, blockSize);\n  },\n\n  unpad(data) {\n    const _data = data;\n\n    // Remove zero padding\n    _pad_zeropadding_js__WEBPACK_IMPORTED_MODULE_1__.ZeroPadding.unpad(_data);\n\n    // Remove one more byte -- the 0x80 byte\n    _data.sigBytes -= 1;\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGFkLWlzbzk3OTcxLmpzPzdmMjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRW1CO0FBR1c7O0FBRTlCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdCQUFnQixzREFBZ0I7O0FBRWhDO0FBQ0EsSUFBSSxnRUFBZTtBQUNuQixHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQSxJQUFJLGtFQUFpQjs7QUFFckI7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3BhZC1pc285Nzk3MS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFdvcmRBcnJheSxcbn0gZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCB7XG4gIFplcm9QYWRkaW5nLFxufSBmcm9tICcuL3BhZC16ZXJvcGFkZGluZy5qcyc7XG5cbi8qKlxuICogSVNPL0lFQyA5Nzk3LTEgUGFkZGluZyBNZXRob2QgMi5cbiAqL1xuZXhwb3J0IGNvbnN0IElzbzk3OTcxID0ge1xuICBwYWQoZGF0YSwgYmxvY2tTaXplKSB7XG4gICAgLy8gQWRkIDB4ODAgYnl0ZVxuICAgIGRhdGEuY29uY2F0KFdvcmRBcnJheS5jcmVhdGUoWzB4ODAwMDAwMDBdLCAxKSk7XG5cbiAgICAvLyBaZXJvIHBhZCB0aGUgcmVzdFxuICAgIFplcm9QYWRkaW5nLnBhZChkYXRhLCBibG9ja1NpemUpO1xuICB9LFxuXG4gIHVucGFkKGRhdGEpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBSZW1vdmUgemVybyBwYWRkaW5nXG4gICAgWmVyb1BhZGRpbmcudW5wYWQoX2RhdGEpO1xuXG4gICAgLy8gUmVtb3ZlIG9uZSBtb3JlIGJ5dGUgLS0gdGhlIDB4ODAgYnl0ZVxuICAgIF9kYXRhLnNpZ0J5dGVzIC09IDE7XG4gIH0sXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pad-iso97971.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pad-nopadding.js":
/*!*****************************************************!*\
  !*** ./node_modules/crypto-es/lib/pad-nopadding.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"NoPadding\": function() { return /* binding */ NoPadding; }\n/* harmony export */ });\n/**\n * A noop padding strategy.\n */\nconst NoPadding = {\n  pad() {\n  },\n\n  unpad() {\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGFkLW5vcGFkZGluZy5qcz8xMjY3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3BhZC1ub3BhZGRpbmcuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgbm9vcCBwYWRkaW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgTm9QYWRkaW5nID0ge1xuICBwYWQoKSB7XG4gIH0sXG5cbiAgdW5wYWQoKSB7XG4gIH0sXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pad-nopadding.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pad-zeropadding.js":
/*!*******************************************************!*\
  !*** ./node_modules/crypto-es/lib/pad-zeropadding.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ZeroPadding\": function() { return /* binding */ ZeroPadding; }\n/* harmony export */ });\n/**\n * Zero padding strategy.\n */\nconst ZeroPadding = {\n  pad(data, blockSize) {\n    const _data = data;\n\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Pad\n    _data.clamp();\n    _data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);\n  },\n\n  unpad(data) {\n    const _data = data;\n\n    // Shortcut\n    const dataWords = _data.words;\n\n    // Unpad\n    for (let i = _data.sigBytes - 1; i >= 0; i -= 1) {\n      if (((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {\n        _data.sigBytes = i + 1;\n        break;\n      }\n    }\n  },\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGFkLXplcm9wYWRkaW5nLmpzPzM2MTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3BhZC16ZXJvcGFkZGluZy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogWmVybyBwYWRkaW5nIHN0cmF0ZWd5LlxuICovXG5leHBvcnQgY29uc3QgWmVyb1BhZGRpbmcgPSB7XG4gIHBhZChkYXRhLCBibG9ja1NpemUpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuICAgIC8vIFBhZFxuICAgIF9kYXRhLmNsYW1wKCk7XG4gICAgX2RhdGEuc2lnQnl0ZXMgKz0gYmxvY2tTaXplQnl0ZXMgLSAoKGRhdGEuc2lnQnl0ZXMgJSBibG9ja1NpemVCeXRlcykgfHwgYmxvY2tTaXplQnl0ZXMpO1xuICB9LFxuXG4gIHVucGFkKGRhdGEpIHtcbiAgICBjb25zdCBfZGF0YSA9IGRhdGE7XG5cbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IGRhdGFXb3JkcyA9IF9kYXRhLndvcmRzO1xuXG4gICAgLy8gVW5wYWRcbiAgICBmb3IgKGxldCBpID0gX2RhdGEuc2lnQnl0ZXMgLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKCgoZGF0YVdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZikpIHtcbiAgICAgICAgX2RhdGEuc2lnQnl0ZXMgPSBpICsgMTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9LFxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pad-zeropadding.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/pbkdf2.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/pbkdf2.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"PBKDF2Algo\": function() { return /* binding */ PBKDF2Algo; },\n/* harmony export */   \"PBKDF2\": function() { return /* binding */ PBKDF2; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"./node_modules/crypto-es/lib/sha1.js\");\n/* harmony import */ var _hmac_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hmac.js */ \"./node_modules/crypto-es/lib/hmac.js\");\n\n\n\n\n/**\n * Password-Based Key Derivation Function 2 algorithm.\n */\nclass PBKDF2Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.PBKDF2.create();\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hasher to use. Default: SHA1\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      new _core_js__WEBPACK_IMPORTED_MODULE_0__.Base(),\n      {\n        keySize: 128 / 32,\n        hasher: _sha1_js__WEBPACK_IMPORTED_MODULE_1__.SHA1Algo,\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Computes the Password-Based Key Derivation Function 2.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    // Shortcut\n    const { cfg } = this;\n\n    // Init HMAC\n    const hmac = _hmac_js__WEBPACK_IMPORTED_MODULE_2__.HMAC.create(cfg.hasher, password);\n\n    // Initial values\n    const derivedKey = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create();\n    const blockIndex = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create([0x00000001]);\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const blockIndexWords = blockIndex.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      const block = hmac.update(salt).finalize(blockIndex);\n      hmac.reset();\n\n      // Shortcuts\n      const blockWords = block.words;\n      const blockWordsLength = blockWords.length;\n\n      // Iterations\n      let intermediate = block;\n      for (let i = 1; i < iterations; i += 1) {\n        intermediate = hmac.finalize(intermediate);\n        hmac.reset();\n\n        // Shortcut\n        const intermediateWords = intermediate.words;\n\n        // XOR intermediate with block\n        for (let j = 0; j < blockWordsLength; j += 1) {\n          blockWords[j] ^= intermediateWords[j];\n        }\n      }\n\n      derivedKey.concat(block);\n      blockIndexWords[0] += 1;\n    }\n    derivedKey.sigBytes = keySize * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Computes the Password-Based Key Derivation Function 2.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.PBKDF2(password, salt);\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\n *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\n */\nconst PBKDF2 = (password, salt, cfg) => PBKDF2Algo.create(cfg).compute(password, salt);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcGJrZGYyLmpzPzQ0MTIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFHbUI7QUFDa0I7QUFDSjs7QUFFakM7QUFDQTtBQUNBO0FBQ08seUJBQXlCLDBDQUFJO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9ELGtEQUFrRCwrQkFBK0I7QUFDakY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQSxVQUFVLDBDQUFJO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBUTtBQUN4QjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07O0FBRWpCO0FBQ0EsaUJBQWlCLGlEQUFXOztBQUU1QjtBQUNBLHVCQUF1QixzREFBZ0I7QUFDdkMsdUJBQXVCLHNEQUFnQjs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzQkFBc0I7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxhQUFhO0FBQy9ELGtEQUFrRCwrQkFBK0I7QUFDakY7QUFDTyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3Bia2RmMi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEJhc2UsXG4gIFdvcmRBcnJheSxcbn0gZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCB7IFNIQTFBbGdvIH0gZnJvbSAnLi9zaGExLmpzJztcbmltcG9ydCB7IEhNQUMgfSBmcm9tICcuL2htYWMuanMnO1xuXG4vKipcbiAqIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIgYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgUEJLREYyQWxnbyBleHRlbmRzIEJhc2Uge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgY29uc3Qga2RmID0gQ3J5cHRvSlMuYWxnby5QQktERjIuY3JlYXRlKCk7XG4gICAqICAgICBjb25zdCBrZGYgPSBDcnlwdG9KUy5hbGdvLlBCS0RGMi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xuICAgKiAgICAgY29uc3Qga2RmID0gQ3J5cHRvSlMuYWxnby5QQktERjIuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIHN1cGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGUga2V5IHNpemUgaW4gd29yZHMgdG8gZ2VuZXJhdGUuIERlZmF1bHQ6IDQgKDEyOCBiaXRzKVxuICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UuIERlZmF1bHQ6IFNIQTFcbiAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuICAgICAqL1xuICAgIHRoaXMuY2ZnID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIG5ldyBCYXNlKCksXG4gICAgICB7XG4gICAgICAgIGtleVNpemU6IDEyOCAvIDMyLFxuICAgICAgICBoYXNoZXI6IFNIQTFBbGdvLFxuICAgICAgICBpdGVyYXRpb25zOiAxLFxuICAgICAgfSxcbiAgICAgIGNmZyxcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBQYXNzd29yZC1CYXNlZCBLZXkgRGVyaXZhdGlvbiBGdW5jdGlvbiAyLlxuICAgKlxuICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cbiAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cbiAgICpcbiAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGVyaXZlZCBrZXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICBjb25zdCBrZXkgPSBrZGYuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG4gICAqL1xuICBjb21wdXRlKHBhc3N3b3JkLCBzYWx0KSB7XG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCB7IGNmZyB9ID0gdGhpcztcblxuICAgIC8vIEluaXQgSE1BQ1xuICAgIGNvbnN0IGhtYWMgPSBITUFDLmNyZWF0ZShjZmcuaGFzaGVyLCBwYXNzd29yZCk7XG5cbiAgICAvLyBJbml0aWFsIHZhbHVlc1xuICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBXb3JkQXJyYXkuY3JlYXRlKCk7XG4gICAgY29uc3QgYmxvY2tJbmRleCA9IFdvcmRBcnJheS5jcmVhdGUoWzB4MDAwMDAwMDFdKTtcblxuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGRlcml2ZWRLZXlXb3JkcyA9IGRlcml2ZWRLZXkud29yZHM7XG4gICAgY29uc3QgYmxvY2tJbmRleFdvcmRzID0gYmxvY2tJbmRleC53b3JkcztcbiAgICBjb25zdCB7IGtleVNpemUsIGl0ZXJhdGlvbnMgfSA9IGNmZztcblxuICAgIC8vIEdlbmVyYXRlIGtleVxuICAgIHdoaWxlIChkZXJpdmVkS2V5V29yZHMubGVuZ3RoIDwga2V5U2l6ZSkge1xuICAgICAgY29uc3QgYmxvY2sgPSBobWFjLnVwZGF0ZShzYWx0KS5maW5hbGl6ZShibG9ja0luZGV4KTtcbiAgICAgIGhtYWMucmVzZXQoKTtcblxuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICBjb25zdCBibG9ja1dvcmRzID0gYmxvY2sud29yZHM7XG4gICAgICBjb25zdCBibG9ja1dvcmRzTGVuZ3RoID0gYmxvY2tXb3Jkcy5sZW5ndGg7XG5cbiAgICAgIC8vIEl0ZXJhdGlvbnNcbiAgICAgIGxldCBpbnRlcm1lZGlhdGUgPSBibG9jaztcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaXRlcmF0aW9uczsgaSArPSAxKSB7XG4gICAgICAgIGludGVybWVkaWF0ZSA9IGhtYWMuZmluYWxpemUoaW50ZXJtZWRpYXRlKTtcbiAgICAgICAgaG1hYy5yZXNldCgpO1xuXG4gICAgICAgIC8vIFNob3J0Y3V0XG4gICAgICAgIGNvbnN0IGludGVybWVkaWF0ZVdvcmRzID0gaW50ZXJtZWRpYXRlLndvcmRzO1xuXG4gICAgICAgIC8vIFhPUiBpbnRlcm1lZGlhdGUgd2l0aCBibG9ja1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJsb2NrV29yZHNMZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIGJsb2NrV29yZHNbal0gXj0gaW50ZXJtZWRpYXRlV29yZHNbal07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGVyaXZlZEtleS5jb25jYXQoYmxvY2spO1xuICAgICAgYmxvY2tJbmRleFdvcmRzWzBdICs9IDE7XG4gICAgfVxuICAgIGRlcml2ZWRLZXkuc2lnQnl0ZXMgPSBrZXlTaXplICogNDtcblxuICAgIHJldHVybiBkZXJpdmVkS2V5O1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIFBhc3N3b3JkLUJhc2VkIEtleSBEZXJpdmF0aW9uIEZ1bmN0aW9uIDIuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuUEJLREYyKHBhc3N3b3JkLCBzYWx0KTtcbiAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuUEJLREYyKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XG4gKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLlBCS0RGMihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuICovXG5leHBvcnQgY29uc3QgUEJLREYyID0gKHBhc3N3b3JkLCBzYWx0LCBjZmcpID0+IFBCS0RGMkFsZ28uY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/pbkdf2.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/rabbit-legacy.js":
/*!*****************************************************!*\
  !*** ./node_modules/crypto-es/lib/rabbit-legacy.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RabbitLegacyAlgo\": function() { return /* binding */ RabbitLegacyAlgo; },\n/* harmony export */   \"RabbitLegacy\": function() { return /* binding */ RabbitLegacy; }\n/* harmony export */ });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\n// Reusable objects\nconst S = [];\nconst C_ = [];\nconst G = [];\n\nfunction nextState() {\n  // Shortcuts\n  const X = this._X;\n  const C = this._C;\n\n  // Save old counter values\n  for (let i = 0; i < 8; i += 1) {\n    C_[i] = C[i];\n  }\n\n  // Calculate new counter values\n  C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n  C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n  C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n  C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n  C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n  C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n  C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n  C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n  this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n  // Calculate the g-values\n  for (let i = 0; i < 8; i += 1) {\n    const gx = X[i] + C[i];\n\n    // Construct high and low argument for squaring\n    const ga = gx & 0xffff;\n    const gb = gx >>> 16;\n\n    // Calculate high and low result of squaring\n    const gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n    const gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n    // High XOR low\n    G[i] = gh ^ gl;\n  }\n\n  // Calculate new state values\n  X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n  X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0;\n  X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n  X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0;\n  X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n  X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0;\n  X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n  X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0;\n}\n\n/**\n * Rabbit stream cipher algorithm.\n *\n * This is a legacy version that neglected to convert the key to little-endian.\n * This error doesn't affect the cipher's security,\n * but it does affect its compatibility with other implementations.\n */\nclass RabbitLegacyAlgo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.StreamCipher {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 128 / 32;\n    this.ivSize = 64 / 32;\n  }\n\n  _doReset() {\n    // Shortcuts\n    const K = this._key.words;\n    const { iv } = this.cfg;\n\n    // Generate initial state values\n    this._X = [\n      K[0], (K[3] << 16) | (K[2] >>> 16),\n      K[1], (K[0] << 16) | (K[3] >>> 16),\n      K[2], (K[1] << 16) | (K[0] >>> 16),\n      K[3], (K[2] << 16) | (K[1] >>> 16),\n    ];\n    const X = this._X;\n\n    // Generate initial counter values\n    this._C = [\n      (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n      (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n      (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n      (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff),\n    ];\n    const C = this._C;\n\n    // Carry bit\n    this._b = 0;\n\n    // Iterate the system four times\n    for (let i = 0; i < 4; i += 1) {\n      nextState.call(this);\n    }\n\n    // Modify the counters\n    for (let i = 0; i < 8; i += 1) {\n      C[i] ^= X[(i + 4) & 7];\n    }\n\n    // IV setup\n    if (iv) {\n      // Shortcuts\n      const IV = iv.words;\n      const IV_0 = IV[0];\n      const IV_1 = IV[1];\n\n      // Generate four subvectors\n      const i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff)\n        | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n      const i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff)\n        | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n      const i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n      const i3 = (i2 << 16) | (i0 & 0x0000ffff);\n\n      // Modify counter values\n      C[0] ^= i0;\n      C[1] ^= i1;\n      C[2] ^= i2;\n      C[3] ^= i3;\n      C[4] ^= i0;\n      C[5] ^= i1;\n      C[6] ^= i2;\n      C[7] ^= i3;\n\n      // Iterate the system four times\n      for (let i = 0; i < 4; i += 1) {\n        nextState.call(this);\n      }\n    }\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Shortcut\n    const X = this._X;\n\n    // Iterate the system\n    nextState.call(this);\n\n    // Generate four keystream words\n    S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n    S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n    S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n    S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n    for (let i = 0; i < 4; i += 1) {\n      // Swap endian\n      S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 0x00ff00ff)\n        | (((S[i] << 24) | (S[i] >>> 8)) & 0xff00ff00);\n\n      // Encrypt\n      _M[offset + i] ^= S[i];\n    }\n  }\n}\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);\n */\nconst RabbitLegacy = _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.StreamCipher._createHelper(RabbitLegacyAlgo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcmFiYml0LWxlZ2FjeS5qcz8wZjQzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUUwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IseURBQVk7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsdUVBQTBCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcmFiYml0LWxlZ2FjeS5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFN0cmVhbUNpcGhlcixcbn0gZnJvbSAnLi9jaXBoZXItY29yZS5qcyc7XG5cbi8vIFJldXNhYmxlIG9iamVjdHNcbmNvbnN0IFMgPSBbXTtcbmNvbnN0IENfID0gW107XG5jb25zdCBHID0gW107XG5cbmZ1bmN0aW9uIG5leHRTdGF0ZSgpIHtcbiAgLy8gU2hvcnRjdXRzXG4gIGNvbnN0IFggPSB0aGlzLl9YO1xuICBjb25zdCBDID0gdGhpcy5fQztcblxuICAvLyBTYXZlIG9sZCBjb3VudGVyIHZhbHVlc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgIENfW2ldID0gQ1tpXTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBuZXcgY291bnRlciB2YWx1ZXNcbiAgQ1swXSA9IChDWzBdICsgMHg0ZDM0ZDM0ZCArIHRoaXMuX2IpIHwgMDtcbiAgQ1sxXSA9IChDWzFdICsgMHhkMzRkMzRkMyArICgoQ1swXSA+Pj4gMCkgPCAoQ19bMF0gPj4+IDApID8gMSA6IDApKSB8IDA7XG4gIENbMl0gPSAoQ1syXSArIDB4MzRkMzRkMzQgKyAoKENbMV0gPj4+IDApIDwgKENfWzFdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICBDWzNdID0gKENbM10gKyAweDRkMzRkMzRkICsgKChDWzJdID4+PiAwKSA8IChDX1syXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcbiAgQ1s0XSA9IChDWzRdICsgMHhkMzRkMzRkMyArICgoQ1szXSA+Pj4gMCkgPCAoQ19bM10gPj4+IDApID8gMSA6IDApKSB8IDA7XG4gIENbNV0gPSAoQ1s1XSArIDB4MzRkMzRkMzQgKyAoKENbNF0gPj4+IDApIDwgKENfWzRdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICBDWzZdID0gKENbNl0gKyAweDRkMzRkMzRkICsgKChDWzVdID4+PiAwKSA8IChDX1s1XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcbiAgQ1s3XSA9IChDWzddICsgMHhkMzRkMzRkMyArICgoQ1s2XSA+Pj4gMCkgPCAoQ19bNl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG4gIHRoaXMuX2IgPSAoQ1s3XSA+Pj4gMCkgPCAoQ19bN10gPj4+IDApID8gMSA6IDA7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBnLXZhbHVlc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGd4ID0gWFtpXSArIENbaV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgaGlnaCBhbmQgbG93IGFyZ3VtZW50IGZvciBzcXVhcmluZ1xuICAgIGNvbnN0IGdhID0gZ3ggJiAweGZmZmY7XG4gICAgY29uc3QgZ2IgPSBneCA+Pj4gMTY7XG5cbiAgICAvLyBDYWxjdWxhdGUgaGlnaCBhbmQgbG93IHJlc3VsdCBvZiBzcXVhcmluZ1xuICAgIGNvbnN0IGdoID0gKCgoKGdhICogZ2EpID4+PiAxNykgKyBnYSAqIGdiKSA+Pj4gMTUpICsgZ2IgKiBnYjtcbiAgICBjb25zdCBnbCA9ICgoKGd4ICYgMHhmZmZmMDAwMCkgKiBneCkgfCAwKSArICgoKGd4ICYgMHgwMDAwZmZmZikgKiBneCkgfCAwKTtcblxuICAgIC8vIEhpZ2ggWE9SIGxvd1xuICAgIEdbaV0gPSBnaCBeIGdsO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIG5ldyBzdGF0ZSB2YWx1ZXNcbiAgWFswXSA9IChHWzBdICsgKChHWzddIDw8IDE2KSB8IChHWzddID4+PiAxNikpICsgKChHWzZdIDw8IDE2KSB8IChHWzZdID4+PiAxNikpKSB8IDA7XG4gIFhbMV0gPSAoR1sxXSArICgoR1swXSA8PCA4KSB8IChHWzBdID4+PiAyNCkpICsgR1s3XSkgfCAwO1xuICBYWzJdID0gKEdbMl0gKyAoKEdbMV0gPDwgMTYpIHwgKEdbMV0gPj4+IDE2KSkgKyAoKEdbMF0gPDwgMTYpIHwgKEdbMF0gPj4+IDE2KSkpIHwgMDtcbiAgWFszXSA9IChHWzNdICsgKChHWzJdIDw8IDgpIHwgKEdbMl0gPj4+IDI0KSkgKyBHWzFdKSB8IDA7XG4gIFhbNF0gPSAoR1s0XSArICgoR1szXSA8PCAxNikgfCAoR1szXSA+Pj4gMTYpKSArICgoR1syXSA8PCAxNikgfCAoR1syXSA+Pj4gMTYpKSkgfCAwO1xuICBYWzVdID0gKEdbNV0gKyAoKEdbNF0gPDwgOCkgfCAoR1s0XSA+Pj4gMjQpKSArIEdbM10pIHwgMDtcbiAgWFs2XSA9IChHWzZdICsgKChHWzVdIDw8IDE2KSB8IChHWzVdID4+PiAxNikpICsgKChHWzRdIDw8IDE2KSB8IChHWzRdID4+PiAxNikpKSB8IDA7XG4gIFhbN10gPSAoR1s3XSArICgoR1s2XSA8PCA4KSB8IChHWzZdID4+PiAyNCkpICsgR1s1XSkgfCAwO1xufVxuXG4vKipcbiAqIFJhYmJpdCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobS5cbiAqXG4gKiBUaGlzIGlzIGEgbGVnYWN5IHZlcnNpb24gdGhhdCBuZWdsZWN0ZWQgdG8gY29udmVydCB0aGUga2V5IHRvIGxpdHRsZS1lbmRpYW4uXG4gKiBUaGlzIGVycm9yIGRvZXNuJ3QgYWZmZWN0IHRoZSBjaXBoZXIncyBzZWN1cml0eSxcbiAqIGJ1dCBpdCBkb2VzIGFmZmVjdCBpdHMgY29tcGF0aWJpbGl0eSB3aXRoIG90aGVyIGltcGxlbWVudGF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFJhYmJpdExlZ2FjeUFsZ28gZXh0ZW5kcyBTdHJlYW1DaXBoZXIge1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG5cbiAgICB0aGlzLmJsb2NrU2l6ZSA9IDEyOCAvIDMyO1xuICAgIHRoaXMuaXZTaXplID0gNjQgLyAzMjtcbiAgfVxuXG4gIF9kb1Jlc2V0KCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IEsgPSB0aGlzLl9rZXkud29yZHM7XG4gICAgY29uc3QgeyBpdiB9ID0gdGhpcy5jZmc7XG5cbiAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIHN0YXRlIHZhbHVlc1xuICAgIHRoaXMuX1ggPSBbXG4gICAgICBLWzBdLCAoS1szXSA8PCAxNikgfCAoS1syXSA+Pj4gMTYpLFxuICAgICAgS1sxXSwgKEtbMF0gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSxcbiAgICAgIEtbMl0sIChLWzFdIDw8IDE2KSB8IChLWzBdID4+PiAxNiksXG4gICAgICBLWzNdLCAoS1syXSA8PCAxNikgfCAoS1sxXSA+Pj4gMTYpLFxuICAgIF07XG4gICAgY29uc3QgWCA9IHRoaXMuX1g7XG5cbiAgICAvLyBHZW5lcmF0ZSBpbml0aWFsIGNvdW50ZXIgdmFsdWVzXG4gICAgdGhpcy5fQyA9IFtcbiAgICAgIChLWzJdIDw8IDE2KSB8IChLWzJdID4+PiAxNiksIChLWzBdICYgMHhmZmZmMDAwMCkgfCAoS1sxXSAmIDB4MDAwMGZmZmYpLFxuICAgICAgKEtbM10gPDwgMTYpIHwgKEtbM10gPj4+IDE2KSwgKEtbMV0gJiAweGZmZmYwMDAwKSB8IChLWzJdICYgMHgwMDAwZmZmZiksXG4gICAgICAoS1swXSA8PCAxNikgfCAoS1swXSA+Pj4gMTYpLCAoS1syXSAmIDB4ZmZmZjAwMDApIHwgKEtbM10gJiAweDAwMDBmZmZmKSxcbiAgICAgIChLWzFdIDw8IDE2KSB8IChLWzFdID4+PiAxNiksIChLWzNdICYgMHhmZmZmMDAwMCkgfCAoS1swXSAmIDB4MDAwMGZmZmYpLFxuICAgIF07XG4gICAgY29uc3QgQyA9IHRoaXMuX0M7XG5cbiAgICAvLyBDYXJyeSBiaXRcbiAgICB0aGlzLl9iID0gMDtcblxuICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8vIE1vZGlmeSB0aGUgY291bnRlcnNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgICAgQ1tpXSBePSBYWyhpICsgNCkgJiA3XTtcbiAgICB9XG5cbiAgICAvLyBJViBzZXR1cFxuICAgIGlmIChpdikge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICBjb25zdCBJViA9IGl2LndvcmRzO1xuICAgICAgY29uc3QgSVZfMCA9IElWWzBdO1xuICAgICAgY29uc3QgSVZfMSA9IElWWzFdO1xuXG4gICAgICAvLyBHZW5lcmF0ZSBmb3VyIHN1YnZlY3RvcnNcbiAgICAgIGNvbnN0IGkwID0gKCgoSVZfMCA8PCA4KSB8IChJVl8wID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChJVl8wIDw8IDI0KSB8IChJVl8wID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcbiAgICAgIGNvbnN0IGkyID0gKCgoSVZfMSA8PCA4KSB8IChJVl8xID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChJVl8xIDw8IDI0KSB8IChJVl8xID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcbiAgICAgIGNvbnN0IGkxID0gKGkwID4+PiAxNikgfCAoaTIgJiAweGZmZmYwMDAwKTtcbiAgICAgIGNvbnN0IGkzID0gKGkyIDw8IDE2KSB8IChpMCAmIDB4MDAwMGZmZmYpO1xuXG4gICAgICAvLyBNb2RpZnkgY291bnRlciB2YWx1ZXNcbiAgICAgIENbMF0gXj0gaTA7XG4gICAgICBDWzFdIF49IGkxO1xuICAgICAgQ1syXSBePSBpMjtcbiAgICAgIENbM10gXj0gaTM7XG4gICAgICBDWzRdIF49IGkwO1xuICAgICAgQ1s1XSBePSBpMTtcbiAgICAgIENbNl0gXj0gaTI7XG4gICAgICBDWzddIF49IGkzO1xuXG4gICAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW0gZm91ciB0aW1lc1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2RvUHJvY2Vzc0Jsb2NrKE0sIG9mZnNldCkge1xuICAgIGNvbnN0IF9NID0gTTtcblxuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgWCA9IHRoaXMuX1g7XG5cbiAgICAvLyBJdGVyYXRlIHRoZSBzeXN0ZW1cbiAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcblxuICAgIC8vIEdlbmVyYXRlIGZvdXIga2V5c3RyZWFtIHdvcmRzXG4gICAgU1swXSA9IFhbMF0gXiAoWFs1XSA+Pj4gMTYpIF4gKFhbM10gPDwgMTYpO1xuICAgIFNbMV0gPSBYWzJdIF4gKFhbN10gPj4+IDE2KSBeIChYWzVdIDw8IDE2KTtcbiAgICBTWzJdID0gWFs0XSBeIChYWzFdID4+PiAxNikgXiAoWFs3XSA8PCAxNik7XG4gICAgU1szXSA9IFhbNl0gXiAoWFszXSA+Pj4gMTYpIF4gKFhbMV0gPDwgMTYpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgIC8vIFN3YXAgZW5kaWFuXG4gICAgICBTW2ldID0gKCgoU1tpXSA8PCA4KSB8IChTW2ldID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChTW2ldIDw8IDI0KSB8IChTW2ldID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcblxuICAgICAgLy8gRW5jcnlwdFxuICAgICAgX01bb2Zmc2V0ICsgaV0gXj0gU1tpXTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbnMgdG8gdGhlIGNpcGhlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGNpcGhlcnRleHQgPSBDcnlwdG9KUy5SYWJiaXRMZWdhY3kuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG4gKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SYWJiaXRMZWdhY3kuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG4gKi9cbmV4cG9ydCBjb25zdCBSYWJiaXRMZWdhY3kgPSBTdHJlYW1DaXBoZXIuX2NyZWF0ZUhlbHBlcihSYWJiaXRMZWdhY3lBbGdvKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/rabbit-legacy.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/rabbit.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/rabbit.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RabbitAlgo\": function() { return /* binding */ RabbitAlgo; },\n/* harmony export */   \"Rabbit\": function() { return /* binding */ Rabbit; }\n/* harmony export */ });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\n// Reusable objects\nconst S = [];\nconst C_ = [];\nconst G = [];\n\nfunction nextState() {\n  // Shortcuts\n  const X = this._X;\n  const C = this._C;\n\n  // Save old counter values\n  for (let i = 0; i < 8; i += 1) {\n    C_[i] = C[i];\n  }\n\n  // Calculate new counter values\n  C[0] = (C[0] + 0x4d34d34d + this._b) | 0;\n  C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;\n  C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;\n  C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;\n  C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;\n  C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;\n  C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;\n  C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;\n  this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;\n\n  // Calculate the g-values\n  for (let i = 0; i < 8; i += 1) {\n    const gx = X[i] + C[i];\n\n    // Construct high and low argument for squaring\n    const ga = gx & 0xffff;\n    const gb = gx >>> 16;\n\n    // Calculate high and low result of squaring\n    const gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;\n    const gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);\n\n    // High XOR low\n    G[i] = gh ^ gl;\n  }\n\n  // Calculate new state values\n  X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;\n  X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0;\n  X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;\n  X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0;\n  X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;\n  X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0;\n  X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;\n  X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0;\n}\n\n/**\n * Rabbit stream cipher algorithm\n */\nclass RabbitAlgo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.StreamCipher {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 128 / 32;\n    this.ivSize = 64 / 32;\n  }\n\n  _doReset() {\n    // Shortcuts\n    const K = this._key.words;\n    const { iv } = this.cfg;\n\n    // Swap endian\n    for (let i = 0; i < 4; i += 1) {\n      K[i] = (((K[i] << 8) | (K[i] >>> 24)) & 0x00ff00ff)\n        | (((K[i] << 24) | (K[i] >>> 8)) & 0xff00ff00);\n    }\n\n    // Generate initial state values\n    this._X = [\n      K[0], (K[3] << 16) | (K[2] >>> 16),\n      K[1], (K[0] << 16) | (K[3] >>> 16),\n      K[2], (K[1] << 16) | (K[0] >>> 16),\n      K[3], (K[2] << 16) | (K[1] >>> 16),\n    ];\n    const X = this._X;\n\n    // Generate initial counter values\n    this._C = [\n      (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),\n      (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),\n      (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),\n      (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff),\n    ];\n    const C = this._C;\n\n    // Carry bit\n    this._b = 0;\n\n    // Iterate the system four times\n    for (let i = 0; i < 4; i += 1) {\n      nextState.call(this);\n    }\n\n    // Modify the counters\n    for (let i = 0; i < 8; i += 1) {\n      C[i] ^= X[(i + 4) & 7];\n    }\n\n    // IV setup\n    if (iv) {\n      // Shortcuts\n      const IV = iv.words;\n      const IV_0 = IV[0];\n      const IV_1 = IV[1];\n\n      // Generate four subvectors\n      const i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff)\n        | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);\n      const i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff)\n        | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);\n      const i1 = (i0 >>> 16) | (i2 & 0xffff0000);\n      const i3 = (i2 << 16) | (i0 & 0x0000ffff);\n\n      // Modify counter values\n      C[0] ^= i0;\n      C[1] ^= i1;\n      C[2] ^= i2;\n      C[3] ^= i3;\n      C[4] ^= i0;\n      C[5] ^= i1;\n      C[6] ^= i2;\n      C[7] ^= i3;\n\n      // Iterate the system four times\n      for (let i = 0; i < 4; i += 1) {\n        nextState.call(this);\n      }\n    }\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Shortcut\n    const X = this._X;\n\n    // Iterate the system\n    nextState.call(this);\n\n    // Generate four keystream words\n    S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);\n    S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);\n    S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);\n    S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);\n\n    for (let i = 0; i < 4; i += 1) {\n      // Swap endian\n      S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 0x00ff00ff)\n        | (((S[i] << 24) | (S[i] >>> 8)) & 0xff00ff00);\n\n      // Encrypt\n      _M[offset + i] ^= S[i];\n    }\n  }\n}\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);\n */\nconst Rabbit = _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.StreamCipher._createHelper(RabbitAlgo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcmFiYml0LmpzP2ZlNGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBRTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsT0FBTztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTyx5QkFBeUIseURBQVk7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxLQUFLOztBQUVoQjtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxlQUFlLHVFQUEwQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3JhYmJpdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFN0cmVhbUNpcGhlcixcbn0gZnJvbSAnLi9jaXBoZXItY29yZS5qcyc7XG5cbi8vIFJldXNhYmxlIG9iamVjdHNcbmNvbnN0IFMgPSBbXTtcbmNvbnN0IENfID0gW107XG5jb25zdCBHID0gW107XG5cbmZ1bmN0aW9uIG5leHRTdGF0ZSgpIHtcbiAgLy8gU2hvcnRjdXRzXG4gIGNvbnN0IFggPSB0aGlzLl9YO1xuICBjb25zdCBDID0gdGhpcy5fQztcblxuICAvLyBTYXZlIG9sZCBjb3VudGVyIHZhbHVlc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgIENfW2ldID0gQ1tpXTtcbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBuZXcgY291bnRlciB2YWx1ZXNcbiAgQ1swXSA9IChDWzBdICsgMHg0ZDM0ZDM0ZCArIHRoaXMuX2IpIHwgMDtcbiAgQ1sxXSA9IChDWzFdICsgMHhkMzRkMzRkMyArICgoQ1swXSA+Pj4gMCkgPCAoQ19bMF0gPj4+IDApID8gMSA6IDApKSB8IDA7XG4gIENbMl0gPSAoQ1syXSArIDB4MzRkMzRkMzQgKyAoKENbMV0gPj4+IDApIDwgKENfWzFdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICBDWzNdID0gKENbM10gKyAweDRkMzRkMzRkICsgKChDWzJdID4+PiAwKSA8IChDX1syXSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcbiAgQ1s0XSA9IChDWzRdICsgMHhkMzRkMzRkMyArICgoQ1szXSA+Pj4gMCkgPCAoQ19bM10gPj4+IDApID8gMSA6IDApKSB8IDA7XG4gIENbNV0gPSAoQ1s1XSArIDB4MzRkMzRkMzQgKyAoKENbNF0gPj4+IDApIDwgKENfWzRdID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICBDWzZdID0gKENbNl0gKyAweDRkMzRkMzRkICsgKChDWzVdID4+PiAwKSA8IChDX1s1XSA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcbiAgQ1s3XSA9IChDWzddICsgMHhkMzRkMzRkMyArICgoQ1s2XSA+Pj4gMCkgPCAoQ19bNl0gPj4+IDApID8gMSA6IDApKSB8IDA7XG4gIHRoaXMuX2IgPSAoQ1s3XSA+Pj4gMCkgPCAoQ19bN10gPj4+IDApID8gMSA6IDA7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSBnLXZhbHVlc1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkgKz0gMSkge1xuICAgIGNvbnN0IGd4ID0gWFtpXSArIENbaV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgaGlnaCBhbmQgbG93IGFyZ3VtZW50IGZvciBzcXVhcmluZ1xuICAgIGNvbnN0IGdhID0gZ3ggJiAweGZmZmY7XG4gICAgY29uc3QgZ2IgPSBneCA+Pj4gMTY7XG5cbiAgICAvLyBDYWxjdWxhdGUgaGlnaCBhbmQgbG93IHJlc3VsdCBvZiBzcXVhcmluZ1xuICAgIGNvbnN0IGdoID0gKCgoKGdhICogZ2EpID4+PiAxNykgKyBnYSAqIGdiKSA+Pj4gMTUpICsgZ2IgKiBnYjtcbiAgICBjb25zdCBnbCA9ICgoKGd4ICYgMHhmZmZmMDAwMCkgKiBneCkgfCAwKSArICgoKGd4ICYgMHgwMDAwZmZmZikgKiBneCkgfCAwKTtcblxuICAgIC8vIEhpZ2ggWE9SIGxvd1xuICAgIEdbaV0gPSBnaCBeIGdsO1xuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIG5ldyBzdGF0ZSB2YWx1ZXNcbiAgWFswXSA9IChHWzBdICsgKChHWzddIDw8IDE2KSB8IChHWzddID4+PiAxNikpICsgKChHWzZdIDw8IDE2KSB8IChHWzZdID4+PiAxNikpKSB8IDA7XG4gIFhbMV0gPSAoR1sxXSArICgoR1swXSA8PCA4KSB8IChHWzBdID4+PiAyNCkpICsgR1s3XSkgfCAwO1xuICBYWzJdID0gKEdbMl0gKyAoKEdbMV0gPDwgMTYpIHwgKEdbMV0gPj4+IDE2KSkgKyAoKEdbMF0gPDwgMTYpIHwgKEdbMF0gPj4+IDE2KSkpIHwgMDtcbiAgWFszXSA9IChHWzNdICsgKChHWzJdIDw8IDgpIHwgKEdbMl0gPj4+IDI0KSkgKyBHWzFdKSB8IDA7XG4gIFhbNF0gPSAoR1s0XSArICgoR1szXSA8PCAxNikgfCAoR1szXSA+Pj4gMTYpKSArICgoR1syXSA8PCAxNikgfCAoR1syXSA+Pj4gMTYpKSkgfCAwO1xuICBYWzVdID0gKEdbNV0gKyAoKEdbNF0gPDwgOCkgfCAoR1s0XSA+Pj4gMjQpKSArIEdbM10pIHwgMDtcbiAgWFs2XSA9IChHWzZdICsgKChHWzVdIDw8IDE2KSB8IChHWzVdID4+PiAxNikpICsgKChHWzRdIDw8IDE2KSB8IChHWzRdID4+PiAxNikpKSB8IDA7XG4gIFhbN10gPSAoR1s3XSArICgoR1s2XSA8PCA4KSB8IChHWzZdID4+PiAyNCkpICsgR1s1XSkgfCAwO1xufVxuXG4vKipcbiAqIFJhYmJpdCBzdHJlYW0gY2lwaGVyIGFsZ29yaXRobVxuICovXG5leHBvcnQgY2xhc3MgUmFiYml0QWxnbyBleHRlbmRzIFN0cmVhbUNpcGhlciB7XG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICBzdXBlciguLi5hcmdzKTtcblxuICAgIHRoaXMuYmxvY2tTaXplID0gMTI4IC8gMzI7XG4gICAgdGhpcy5pdlNpemUgPSA2NCAvIDMyO1xuICB9XG5cbiAgX2RvUmVzZXQoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgSyA9IHRoaXMuX2tleS53b3JkcztcbiAgICBjb25zdCB7IGl2IH0gPSB0aGlzLmNmZztcblxuICAgIC8vIFN3YXAgZW5kaWFuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgIEtbaV0gPSAoKChLW2ldIDw8IDgpIHwgKEtbaV0gPj4+IDI0KSkgJiAweDAwZmYwMGZmKVxuICAgICAgICB8ICgoKEtbaV0gPDwgMjQpIHwgKEtbaV0gPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuICAgIH1cblxuICAgIC8vIEdlbmVyYXRlIGluaXRpYWwgc3RhdGUgdmFsdWVzXG4gICAgdGhpcy5fWCA9IFtcbiAgICAgIEtbMF0sIChLWzNdIDw8IDE2KSB8IChLWzJdID4+PiAxNiksXG4gICAgICBLWzFdLCAoS1swXSA8PCAxNikgfCAoS1szXSA+Pj4gMTYpLFxuICAgICAgS1syXSwgKEtbMV0gPDwgMTYpIHwgKEtbMF0gPj4+IDE2KSxcbiAgICAgIEtbM10sIChLWzJdIDw8IDE2KSB8IChLWzFdID4+PiAxNiksXG4gICAgXTtcbiAgICBjb25zdCBYID0gdGhpcy5fWDtcblxuICAgIC8vIEdlbmVyYXRlIGluaXRpYWwgY291bnRlciB2YWx1ZXNcbiAgICB0aGlzLl9DID0gW1xuICAgICAgKEtbMl0gPDwgMTYpIHwgKEtbMl0gPj4+IDE2KSwgKEtbMF0gJiAweGZmZmYwMDAwKSB8IChLWzFdICYgMHgwMDAwZmZmZiksXG4gICAgICAoS1szXSA8PCAxNikgfCAoS1szXSA+Pj4gMTYpLCAoS1sxXSAmIDB4ZmZmZjAwMDApIHwgKEtbMl0gJiAweDAwMDBmZmZmKSxcbiAgICAgIChLWzBdIDw8IDE2KSB8IChLWzBdID4+PiAxNiksIChLWzJdICYgMHhmZmZmMDAwMCkgfCAoS1szXSAmIDB4MDAwMGZmZmYpLFxuICAgICAgKEtbMV0gPDwgMTYpIHwgKEtbMV0gPj4+IDE2KSwgKEtbM10gJiAweGZmZmYwMDAwKSB8IChLWzBdICYgMHgwMDAwZmZmZiksXG4gICAgXTtcbiAgICBjb25zdCBDID0gdGhpcy5fQztcblxuICAgIC8vIENhcnJ5IGJpdFxuICAgIHRoaXMuX2IgPSAwO1xuXG4gICAgLy8gSXRlcmF0ZSB0aGUgc3lzdGVtIGZvdXIgdGltZXNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgbmV4dFN0YXRlLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLy8gTW9kaWZ5IHRoZSBjb3VudGVyc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSArPSAxKSB7XG4gICAgICBDW2ldIF49IFhbKGkgKyA0KSAmIDddO1xuICAgIH1cblxuICAgIC8vIElWIHNldHVwXG4gICAgaWYgKGl2KSB7XG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIGNvbnN0IElWID0gaXYud29yZHM7XG4gICAgICBjb25zdCBJVl8wID0gSVZbMF07XG4gICAgICBjb25zdCBJVl8xID0gSVZbMV07XG5cbiAgICAgIC8vIEdlbmVyYXRlIGZvdXIgc3VidmVjdG9yc1xuICAgICAgY29uc3QgaTAgPSAoKChJVl8wIDw8IDgpIHwgKElWXzAgPj4+IDI0KSkgJiAweDAwZmYwMGZmKVxuICAgICAgICB8ICgoKElWXzAgPDwgMjQpIHwgKElWXzAgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuICAgICAgY29uc3QgaTIgPSAoKChJVl8xIDw8IDgpIHwgKElWXzEgPj4+IDI0KSkgJiAweDAwZmYwMGZmKVxuICAgICAgICB8ICgoKElWXzEgPDwgMjQpIHwgKElWXzEgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuICAgICAgY29uc3QgaTEgPSAoaTAgPj4+IDE2KSB8IChpMiAmIDB4ZmZmZjAwMDApO1xuICAgICAgY29uc3QgaTMgPSAoaTIgPDwgMTYpIHwgKGkwICYgMHgwMDAwZmZmZik7XG5cbiAgICAgIC8vIE1vZGlmeSBjb3VudGVyIHZhbHVlc1xuICAgICAgQ1swXSBePSBpMDtcbiAgICAgIENbMV0gXj0gaTE7XG4gICAgICBDWzJdIF49IGkyO1xuICAgICAgQ1szXSBePSBpMztcbiAgICAgIENbNF0gXj0gaTA7XG4gICAgICBDWzVdIF49IGkxO1xuICAgICAgQ1s2XSBePSBpMjtcbiAgICAgIENbN10gXj0gaTM7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbSBmb3VyIHRpbWVzXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgICBuZXh0U3RhdGUuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgX00gPSBNO1xuXG4gICAgLy8gU2hvcnRjdXRcbiAgICBjb25zdCBYID0gdGhpcy5fWDtcblxuICAgIC8vIEl0ZXJhdGUgdGhlIHN5c3RlbVxuICAgIG5leHRTdGF0ZS5jYWxsKHRoaXMpO1xuXG4gICAgLy8gR2VuZXJhdGUgZm91ciBrZXlzdHJlYW0gd29yZHNcbiAgICBTWzBdID0gWFswXSBeIChYWzVdID4+PiAxNikgXiAoWFszXSA8PCAxNik7XG4gICAgU1sxXSA9IFhbMl0gXiAoWFs3XSA+Pj4gMTYpIF4gKFhbNV0gPDwgMTYpO1xuICAgIFNbMl0gPSBYWzRdIF4gKFhbMV0gPj4+IDE2KSBeIChYWzddIDw8IDE2KTtcbiAgICBTWzNdID0gWFs2XSBeIChYWzNdID4+PiAxNikgXiAoWFsxXSA8PCAxNik7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkgKz0gMSkge1xuICAgICAgLy8gU3dhcCBlbmRpYW5cbiAgICAgIFNbaV0gPSAoKChTW2ldIDw8IDgpIHwgKFNbaV0gPj4+IDI0KSkgJiAweDAwZmYwMGZmKVxuICAgICAgICB8ICgoKFNbaV0gPDwgMjQpIHwgKFNbaV0gPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuXG4gICAgICAvLyBFbmNyeXB0XG4gICAgICBfTVtvZmZzZXQgKyBpXSBePSBTW2ldO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlJhYmJpdC5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcbiAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLlJhYmJpdC5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IFJhYmJpdCA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJhYmJpdEFsZ28pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/rabbit.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/rc4.js":
/*!*******************************************!*\
  !*** ./node_modules/crypto-es/lib/rc4.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RC4Algo\": function() { return /* binding */ RC4Algo; },\n/* harmony export */   \"RC4\": function() { return /* binding */ RC4; },\n/* harmony export */   \"RC4DropAlgo\": function() { return /* binding */ RC4DropAlgo; },\n/* harmony export */   \"RC4Drop\": function() { return /* binding */ RC4Drop; }\n/* harmony export */ });\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\nfunction generateKeystreamWord() {\n  // Shortcuts\n  const S = this._S;\n  let i = this._i;\n  let j = this._j;\n\n  // Generate keystream word\n  let keystreamWord = 0;\n  for (let n = 0; n < 4; n += 1) {\n    i = (i + 1) % 256;\n    j = (j + S[i]) % 256;\n\n    // Swap\n    const t = S[i];\n    S[i] = S[j];\n    S[j] = t;\n\n    keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);\n  }\n\n  // Update counters\n  this._i = i;\n  this._j = j;\n\n  return keystreamWord;\n}\n\n/**\n * RC4 stream cipher algorithm.\n */\nclass RC4Algo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.StreamCipher {\n  _doReset() {\n    // Shortcuts\n    const key = this._key;\n    const keyWords = key.words;\n    const keySigBytes = key.sigBytes;\n\n    // Init sbox\n    this._S = [];\n    const S = this._S;\n    for (let i = 0; i < 256; i += 1) {\n      S[i] = i;\n    }\n\n    // Key setup\n    for (let i = 0, j = 0; i < 256; i += 1) {\n      const keyByteIndex = i % keySigBytes;\n      const keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;\n\n      j = (j + S[i] + keyByte) % 256;\n\n      // Swap\n      const t = S[i];\n      S[i] = S[j];\n      S[j] = t;\n    }\n\n    // Counters\n    this._j = 0;\n    this._i = this._j;\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    _M[offset] ^= generateKeystreamWord.call(this);\n  }\n}\nRC4Algo.keySize = 256 / 32;\nRC4Algo.ivSize = 0;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);\n */\nconst RC4 = _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.StreamCipher._createHelper(RC4Algo);\n\n/**\n * Modified RC4 stream cipher algorithm.\n */\nclass RC4DropAlgo extends RC4Algo {\n  constructor(...args) {\n    super(...args);\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} drop The number of keystream words to drop. Default 192\n     */\n    Object.assign(this.cfg, { drop: 192 });\n  }\n\n  _doReset() {\n    super._doReset.call(this);\n\n    // Drop\n    for (let i = this.cfg.drop; i > 0; i -= 1) {\n      generateKeystreamWord.call(this);\n    }\n  }\n}\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);\n */\nconst RC4Drop = _cipher_core_js__WEBPACK_IMPORTED_MODULE_0__.StreamCipher._createHelper(RC4DropAlgo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcmM0LmpzPzYyODIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFFMEI7O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDTyxzQkFBc0IseURBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLFNBQVM7QUFDbkM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sWUFBWSx1RUFBMEI7O0FBRTdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBLDZCQUE2QixZQUFZO0FBQ3pDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsT0FBTztBQUN0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0JBQWdCLHVFQUEwQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3JjNC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFN0cmVhbUNpcGhlcixcbn0gZnJvbSAnLi9jaXBoZXItY29yZS5qcyc7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5c3RyZWFtV29yZCgpIHtcbiAgLy8gU2hvcnRjdXRzXG4gIGNvbnN0IFMgPSB0aGlzLl9TO1xuICBsZXQgaSA9IHRoaXMuX2k7XG4gIGxldCBqID0gdGhpcy5fajtcblxuICAvLyBHZW5lcmF0ZSBrZXlzdHJlYW0gd29yZFxuICBsZXQga2V5c3RyZWFtV29yZCA9IDA7XG4gIGZvciAobGV0IG4gPSAwOyBuIDwgNDsgbiArPSAxKSB7XG4gICAgaSA9IChpICsgMSkgJSAyNTY7XG4gICAgaiA9IChqICsgU1tpXSkgJSAyNTY7XG5cbiAgICAvLyBTd2FwXG4gICAgY29uc3QgdCA9IFNbaV07XG4gICAgU1tpXSA9IFNbal07XG4gICAgU1tqXSA9IHQ7XG5cbiAgICBrZXlzdHJlYW1Xb3JkIHw9IFNbKFNbaV0gKyBTW2pdKSAlIDI1Nl0gPDwgKDI0IC0gbiAqIDgpO1xuICB9XG5cbiAgLy8gVXBkYXRlIGNvdW50ZXJzXG4gIHRoaXMuX2kgPSBpO1xuICB0aGlzLl9qID0gajtcblxuICByZXR1cm4ga2V5c3RyZWFtV29yZDtcbn1cblxuLyoqXG4gKiBSQzQgc3RyZWFtIGNpcGhlciBhbGdvcml0aG0uXG4gKi9cbmV4cG9ydCBjbGFzcyBSQzRBbGdvIGV4dGVuZHMgU3RyZWFtQ2lwaGVyIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3Qga2V5ID0gdGhpcy5fa2V5O1xuICAgIGNvbnN0IGtleVdvcmRzID0ga2V5LndvcmRzO1xuICAgIGNvbnN0IGtleVNpZ0J5dGVzID0ga2V5LnNpZ0J5dGVzO1xuXG4gICAgLy8gSW5pdCBzYm94XG4gICAgdGhpcy5fUyA9IFtdO1xuICAgIGNvbnN0IFMgPSB0aGlzLl9TO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpICs9IDEpIHtcbiAgICAgIFNbaV0gPSBpO1xuICAgIH1cblxuICAgIC8vIEtleSBzZXR1cFxuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IDI1NjsgaSArPSAxKSB7XG4gICAgICBjb25zdCBrZXlCeXRlSW5kZXggPSBpICUga2V5U2lnQnl0ZXM7XG4gICAgICBjb25zdCBrZXlCeXRlID0gKGtleVdvcmRzW2tleUJ5dGVJbmRleCA+Pj4gMl0gPj4+ICgyNCAtIChrZXlCeXRlSW5kZXggJSA0KSAqIDgpKSAmIDB4ZmY7XG5cbiAgICAgIGogPSAoaiArIFNbaV0gKyBrZXlCeXRlKSAlIDI1NjtcblxuICAgICAgLy8gU3dhcFxuICAgICAgY29uc3QgdCA9IFNbaV07XG4gICAgICBTW2ldID0gU1tqXTtcbiAgICAgIFNbal0gPSB0O1xuICAgIH1cblxuICAgIC8vIENvdW50ZXJzXG4gICAgdGhpcy5faiA9IDA7XG4gICAgdGhpcy5faSA9IHRoaXMuX2o7XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgX00gPSBNO1xuXG4gICAgX01bb2Zmc2V0XSBePSBnZW5lcmF0ZUtleXN0cmVhbVdvcmQuY2FsbCh0aGlzKTtcbiAgfVxufVxuUkM0QWxnby5rZXlTaXplID0gMjU2IC8gMzI7XG5SQzRBbGdvLml2U2l6ZSA9IDA7XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuUkM0LmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuUkM0LmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICovXG5leHBvcnQgY29uc3QgUkM0ID0gU3RyZWFtQ2lwaGVyLl9jcmVhdGVIZWxwZXIoUkM0QWxnbyk7XG5cbi8qKlxuICogTW9kaWZpZWQgUkM0IHN0cmVhbSBjaXBoZXIgYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgUkM0RHJvcEFsZ28gZXh0ZW5kcyBSQzRBbGdvIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGRyb3AgVGhlIG51bWJlciBvZiBrZXlzdHJlYW0gd29yZHMgdG8gZHJvcC4gRGVmYXVsdCAxOTJcbiAgICAgKi9cbiAgICBPYmplY3QuYXNzaWduKHRoaXMuY2ZnLCB7IGRyb3A6IDE5MiB9KTtcbiAgfVxuXG4gIF9kb1Jlc2V0KCkge1xuICAgIHN1cGVyLl9kb1Jlc2V0LmNhbGwodGhpcyk7XG5cbiAgICAvLyBEcm9wXG4gICAgZm9yIChsZXQgaSA9IHRoaXMuY2ZnLmRyb3A7IGkgPiAwOyBpIC09IDEpIHtcbiAgICAgIGdlbmVyYXRlS2V5c3RyZWFtV29yZC5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLlJDNERyb3AuZW5jcnlwdChtZXNzYWdlLCBrZXksIGNmZyk7XG4gKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5SQzREcm9wLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICovXG5leHBvcnQgY29uc3QgUkM0RHJvcCA9IFN0cmVhbUNpcGhlci5fY3JlYXRlSGVscGVyKFJDNERyb3BBbGdvKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/rc4.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/ripemd160.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-es/lib/ripemd160.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"RIPEMD160Algo\": function() { return /* binding */ RIPEMD160Algo; },\n/* harmony export */   \"RIPEMD160\": function() { return /* binding */ RIPEMD160; },\n/* harmony export */   \"HmacRIPEMD160\": function() { return /* binding */ HmacRIPEMD160; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/** @preserve\n(c) 2012 by Cédric Mesnil. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted\nprovided that the following conditions are met:\n\n    - Redistributions of source code must retain the above copyright notice, this list of\n    conditions and the following disclaimer.\n    - Redistributions in binary form must reproduce the above copyright notice, this list\n    of conditions and the following disclaimer in the documentation and/or other materials\n    provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS\nOR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\nWAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n\n// Constants table\nconst _zl = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create([\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,\n  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,\n  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);\nconst _zr = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create([\n  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,\n  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,\n  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,\n  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,\n  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);\nconst _sl = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create([\n  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,\n  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,\n  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,\n  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,\n  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);\nconst _sr = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create([\n  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,\n  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,\n  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,\n  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,\n  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);\n\nconst _hl = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);\nconst _hr = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);\n\nconst f1 = (x, y, z) => (x) ^ (y) ^ (z);\n\nconst f2 = (x, y, z) => ((x) & (y)) | ((~x) & (z));\n\nconst f3 = (x, y, z) => ((x) | (~(y))) ^ (z);\n\nconst f4 = (x, y, z) => ((x) & (z)) | ((y) & (~(z)));\n\nconst f5 = (x, y, z) => (x) ^ ((y) | (~(z)));\n\nconst rotl = (x, n) => (x << n) | (x >>> (32 - n));\n\n/**\n * RIPEMD160 hash algorithm.\n */\nclass RIPEMD160Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher {\n  _doReset() {\n    this._hash = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Swap endian\n    for (let i = 0; i < 16; i += 1) {\n      // Shortcuts\n      const offset_i = offset + i;\n      const M_offset_i = _M[offset_i];\n\n      // Swap\n      _M[offset_i] = (\n        (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff)\n          | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)\n      );\n    }\n    // Shortcut\n    const H = this._hash.words;\n    const hl = _hl.words;\n    const hr = _hr.words;\n    const zl = _zl.words;\n    const zr = _zr.words;\n    const sl = _sl.words;\n    const sr = _sr.words;\n\n    // Working variables\n    let al = H[0];\n    let bl = H[1];\n    let cl = H[2];\n    let dl = H[3];\n    let el = H[4];\n    let ar = H[0];\n    let br = H[1];\n    let cr = H[2];\n    let dr = H[3];\n    let er = H[4];\n\n    // Computation\n    let t;\n    for (let i = 0; i < 80; i += 1) {\n      t = (al + _M[offset + zl[i]]) | 0;\n      if (i < 16) {\n        t += f1(bl, cl, dl) + hl[0];\n      } else if (i < 32) {\n        t += f2(bl, cl, dl) + hl[1];\n      } else if (i < 48) {\n        t += f3(bl, cl, dl) + hl[2];\n      } else if (i < 64) {\n        t += f4(bl, cl, dl) + hl[3];\n      } else { // if (i<80) {\n        t += f5(bl, cl, dl) + hl[4];\n      }\n      t |= 0;\n      t = rotl(t, sl[i]);\n      t = (t + el) | 0;\n      al = el;\n      el = dl;\n      dl = rotl(cl, 10);\n      cl = bl;\n      bl = t;\n\n      t = (ar + _M[offset + zr[i]]) | 0;\n      if (i < 16) {\n        t += f5(br, cr, dr) + hr[0];\n      } else if (i < 32) {\n        t += f4(br, cr, dr) + hr[1];\n      } else if (i < 48) {\n        t += f3(br, cr, dr) + hr[2];\n      } else if (i < 64) {\n        t += f2(br, cr, dr) + hr[3];\n      } else { // if (i<80) {\n        t += f1(br, cr, dr) + hr[4];\n      }\n      t |= 0;\n      t = rotl(t, sr[i]);\n      t = (t + er) | 0;\n      ar = er;\n      er = dr;\n      dr = rotl(cr, 10);\n      cr = br;\n      br = t;\n    }\n    // Intermediate hash value\n    t = (H[1] + cl + dr) | 0;\n    H[1] = (H[2] + dl + er) | 0;\n    H[2] = (H[3] + el + ar) | 0;\n    H[3] = (H[4] + al + br) | 0;\n    H[4] = (H[0] + bl + cr) | 0;\n    H[0] = t;\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n      (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)\n    );\n    data.sigBytes = (dataWords.length + 1) * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const hash = this._hash;\n    const H = hash.words;\n\n    // Swap endian\n    for (let i = 0; i < 5; i += 1) {\n      // Shortcut\n      const H_i = H[i];\n\n      // Swap\n      H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff)\n        | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n    }\n\n    // Return final computed hash\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.RIPEMD160('message');\n *     var hash = CryptoJS.RIPEMD160(wordArray);\n */\nconst RIPEMD160 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHelper(RIPEMD160Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacRIPEMD160(message, key);\n */\nconst HmacRIPEMD160 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHmacHelper(RIPEMD160Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvcmlwZW1kMTYwLmpzP2UxYzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBS21COztBQUVuQjtBQUNBLFlBQVksc0RBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNEQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxzREFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0RBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxzREFBZ0I7QUFDNUIsWUFBWSxzREFBZ0I7O0FBRTVCOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLDRCQUE0Qiw0Q0FBTTtBQUN6QztBQUNBLGlCQUFpQixzREFBZ0I7QUFDakM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU8sT0FBTztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxrQkFBa0IsMERBQW9COztBQUU3QztBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHNCQUFzQiw4REFBd0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9yaXBlbWQxNjAuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQHByZXNlcnZlXG4oYykgMjAxMiBieSBDw6lkcmljIE1lc25pbC4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblxuUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZFxucHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlIG1ldDpcblxuICAgIC0gUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2ZcbiAgICBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgLSBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdFxuICAgIG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzXG4gICAgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG5USElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1Ncbk9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFQgSE9MREVSIE9SXG5DT05UUklCVVRPUlMgQkUgTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMXG5EQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG5EQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSxcbldIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTllcbldBWSBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuaW1wb3J0IHtcbiAgV29yZEFycmF5LFxuICBIYXNoZXIsXG59IGZyb20gJy4vY29yZS5qcyc7XG5cbi8vIENvbnN0YW50cyB0YWJsZVxuY29uc3QgX3psID0gV29yZEFycmF5LmNyZWF0ZShbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG4gIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG4gIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNdKTtcbmNvbnN0IF96ciA9IFdvcmRBcnJheS5jcmVhdGUoW1xuICA1LCAxNCwgNywgMCwgOSwgMiwgMTEsIDQsIDEzLCA2LCAxNSwgOCwgMSwgMTAsIDMsIDEyLFxuICA2LCAxMSwgMywgNywgMCwgMTMsIDUsIDEwLCAxNCwgMTUsIDgsIDEyLCA0LCA5LCAxLCAyLFxuICAxNSwgNSwgMSwgMywgNywgMTQsIDYsIDksIDExLCA4LCAxMiwgMiwgMTAsIDAsIDQsIDEzLFxuICA4LCA2LCA0LCAxLCAzLCAxMSwgMTUsIDAsIDUsIDEyLCAyLCAxMywgOSwgNywgMTAsIDE0LFxuICAxMiwgMTUsIDEwLCA0LCAxLCA1LCA4LCA3LCA2LCAyLCAxMywgMTQsIDAsIDMsIDksIDExXSk7XG5jb25zdCBfc2wgPSBXb3JkQXJyYXkuY3JlYXRlKFtcbiAgMTEsIDE0LCAxNSwgMTIsIDUsIDgsIDcsIDksIDExLCAxMywgMTQsIDE1LCA2LCA3LCA5LCA4LFxuICA3LCA2LCA4LCAxMywgMTEsIDksIDcsIDE1LCA3LCAxMiwgMTUsIDksIDExLCA3LCAxMywgMTIsXG4gIDExLCAxMywgNiwgNywgMTQsIDksIDEzLCAxNSwgMTQsIDgsIDEzLCA2LCA1LCAxMiwgNywgNSxcbiAgMTEsIDEyLCAxNCwgMTUsIDE0LCAxNSwgOSwgOCwgOSwgMTQsIDUsIDYsIDgsIDYsIDUsIDEyLFxuICA5LCAxNSwgNSwgMTEsIDYsIDgsIDEzLCAxMiwgNSwgMTIsIDEzLCAxNCwgMTEsIDgsIDUsIDZdKTtcbmNvbnN0IF9zciA9IFdvcmRBcnJheS5jcmVhdGUoW1xuICA4LCA5LCA5LCAxMSwgMTMsIDE1LCAxNSwgNSwgNywgNywgOCwgMTEsIDE0LCAxNCwgMTIsIDYsXG4gIDksIDEzLCAxNSwgNywgMTIsIDgsIDksIDExLCA3LCA3LCAxMiwgNywgNiwgMTUsIDEzLCAxMSxcbiAgOSwgNywgMTUsIDExLCA4LCA2LCA2LCAxNCwgMTIsIDEzLCA1LCAxNCwgMTMsIDEzLCA3LCA1LFxuICAxNSwgNSwgOCwgMTEsIDE0LCAxNCwgNiwgMTQsIDYsIDksIDEyLCA5LCAxMiwgNSwgMTUsIDgsXG4gIDgsIDUsIDEyLCA5LCAxMiwgNSwgMTQsIDYsIDgsIDEzLCA2LCA1LCAxNSwgMTMsIDExLCAxMV0pO1xuXG5jb25zdCBfaGwgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDAwMDAwMDAwLCAweDVBODI3OTk5LCAweDZFRDlFQkExLCAweDhGMUJCQ0RDLCAweEE5NTNGRDRFXSk7XG5jb25zdCBfaHIgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDUwQTI4QkU2LCAweDVDNEREMTI0LCAweDZENzAzRUYzLCAweDdBNkQ3NkU5LCAweDAwMDAwMDAwXSk7XG5cbmNvbnN0IGYxID0gKHgsIHksIHopID0+ICh4KSBeICh5KSBeICh6KTtcblxuY29uc3QgZjIgPSAoeCwgeSwgeikgPT4gKCh4KSAmICh5KSkgfCAoKH54KSAmICh6KSk7XG5cbmNvbnN0IGYzID0gKHgsIHksIHopID0+ICgoeCkgfCAofih5KSkpIF4gKHopO1xuXG5jb25zdCBmNCA9ICh4LCB5LCB6KSA9PiAoKHgpICYgKHopKSB8ICgoeSkgJiAofih6KSkpO1xuXG5jb25zdCBmNSA9ICh4LCB5LCB6KSA9PiAoeCkgXiAoKHkpIHwgKH4oeikpKTtcblxuY29uc3Qgcm90bCA9ICh4LCBuKSA9PiAoeCA8PCBuKSB8ICh4ID4+PiAoMzIgLSBuKSk7XG5cbi8qKlxuICogUklQRU1EMTYwIGhhc2ggYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgUklQRU1EMTYwQWxnbyBleHRlbmRzIEhhc2hlciB7XG4gIF9kb1Jlc2V0KCkge1xuICAgIHRoaXMuX2hhc2ggPSBXb3JkQXJyYXkuY3JlYXRlKFsweDY3NDUyMzAxLCAweEVGQ0RBQjg5LCAweDk4QkFEQ0ZFLCAweDEwMzI1NDc2LCAweEMzRDJFMUYwXSk7XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgY29uc3QgX00gPSBNO1xuXG4gICAgLy8gU3dhcCBlbmRpYW5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgY29uc3Qgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuICAgICAgY29uc3QgTV9vZmZzZXRfaSA9IF9NW29mZnNldF9pXTtcblxuICAgICAgLy8gU3dhcFxuICAgICAgX01bb2Zmc2V0X2ldID0gKFxuICAgICAgICAoKChNX29mZnNldF9pIDw8IDgpIHwgKE1fb2Zmc2V0X2kgPj4+IDI0KSkgJiAweDAwZmYwMGZmKVxuICAgICAgICAgIHwgKCgoTV9vZmZzZXRfaSA8PCAyNCkgfCAoTV9vZmZzZXRfaSA+Pj4gOCkpICYgMHhmZjAwZmYwMClcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIFNob3J0Y3V0XG4gICAgY29uc3QgSCA9IHRoaXMuX2hhc2gud29yZHM7XG4gICAgY29uc3QgaGwgPSBfaGwud29yZHM7XG4gICAgY29uc3QgaHIgPSBfaHIud29yZHM7XG4gICAgY29uc3QgemwgPSBfemwud29yZHM7XG4gICAgY29uc3QgenIgPSBfenIud29yZHM7XG4gICAgY29uc3Qgc2wgPSBfc2wud29yZHM7XG4gICAgY29uc3Qgc3IgPSBfc3Iud29yZHM7XG5cbiAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuICAgIGxldCBhbCA9IEhbMF07XG4gICAgbGV0IGJsID0gSFsxXTtcbiAgICBsZXQgY2wgPSBIWzJdO1xuICAgIGxldCBkbCA9IEhbM107XG4gICAgbGV0IGVsID0gSFs0XTtcbiAgICBsZXQgYXIgPSBIWzBdO1xuICAgIGxldCBiciA9IEhbMV07XG4gICAgbGV0IGNyID0gSFsyXTtcbiAgICBsZXQgZHIgPSBIWzNdO1xuICAgIGxldCBlciA9IEhbNF07XG5cbiAgICAvLyBDb21wdXRhdGlvblxuICAgIGxldCB0O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuICAgICAgdCA9IChhbCArIF9NW29mZnNldCArIHpsW2ldXSkgfCAwO1xuICAgICAgaWYgKGkgPCAxNikge1xuICAgICAgICB0ICs9IGYxKGJsLCBjbCwgZGwpICsgaGxbMF07XG4gICAgICB9IGVsc2UgaWYgKGkgPCAzMikge1xuICAgICAgICB0ICs9IGYyKGJsLCBjbCwgZGwpICsgaGxbMV07XG4gICAgICB9IGVsc2UgaWYgKGkgPCA0OCkge1xuICAgICAgICB0ICs9IGYzKGJsLCBjbCwgZGwpICsgaGxbMl07XG4gICAgICB9IGVsc2UgaWYgKGkgPCA2NCkge1xuICAgICAgICB0ICs9IGY0KGJsLCBjbCwgZGwpICsgaGxbM107XG4gICAgICB9IGVsc2UgeyAvLyBpZiAoaTw4MCkge1xuICAgICAgICB0ICs9IGY1KGJsLCBjbCwgZGwpICsgaGxbNF07XG4gICAgICB9XG4gICAgICB0IHw9IDA7XG4gICAgICB0ID0gcm90bCh0LCBzbFtpXSk7XG4gICAgICB0ID0gKHQgKyBlbCkgfCAwO1xuICAgICAgYWwgPSBlbDtcbiAgICAgIGVsID0gZGw7XG4gICAgICBkbCA9IHJvdGwoY2wsIDEwKTtcbiAgICAgIGNsID0gYmw7XG4gICAgICBibCA9IHQ7XG5cbiAgICAgIHQgPSAoYXIgKyBfTVtvZmZzZXQgKyB6cltpXV0pIHwgMDtcbiAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgdCArPSBmNShiciwgY3IsIGRyKSArIGhyWzBdO1xuICAgICAgfSBlbHNlIGlmIChpIDwgMzIpIHtcbiAgICAgICAgdCArPSBmNChiciwgY3IsIGRyKSArIGhyWzFdO1xuICAgICAgfSBlbHNlIGlmIChpIDwgNDgpIHtcbiAgICAgICAgdCArPSBmMyhiciwgY3IsIGRyKSArIGhyWzJdO1xuICAgICAgfSBlbHNlIGlmIChpIDwgNjQpIHtcbiAgICAgICAgdCArPSBmMihiciwgY3IsIGRyKSArIGhyWzNdO1xuICAgICAgfSBlbHNlIHsgLy8gaWYgKGk8ODApIHtcbiAgICAgICAgdCArPSBmMShiciwgY3IsIGRyKSArIGhyWzRdO1xuICAgICAgfVxuICAgICAgdCB8PSAwO1xuICAgICAgdCA9IHJvdGwodCwgc3JbaV0pO1xuICAgICAgdCA9ICh0ICsgZXIpIHwgMDtcbiAgICAgIGFyID0gZXI7XG4gICAgICBlciA9IGRyO1xuICAgICAgZHIgPSByb3RsKGNyLCAxMCk7XG4gICAgICBjciA9IGJyO1xuICAgICAgYnIgPSB0O1xuICAgIH1cbiAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuICAgIHQgPSAoSFsxXSArIGNsICsgZHIpIHwgMDtcbiAgICBIWzFdID0gKEhbMl0gKyBkbCArIGVyKSB8IDA7XG4gICAgSFsyXSA9IChIWzNdICsgZWwgKyBhcikgfCAwO1xuICAgIEhbM10gPSAoSFs0XSArIGFsICsgYnIpIHwgMDtcbiAgICBIWzRdID0gKEhbMF0gKyBibCArIGNyKSB8IDA7XG4gICAgSFswXSA9IHQ7XG4gIH1cblxuICBfZG9GaW5hbGl6ZSgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG4gICAgY29uc3QgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuICAgIGNvbnN0IG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG4gICAgLy8gQWRkIHBhZGRpbmdcbiAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIChuQml0c0xlZnQgJSAzMikpO1xuICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxuICAgICAgKCgobkJpdHNUb3RhbCA8PCA4KSB8IChuQml0c1RvdGFsID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChuQml0c1RvdGFsIDw8IDI0KSB8IChuQml0c1RvdGFsID4+PiA4KSkgJiAweGZmMDBmZjAwKVxuICAgICk7XG4gICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG4gICAgLy8gSGFzaCBmaW5hbCBibG9ja3NcbiAgICB0aGlzLl9wcm9jZXNzKCk7XG5cbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBoYXNoID0gdGhpcy5faGFzaDtcbiAgICBjb25zdCBIID0gaGFzaC53b3JkcztcblxuICAgIC8vIFN3YXAgZW5kaWFuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA1OyBpICs9IDEpIHtcbiAgICAgIC8vIFNob3J0Y3V0XG4gICAgICBjb25zdCBIX2kgPSBIW2ldO1xuXG4gICAgICAvLyBTd2FwXG4gICAgICBIW2ldID0gKCgoSF9pIDw8IDgpIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpXG4gICAgICAgIHwgKCgoSF9pIDw8IDI0KSB8IChIX2kgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuICAgIH1cblxuICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlJJUEVNRDE2MCgnbWVzc2FnZScpO1xuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuUklQRU1EMTYwKHdvcmRBcnJheSk7XG4gKi9cbmV4cG9ydCBjb25zdCBSSVBFTUQxNjAgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihSSVBFTUQxNjBBbGdvKTtcblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNSSVBFTUQxNjAobWVzc2FnZSwga2V5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IEhtYWNSSVBFTUQxNjAgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoUklQRU1EMTYwQWxnbyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/ripemd160.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha1.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha1.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SHA1Algo\": function() { return /* binding */ SHA1Algo; },\n/* harmony export */   \"SHA1\": function() { return /* binding */ SHA1; },\n/* harmony export */   \"HmacSHA1\": function() { return /* binding */ HmacSHA1; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\n// Reusable object\nconst W = [];\n\n/**\n * SHA-1 hash algorithm.\n */\nclass SHA1Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher {\n  _doReset() {\n    this._hash = new _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray([\n      0x67452301,\n      0xefcdab89,\n      0x98badcfe,\n      0x10325476,\n      0xc3d2e1f0,\n    ]);\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcut\n    const H = this._hash.words;\n\n    // Working variables\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    // Computation\n    for (let i = 0; i < 80; i += 1) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n        W[i] = (n << 1) | (n >>> 31);\n      }\n\n      let t = ((a << 5) | (a >>> 27)) + e + W[i];\n      if (i < 20) {\n        t += ((b & c) | (~b & d)) + 0x5a827999;\n      } else if (i < 40) {\n        t += (b ^ c ^ d) + 0x6ed9eba1;\n      } else if (i < 60) {\n        t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;\n      } else /* if (i < 80) */ {\n        t += (b ^ c ^ d) - 0x359d3e2a;\n      }\n\n      e = d;\n      d = c;\n      c = (b << 30) | (b >>> 2);\n      b = a;\n      a = t;\n    }\n\n    // Intermediate hash value\n    H[0] = (H[0] + a) | 0;\n    H[1] = (H[1] + b) | 0;\n    H[2] = (H[2] + c) | 0;\n    H[3] = (H[3] + d) | 0;\n    H[4] = (H[4] + e) | 0;\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Return final computed hash\n    return this._hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA1('message');\n *     var hash = CryptoJS.SHA1(wordArray);\n */\nconst SHA1 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHelper(SHA1Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA1(message, key);\n */\nconst HmacSHA1 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHmacHelper(SHA1Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMS5qcz9iZDYyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFHbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ08sdUJBQXVCLDRDQUFNO0FBQ3BDO0FBQ0EscUJBQXFCLCtDQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGFBQWEsMERBQW9COztBQUV4QztBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlCQUFpQiw4REFBd0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9zaGExLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgV29yZEFycmF5LFxuICBIYXNoZXIsXG59IGZyb20gJy4vY29yZS5qcyc7XG5cbi8vIFJldXNhYmxlIG9iamVjdFxuY29uc3QgVyA9IFtdO1xuXG4vKipcbiAqIFNIQS0xIGhhc2ggYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgU0hBMUFsZ28gZXh0ZW5kcyBIYXNoZXIge1xuICBfZG9SZXNldCgpIHtcbiAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheShbXG4gICAgICAweDY3NDUyMzAxLFxuICAgICAgMHhlZmNkYWI4OSxcbiAgICAgIDB4OThiYWRjZmUsXG4gICAgICAweDEwMzI1NDc2LFxuICAgICAgMHhjM2QyZTFmMCxcbiAgICBdKTtcbiAgfVxuXG4gIF9kb1Byb2Nlc3NCbG9jayhNLCBvZmZzZXQpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG4gICAgLy8gV29ya2luZyB2YXJpYWJsZXNcbiAgICBsZXQgYSA9IEhbMF07XG4gICAgbGV0IGIgPSBIWzFdO1xuICAgIGxldCBjID0gSFsyXTtcbiAgICBsZXQgZCA9IEhbM107XG4gICAgbGV0IGUgPSBIWzRdO1xuXG4gICAgLy8gQ29tcHV0YXRpb25cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbiA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XG4gICAgICAgIFdbaV0gPSAobiA8PCAxKSB8IChuID4+PiAzMSk7XG4gICAgICB9XG5cbiAgICAgIGxldCB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBlICsgV1tpXTtcbiAgICAgIGlmIChpIDwgMjApIHtcbiAgICAgICAgdCArPSAoKGIgJiBjKSB8ICh+YiAmIGQpKSArIDB4NWE4Mjc5OTk7XG4gICAgICB9IGVsc2UgaWYgKGkgPCA0MCkge1xuICAgICAgICB0ICs9IChiIF4gYyBeIGQpICsgMHg2ZWQ5ZWJhMTtcbiAgICAgIH0gZWxzZSBpZiAoaSA8IDYwKSB7XG4gICAgICAgIHQgKz0gKChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKSkgLSAweDcwZTQ0MzI0O1xuICAgICAgfSBlbHNlIC8qIGlmIChpIDwgODApICovIHtcbiAgICAgICAgdCArPSAoYiBeIGMgXiBkKSAtIDB4MzU5ZDNlMmE7XG4gICAgICB9XG5cbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gKGIgPDwgMzApIHwgKGIgPj4+IDIpO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gdDtcbiAgICB9XG5cbiAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcbiAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG4gICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcbiAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG4gIH1cblxuICBfZG9GaW5hbGl6ZSgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG4gICAgY29uc3QgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuICAgIGNvbnN0IG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG4gICAgLy8gQWRkIHBhZGRpbmdcbiAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIChuQml0c0xlZnQgJSAzMikpO1xuICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcbiAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cbiAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG4gICAgcmV0dXJuIHRoaXMuX2hhc2g7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEoJ21lc3NhZ2UnKTtcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEod29yZEFycmF5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IFNIQTEgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEExQWxnbyk7XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMShtZXNzYWdlLCBrZXkpO1xuICovXG5leHBvcnQgY29uc3QgSG1hY1NIQTEgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMUFsZ28pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha1.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha224.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha224.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SHA224Algo\": function() { return /* binding */ SHA224Algo; },\n/* harmony export */   \"SHA224\": function() { return /* binding */ SHA224; },\n/* harmony export */   \"HmacSHA224\": function() { return /* binding */ HmacSHA224; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _sha256_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha256.js */ \"./node_modules/crypto-es/lib/sha256.js\");\n\n\n\n/**\n * SHA-224 hash algorithm.\n */\nclass SHA224Algo extends _sha256_js__WEBPACK_IMPORTED_MODULE_1__.SHA256Algo {\n  _doReset() {\n    this._hash = new _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray([\n      0xc1059ed8,\n      0x367cd507,\n      0x3070dd17,\n      0xf70e5939,\n      0xffc00b31,\n      0x68581511,\n      0x64f98fa7,\n      0xbefa4fa4,\n    ]);\n  }\n\n  _doFinalize() {\n    const hash = super._doFinalize.call(this);\n\n    hash.sigBytes -= 4;\n\n    return hash;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA224('message');\n *     var hash = CryptoJS.SHA224(wordArray);\n */\nconst SHA224 = _sha256_js__WEBPACK_IMPORTED_MODULE_1__.SHA256Algo._createHelper(SHA224Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA224(message, key);\n */\nconst HmacSHA224 = _sha256_js__WEBPACK_IMPORTED_MODULE_1__.SHA256Algo._createHmacHelper(SHA224Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMjI0LmpzPzE0OGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBc0M7QUFDRzs7QUFFekM7QUFDQTtBQUNBO0FBQ08seUJBQXlCLGtEQUFVO0FBQzFDO0FBQ0EscUJBQXFCLCtDQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxlQUFlLGdFQUF3Qjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsb0VBQTRCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMjI0LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV29yZEFycmF5IH0gZnJvbSAnLi9jb3JlLmpzJztcbmltcG9ydCB7IFNIQTI1NkFsZ28gfSBmcm9tICcuL3NoYTI1Ni5qcyc7XG5cbi8qKlxuICogU0hBLTIyNCBoYXNoIGFsZ29yaXRobS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNIQTIyNEFsZ28gZXh0ZW5kcyBTSEEyNTZBbGdvIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkoW1xuICAgICAgMHhjMTA1OWVkOCxcbiAgICAgIDB4MzY3Y2Q1MDcsXG4gICAgICAweDMwNzBkZDE3LFxuICAgICAgMHhmNzBlNTkzOSxcbiAgICAgIDB4ZmZjMDBiMzEsXG4gICAgICAweDY4NTgxNTExLFxuICAgICAgMHg2NGY5OGZhNyxcbiAgICAgIDB4YmVmYTRmYTQsXG4gICAgXSk7XG4gIH1cblxuICBfZG9GaW5hbGl6ZSgpIHtcbiAgICBjb25zdCBoYXNoID0gc3VwZXIuX2RvRmluYWxpemUuY2FsbCh0aGlzKTtcblxuICAgIGhhc2guc2lnQnl0ZXMgLT0gNDtcblxuICAgIHJldHVybiBoYXNoO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyMjQoJ21lc3NhZ2UnKTtcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTIyNCh3b3JkQXJyYXkpO1xuICovXG5leHBvcnQgY29uc3QgU0hBMjI0ID0gU0hBMjU2QWxnby5fY3JlYXRlSGVscGVyKFNIQTIyNEFsZ28pO1xuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTIyNChtZXNzYWdlLCBrZXkpO1xuICovXG5leHBvcnQgY29uc3QgSG1hY1NIQTIyNCA9IFNIQTI1NkFsZ28uX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjI0QWxnbyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha224.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha256.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha256.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SHA256Algo\": function() { return /* binding */ SHA256Algo; },\n/* harmony export */   \"SHA256\": function() { return /* binding */ SHA256; },\n/* harmony export */   \"HmacSHA256\": function() { return /* binding */ HmacSHA256; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\n// Initialization and round constants tables\nconst H = [];\nconst K = [];\n\n// Compute constants\nconst isPrime = (n) => {\n  const sqrtN = Math.sqrt(n);\n  for (let factor = 2; factor <= sqrtN; factor += 1) {\n    if (!(n % factor)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nconst getFractionalBits = n => ((n - (n | 0)) * 0x100000000) | 0;\n\nlet n = 2;\nlet nPrime = 0;\nwhile (nPrime < 64) {\n  if (isPrime(n)) {\n    if (nPrime < 8) {\n      H[nPrime] = getFractionalBits(n ** (1 / 2));\n    }\n    K[nPrime] = getFractionalBits(n ** (1 / 3));\n\n    nPrime += 1;\n  }\n\n  n += 1;\n}\n\n// Reusable object\nconst W = [];\n\n/**\n * SHA-256 hash algorithm.\n */\nclass SHA256Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher {\n  _doReset() {\n    this._hash = new _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray(H.slice(0));\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcut\n    const _H = this._hash.words;\n\n    // Working variables\n    let a = _H[0];\n    let b = _H[1];\n    let c = _H[2];\n    let d = _H[3];\n    let e = _H[4];\n    let f = _H[5];\n    let g = _H[6];\n    let h = _H[7];\n\n    // Computation\n    for (let i = 0; i < 64; i += 1) {\n      if (i < 16) {\n        W[i] = M[offset + i] | 0;\n      } else {\n        const gamma0x = W[i - 15];\n        const gamma0 = ((gamma0x << 25) | (gamma0x >>> 7))\n          ^ ((gamma0x << 14) | (gamma0x >>> 18))\n          ^ (gamma0x >>> 3);\n\n        const gamma1x = W[i - 2];\n        const gamma1 = ((gamma1x << 15) | (gamma1x >>> 17))\n          ^ ((gamma1x << 13) | (gamma1x >>> 19))\n          ^ (gamma1x >>> 10);\n\n        W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n      }\n\n      const ch = (e & f) ^ (~e & g);\n      const maj = (a & b) ^ (a & c) ^ (b & c);\n\n      const sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n      const sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));\n\n      const t1 = h + sigma1 + ch + K[i] + W[i];\n      const t2 = sigma0 + maj;\n\n      h = g;\n      g = f;\n      f = e;\n      e = (d + t1) | 0;\n      d = c;\n      c = b;\n      b = a;\n      a = (t1 + t2) | 0;\n    }\n\n    // Intermediate hash value\n    _H[0] = (_H[0] + a) | 0;\n    _H[1] = (_H[1] + b) | 0;\n    _H[2] = (_H[2] + c) | 0;\n    _H[3] = (_H[3] + d) | 0;\n    _H[4] = (_H[4] + e) | 0;\n    _H[5] = (_H[5] + f) | 0;\n    _H[6] = (_H[6] + g) | 0;\n    _H[7] = (_H[7] + h) | 0;\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Return final computed hash\n    return this._hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA256('message');\n *     var hash = CryptoJS.SHA256(wordArray);\n */\nconst SHA256 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHelper(SHA256Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA256(message, key);\n */\nconst HmacSHA256 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHmacHelper(SHA256Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMjU2LmpzPzRkZTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUdtQjs7QUFFbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5Qiw0Q0FBTTtBQUN0QztBQUNBLHFCQUFxQiwrQ0FBUztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZUFBZSwwREFBb0I7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLDhEQUF3QiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3NoYTI1Ni5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFdvcmRBcnJheSxcbiAgSGFzaGVyLFxufSBmcm9tICcuL2NvcmUuanMnO1xuXG4vLyBJbml0aWFsaXphdGlvbiBhbmQgcm91bmQgY29uc3RhbnRzIHRhYmxlc1xuY29uc3QgSCA9IFtdO1xuY29uc3QgSyA9IFtdO1xuXG4vLyBDb21wdXRlIGNvbnN0YW50c1xuY29uc3QgaXNQcmltZSA9IChuKSA9PiB7XG4gIGNvbnN0IHNxcnROID0gTWF0aC5zcXJ0KG4pO1xuICBmb3IgKGxldCBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvciArPSAxKSB7XG4gICAgaWYgKCEobiAlIGZhY3RvcikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGdldEZyYWN0aW9uYWxCaXRzID0gbiA9PiAoKG4gLSAobiB8IDApKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cbmxldCBuID0gMjtcbmxldCBuUHJpbWUgPSAwO1xud2hpbGUgKG5QcmltZSA8IDY0KSB7XG4gIGlmIChpc1ByaW1lKG4pKSB7XG4gICAgaWYgKG5QcmltZSA8IDgpIHtcbiAgICAgIEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKG4gKiogKDEgLyAyKSk7XG4gICAgfVxuICAgIEtbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKG4gKiogKDEgLyAzKSk7XG5cbiAgICBuUHJpbWUgKz0gMTtcbiAgfVxuXG4gIG4gKz0gMTtcbn1cblxuLy8gUmV1c2FibGUgb2JqZWN0XG5jb25zdCBXID0gW107XG5cbi8qKlxuICogU0hBLTI1NiBoYXNoIGFsZ29yaXRobS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNIQTI1NkFsZ28gZXh0ZW5kcyBIYXNoZXIge1xuICBfZG9SZXNldCgpIHtcbiAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheShILnNsaWNlKDApKTtcbiAgfVxuXG4gIF9kb1Byb2Nlc3NCbG9jayhNLCBvZmZzZXQpIHtcbiAgICAvLyBTaG9ydGN1dFxuICAgIGNvbnN0IF9IID0gdGhpcy5faGFzaC53b3JkcztcblxuICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG4gICAgbGV0IGEgPSBfSFswXTtcbiAgICBsZXQgYiA9IF9IWzFdO1xuICAgIGxldCBjID0gX0hbMl07XG4gICAgbGV0IGQgPSBfSFszXTtcbiAgICBsZXQgZSA9IF9IWzRdO1xuICAgIGxldCBmID0gX0hbNV07XG4gICAgbGV0IGcgPSBfSFs2XTtcbiAgICBsZXQgaCA9IF9IWzddO1xuXG4gICAgLy8gQ29tcHV0YXRpb25cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpICs9IDEpIHtcbiAgICAgIGlmIChpIDwgMTYpIHtcbiAgICAgICAgV1tpXSA9IE1bb2Zmc2V0ICsgaV0gfCAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZ2FtbWEweCA9IFdbaSAtIDE1XTtcbiAgICAgICAgY29uc3QgZ2FtbWEwID0gKChnYW1tYTB4IDw8IDI1KSB8IChnYW1tYTB4ID4+PiA3KSlcbiAgICAgICAgICBeICgoZ2FtbWEweCA8PCAxNCkgfCAoZ2FtbWEweCA+Pj4gMTgpKVxuICAgICAgICAgIF4gKGdhbW1hMHggPj4+IDMpO1xuXG4gICAgICAgIGNvbnN0IGdhbW1hMXggPSBXW2kgLSAyXTtcbiAgICAgICAgY29uc3QgZ2FtbWExID0gKChnYW1tYTF4IDw8IDE1KSB8IChnYW1tYTF4ID4+PiAxNykpXG4gICAgICAgICAgXiAoKGdhbW1hMXggPDwgMTMpIHwgKGdhbW1hMXggPj4+IDE5KSlcbiAgICAgICAgICBeIChnYW1tYTF4ID4+PiAxMCk7XG5cbiAgICAgICAgV1tpXSA9IGdhbW1hMCArIFdbaSAtIDddICsgZ2FtbWExICsgV1tpIC0gMTZdO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaCA9IChlICYgZikgXiAofmUgJiBnKTtcbiAgICAgIGNvbnN0IG1haiA9IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcblxuICAgICAgY29uc3Qgc2lnbWEwID0gKChhIDw8IDMwKSB8IChhID4+PiAyKSkgXiAoKGEgPDwgMTkpIHwgKGEgPj4+IDEzKSkgXiAoKGEgPDwgMTApIHwgKGEgPj4+IDIyKSk7XG4gICAgICBjb25zdCBzaWdtYTEgPSAoKGUgPDwgMjYpIHwgKGUgPj4+IDYpKSBeICgoZSA8PCAyMSkgfCAoZSA+Pj4gMTEpKSBeICgoZSA8PCA3KSB8IChlID4+PiAyNSkpO1xuXG4gICAgICBjb25zdCB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldO1xuICAgICAgY29uc3QgdDIgPSBzaWdtYTAgKyBtYWo7XG5cbiAgICAgIGggPSBnO1xuICAgICAgZyA9IGY7XG4gICAgICBmID0gZTtcbiAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBiO1xuICAgICAgYiA9IGE7XG4gICAgICBhID0gKHQxICsgdDIpIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuICAgIF9IWzBdID0gKF9IWzBdICsgYSkgfCAwO1xuICAgIF9IWzFdID0gKF9IWzFdICsgYikgfCAwO1xuICAgIF9IWzJdID0gKF9IWzJdICsgYykgfCAwO1xuICAgIF9IWzNdID0gKF9IWzNdICsgZCkgfCAwO1xuICAgIF9IWzRdID0gKF9IWzRdICsgZSkgfCAwO1xuICAgIF9IWzVdID0gKF9IWzVdICsgZikgfCAwO1xuICAgIF9IWzZdID0gKF9IWzZdICsgZykgfCAwO1xuICAgIF9IWzddID0gKF9IWzddICsgaCkgfCAwO1xuICB9XG5cbiAgX2RvRmluYWxpemUoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2RhdGE7XG4gICAgY29uc3QgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuICAgIGNvbnN0IG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcbiAgICBjb25zdCBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuICAgIC8vIEFkZCBwYWRkaW5nXG4gICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSAobkJpdHNMZWZ0ICUgMzIpKTtcbiAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcbiAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG4gICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG4gICAgLy8gSGFzaCBmaW5hbCBibG9ja3NcbiAgICB0aGlzLl9wcm9jZXNzKCk7XG5cbiAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuICAgIHJldHVybiB0aGlzLl9oYXNoO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgY2xvbmUgPSBzdXBlci5jbG9uZS5jYWxsKHRoaXMpO1xuICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoJ21lc3NhZ2UnKTtcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1Nih3b3JkQXJyYXkpO1xuICovXG5leHBvcnQgY29uc3QgU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMjU2QWxnbyk7XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG4gKlxuICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cbiAqXG4gKiBAc3RhdGljXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjU2KG1lc3NhZ2UsIGtleSk7XG4gKi9cbmV4cG9ydCBjb25zdCBIbWFjU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTI1NkFsZ28pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha256.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha3.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha3.js ***!
  \********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SHA3Algo\": function() { return /* binding */ SHA3Algo; },\n/* harmony export */   \"SHA3\": function() { return /* binding */ SHA3; },\n/* harmony export */   \"HmacSHA3\": function() { return /* binding */ HmacSHA3; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _x64_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./x64-core.js */ \"./node_modules/crypto-es/lib/x64-core.js\");\n\n\n\n// Constants tables\nconst RHO_OFFSETS = [];\nconst PI_INDEXES = [];\nconst ROUND_CONSTANTS = [];\n\n// Compute Constants\n// Compute rho offset constants\nlet _x = 1;\nlet _y = 0;\nfor (let t = 0; t < 24; t += 1) {\n  RHO_OFFSETS[_x + 5 * _y] = ((t + 1) * (t + 2) / 2) % 64;\n\n  const newX = _y % 5;\n  const newY = (2 * _x + 3 * _y) % 5;\n  _x = newX;\n  _y = newY;\n}\n\n// Compute pi index constants\nfor (let x = 0; x < 5; x += 1) {\n  for (let y = 0; y < 5; y += 1) {\n    PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;\n  }\n}\n\n// Compute round constants\nlet LFSR = 0x01;\nfor (let i = 0; i < 24; i += 1) {\n  let roundConstantMsw = 0;\n  let roundConstantLsw = 0;\n\n  for (let j = 0; j < 7; j += 1) {\n    if (LFSR & 0x01) {\n      const bitPosition = (1 << j) - 1;\n      if (bitPosition < 32) {\n        roundConstantLsw ^= 1 << bitPosition;\n      } else /* if (bitPosition >= 32) */ {\n        roundConstantMsw ^= 1 << (bitPosition - 32);\n      }\n    }\n\n    // Compute next LFSR\n    if (LFSR & 0x80) {\n      // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1\n      LFSR = (LFSR << 1) ^ 0x71;\n    } else {\n      LFSR <<= 1;\n    }\n  }\n\n  ROUND_CONSTANTS[i] = _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word.create(roundConstantMsw, roundConstantLsw);\n}\n\n// Reusable objects for temporary values\nconst T = [];\nfor (let i = 0; i < 25; i += 1) {\n  T[i] = _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word.create();\n}\n\n/**\n * SHA-3 hash algorithm.\n */\nclass SHA3Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher {\n  constructor(cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {number} outputLength\n     *   The desired number of bits in the output hash.\n     *   Only values permitted are: 224, 256, 384, 512.\n     *   Default: 512\n     */\n    super(Object.assign(\n      { outputLength: 512 },\n      cfg,\n    ));\n  }\n\n  _doReset() {\n    this._state = [];\n    const state = this._state;\n    for (let i = 0; i < 25; i += 1) {\n      state[i] = new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word();\n    }\n\n    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcuts\n    const state = this._state;\n    const nBlockSizeLanes = this.blockSize / 2;\n\n    // Absorb\n    for (let i = 0; i < nBlockSizeLanes; i += 1) {\n      // Shortcuts\n      let M2i = M[offset + 2 * i];\n      let M2i1 = M[offset + 2 * i + 1];\n\n      // Swap endian\n      M2i = (((M2i << 8) | (M2i >>> 24)) & 0x00ff00ff)\n        | (((M2i << 24) | (M2i >>> 8)) & 0xff00ff00);\n      M2i1 = (((M2i1 << 8) | (M2i1 >>> 24)) & 0x00ff00ff)\n        | (((M2i1 << 24) | (M2i1 >>> 8)) & 0xff00ff00);\n\n      // Absorb message into state\n      const lane = state[i];\n      lane.high ^= M2i1;\n      lane.low ^= M2i;\n    }\n\n    // Rounds\n    for (let round = 0; round < 24; round += 1) {\n      // Theta\n      for (let x = 0; x < 5; x += 1) {\n        // Mix column lanes\n        let tMsw = 0;\n        let tLsw = 0;\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          tMsw ^= lane.high;\n          tLsw ^= lane.low;\n        }\n\n        // Temporary values\n        const Tx = T[x];\n        Tx.high = tMsw;\n        Tx.low = tLsw;\n      }\n      for (let x = 0; x < 5; x += 1) {\n        // Shortcuts\n        const Tx4 = T[(x + 4) % 5];\n        const Tx1 = T[(x + 1) % 5];\n        const Tx1Msw = Tx1.high;\n        const Tx1Lsw = Tx1.low;\n\n        // Mix surrounding columns\n        const tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));\n        const tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));\n        for (let y = 0; y < 5; y += 1) {\n          const lane = state[x + 5 * y];\n          lane.high ^= tMsw;\n          lane.low ^= tLsw;\n        }\n      }\n\n      // Rho Pi\n      for (let laneIndex = 1; laneIndex < 25; laneIndex += 1) {\n        let tMsw;\n        let tLsw;\n\n        // Shortcuts\n        const lane = state[laneIndex];\n        const laneMsw = lane.high;\n        const laneLsw = lane.low;\n        const rhoOffset = RHO_OFFSETS[laneIndex];\n\n        // Rotate lanes\n        if (rhoOffset < 32) {\n          tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));\n          tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));\n        } else /* if (rhoOffset >= 32) */ {\n          tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));\n          tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));\n        }\n\n        // Transpose lanes\n        const TPiLane = T[PI_INDEXES[laneIndex]];\n        TPiLane.high = tMsw;\n        TPiLane.low = tLsw;\n      }\n\n      // Rho pi at x = y = 0\n      const T0 = T[0];\n      const state0 = state[0];\n      T0.high = state0.high;\n      T0.low = state0.low;\n\n      // Chi\n      for (let x = 0; x < 5; x += 1) {\n        for (let y = 0; y < 5; y += 1) {\n          // Shortcuts\n          const laneIndex = x + 5 * y;\n          const lane = state[laneIndex];\n          const TLane = T[laneIndex];\n          const Tx1Lane = T[((x + 1) % 5) + 5 * y];\n          const Tx2Lane = T[((x + 2) % 5) + 5 * y];\n\n          // Mix rows\n          lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);\n          lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);\n        }\n      }\n\n      // Iota\n      const lane = state[0];\n      const roundConstant = ROUND_CONSTANTS[round];\n      lane.high ^= roundConstant.high;\n      lane.low ^= roundConstant.low;\n    }\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n    const nBitsLeft = data.sigBytes * 8;\n    const blockSizeBits = this.blockSize * 32;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - (nBitsLeft % 32));\n    dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const state = this._state;\n    const outputLengthBytes = this.cfg.outputLength / 8;\n    const outputLengthLanes = outputLengthBytes / 8;\n\n    // Squeeze\n    const hashWords = [];\n    for (let i = 0; i < outputLengthLanes; i += 1) {\n      // Shortcuts\n      const lane = state[i];\n      let laneMsw = lane.high;\n      let laneLsw = lane.low;\n\n      // Swap endian\n      laneMsw = (((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff)\n        | (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00);\n      laneLsw = (((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff)\n        | (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00);\n\n      // Squeeze state to retrieve hash\n      hashWords.push(laneLsw);\n      hashWords.push(laneMsw);\n    }\n\n    // Return final computed hash\n    return new _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray(hashWords, outputLengthBytes);\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n\n    clone._state = this._state.slice(0);\n    const state = clone._state;\n    for (let i = 0; i < 25; i += 1) {\n      state[i] = state[i].clone();\n    }\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA3('message');\n *     var hash = CryptoJS.SHA3(wordArray);\n */\nconst SHA3 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHelper(SHA3Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA3(message, key);\n */\nconst HmacSHA3 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHmacHelper(SHA3Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMy5qcz8yNTk4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBR21CO0FBQ3FCOztBQUV4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUEsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsd0RBQWM7QUFDckM7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixTQUFTLHdEQUFjO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNPLHVCQUF1Qiw0Q0FBTTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG9CQUFvQjtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLGlEQUFPO0FBQzVCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBLHFCQUFxQixPQUFPO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsZ0JBQWdCO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUIsdUJBQXVCLE9BQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsK0NBQVM7QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGFBQWEsMERBQW9COztBQUV4QztBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGlCQUFpQiw4REFBd0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9zaGEzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgV29yZEFycmF5LFxuICBIYXNoZXIsXG59IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQgeyBYNjRXb3JkIH0gZnJvbSAnLi94NjQtY29yZS5qcyc7XG5cbi8vIENvbnN0YW50cyB0YWJsZXNcbmNvbnN0IFJIT19PRkZTRVRTID0gW107XG5jb25zdCBQSV9JTkRFWEVTID0gW107XG5jb25zdCBST1VORF9DT05TVEFOVFMgPSBbXTtcblxuLy8gQ29tcHV0ZSBDb25zdGFudHNcbi8vIENvbXB1dGUgcmhvIG9mZnNldCBjb25zdGFudHNcbmxldCBfeCA9IDE7XG5sZXQgX3kgPSAwO1xuZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCArPSAxKSB7XG4gIFJIT19PRkZTRVRTW194ICsgNSAqIF95XSA9ICgodCArIDEpICogKHQgKyAyKSAvIDIpICUgNjQ7XG5cbiAgY29uc3QgbmV3WCA9IF95ICUgNTtcbiAgY29uc3QgbmV3WSA9ICgyICogX3ggKyAzICogX3kpICUgNTtcbiAgX3ggPSBuZXdYO1xuICBfeSA9IG5ld1k7XG59XG5cbi8vIENvbXB1dGUgcGkgaW5kZXggY29uc3RhbnRzXG5mb3IgKGxldCB4ID0gMDsgeCA8IDU7IHggKz0gMSkge1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IDU7IHkgKz0gMSkge1xuICAgIFBJX0lOREVYRVNbeCArIDUgKiB5XSA9IHkgKyAoKDIgKiB4ICsgMyAqIHkpICUgNSkgKiA1O1xuICB9XG59XG5cbi8vIENvbXB1dGUgcm91bmQgY29uc3RhbnRzXG5sZXQgTEZTUiA9IDB4MDE7XG5mb3IgKGxldCBpID0gMDsgaSA8IDI0OyBpICs9IDEpIHtcbiAgbGV0IHJvdW5kQ29uc3RhbnRNc3cgPSAwO1xuICBsZXQgcm91bmRDb25zdGFudExzdyA9IDA7XG5cbiAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqICs9IDEpIHtcbiAgICBpZiAoTEZTUiAmIDB4MDEpIHtcbiAgICAgIGNvbnN0IGJpdFBvc2l0aW9uID0gKDEgPDwgaikgLSAxO1xuICAgICAgaWYgKGJpdFBvc2l0aW9uIDwgMzIpIHtcbiAgICAgICAgcm91bmRDb25zdGFudExzdyBePSAxIDw8IGJpdFBvc2l0aW9uO1xuICAgICAgfSBlbHNlIC8qIGlmIChiaXRQb3NpdGlvbiA+PSAzMikgKi8ge1xuICAgICAgICByb3VuZENvbnN0YW50TXN3IF49IDEgPDwgKGJpdFBvc2l0aW9uIC0gMzIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvbXB1dGUgbmV4dCBMRlNSXG4gICAgaWYgKExGU1IgJiAweDgwKSB7XG4gICAgICAvLyBQcmltaXRpdmUgcG9seW5vbWlhbCBvdmVyIEdGKDIpOiB4XjggKyB4XjYgKyB4XjUgKyB4XjQgKyAxXG4gICAgICBMRlNSID0gKExGU1IgPDwgMSkgXiAweDcxO1xuICAgIH0gZWxzZSB7XG4gICAgICBMRlNSIDw8PSAxO1xuICAgIH1cbiAgfVxuXG4gIFJPVU5EX0NPTlNUQU5UU1tpXSA9IFg2NFdvcmQuY3JlYXRlKHJvdW5kQ29uc3RhbnRNc3csIHJvdW5kQ29uc3RhbnRMc3cpO1xufVxuXG4vLyBSZXVzYWJsZSBvYmplY3RzIGZvciB0ZW1wb3JhcnkgdmFsdWVzXG5jb25zdCBUID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDI1OyBpICs9IDEpIHtcbiAgVFtpXSA9IFg2NFdvcmQuY3JlYXRlKCk7XG59XG5cbi8qKlxuICogU0hBLTMgaGFzaCBhbGdvcml0aG0uXG4gKi9cbmV4cG9ydCBjbGFzcyBTSEEzQWxnbyBleHRlbmRzIEhhc2hlciB7XG4gIGNvbnN0cnVjdG9yKGNmZykge1xuICAgIC8qKlxuICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBvdXRwdXRMZW5ndGhcbiAgICAgKiAgIFRoZSBkZXNpcmVkIG51bWJlciBvZiBiaXRzIGluIHRoZSBvdXRwdXQgaGFzaC5cbiAgICAgKiAgIE9ubHkgdmFsdWVzIHBlcm1pdHRlZCBhcmU6IDIyNCwgMjU2LCAzODQsIDUxMi5cbiAgICAgKiAgIERlZmF1bHQ6IDUxMlxuICAgICAqL1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oXG4gICAgICB7IG91dHB1dExlbmd0aDogNTEyIH0sXG4gICAgICBjZmcsXG4gICAgKSk7XG4gIH1cblxuICBfZG9SZXNldCgpIHtcbiAgICB0aGlzLl9zdGF0ZSA9IFtdO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTsgaSArPSAxKSB7XG4gICAgICBzdGF0ZVtpXSA9IG5ldyBYNjRXb3JkKCk7XG4gICAgfVxuXG4gICAgdGhpcy5ibG9ja1NpemUgPSAoMTYwMCAtIDIgKiB0aGlzLmNmZy5vdXRwdXRMZW5ndGgpIC8gMzI7XG4gIH1cblxuICBfZG9Qcm9jZXNzQmxvY2soTSwgb2Zmc2V0KSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBjb25zdCBuQmxvY2tTaXplTGFuZXMgPSB0aGlzLmJsb2NrU2l6ZSAvIDI7XG5cbiAgICAvLyBBYnNvcmJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5CbG9ja1NpemVMYW5lczsgaSArPSAxKSB7XG4gICAgICAvLyBTaG9ydGN1dHNcbiAgICAgIGxldCBNMmkgPSBNW29mZnNldCArIDIgKiBpXTtcbiAgICAgIGxldCBNMmkxID0gTVtvZmZzZXQgKyAyICogaSArIDFdO1xuXG4gICAgICAvLyBTd2FwIGVuZGlhblxuICAgICAgTTJpID0gKCgoTTJpIDw8IDgpIHwgKE0yaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpXG4gICAgICAgIHwgKCgoTTJpIDw8IDI0KSB8IChNMmkgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuICAgICAgTTJpMSA9ICgoKE0yaTEgPDwgOCkgfCAoTTJpMSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpXG4gICAgICAgIHwgKCgoTTJpMSA8PCAyNCkgfCAoTTJpMSA+Pj4gOCkpICYgMHhmZjAwZmYwMCk7XG5cbiAgICAgIC8vIEFic29yYiBtZXNzYWdlIGludG8gc3RhdGVcbiAgICAgIGNvbnN0IGxhbmUgPSBzdGF0ZVtpXTtcbiAgICAgIGxhbmUuaGlnaCBePSBNMmkxO1xuICAgICAgbGFuZS5sb3cgXj0gTTJpO1xuICAgIH1cblxuICAgIC8vIFJvdW5kc1xuICAgIGZvciAobGV0IHJvdW5kID0gMDsgcm91bmQgPCAyNDsgcm91bmQgKz0gMSkge1xuICAgICAgLy8gVGhldGFcbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNTsgeCArPSAxKSB7XG4gICAgICAgIC8vIE1peCBjb2x1bW4gbGFuZXNcbiAgICAgICAgbGV0IHRNc3cgPSAwO1xuICAgICAgICBsZXQgdExzdyA9IDA7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTsgeSArPSAxKSB7XG4gICAgICAgICAgY29uc3QgbGFuZSA9IHN0YXRlW3ggKyA1ICogeV07XG4gICAgICAgICAgdE1zdyBePSBsYW5lLmhpZ2g7XG4gICAgICAgICAgdExzdyBePSBsYW5lLmxvdztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRlbXBvcmFyeSB2YWx1ZXNcbiAgICAgICAgY29uc3QgVHggPSBUW3hdO1xuICAgICAgICBUeC5oaWdoID0gdE1zdztcbiAgICAgICAgVHgubG93ID0gdExzdztcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgNTsgeCArPSAxKSB7XG4gICAgICAgIC8vIFNob3J0Y3V0c1xuICAgICAgICBjb25zdCBUeDQgPSBUWyh4ICsgNCkgJSA1XTtcbiAgICAgICAgY29uc3QgVHgxID0gVFsoeCArIDEpICUgNV07XG4gICAgICAgIGNvbnN0IFR4MU1zdyA9IFR4MS5oaWdoO1xuICAgICAgICBjb25zdCBUeDFMc3cgPSBUeDEubG93O1xuXG4gICAgICAgIC8vIE1peCBzdXJyb3VuZGluZyBjb2x1bW5zXG4gICAgICAgIGNvbnN0IHRNc3cgPSBUeDQuaGlnaCBeICgoVHgxTXN3IDw8IDEpIHwgKFR4MUxzdyA+Pj4gMzEpKTtcbiAgICAgICAgY29uc3QgdExzdyA9IFR4NC5sb3cgXiAoKFR4MUxzdyA8PCAxKSB8IChUeDFNc3cgPj4+IDMxKSk7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTsgeSArPSAxKSB7XG4gICAgICAgICAgY29uc3QgbGFuZSA9IHN0YXRlW3ggKyA1ICogeV07XG4gICAgICAgICAgbGFuZS5oaWdoIF49IHRNc3c7XG4gICAgICAgICAgbGFuZS5sb3cgXj0gdExzdztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBSaG8gUGlcbiAgICAgIGZvciAobGV0IGxhbmVJbmRleCA9IDE7IGxhbmVJbmRleCA8IDI1OyBsYW5lSW5kZXggKz0gMSkge1xuICAgICAgICBsZXQgdE1zdztcbiAgICAgICAgbGV0IHRMc3c7XG5cbiAgICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICAgIGNvbnN0IGxhbmUgPSBzdGF0ZVtsYW5lSW5kZXhdO1xuICAgICAgICBjb25zdCBsYW5lTXN3ID0gbGFuZS5oaWdoO1xuICAgICAgICBjb25zdCBsYW5lTHN3ID0gbGFuZS5sb3c7XG4gICAgICAgIGNvbnN0IHJob09mZnNldCA9IFJIT19PRkZTRVRTW2xhbmVJbmRleF07XG5cbiAgICAgICAgLy8gUm90YXRlIGxhbmVzXG4gICAgICAgIGlmIChyaG9PZmZzZXQgPCAzMikge1xuICAgICAgICAgIHRNc3cgPSAobGFuZU1zdyA8PCByaG9PZmZzZXQpIHwgKGxhbmVMc3cgPj4+ICgzMiAtIHJob09mZnNldCkpO1xuICAgICAgICAgIHRMc3cgPSAobGFuZUxzdyA8PCByaG9PZmZzZXQpIHwgKGxhbmVNc3cgPj4+ICgzMiAtIHJob09mZnNldCkpO1xuICAgICAgICB9IGVsc2UgLyogaWYgKHJob09mZnNldCA+PSAzMikgKi8ge1xuICAgICAgICAgIHRNc3cgPSAobGFuZUxzdyA8PCAocmhvT2Zmc2V0IC0gMzIpKSB8IChsYW5lTXN3ID4+PiAoNjQgLSByaG9PZmZzZXQpKTtcbiAgICAgICAgICB0THN3ID0gKGxhbmVNc3cgPDwgKHJob09mZnNldCAtIDMyKSkgfCAobGFuZUxzdyA+Pj4gKDY0IC0gcmhvT2Zmc2V0KSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFuc3Bvc2UgbGFuZXNcbiAgICAgICAgY29uc3QgVFBpTGFuZSA9IFRbUElfSU5ERVhFU1tsYW5lSW5kZXhdXTtcbiAgICAgICAgVFBpTGFuZS5oaWdoID0gdE1zdztcbiAgICAgICAgVFBpTGFuZS5sb3cgPSB0THN3O1xuICAgICAgfVxuXG4gICAgICAvLyBSaG8gcGkgYXQgeCA9IHkgPSAwXG4gICAgICBjb25zdCBUMCA9IFRbMF07XG4gICAgICBjb25zdCBzdGF0ZTAgPSBzdGF0ZVswXTtcbiAgICAgIFQwLmhpZ2ggPSBzdGF0ZTAuaGlnaDtcbiAgICAgIFQwLmxvdyA9IHN0YXRlMC5sb3c7XG5cbiAgICAgIC8vIENoaVxuICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCA1OyB4ICs9IDEpIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1OyB5ICs9IDEpIHtcbiAgICAgICAgICAvLyBTaG9ydGN1dHNcbiAgICAgICAgICBjb25zdCBsYW5lSW5kZXggPSB4ICsgNSAqIHk7XG4gICAgICAgICAgY29uc3QgbGFuZSA9IHN0YXRlW2xhbmVJbmRleF07XG4gICAgICAgICAgY29uc3QgVExhbmUgPSBUW2xhbmVJbmRleF07XG4gICAgICAgICAgY29uc3QgVHgxTGFuZSA9IFRbKCh4ICsgMSkgJSA1KSArIDUgKiB5XTtcbiAgICAgICAgICBjb25zdCBUeDJMYW5lID0gVFsoKHggKyAyKSAlIDUpICsgNSAqIHldO1xuXG4gICAgICAgICAgLy8gTWl4IHJvd3NcbiAgICAgICAgICBsYW5lLmhpZ2ggPSBUTGFuZS5oaWdoIF4gKH5UeDFMYW5lLmhpZ2ggJiBUeDJMYW5lLmhpZ2gpO1xuICAgICAgICAgIGxhbmUubG93ID0gVExhbmUubG93IF4gKH5UeDFMYW5lLmxvdyAmIFR4MkxhbmUubG93KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJb3RhXG4gICAgICBjb25zdCBsYW5lID0gc3RhdGVbMF07XG4gICAgICBjb25zdCByb3VuZENvbnN0YW50ID0gUk9VTkRfQ09OU1RBTlRTW3JvdW5kXTtcbiAgICAgIGxhbmUuaGlnaCBePSByb3VuZENvbnN0YW50LmhpZ2g7XG4gICAgICBsYW5lLmxvdyBePSByb3VuZENvbnN0YW50LmxvdztcbiAgICB9XG4gIH1cblxuICBfZG9GaW5hbGl6ZSgpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZGF0YTtcbiAgICBjb25zdCBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuICAgIGNvbnN0IG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuICAgIGNvbnN0IGJsb2NrU2l6ZUJpdHMgPSB0aGlzLmJsb2NrU2l6ZSAqIDMyO1xuXG4gICAgLy8gQWRkIHBhZGRpbmdcbiAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDEgPDwgKDI0IC0gKG5CaXRzTGVmdCAlIDMyKSk7XG4gICAgZGF0YVdvcmRzWygoTWF0aC5jZWlsKChuQml0c0xlZnQgKyAxKSAvIGJsb2NrU2l6ZUJpdHMpICogYmxvY2tTaXplQml0cykgPj4+IDUpIC0gMV0gfD0gMHg4MDtcbiAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cbiAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgY29uc3Qgb3V0cHV0TGVuZ3RoQnl0ZXMgPSB0aGlzLmNmZy5vdXRwdXRMZW5ndGggLyA4O1xuICAgIGNvbnN0IG91dHB1dExlbmd0aExhbmVzID0gb3V0cHV0TGVuZ3RoQnl0ZXMgLyA4O1xuXG4gICAgLy8gU3F1ZWV6ZVxuICAgIGNvbnN0IGhhc2hXb3JkcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0TGVuZ3RoTGFuZXM7IGkgKz0gMSkge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICBjb25zdCBsYW5lID0gc3RhdGVbaV07XG4gICAgICBsZXQgbGFuZU1zdyA9IGxhbmUuaGlnaDtcbiAgICAgIGxldCBsYW5lTHN3ID0gbGFuZS5sb3c7XG5cbiAgICAgIC8vIFN3YXAgZW5kaWFuXG4gICAgICBsYW5lTXN3ID0gKCgobGFuZU1zdyA8PCA4KSB8IChsYW5lTXN3ID4+PiAyNCkpICYgMHgwMGZmMDBmZilcbiAgICAgICAgfCAoKChsYW5lTXN3IDw8IDI0KSB8IChsYW5lTXN3ID4+PiA4KSkgJiAweGZmMDBmZjAwKTtcbiAgICAgIGxhbmVMc3cgPSAoKChsYW5lTHN3IDw8IDgpIHwgKGxhbmVMc3cgPj4+IDI0KSkgJiAweDAwZmYwMGZmKVxuICAgICAgICB8ICgoKGxhbmVMc3cgPDwgMjQpIHwgKGxhbmVMc3cgPj4+IDgpKSAmIDB4ZmYwMGZmMDApO1xuXG4gICAgICAvLyBTcXVlZXplIHN0YXRlIHRvIHJldHJpZXZlIGhhc2hcbiAgICAgIGhhc2hXb3Jkcy5wdXNoKGxhbmVMc3cpO1xuICAgICAgaGFzaFdvcmRzLnB1c2gobGFuZU1zdyk7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcbiAgICByZXR1cm4gbmV3IFdvcmRBcnJheShoYXNoV29yZHMsIG91dHB1dExlbmd0aEJ5dGVzKTtcbiAgfVxuXG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gc3VwZXIuY2xvbmUuY2FsbCh0aGlzKTtcblxuICAgIGNsb25lLl9zdGF0ZSA9IHRoaXMuX3N0YXRlLnNsaWNlKDApO1xuICAgIGNvbnN0IHN0YXRlID0gY2xvbmUuX3N0YXRlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjU7IGkgKz0gMSkge1xuICAgICAgc3RhdGVbaV0gPSBzdGF0ZVtpXS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBjbG9uZTtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMygnbWVzc2FnZScpO1xuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMyh3b3JkQXJyYXkpO1xuICovXG5leHBvcnQgY29uc3QgU0hBMyA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTNBbGdvKTtcblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEzKG1lc3NhZ2UsIGtleSk7XG4gKi9cbmV4cG9ydCBjb25zdCBIbWFjU0hBMyA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEzQWxnbyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha3.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha384.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha384.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SHA384Algo\": function() { return /* binding */ SHA384Algo; },\n/* harmony export */   \"SHA384\": function() { return /* binding */ SHA384; },\n/* harmony export */   \"HmacSHA384\": function() { return /* binding */ HmacSHA384; }\n/* harmony export */ });\n/* harmony import */ var _x64_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x64-core.js */ \"./node_modules/crypto-es/lib/x64-core.js\");\n/* harmony import */ var _sha512_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha512.js */ \"./node_modules/crypto-es/lib/sha512.js\");\n\n\n\n/**\n * SHA-384 hash algorithm.\n */\nclass SHA384Algo extends _sha512_js__WEBPACK_IMPORTED_MODULE_1__.SHA512Algo {\n  _doReset() {\n    this._hash = new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__.X64WordArray([\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__.X64Word(0xcbbb9d5d, 0xc1059ed8),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__.X64Word(0x629a292a, 0x367cd507),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__.X64Word(0x9159015a, 0x3070dd17),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__.X64Word(0x152fecd8, 0xf70e5939),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__.X64Word(0x67332667, 0xffc00b31),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__.X64Word(0x8eb44a87, 0x68581511),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__.X64Word(0xdb0c2e0d, 0x64f98fa7),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_0__.X64Word(0x47b5481d, 0xbefa4fa4),\n    ]);\n  }\n\n  _doFinalize() {\n    const hash = super._doFinalize.call(this);\n\n    hash.sigBytes -= 16;\n\n    return hash;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA384('message');\n *     var hash = CryptoJS.SHA384(wordArray);\n */\nconst SHA384 = _sha512_js__WEBPACK_IMPORTED_MODULE_1__.SHA512Algo._createHelper(SHA384Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA384(message, key);\n */\nconst HmacSHA384 = _sha512_js__WEBPACK_IMPORTED_MODULE_1__.SHA512Algo._createHmacHelper(SHA384Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhMzg0LmpzPzY1NWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFHdUI7QUFDa0I7O0FBRXpDO0FBQ0E7QUFDQTtBQUNPLHlCQUF5QixrREFBVTtBQUMxQztBQUNBLHFCQUFxQixzREFBWTtBQUNqQyxVQUFVLGlEQUFPO0FBQ2pCLFVBQVUsaURBQU87QUFDakIsVUFBVSxpREFBTztBQUNqQixVQUFVLGlEQUFPO0FBQ2pCLFVBQVUsaURBQU87QUFDakIsVUFBVSxpREFBTztBQUNqQixVQUFVLGlEQUFPO0FBQ2pCLFVBQVUsaURBQU87QUFDakI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZUFBZSxnRUFBd0I7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sbUJBQW1CLG9FQUE0QiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3NoYTM4NC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIFg2NFdvcmQsXG4gIFg2NFdvcmRBcnJheSxcbn0gZnJvbSAnLi94NjQtY29yZS5qcyc7XG5pbXBvcnQgeyBTSEE1MTJBbGdvIH0gZnJvbSAnLi9zaGE1MTIuanMnO1xuXG4vKipcbiAqIFNIQS0zODQgaGFzaCBhbGdvcml0aG0uXG4gKi9cbmV4cG9ydCBjbGFzcyBTSEEzODRBbGdvIGV4dGVuZHMgU0hBNTEyQWxnbyB7XG4gIF9kb1Jlc2V0KCkge1xuICAgIHRoaXMuX2hhc2ggPSBuZXcgWDY0V29yZEFycmF5KFtcbiAgICAgIG5ldyBYNjRXb3JkKDB4Y2JiYjlkNWQsIDB4YzEwNTllZDgpLFxuICAgICAgbmV3IFg2NFdvcmQoMHg2MjlhMjkyYSwgMHgzNjdjZDUwNyksXG4gICAgICBuZXcgWDY0V29yZCgweDkxNTkwMTVhLCAweDMwNzBkZDE3KSxcbiAgICAgIG5ldyBYNjRXb3JkKDB4MTUyZmVjZDgsIDB4ZjcwZTU5MzkpLFxuICAgICAgbmV3IFg2NFdvcmQoMHg2NzMzMjY2NywgMHhmZmMwMGIzMSksXG4gICAgICBuZXcgWDY0V29yZCgweDhlYjQ0YTg3LCAweDY4NTgxNTExKSxcbiAgICAgIG5ldyBYNjRXb3JkKDB4ZGIwYzJlMGQsIDB4NjRmOThmYTcpLFxuICAgICAgbmV3IFg2NFdvcmQoMHg0N2I1NDgxZCwgMHhiZWZhNGZhNCksXG4gICAgXSk7XG4gIH1cblxuICBfZG9GaW5hbGl6ZSgpIHtcbiAgICBjb25zdCBoYXNoID0gc3VwZXIuX2RvRmluYWxpemUuY2FsbCh0aGlzKTtcblxuICAgIGhhc2guc2lnQnl0ZXMgLT0gMTY7XG5cbiAgICByZXR1cm4gaGFzaDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuICpcbiAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG4gKlxuICogQHN0YXRpY1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMzg0KCdtZXNzYWdlJyk7XG4gKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEzODQod29yZEFycmF5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IFNIQTM4NCA9IFNIQTUxMkFsZ28uX2NyZWF0ZUhlbHBlcihTSEEzODRBbGdvKTtcblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEEzODQobWVzc2FnZSwga2V5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IEhtYWNTSEEzODQgPSBTSEE1MTJBbGdvLl9jcmVhdGVIbWFjSGVscGVyKFNIQTM4NEFsZ28pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha384.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/sha512.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-es/lib/sha512.js ***!
  \**********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"SHA512Algo\": function() { return /* binding */ SHA512Algo; },\n/* harmony export */   \"SHA512\": function() { return /* binding */ SHA512; },\n/* harmony export */   \"HmacSHA512\": function() { return /* binding */ HmacSHA512; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _x64_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./x64-core.js */ \"./node_modules/crypto-es/lib/x64-core.js\");\n\n\n\n// Constants\nconst K = [\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x428a2f98, 0xd728ae22),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x71374491, 0x23ef65cd),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xb5c0fbcf, 0xec4d3b2f),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xe9b5dba5, 0x8189dbbc),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x3956c25b, 0xf348b538),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x59f111f1, 0xb605d019),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x923f82a4, 0xaf194f9b),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xab1c5ed5, 0xda6d8118),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xd807aa98, 0xa3030242),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x12835b01, 0x45706fbe),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x243185be, 0x4ee4b28c),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x550c7dc3, 0xd5ffb4e2),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x72be5d74, 0xf27b896f),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x80deb1fe, 0x3b1696b1),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x9bdc06a7, 0x25c71235),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xc19bf174, 0xcf692694),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xe49b69c1, 0x9ef14ad2),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xefbe4786, 0x384f25e3),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x0fc19dc6, 0x8b8cd5b5),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x240ca1cc, 0x77ac9c65),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x2de92c6f, 0x592b0275),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x4a7484aa, 0x6ea6e483),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x5cb0a9dc, 0xbd41fbd4),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x76f988da, 0x831153b5),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x983e5152, 0xee66dfab),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xa831c66d, 0x2db43210),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xb00327c8, 0x98fb213f),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xbf597fc7, 0xbeef0ee4),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xc6e00bf3, 0x3da88fc2),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xd5a79147, 0x930aa725),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x06ca6351, 0xe003826f),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x14292967, 0x0a0e6e70),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x27b70a85, 0x46d22ffc),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x2e1b2138, 0x5c26c926),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x4d2c6dfc, 0x5ac42aed),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x53380d13, 0x9d95b3df),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x650a7354, 0x8baf63de),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x766a0abb, 0x3c77b2a8),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x81c2c92e, 0x47edaee6),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x92722c85, 0x1482353b),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xa2bfe8a1, 0x4cf10364),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xa81a664b, 0xbc423001),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xc24b8b70, 0xd0f89791),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xc76c51a3, 0x0654be30),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xd192e819, 0xd6ef5218),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xd6990624, 0x5565a910),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xf40e3585, 0x5771202a),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x106aa070, 0x32bbd1b8),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x19a4c116, 0xb8d2d0c8),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x1e376c08, 0x5141ab53),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x2748774c, 0xdf8eeb99),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x34b0bcb5, 0xe19b48a8),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x391c0cb3, 0xc5c95a63),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x4ed8aa4a, 0xe3418acb),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x5b9cca4f, 0x7763e373),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x682e6ff3, 0xd6b2b8a3),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x748f82ee, 0x5defb2fc),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x78a5636f, 0x43172f60),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x84c87814, 0xa1f0ab72),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x8cc70208, 0x1a6439ec),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x90befffa, 0x23631e28),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xa4506ceb, 0xde82bde9),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xbef9a3f7, 0xb2c67915),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xc67178f2, 0xe372532b),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xca273ece, 0xea26619c),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xd186b8c7, 0x21c0c207),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xeada7dd6, 0xcde0eb1e),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xf57d4f7f, 0xee6ed178),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x06f067aa, 0x72176fba),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x0a637dc5, 0xa2c898a6),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x113f9804, 0xbef90dae),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x1b710b35, 0x131c471b),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x28db77f5, 0x23047d84),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x32caab7b, 0x40c72493),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x3c9ebe0a, 0x15c9bebc),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x431d67c4, 0x9c100d4c),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x4cc5d4be, 0xcb3e42b6),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x597f299c, 0xfc657e2a),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x5fcb6fab, 0x3ad6faec),\n  new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x6c44198c, 0x4a475817),\n];\n\n// Reusable objects\nconst W = [];\nfor (let i = 0; i < 80; i += 1) {\n  W[i] = new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word();\n}\n\n/**\n * SHA-512 hash algorithm.\n */\nclass SHA512Algo extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher {\n  constructor() {\n    super();\n\n    this.blockSize = 1024 / 32;\n  }\n\n  _doReset() {\n    this._hash = new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64WordArray([\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x6a09e667, 0xf3bcc908),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xbb67ae85, 0x84caa73b),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x3c6ef372, 0xfe94f82b),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0xa54ff53a, 0x5f1d36f1),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x510e527f, 0xade682d1),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x9b05688c, 0x2b3e6c1f),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x1f83d9ab, 0xfb41bd6b),\n      new _x64_core_js__WEBPACK_IMPORTED_MODULE_1__.X64Word(0x5be0cd19, 0x137e2179),\n    ]);\n  }\n\n  _doProcessBlock(M, offset) {\n    // Shortcuts\n    const H = this._hash.words;\n\n    const H0 = H[0];\n    const H1 = H[1];\n    const H2 = H[2];\n    const H3 = H[3];\n    const H4 = H[4];\n    const H5 = H[5];\n    const H6 = H[6];\n    const H7 = H[7];\n\n    const H0h = H0.high;\n    let H0l = H0.low;\n    const H1h = H1.high;\n    let H1l = H1.low;\n    const H2h = H2.high;\n    let H2l = H2.low;\n    const H3h = H3.high;\n    let H3l = H3.low;\n    const H4h = H4.high;\n    let H4l = H4.low;\n    const H5h = H5.high;\n    let H5l = H5.low;\n    const H6h = H6.high;\n    let H6l = H6.low;\n    const H7h = H7.high;\n    let H7l = H7.low;\n\n    // Working variables\n    let ah = H0h;\n    let al = H0l;\n    let bh = H1h;\n    let bl = H1l;\n    let ch = H2h;\n    let cl = H2l;\n    let dh = H3h;\n    let dl = H3l;\n    let eh = H4h;\n    let el = H4l;\n    let fh = H5h;\n    let fl = H5l;\n    let gh = H6h;\n    let gl = H6l;\n    let hh = H7h;\n    let hl = H7l;\n\n    // Rounds\n    for (let i = 0; i < 80; i += 1) {\n      let Wil;\n      let Wih;\n\n      // Shortcut\n      const Wi = W[i];\n\n      // Extend message\n      if (i < 16) {\n        Wi.high = M[offset + i * 2] | 0;\n        Wih = Wi.high;\n        Wi.low = M[offset + i * 2 + 1] | 0;\n        Wil = Wi.low;\n      } else {\n        // Gamma0\n        const gamma0x = W[i - 15];\n        const gamma0xh = gamma0x.high;\n        const gamma0xl = gamma0x.low;\n        const gamma0h = ((gamma0xh >>> 1) | (gamma0xl << 31))\n          ^ ((gamma0xh >>> 8) | (gamma0xl << 24))\n          ^ (gamma0xh >>> 7);\n        const gamma0l = ((gamma0xl >>> 1) | (gamma0xh << 31))\n          ^ ((gamma0xl >>> 8) | (gamma0xh << 24))\n          ^ ((gamma0xl >>> 7) | (gamma0xh << 25));\n\n        // Gamma1\n        const gamma1x = W[i - 2];\n        const gamma1xh = gamma1x.high;\n        const gamma1xl = gamma1x.low;\n        const gamma1h = ((gamma1xh >>> 19) | (gamma1xl << 13))\n          ^ ((gamma1xh << 3) | (gamma1xl >>> 29))\n          ^ (gamma1xh >>> 6);\n        const gamma1l = ((gamma1xl >>> 19) | (gamma1xh << 13))\n          ^ ((gamma1xl << 3) | (gamma1xh >>> 29))\n          ^ ((gamma1xl >>> 6) | (gamma1xh << 26));\n\n        // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]\n        const Wi7 = W[i - 7];\n        const Wi7h = Wi7.high;\n        const Wi7l = Wi7.low;\n\n        const Wi16 = W[i - 16];\n        const Wi16h = Wi16.high;\n        const Wi16l = Wi16.low;\n\n        Wil = gamma0l + Wi7l;\n        Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);\n        Wil += gamma1l;\n        Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);\n        Wil += Wi16l;\n        Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);\n\n        Wi.high = Wih;\n        Wi.low = Wil;\n      }\n\n      const chh = (eh & fh) ^ (~eh & gh);\n      const chl = (el & fl) ^ (~el & gl);\n      const majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);\n      const majl = (al & bl) ^ (al & cl) ^ (bl & cl);\n\n      const sigma0h = ((ah >>> 28) | (al << 4))\n        ^ ((ah << 30) | (al >>> 2))\n        ^ ((ah << 25) | (al >>> 7));\n      const sigma0l = ((al >>> 28) | (ah << 4))\n        ^ ((al << 30) | (ah >>> 2))\n        ^ ((al << 25) | (ah >>> 7));\n      const sigma1h = ((eh >>> 14) | (el << 18))\n        ^ ((eh >>> 18) | (el << 14))\n        ^ ((eh << 23) | (el >>> 9));\n      const sigma1l = ((el >>> 14) | (eh << 18))\n        ^ ((el >>> 18) | (eh << 14))\n        ^ ((el << 23) | (eh >>> 9));\n\n      // t1 = h + sigma1 + ch + K[i] + W[i]\n      const Ki = K[i];\n      const Kih = Ki.high;\n      const Kil = Ki.low;\n\n      let t1l = hl + sigma1l;\n      let t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);\n      t1l += chl;\n      t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);\n      t1l += Kil;\n      t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);\n      t1l += Wil;\n      t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);\n\n      // t2 = sigma0 + maj\n      const t2l = sigma0l + majl;\n      const t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);\n\n      // Update working variables\n      hh = gh;\n      hl = gl;\n      gh = fh;\n      gl = fl;\n      fh = eh;\n      fl = el;\n      el = (dl + t1l) | 0;\n      eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;\n      dh = ch;\n      dl = cl;\n      ch = bh;\n      cl = bl;\n      bh = ah;\n      bl = al;\n      al = (t1l + t2l) | 0;\n      ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;\n    }\n\n    // Intermediate hash value\n    H0.low = (H0l + al);\n    H0l = H0.low;\n    H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));\n    H1.low = (H1l + bl);\n    H1l = H1.low;\n    H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));\n    H2.low = (H2l + cl);\n    H2l = H2.low;\n    H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));\n    H3.low = (H3l + dl);\n    H3l = H3.low;\n    H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));\n    H4.low = (H4l + el);\n    H4l = H4.low;\n    H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));\n    H5.low = (H5l + fl);\n    H5l = H5.low;\n    H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));\n    H6.low = (H6l + gl);\n    H6l = H6.low;\n    H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));\n    H7.low = (H7l + hl);\n    H7l = H7.low;\n    H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));\n  }\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n    dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);\n    dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;\n    data.sigBytes = dataWords.length * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Convert hash to 32-bit word array before returning\n    const hash = this._hash.toX32();\n\n    // Return final computed hash\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.SHA512('message');\n *     var hash = CryptoJS.SHA512(wordArray);\n */\nconst SHA512 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHelper(SHA512Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacSHA512(message, key);\n */\nconst HmacSHA512 = _core_js__WEBPACK_IMPORTED_MODULE_0__.Hasher._createHmacHelper(SHA512Algo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvc2hhNTEyLmpzPzE3NDIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUM7QUFJWjs7QUFFdkI7QUFDQTtBQUNBLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2IsTUFBTSxpREFBTztBQUNiLE1BQU0saURBQU87QUFDYixNQUFNLGlEQUFPO0FBQ2I7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixhQUFhLGlEQUFPO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNPLHlCQUF5Qiw0Q0FBTTtBQUN0QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsc0RBQVk7QUFDakMsVUFBVSxpREFBTztBQUNqQixVQUFVLGlEQUFPO0FBQ2pCLFVBQVUsaURBQU87QUFDakIsVUFBVSxpREFBTztBQUNqQixVQUFVLGlEQUFPO0FBQ2pCLFVBQVUsaURBQU87QUFDakIsVUFBVSxpREFBTztBQUNqQixVQUFVLGlEQUFPO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGVBQWUsMERBQW9COztBQUUxQztBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG1CQUFtQiw4REFBd0IiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi9zaGE1MTIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIYXNoZXIgfSBmcm9tICcuL2NvcmUuanMnO1xuaW1wb3J0IHtcbiAgWDY0V29yZCxcbiAgWDY0V29yZEFycmF5LFxufSBmcm9tICcuL3g2NC1jb3JlLmpzJztcblxuLy8gQ29uc3RhbnRzXG5jb25zdCBLID0gW1xuICBuZXcgWDY0V29yZCgweDQyOGEyZjk4LCAweGQ3MjhhZTIyKSxcbiAgbmV3IFg2NFdvcmQoMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCksXG4gIG5ldyBYNjRXb3JkKDB4YjVjMGZiY2YsIDB4ZWM0ZDNiMmYpLFxuICBuZXcgWDY0V29yZCgweGU5YjVkYmE1LCAweDgxODlkYmJjKSxcbiAgbmV3IFg2NFdvcmQoMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCksXG4gIG5ldyBYNjRXb3JkKDB4NTlmMTExZjEsIDB4YjYwNWQwMTkpLFxuICBuZXcgWDY0V29yZCgweDkyM2Y4MmE0LCAweGFmMTk0ZjliKSxcbiAgbmV3IFg2NFdvcmQoMHhhYjFjNWVkNSwgMHhkYTZkODExOCksXG4gIG5ldyBYNjRXb3JkKDB4ZDgwN2FhOTgsIDB4YTMwMzAyNDIpLFxuICBuZXcgWDY0V29yZCgweDEyODM1YjAxLCAweDQ1NzA2ZmJlKSxcbiAgbmV3IFg2NFdvcmQoMHgyNDMxODViZSwgMHg0ZWU0YjI4YyksXG4gIG5ldyBYNjRXb3JkKDB4NTUwYzdkYzMsIDB4ZDVmZmI0ZTIpLFxuICBuZXcgWDY0V29yZCgweDcyYmU1ZDc0LCAweGYyN2I4OTZmKSxcbiAgbmV3IFg2NFdvcmQoMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSksXG4gIG5ldyBYNjRXb3JkKDB4OWJkYzA2YTcsIDB4MjVjNzEyMzUpLFxuICBuZXcgWDY0V29yZCgweGMxOWJmMTc0LCAweGNmNjkyNjk0KSxcbiAgbmV3IFg2NFdvcmQoMHhlNDliNjljMSwgMHg5ZWYxNGFkMiksXG4gIG5ldyBYNjRXb3JkKDB4ZWZiZTQ3ODYsIDB4Mzg0ZjI1ZTMpLFxuICBuZXcgWDY0V29yZCgweDBmYzE5ZGM2LCAweDhiOGNkNWI1KSxcbiAgbmV3IFg2NFdvcmQoMHgyNDBjYTFjYywgMHg3N2FjOWM2NSksXG4gIG5ldyBYNjRXb3JkKDB4MmRlOTJjNmYsIDB4NTkyYjAyNzUpLFxuICBuZXcgWDY0V29yZCgweDRhNzQ4NGFhLCAweDZlYTZlNDgzKSxcbiAgbmV3IFg2NFdvcmQoMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCksXG4gIG5ldyBYNjRXb3JkKDB4NzZmOTg4ZGEsIDB4ODMxMTUzYjUpLFxuICBuZXcgWDY0V29yZCgweDk4M2U1MTUyLCAweGVlNjZkZmFiKSxcbiAgbmV3IFg2NFdvcmQoMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCksXG4gIG5ldyBYNjRXb3JkKDB4YjAwMzI3YzgsIDB4OThmYjIxM2YpLFxuICBuZXcgWDY0V29yZCgweGJmNTk3ZmM3LCAweGJlZWYwZWU0KSxcbiAgbmV3IFg2NFdvcmQoMHhjNmUwMGJmMywgMHgzZGE4OGZjMiksXG4gIG5ldyBYNjRXb3JkKDB4ZDVhNzkxNDcsIDB4OTMwYWE3MjUpLFxuICBuZXcgWDY0V29yZCgweDA2Y2E2MzUxLCAweGUwMDM4MjZmKSxcbiAgbmV3IFg2NFdvcmQoMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCksXG4gIG5ldyBYNjRXb3JkKDB4MjdiNzBhODUsIDB4NDZkMjJmZmMpLFxuICBuZXcgWDY0V29yZCgweDJlMWIyMTM4LCAweDVjMjZjOTI2KSxcbiAgbmV3IFg2NFdvcmQoMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCksXG4gIG5ldyBYNjRXb3JkKDB4NTMzODBkMTMsIDB4OWQ5NWIzZGYpLFxuICBuZXcgWDY0V29yZCgweDY1MGE3MzU0LCAweDhiYWY2M2RlKSxcbiAgbmV3IFg2NFdvcmQoMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCksXG4gIG5ldyBYNjRXb3JkKDB4ODFjMmM5MmUsIDB4NDdlZGFlZTYpLFxuICBuZXcgWDY0V29yZCgweDkyNzIyYzg1LCAweDE0ODIzNTNiKSxcbiAgbmV3IFg2NFdvcmQoMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCksXG4gIG5ldyBYNjRXb3JkKDB4YTgxYTY2NGIsIDB4YmM0MjMwMDEpLFxuICBuZXcgWDY0V29yZCgweGMyNGI4YjcwLCAweGQwZjg5NzkxKSxcbiAgbmV3IFg2NFdvcmQoMHhjNzZjNTFhMywgMHgwNjU0YmUzMCksXG4gIG5ldyBYNjRXb3JkKDB4ZDE5MmU4MTksIDB4ZDZlZjUyMTgpLFxuICBuZXcgWDY0V29yZCgweGQ2OTkwNjI0LCAweDU1NjVhOTEwKSxcbiAgbmV3IFg2NFdvcmQoMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSksXG4gIG5ldyBYNjRXb3JkKDB4MTA2YWEwNzAsIDB4MzJiYmQxYjgpLFxuICBuZXcgWDY0V29yZCgweDE5YTRjMTE2LCAweGI4ZDJkMGM4KSxcbiAgbmV3IFg2NFdvcmQoMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyksXG4gIG5ldyBYNjRXb3JkKDB4Mjc0ODc3NGMsIDB4ZGY4ZWViOTkpLFxuICBuZXcgWDY0V29yZCgweDM0YjBiY2I1LCAweGUxOWI0OGE4KSxcbiAgbmV3IFg2NFdvcmQoMHgzOTFjMGNiMywgMHhjNWM5NWE2MyksXG4gIG5ldyBYNjRXb3JkKDB4NGVkOGFhNGEsIDB4ZTM0MThhY2IpLFxuICBuZXcgWDY0V29yZCgweDViOWNjYTRmLCAweDc3NjNlMzczKSxcbiAgbmV3IFg2NFdvcmQoMHg2ODJlNmZmMywgMHhkNmIyYjhhMyksXG4gIG5ldyBYNjRXb3JkKDB4NzQ4ZjgyZWUsIDB4NWRlZmIyZmMpLFxuICBuZXcgWDY0V29yZCgweDc4YTU2MzZmLCAweDQzMTcyZjYwKSxcbiAgbmV3IFg2NFdvcmQoMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiksXG4gIG5ldyBYNjRXb3JkKDB4OGNjNzAyMDgsIDB4MWE2NDM5ZWMpLFxuICBuZXcgWDY0V29yZCgweDkwYmVmZmZhLCAweDIzNjMxZTI4KSxcbiAgbmV3IFg2NFdvcmQoMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSksXG4gIG5ldyBYNjRXb3JkKDB4YmVmOWEzZjcsIDB4YjJjNjc5MTUpLFxuICBuZXcgWDY0V29yZCgweGM2NzE3OGYyLCAweGUzNzI1MzJiKSxcbiAgbmV3IFg2NFdvcmQoMHhjYTI3M2VjZSwgMHhlYTI2NjE5YyksXG4gIG5ldyBYNjRXb3JkKDB4ZDE4NmI4YzcsIDB4MjFjMGMyMDcpLFxuICBuZXcgWDY0V29yZCgweGVhZGE3ZGQ2LCAweGNkZTBlYjFlKSxcbiAgbmV3IFg2NFdvcmQoMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCksXG4gIG5ldyBYNjRXb3JkKDB4MDZmMDY3YWEsIDB4NzIxNzZmYmEpLFxuICBuZXcgWDY0V29yZCgweDBhNjM3ZGM1LCAweGEyYzg5OGE2KSxcbiAgbmV3IFg2NFdvcmQoMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSksXG4gIG5ldyBYNjRXb3JkKDB4MWI3MTBiMzUsIDB4MTMxYzQ3MWIpLFxuICBuZXcgWDY0V29yZCgweDI4ZGI3N2Y1LCAweDIzMDQ3ZDg0KSxcbiAgbmV3IFg2NFdvcmQoMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyksXG4gIG5ldyBYNjRXb3JkKDB4M2M5ZWJlMGEsIDB4MTVjOWJlYmMpLFxuICBuZXcgWDY0V29yZCgweDQzMWQ2N2M0LCAweDljMTAwZDRjKSxcbiAgbmV3IFg2NFdvcmQoMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiksXG4gIG5ldyBYNjRXb3JkKDB4NTk3ZjI5OWMsIDB4ZmM2NTdlMmEpLFxuICBuZXcgWDY0V29yZCgweDVmY2I2ZmFiLCAweDNhZDZmYWVjKSxcbiAgbmV3IFg2NFdvcmQoMHg2YzQ0MTk4YywgMHg0YTQ3NTgxNyksXG5dO1xuXG4vLyBSZXVzYWJsZSBvYmplY3RzXG5jb25zdCBXID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IDgwOyBpICs9IDEpIHtcbiAgV1tpXSA9IG5ldyBYNjRXb3JkKCk7XG59XG5cbi8qKlxuICogU0hBLTUxMiBoYXNoIGFsZ29yaXRobS5cbiAqL1xuZXhwb3J0IGNsYXNzIFNIQTUxMkFsZ28gZXh0ZW5kcyBIYXNoZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5ibG9ja1NpemUgPSAxMDI0IC8gMzI7XG4gIH1cblxuICBfZG9SZXNldCgpIHtcbiAgICB0aGlzLl9oYXNoID0gbmV3IFg2NFdvcmRBcnJheShbXG4gICAgICBuZXcgWDY0V29yZCgweDZhMDllNjY3LCAweGYzYmNjOTA4KSxcbiAgICAgIG5ldyBYNjRXb3JkKDB4YmI2N2FlODUsIDB4ODRjYWE3M2IpLFxuICAgICAgbmV3IFg2NFdvcmQoMHgzYzZlZjM3MiwgMHhmZTk0ZjgyYiksXG4gICAgICBuZXcgWDY0V29yZCgweGE1NGZmNTNhLCAweDVmMWQzNmYxKSxcbiAgICAgIG5ldyBYNjRXb3JkKDB4NTEwZTUyN2YsIDB4YWRlNjgyZDEpLFxuICAgICAgbmV3IFg2NFdvcmQoMHg5YjA1Njg4YywgMHgyYjNlNmMxZiksXG4gICAgICBuZXcgWDY0V29yZCgweDFmODNkOWFiLCAweGZiNDFiZDZiKSxcbiAgICAgIG5ldyBYNjRXb3JkKDB4NWJlMGNkMTksIDB4MTM3ZTIxNzkpLFxuICAgIF0pO1xuICB9XG5cbiAgX2RvUHJvY2Vzc0Jsb2NrKE0sIG9mZnNldCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG4gICAgY29uc3QgSDAgPSBIWzBdO1xuICAgIGNvbnN0IEgxID0gSFsxXTtcbiAgICBjb25zdCBIMiA9IEhbMl07XG4gICAgY29uc3QgSDMgPSBIWzNdO1xuICAgIGNvbnN0IEg0ID0gSFs0XTtcbiAgICBjb25zdCBINSA9IEhbNV07XG4gICAgY29uc3QgSDYgPSBIWzZdO1xuICAgIGNvbnN0IEg3ID0gSFs3XTtcblxuICAgIGNvbnN0IEgwaCA9IEgwLmhpZ2g7XG4gICAgbGV0IEgwbCA9IEgwLmxvdztcbiAgICBjb25zdCBIMWggPSBIMS5oaWdoO1xuICAgIGxldCBIMWwgPSBIMS5sb3c7XG4gICAgY29uc3QgSDJoID0gSDIuaGlnaDtcbiAgICBsZXQgSDJsID0gSDIubG93O1xuICAgIGNvbnN0IEgzaCA9IEgzLmhpZ2g7XG4gICAgbGV0IEgzbCA9IEgzLmxvdztcbiAgICBjb25zdCBINGggPSBINC5oaWdoO1xuICAgIGxldCBINGwgPSBINC5sb3c7XG4gICAgY29uc3QgSDVoID0gSDUuaGlnaDtcbiAgICBsZXQgSDVsID0gSDUubG93O1xuICAgIGNvbnN0IEg2aCA9IEg2LmhpZ2g7XG4gICAgbGV0IEg2bCA9IEg2LmxvdztcbiAgICBjb25zdCBIN2ggPSBINy5oaWdoO1xuICAgIGxldCBIN2wgPSBINy5sb3c7XG5cbiAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuICAgIGxldCBhaCA9IEgwaDtcbiAgICBsZXQgYWwgPSBIMGw7XG4gICAgbGV0IGJoID0gSDFoO1xuICAgIGxldCBibCA9IEgxbDtcbiAgICBsZXQgY2ggPSBIMmg7XG4gICAgbGV0IGNsID0gSDJsO1xuICAgIGxldCBkaCA9IEgzaDtcbiAgICBsZXQgZGwgPSBIM2w7XG4gICAgbGV0IGVoID0gSDRoO1xuICAgIGxldCBlbCA9IEg0bDtcbiAgICBsZXQgZmggPSBINWg7XG4gICAgbGV0IGZsID0gSDVsO1xuICAgIGxldCBnaCA9IEg2aDtcbiAgICBsZXQgZ2wgPSBINmw7XG4gICAgbGV0IGhoID0gSDdoO1xuICAgIGxldCBobCA9IEg3bDtcblxuICAgIC8vIFJvdW5kc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkgKz0gMSkge1xuICAgICAgbGV0IFdpbDtcbiAgICAgIGxldCBXaWg7XG5cbiAgICAgIC8vIFNob3J0Y3V0XG4gICAgICBjb25zdCBXaSA9IFdbaV07XG5cbiAgICAgIC8vIEV4dGVuZCBtZXNzYWdlXG4gICAgICBpZiAoaSA8IDE2KSB7XG4gICAgICAgIFdpLmhpZ2ggPSBNW29mZnNldCArIGkgKiAyXSB8IDA7XG4gICAgICAgIFdpaCA9IFdpLmhpZ2g7XG4gICAgICAgIFdpLmxvdyA9IE1bb2Zmc2V0ICsgaSAqIDIgKyAxXSB8IDA7XG4gICAgICAgIFdpbCA9IFdpLmxvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEdhbW1hMFxuICAgICAgICBjb25zdCBnYW1tYTB4ID0gV1tpIC0gMTVdO1xuICAgICAgICBjb25zdCBnYW1tYTB4aCA9IGdhbW1hMHguaGlnaDtcbiAgICAgICAgY29uc3QgZ2FtbWEweGwgPSBnYW1tYTB4LmxvdztcbiAgICAgICAgY29uc3QgZ2FtbWEwaCA9ICgoZ2FtbWEweGggPj4+IDEpIHwgKGdhbW1hMHhsIDw8IDMxKSlcbiAgICAgICAgICBeICgoZ2FtbWEweGggPj4+IDgpIHwgKGdhbW1hMHhsIDw8IDI0KSlcbiAgICAgICAgICBeIChnYW1tYTB4aCA+Pj4gNyk7XG4gICAgICAgIGNvbnN0IGdhbW1hMGwgPSAoKGdhbW1hMHhsID4+PiAxKSB8IChnYW1tYTB4aCA8PCAzMSkpXG4gICAgICAgICAgXiAoKGdhbW1hMHhsID4+PiA4KSB8IChnYW1tYTB4aCA8PCAyNCkpXG4gICAgICAgICAgXiAoKGdhbW1hMHhsID4+PiA3KSB8IChnYW1tYTB4aCA8PCAyNSkpO1xuXG4gICAgICAgIC8vIEdhbW1hMVxuICAgICAgICBjb25zdCBnYW1tYTF4ID0gV1tpIC0gMl07XG4gICAgICAgIGNvbnN0IGdhbW1hMXhoID0gZ2FtbWExeC5oaWdoO1xuICAgICAgICBjb25zdCBnYW1tYTF4bCA9IGdhbW1hMXgubG93O1xuICAgICAgICBjb25zdCBnYW1tYTFoID0gKChnYW1tYTF4aCA+Pj4gMTkpIHwgKGdhbW1hMXhsIDw8IDEzKSlcbiAgICAgICAgICBeICgoZ2FtbWExeGggPDwgMykgfCAoZ2FtbWExeGwgPj4+IDI5KSlcbiAgICAgICAgICBeIChnYW1tYTF4aCA+Pj4gNik7XG4gICAgICAgIGNvbnN0IGdhbW1hMWwgPSAoKGdhbW1hMXhsID4+PiAxOSkgfCAoZ2FtbWExeGggPDwgMTMpKVxuICAgICAgICAgIF4gKChnYW1tYTF4bCA8PCAzKSB8IChnYW1tYTF4aCA+Pj4gMjkpKVxuICAgICAgICAgIF4gKChnYW1tYTF4bCA+Pj4gNikgfCAoZ2FtbWExeGggPDwgMjYpKTtcblxuICAgICAgICAvLyBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl1cbiAgICAgICAgY29uc3QgV2k3ID0gV1tpIC0gN107XG4gICAgICAgIGNvbnN0IFdpN2ggPSBXaTcuaGlnaDtcbiAgICAgICAgY29uc3QgV2k3bCA9IFdpNy5sb3c7XG5cbiAgICAgICAgY29uc3QgV2kxNiA9IFdbaSAtIDE2XTtcbiAgICAgICAgY29uc3QgV2kxNmggPSBXaTE2LmhpZ2g7XG4gICAgICAgIGNvbnN0IFdpMTZsID0gV2kxNi5sb3c7XG5cbiAgICAgICAgV2lsID0gZ2FtbWEwbCArIFdpN2w7XG4gICAgICAgIFdpaCA9IGdhbW1hMGggKyBXaTdoICsgKChXaWwgPj4+IDApIDwgKGdhbW1hMGwgPj4+IDApID8gMSA6IDApO1xuICAgICAgICBXaWwgKz0gZ2FtbWExbDtcbiAgICAgICAgV2loID0gV2loICsgZ2FtbWExaCArICgoV2lsID4+PiAwKSA8IChnYW1tYTFsID4+PiAwKSA/IDEgOiAwKTtcbiAgICAgICAgV2lsICs9IFdpMTZsO1xuICAgICAgICBXaWggPSBXaWggKyBXaTE2aCArICgoV2lsID4+PiAwKSA8IChXaTE2bCA+Pj4gMCkgPyAxIDogMCk7XG5cbiAgICAgICAgV2kuaGlnaCA9IFdpaDtcbiAgICAgICAgV2kubG93ID0gV2lsO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBjaGggPSAoZWggJiBmaCkgXiAofmVoICYgZ2gpO1xuICAgICAgY29uc3QgY2hsID0gKGVsICYgZmwpIF4gKH5lbCAmIGdsKTtcbiAgICAgIGNvbnN0IG1hamggPSAoYWggJiBiaCkgXiAoYWggJiBjaCkgXiAoYmggJiBjaCk7XG4gICAgICBjb25zdCBtYWpsID0gKGFsICYgYmwpIF4gKGFsICYgY2wpIF4gKGJsICYgY2wpO1xuXG4gICAgICBjb25zdCBzaWdtYTBoID0gKChhaCA+Pj4gMjgpIHwgKGFsIDw8IDQpKVxuICAgICAgICBeICgoYWggPDwgMzApIHwgKGFsID4+PiAyKSlcbiAgICAgICAgXiAoKGFoIDw8IDI1KSB8IChhbCA+Pj4gNykpO1xuICAgICAgY29uc3Qgc2lnbWEwbCA9ICgoYWwgPj4+IDI4KSB8IChhaCA8PCA0KSlcbiAgICAgICAgXiAoKGFsIDw8IDMwKSB8IChhaCA+Pj4gMikpXG4gICAgICAgIF4gKChhbCA8PCAyNSkgfCAoYWggPj4+IDcpKTtcbiAgICAgIGNvbnN0IHNpZ21hMWggPSAoKGVoID4+PiAxNCkgfCAoZWwgPDwgMTgpKVxuICAgICAgICBeICgoZWggPj4+IDE4KSB8IChlbCA8PCAxNCkpXG4gICAgICAgIF4gKChlaCA8PCAyMykgfCAoZWwgPj4+IDkpKTtcbiAgICAgIGNvbnN0IHNpZ21hMWwgPSAoKGVsID4+PiAxNCkgfCAoZWggPDwgMTgpKVxuICAgICAgICBeICgoZWwgPj4+IDE4KSB8IChlaCA8PCAxNCkpXG4gICAgICAgIF4gKChlbCA8PCAyMykgfCAoZWggPj4+IDkpKTtcblxuICAgICAgLy8gdDEgPSBoICsgc2lnbWExICsgY2ggKyBLW2ldICsgV1tpXVxuICAgICAgY29uc3QgS2kgPSBLW2ldO1xuICAgICAgY29uc3QgS2loID0gS2kuaGlnaDtcbiAgICAgIGNvbnN0IEtpbCA9IEtpLmxvdztcblxuICAgICAgbGV0IHQxbCA9IGhsICsgc2lnbWExbDtcbiAgICAgIGxldCB0MWggPSBoaCArIHNpZ21hMWggKyAoKHQxbCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApO1xuICAgICAgdDFsICs9IGNobDtcbiAgICAgIHQxaCA9IHQxaCArIGNoaCArICgodDFsID4+PiAwKSA8IChjaGwgPj4+IDApID8gMSA6IDApO1xuICAgICAgdDFsICs9IEtpbDtcbiAgICAgIHQxaCA9IHQxaCArIEtpaCArICgodDFsID4+PiAwKSA8IChLaWwgPj4+IDApID8gMSA6IDApO1xuICAgICAgdDFsICs9IFdpbDtcbiAgICAgIHQxaCA9IHQxaCArIFdpaCArICgodDFsID4+PiAwKSA8IChXaWwgPj4+IDApID8gMSA6IDApO1xuXG4gICAgICAvLyB0MiA9IHNpZ21hMCArIG1halxuICAgICAgY29uc3QgdDJsID0gc2lnbWEwbCArIG1hamw7XG4gICAgICBjb25zdCB0MmggPSBzaWdtYTBoICsgbWFqaCArICgodDJsID4+PiAwKSA8IChzaWdtYTBsID4+PiAwKSA/IDEgOiAwKTtcblxuICAgICAgLy8gVXBkYXRlIHdvcmtpbmcgdmFyaWFibGVzXG4gICAgICBoaCA9IGdoO1xuICAgICAgaGwgPSBnbDtcbiAgICAgIGdoID0gZmg7XG4gICAgICBnbCA9IGZsO1xuICAgICAgZmggPSBlaDtcbiAgICAgIGZsID0gZWw7XG4gICAgICBlbCA9IChkbCArIHQxbCkgfCAwO1xuICAgICAgZWggPSAoZGggKyB0MWggKyAoKGVsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpIHwgMDtcbiAgICAgIGRoID0gY2g7XG4gICAgICBkbCA9IGNsO1xuICAgICAgY2ggPSBiaDtcbiAgICAgIGNsID0gYmw7XG4gICAgICBiaCA9IGFoO1xuICAgICAgYmwgPSBhbDtcbiAgICAgIGFsID0gKHQxbCArIHQybCkgfCAwO1xuICAgICAgYWggPSAodDFoICsgdDJoICsgKChhbCA+Pj4gMCkgPCAodDFsID4+PiAwKSA/IDEgOiAwKSkgfCAwO1xuICAgIH1cblxuICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG4gICAgSDAubG93ID0gKEgwbCArIGFsKTtcbiAgICBIMGwgPSBIMC5sb3c7XG4gICAgSDAuaGlnaCA9IChIMGggKyBhaCArICgoSDBsID4+PiAwKSA8IChhbCA+Pj4gMCkgPyAxIDogMCkpO1xuICAgIEgxLmxvdyA9IChIMWwgKyBibCk7XG4gICAgSDFsID0gSDEubG93O1xuICAgIEgxLmhpZ2ggPSAoSDFoICsgYmggKyAoKEgxbCA+Pj4gMCkgPCAoYmwgPj4+IDApID8gMSA6IDApKTtcbiAgICBIMi5sb3cgPSAoSDJsICsgY2wpO1xuICAgIEgybCA9IEgyLmxvdztcbiAgICBIMi5oaWdoID0gKEgyaCArIGNoICsgKChIMmwgPj4+IDApIDwgKGNsID4+PiAwKSA/IDEgOiAwKSk7XG4gICAgSDMubG93ID0gKEgzbCArIGRsKTtcbiAgICBIM2wgPSBIMy5sb3c7XG4gICAgSDMuaGlnaCA9IChIM2ggKyBkaCArICgoSDNsID4+PiAwKSA8IChkbCA+Pj4gMCkgPyAxIDogMCkpO1xuICAgIEg0LmxvdyA9IChINGwgKyBlbCk7XG4gICAgSDRsID0gSDQubG93O1xuICAgIEg0LmhpZ2ggPSAoSDRoICsgZWggKyAoKEg0bCA+Pj4gMCkgPCAoZWwgPj4+IDApID8gMSA6IDApKTtcbiAgICBINS5sb3cgPSAoSDVsICsgZmwpO1xuICAgIEg1bCA9IEg1LmxvdztcbiAgICBINS5oaWdoID0gKEg1aCArIGZoICsgKChINWwgPj4+IDApIDwgKGZsID4+PiAwKSA/IDEgOiAwKSk7XG4gICAgSDYubG93ID0gKEg2bCArIGdsKTtcbiAgICBINmwgPSBINi5sb3c7XG4gICAgSDYuaGlnaCA9IChINmggKyBnaCArICgoSDZsID4+PiAwKSA8IChnbCA+Pj4gMCkgPyAxIDogMCkpO1xuICAgIEg3LmxvdyA9IChIN2wgKyBobCk7XG4gICAgSDdsID0gSDcubG93O1xuICAgIEg3LmhpZ2ggPSAoSDdoICsgaGggKyAoKEg3bCA+Pj4gMCkgPCAoaGwgPj4+IDApID8gMSA6IDApKTtcbiAgfVxuXG4gIF9kb0ZpbmFsaXplKCkge1xuICAgIC8vIFNob3J0Y3V0c1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9kYXRhO1xuICAgIGNvbnN0IGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cbiAgICBjb25zdCBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG4gICAgY29uc3QgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cbiAgICAvLyBBZGQgcGFkZGluZ1xuICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gKG5CaXRzTGVmdCAlIDMyKSk7XG4gICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDEyOCkgPj4+IDEwKSA8PCA1KSArIDMwXSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcbiAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgMTI4KSA+Pj4gMTApIDw8IDUpICsgMzFdID0gbkJpdHNUb3RhbDtcbiAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cbiAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuICAgIC8vIENvbnZlcnQgaGFzaCB0byAzMi1iaXQgd29yZCBhcnJheSBiZWZvcmUgcmV0dXJuaW5nXG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX2hhc2gudG9YMzIoKTtcblxuICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG4gICAgcmV0dXJuIGhhc2g7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7XG4gICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTUxMignbWVzc2FnZScpO1xuICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBNTEyKHdvcmRBcnJheSk7XG4gKi9cbmV4cG9ydCBjb25zdCBTSEE1MTIgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEE1MTJBbGdvKTtcblxuLyoqXG4gKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG4gKlxuICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG4gKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cbiAqXG4gKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuICpcbiAqIEBzdGF0aWNcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEE1MTIobWVzc2FnZSwga2V5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IEhtYWNTSEE1MTIgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBNTEyQWxnbyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/sha512.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/tripledes.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-es/lib/tripledes.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"DESAlgo\": function() { return /* binding */ DESAlgo; },\n/* harmony export */   \"DES\": function() { return /* binding */ DES; },\n/* harmony export */   \"TripleDESAlgo\": function() { return /* binding */ TripleDESAlgo; },\n/* harmony export */   \"TripleDES\": function() { return /* binding */ TripleDES; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n/* harmony import */ var _cipher_core_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./cipher-core.js */ \"./node_modules/crypto-es/lib/cipher-core.js\");\n\n\n\n// Permuted Choice 1 constants\nconst PC1 = [\n  57, 49, 41, 33, 25, 17, 9, 1,\n  58, 50, 42, 34, 26, 18, 10, 2,\n  59, 51, 43, 35, 27, 19, 11, 3,\n  60, 52, 44, 36, 63, 55, 47, 39,\n  31, 23, 15, 7, 62, 54, 46, 38,\n  30, 22, 14, 6, 61, 53, 45, 37,\n  29, 21, 13, 5, 28, 20, 12, 4,\n];\n\n// Permuted Choice 2 constants\nconst PC2 = [\n  14, 17, 11, 24, 1, 5,\n  3, 28, 15, 6, 21, 10,\n  23, 19, 12, 4, 26, 8,\n  16, 7, 27, 20, 13, 2,\n  41, 52, 31, 37, 47, 55,\n  30, 40, 51, 45, 33, 48,\n  44, 49, 39, 56, 34, 53,\n  46, 42, 50, 36, 29, 32,\n];\n\n// Cumulative bit shift constants\nconst BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];\n\n// SBOXes and round permutation constants\nconst SBOX_P = [\n  {\n    0x0: 0x808200,\n    0x10000000: 0x8000,\n    0x20000000: 0x808002,\n    0x30000000: 0x2,\n    0x40000000: 0x200,\n    0x50000000: 0x808202,\n    0x60000000: 0x800202,\n    0x70000000: 0x800000,\n    0x80000000: 0x202,\n    0x90000000: 0x800200,\n    0xa0000000: 0x8200,\n    0xb0000000: 0x808000,\n    0xc0000000: 0x8002,\n    0xd0000000: 0x800002,\n    0xe0000000: 0x0,\n    0xf0000000: 0x8202,\n    0x8000000: 0x0,\n    0x18000000: 0x808202,\n    0x28000000: 0x8202,\n    0x38000000: 0x8000,\n    0x48000000: 0x808200,\n    0x58000000: 0x200,\n    0x68000000: 0x808002,\n    0x78000000: 0x2,\n    0x88000000: 0x800200,\n    0x98000000: 0x8200,\n    0xa8000000: 0x808000,\n    0xb8000000: 0x800202,\n    0xc8000000: 0x800002,\n    0xd8000000: 0x8002,\n    0xe8000000: 0x202,\n    0xf8000000: 0x800000,\n    0x1: 0x8000,\n    0x10000001: 0x2,\n    0x20000001: 0x808200,\n    0x30000001: 0x800000,\n    0x40000001: 0x808002,\n    0x50000001: 0x8200,\n    0x60000001: 0x200,\n    0x70000001: 0x800202,\n    0x80000001: 0x808202,\n    0x90000001: 0x808000,\n    0xa0000001: 0x800002,\n    0xb0000001: 0x8202,\n    0xc0000001: 0x202,\n    0xd0000001: 0x800200,\n    0xe0000001: 0x8002,\n    0xf0000001: 0x0,\n    0x8000001: 0x808202,\n    0x18000001: 0x808000,\n    0x28000001: 0x800000,\n    0x38000001: 0x200,\n    0x48000001: 0x8000,\n    0x58000001: 0x800002,\n    0x68000001: 0x2,\n    0x78000001: 0x8202,\n    0x88000001: 0x8002,\n    0x98000001: 0x800202,\n    0xa8000001: 0x202,\n    0xb8000001: 0x808200,\n    0xc8000001: 0x800200,\n    0xd8000001: 0x0,\n    0xe8000001: 0x8200,\n    0xf8000001: 0x808002,\n  },\n  {\n    0x0: 0x40084010,\n    0x1000000: 0x4000,\n    0x2000000: 0x80000,\n    0x3000000: 0x40080010,\n    0x4000000: 0x40000010,\n    0x5000000: 0x40084000,\n    0x6000000: 0x40004000,\n    0x7000000: 0x10,\n    0x8000000: 0x84000,\n    0x9000000: 0x40004010,\n    0xa000000: 0x40000000,\n    0xb000000: 0x84010,\n    0xc000000: 0x80010,\n    0xd000000: 0x0,\n    0xe000000: 0x4010,\n    0xf000000: 0x40080000,\n    0x800000: 0x40004000,\n    0x1800000: 0x84010,\n    0x2800000: 0x10,\n    0x3800000: 0x40004010,\n    0x4800000: 0x40084010,\n    0x5800000: 0x40000000,\n    0x6800000: 0x80000,\n    0x7800000: 0x40080010,\n    0x8800000: 0x80010,\n    0x9800000: 0x0,\n    0xa800000: 0x4000,\n    0xb800000: 0x40080000,\n    0xc800000: 0x40000010,\n    0xd800000: 0x84000,\n    0xe800000: 0x40084000,\n    0xf800000: 0x4010,\n    0x10000000: 0x0,\n    0x11000000: 0x40080010,\n    0x12000000: 0x40004010,\n    0x13000000: 0x40084000,\n    0x14000000: 0x40080000,\n    0x15000000: 0x10,\n    0x16000000: 0x84010,\n    0x17000000: 0x4000,\n    0x18000000: 0x4010,\n    0x19000000: 0x80000,\n    0x1a000000: 0x80010,\n    0x1b000000: 0x40000010,\n    0x1c000000: 0x84000,\n    0x1d000000: 0x40004000,\n    0x1e000000: 0x40000000,\n    0x1f000000: 0x40084010,\n    0x10800000: 0x84010,\n    0x11800000: 0x80000,\n    0x12800000: 0x40080000,\n    0x13800000: 0x4000,\n    0x14800000: 0x40004000,\n    0x15800000: 0x40084010,\n    0x16800000: 0x10,\n    0x17800000: 0x40000000,\n    0x18800000: 0x40084000,\n    0x19800000: 0x40000010,\n    0x1a800000: 0x40004010,\n    0x1b800000: 0x80010,\n    0x1c800000: 0x0,\n    0x1d800000: 0x4010,\n    0x1e800000: 0x40080010,\n    0x1f800000: 0x84000,\n  },\n  {\n    0x0: 0x104,\n    0x100000: 0x0,\n    0x200000: 0x4000100,\n    0x300000: 0x10104,\n    0x400000: 0x10004,\n    0x500000: 0x4000004,\n    0x600000: 0x4010104,\n    0x700000: 0x4010000,\n    0x800000: 0x4000000,\n    0x900000: 0x4010100,\n    0xa00000: 0x10100,\n    0xb00000: 0x4010004,\n    0xc00000: 0x4000104,\n    0xd00000: 0x10000,\n    0xe00000: 0x4,\n    0xf00000: 0x100,\n    0x80000: 0x4010100,\n    0x180000: 0x4010004,\n    0x280000: 0x0,\n    0x380000: 0x4000100,\n    0x480000: 0x4000004,\n    0x580000: 0x10000,\n    0x680000: 0x10004,\n    0x780000: 0x104,\n    0x880000: 0x4,\n    0x980000: 0x100,\n    0xa80000: 0x4010000,\n    0xb80000: 0x10104,\n    0xc80000: 0x10100,\n    0xd80000: 0x4000104,\n    0xe80000: 0x4010104,\n    0xf80000: 0x4000000,\n    0x1000000: 0x4010100,\n    0x1100000: 0x10004,\n    0x1200000: 0x10000,\n    0x1300000: 0x4000100,\n    0x1400000: 0x100,\n    0x1500000: 0x4010104,\n    0x1600000: 0x4000004,\n    0x1700000: 0x0,\n    0x1800000: 0x4000104,\n    0x1900000: 0x4000000,\n    0x1a00000: 0x4,\n    0x1b00000: 0x10100,\n    0x1c00000: 0x4010000,\n    0x1d00000: 0x104,\n    0x1e00000: 0x10104,\n    0x1f00000: 0x4010004,\n    0x1080000: 0x4000000,\n    0x1180000: 0x104,\n    0x1280000: 0x4010100,\n    0x1380000: 0x0,\n    0x1480000: 0x10004,\n    0x1580000: 0x4000100,\n    0x1680000: 0x100,\n    0x1780000: 0x4010004,\n    0x1880000: 0x10000,\n    0x1980000: 0x4010104,\n    0x1a80000: 0x10104,\n    0x1b80000: 0x4000004,\n    0x1c80000: 0x4000104,\n    0x1d80000: 0x4010000,\n    0x1e80000: 0x4,\n    0x1f80000: 0x10100,\n  },\n  {\n    0x0: 0x80401000,\n    0x10000: 0x80001040,\n    0x20000: 0x401040,\n    0x30000: 0x80400000,\n    0x40000: 0x0,\n    0x50000: 0x401000,\n    0x60000: 0x80000040,\n    0x70000: 0x400040,\n    0x80000: 0x80000000,\n    0x90000: 0x400000,\n    0xa0000: 0x40,\n    0xb0000: 0x80001000,\n    0xc0000: 0x80400040,\n    0xd0000: 0x1040,\n    0xe0000: 0x1000,\n    0xf0000: 0x80401040,\n    0x8000: 0x80001040,\n    0x18000: 0x40,\n    0x28000: 0x80400040,\n    0x38000: 0x80001000,\n    0x48000: 0x401000,\n    0x58000: 0x80401040,\n    0x68000: 0x0,\n    0x78000: 0x80400000,\n    0x88000: 0x1000,\n    0x98000: 0x80401000,\n    0xa8000: 0x400000,\n    0xb8000: 0x1040,\n    0xc8000: 0x80000000,\n    0xd8000: 0x400040,\n    0xe8000: 0x401040,\n    0xf8000: 0x80000040,\n    0x100000: 0x400040,\n    0x110000: 0x401000,\n    0x120000: 0x80000040,\n    0x130000: 0x0,\n    0x140000: 0x1040,\n    0x150000: 0x80400040,\n    0x160000: 0x80401000,\n    0x170000: 0x80001040,\n    0x180000: 0x80401040,\n    0x190000: 0x80000000,\n    0x1a0000: 0x80400000,\n    0x1b0000: 0x401040,\n    0x1c0000: 0x80001000,\n    0x1d0000: 0x400000,\n    0x1e0000: 0x40,\n    0x1f0000: 0x1000,\n    0x108000: 0x80400000,\n    0x118000: 0x80401040,\n    0x128000: 0x0,\n    0x138000: 0x401000,\n    0x148000: 0x400040,\n    0x158000: 0x80000000,\n    0x168000: 0x80001040,\n    0x178000: 0x40,\n    0x188000: 0x80000040,\n    0x198000: 0x1000,\n    0x1a8000: 0x80001000,\n    0x1b8000: 0x80400040,\n    0x1c8000: 0x1040,\n    0x1d8000: 0x80401000,\n    0x1e8000: 0x400000,\n    0x1f8000: 0x401040,\n  },\n  {\n    0x0: 0x80,\n    0x1000: 0x1040000,\n    0x2000: 0x40000,\n    0x3000: 0x20000000,\n    0x4000: 0x20040080,\n    0x5000: 0x1000080,\n    0x6000: 0x21000080,\n    0x7000: 0x40080,\n    0x8000: 0x1000000,\n    0x9000: 0x20040000,\n    0xa000: 0x20000080,\n    0xb000: 0x21040080,\n    0xc000: 0x21040000,\n    0xd000: 0x0,\n    0xe000: 0x1040080,\n    0xf000: 0x21000000,\n    0x800: 0x1040080,\n    0x1800: 0x21000080,\n    0x2800: 0x80,\n    0x3800: 0x1040000,\n    0x4800: 0x40000,\n    0x5800: 0x20040080,\n    0x6800: 0x21040000,\n    0x7800: 0x20000000,\n    0x8800: 0x20040000,\n    0x9800: 0x0,\n    0xa800: 0x21040080,\n    0xb800: 0x1000080,\n    0xc800: 0x20000080,\n    0xd800: 0x21000000,\n    0xe800: 0x1000000,\n    0xf800: 0x40080,\n    0x10000: 0x40000,\n    0x11000: 0x80,\n    0x12000: 0x20000000,\n    0x13000: 0x21000080,\n    0x14000: 0x1000080,\n    0x15000: 0x21040000,\n    0x16000: 0x20040080,\n    0x17000: 0x1000000,\n    0x18000: 0x21040080,\n    0x19000: 0x21000000,\n    0x1a000: 0x1040000,\n    0x1b000: 0x20040000,\n    0x1c000: 0x40080,\n    0x1d000: 0x20000080,\n    0x1e000: 0x0,\n    0x1f000: 0x1040080,\n    0x10800: 0x21000080,\n    0x11800: 0x1000000,\n    0x12800: 0x1040000,\n    0x13800: 0x20040080,\n    0x14800: 0x20000000,\n    0x15800: 0x1040080,\n    0x16800: 0x80,\n    0x17800: 0x21040000,\n    0x18800: 0x40080,\n    0x19800: 0x21040080,\n    0x1a800: 0x0,\n    0x1b800: 0x21000000,\n    0x1c800: 0x1000080,\n    0x1d800: 0x40000,\n    0x1e800: 0x20040000,\n    0x1f800: 0x20000080,\n  },\n  {\n    0x0: 0x10000008,\n    0x100: 0x2000,\n    0x200: 0x10200000,\n    0x300: 0x10202008,\n    0x400: 0x10002000,\n    0x500: 0x200000,\n    0x600: 0x200008,\n    0x700: 0x10000000,\n    0x800: 0x0,\n    0x900: 0x10002008,\n    0xa00: 0x202000,\n    0xb00: 0x8,\n    0xc00: 0x10200008,\n    0xd00: 0x202008,\n    0xe00: 0x2008,\n    0xf00: 0x10202000,\n    0x80: 0x10200000,\n    0x180: 0x10202008,\n    0x280: 0x8,\n    0x380: 0x200000,\n    0x480: 0x202008,\n    0x580: 0x10000008,\n    0x680: 0x10002000,\n    0x780: 0x2008,\n    0x880: 0x200008,\n    0x980: 0x2000,\n    0xa80: 0x10002008,\n    0xb80: 0x10200008,\n    0xc80: 0x0,\n    0xd80: 0x10202000,\n    0xe80: 0x202000,\n    0xf80: 0x10000000,\n    0x1000: 0x10002000,\n    0x1100: 0x10200008,\n    0x1200: 0x10202008,\n    0x1300: 0x2008,\n    0x1400: 0x200000,\n    0x1500: 0x10000000,\n    0x1600: 0x10000008,\n    0x1700: 0x202000,\n    0x1800: 0x202008,\n    0x1900: 0x0,\n    0x1a00: 0x8,\n    0x1b00: 0x10200000,\n    0x1c00: 0x2000,\n    0x1d00: 0x10002008,\n    0x1e00: 0x10202000,\n    0x1f00: 0x200008,\n    0x1080: 0x8,\n    0x1180: 0x202000,\n    0x1280: 0x200000,\n    0x1380: 0x10000008,\n    0x1480: 0x10002000,\n    0x1580: 0x2008,\n    0x1680: 0x10202008,\n    0x1780: 0x10200000,\n    0x1880: 0x10202000,\n    0x1980: 0x10200008,\n    0x1a80: 0x2000,\n    0x1b80: 0x202008,\n    0x1c80: 0x200008,\n    0x1d80: 0x0,\n    0x1e80: 0x10000000,\n    0x1f80: 0x10002008,\n  },\n  {\n    0x0: 0x100000,\n    0x10: 0x2000401,\n    0x20: 0x400,\n    0x30: 0x100401,\n    0x40: 0x2100401,\n    0x50: 0x0,\n    0x60: 0x1,\n    0x70: 0x2100001,\n    0x80: 0x2000400,\n    0x90: 0x100001,\n    0xa0: 0x2000001,\n    0xb0: 0x2100400,\n    0xc0: 0x2100000,\n    0xd0: 0x401,\n    0xe0: 0x100400,\n    0xf0: 0x2000000,\n    0x8: 0x2100001,\n    0x18: 0x0,\n    0x28: 0x2000401,\n    0x38: 0x2100400,\n    0x48: 0x100000,\n    0x58: 0x2000001,\n    0x68: 0x2000000,\n    0x78: 0x401,\n    0x88: 0x100401,\n    0x98: 0x2000400,\n    0xa8: 0x2100000,\n    0xb8: 0x100001,\n    0xc8: 0x400,\n    0xd8: 0x2100401,\n    0xe8: 0x1,\n    0xf8: 0x100400,\n    0x100: 0x2000000,\n    0x110: 0x100000,\n    0x120: 0x2000401,\n    0x130: 0x2100001,\n    0x140: 0x100001,\n    0x150: 0x2000400,\n    0x160: 0x2100400,\n    0x170: 0x100401,\n    0x180: 0x401,\n    0x190: 0x2100401,\n    0x1a0: 0x100400,\n    0x1b0: 0x1,\n    0x1c0: 0x0,\n    0x1d0: 0x2100000,\n    0x1e0: 0x2000001,\n    0x1f0: 0x400,\n    0x108: 0x100400,\n    0x118: 0x2000401,\n    0x128: 0x2100001,\n    0x138: 0x1,\n    0x148: 0x2000000,\n    0x158: 0x100000,\n    0x168: 0x401,\n    0x178: 0x2100400,\n    0x188: 0x2000001,\n    0x198: 0x2100000,\n    0x1a8: 0x0,\n    0x1b8: 0x2100401,\n    0x1c8: 0x100401,\n    0x1d8: 0x400,\n    0x1e8: 0x2000400,\n    0x1f8: 0x100001,\n  },\n  {\n    0x0: 0x8000820,\n    0x1: 0x20000,\n    0x2: 0x8000000,\n    0x3: 0x20,\n    0x4: 0x20020,\n    0x5: 0x8020820,\n    0x6: 0x8020800,\n    0x7: 0x800,\n    0x8: 0x8020000,\n    0x9: 0x8000800,\n    0xa: 0x20800,\n    0xb: 0x8020020,\n    0xc: 0x820,\n    0xd: 0x0,\n    0xe: 0x8000020,\n    0xf: 0x20820,\n    0x80000000: 0x800,\n    0x80000001: 0x8020820,\n    0x80000002: 0x8000820,\n    0x80000003: 0x8000000,\n    0x80000004: 0x8020000,\n    0x80000005: 0x20800,\n    0x80000006: 0x20820,\n    0x80000007: 0x20,\n    0x80000008: 0x8000020,\n    0x80000009: 0x820,\n    0x8000000a: 0x20020,\n    0x8000000b: 0x8020800,\n    0x8000000c: 0x0,\n    0x8000000d: 0x8020020,\n    0x8000000e: 0x8000800,\n    0x8000000f: 0x20000,\n    0x10: 0x20820,\n    0x11: 0x8020800,\n    0x12: 0x20,\n    0x13: 0x800,\n    0x14: 0x8000800,\n    0x15: 0x8000020,\n    0x16: 0x8020020,\n    0x17: 0x20000,\n    0x18: 0x0,\n    0x19: 0x20020,\n    0x1a: 0x8020000,\n    0x1b: 0x8000820,\n    0x1c: 0x8020820,\n    0x1d: 0x20800,\n    0x1e: 0x820,\n    0x1f: 0x8000000,\n    0x80000010: 0x20000,\n    0x80000011: 0x800,\n    0x80000012: 0x8020020,\n    0x80000013: 0x20820,\n    0x80000014: 0x20,\n    0x80000015: 0x8020000,\n    0x80000016: 0x8000000,\n    0x80000017: 0x8000820,\n    0x80000018: 0x8020820,\n    0x80000019: 0x8000020,\n    0x8000001a: 0x8000800,\n    0x8000001b: 0x0,\n    0x8000001c: 0x20800,\n    0x8000001d: 0x820,\n    0x8000001e: 0x20020,\n    0x8000001f: 0x8020800,\n  },\n];\n\n// Masks that select the SBOX input\nconst SBOX_MASK = [\n  0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,\n  0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f,\n];\n\n// Swap bits across the left and right words\nfunction exchangeLR(offset, mask) {\n  const t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;\n  this._rBlock ^= t;\n  this._lBlock ^= t << offset;\n}\n\nfunction exchangeRL(offset, mask) {\n  const t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;\n  this._lBlock ^= t;\n  this._rBlock ^= t << offset;\n}\n\n/**\n * DES block cipher algorithm.\n */\nclass DESAlgo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_1__.BlockCipher {\n  _doReset() {\n    // Shortcuts\n    const key = this._key;\n    const keyWords = key.words;\n\n    // Select 56 bits according to PC1\n    const keyBits = [];\n    for (let i = 0; i < 56; i += 1) {\n      const keyBitPos = PC1[i] - 1;\n      keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - (keyBitPos % 32))) & 1;\n    }\n\n    // Assemble 16 subkeys\n    this._subKeys = [];\n    const subKeys = this._subKeys;\n    for (let nSubKey = 0; nSubKey < 16; nSubKey += 1) {\n      // Create subkey\n      subKeys[nSubKey] = [];\n      const subKey = subKeys[nSubKey];\n\n      // Shortcut\n      const bitShift = BIT_SHIFTS[nSubKey];\n\n      // Select 48 bits according to PC2\n      for (let i = 0; i < 24; i += 1) {\n        // Select from the left 28 key bits\n        subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - (i % 6));\n\n        // Select from the right 28 key bits\n        subKey[4 + ((i / 6) | 0)]\n          |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)]\n          << (31 - (i % 6));\n      }\n\n      // Since each subkey is applied to an expanded 32-bit input,\n      // the subkey can be broken into 8 values scaled to 32-bits,\n      // which allows the key to be used without expansion\n      subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);\n      for (let i = 1; i < 7; i += 1) {\n        subKey[i] >>>= ((i - 1) * 4 + 3);\n      }\n      subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);\n    }\n\n    // Compute inverse subkeys\n    this._invSubKeys = [];\n    const invSubKeys = this._invSubKeys;\n    for (let i = 0; i < 16; i += 1) {\n      invSubKeys[i] = subKeys[15 - i];\n    }\n  }\n\n  encryptBlock(M, offset) {\n    this._doCryptBlock(M, offset, this._subKeys);\n  }\n\n  decryptBlock(M, offset) {\n    this._doCryptBlock(M, offset, this._invSubKeys);\n  }\n\n  _doCryptBlock(M, offset, subKeys) {\n    const _M = M;\n\n    // Get input\n    this._lBlock = M[offset];\n    this._rBlock = M[offset + 1];\n\n    // Initial permutation\n    exchangeLR.call(this, 4, 0x0f0f0f0f);\n    exchangeLR.call(this, 16, 0x0000ffff);\n    exchangeRL.call(this, 2, 0x33333333);\n    exchangeRL.call(this, 8, 0x00ff00ff);\n    exchangeLR.call(this, 1, 0x55555555);\n\n    // Rounds\n    for (let round = 0; round < 16; round += 1) {\n      // Shortcuts\n      const subKey = subKeys[round];\n      const lBlock = this._lBlock;\n      const rBlock = this._rBlock;\n\n      // Feistel function\n      let f = 0;\n      for (let i = 0; i < 8; i += 1) {\n        f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];\n      }\n      this._lBlock = rBlock;\n      this._rBlock = lBlock ^ f;\n    }\n\n    // Undo swap from last round\n    const t = this._lBlock;\n    this._lBlock = this._rBlock;\n    this._rBlock = t;\n\n    // Final permutation\n    exchangeLR.call(this, 1, 0x55555555);\n    exchangeRL.call(this, 8, 0x00ff00ff);\n    exchangeRL.call(this, 2, 0x33333333);\n    exchangeLR.call(this, 16, 0x0000ffff);\n    exchangeLR.call(this, 4, 0x0f0f0f0f);\n\n    // Set output\n    _M[offset] = this._lBlock;\n    _M[offset + 1] = this._rBlock;\n  }\n}\nDESAlgo.keySize = 64 / 32;\nDESAlgo.ivSize = 64 / 32;\nDESAlgo.blockSize = 64 / 32;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);\n */\nconst DES = _cipher_core_js__WEBPACK_IMPORTED_MODULE_1__.BlockCipher._createHelper(DESAlgo);\n\n/**\n * Triple-DES block cipher algorithm.\n */\nclass TripleDESAlgo extends _cipher_core_js__WEBPACK_IMPORTED_MODULE_1__.BlockCipher {\n  _doReset() {\n    // Shortcuts\n    const key = this._key;\n    const keyWords = key.words;\n    // Make sure the key length is valid (64, 128 or >= 192 bit)\n    if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {\n      throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');\n    }\n\n    // Extend the key according to the keying options defined in 3DES standard\n    const key1 = keyWords.slice(0, 2);\n    const key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);\n    const key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);\n\n    // Create DES instances\n    this._des1 = DESAlgo.createEncryptor(_core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create(key1));\n    this._des2 = DESAlgo.createEncryptor(_core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create(key2));\n    this._des3 = DESAlgo.createEncryptor(_core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray.create(key3));\n  }\n\n  encryptBlock(M, offset) {\n    this._des1.encryptBlock(M, offset);\n    this._des2.decryptBlock(M, offset);\n    this._des3.encryptBlock(M, offset);\n  }\n\n  decryptBlock(M, offset) {\n    this._des3.decryptBlock(M, offset);\n    this._des2.encryptBlock(M, offset);\n    this._des1.decryptBlock(M, offset);\n  }\n}\nTripleDESAlgo.keySize = 192 / 32;\nTripleDESAlgo.ivSize = 64 / 32;\nTripleDESAlgo.blockSize = 64 / 32;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);\n */\nconst TripleDES = _cipher_core_js__WEBPACK_IMPORTED_MODULE_1__.BlockCipher._createHelper(TripleDESAlgo);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIvdHJpcGxlZGVzLmpzP2ZiMGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRW1CO0FBR087O0FBRTFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ08sc0JBQXNCLHdEQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGNBQWM7QUFDdkM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsWUFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLE9BQU87QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sWUFBWSxzRUFBeUI7O0FBRTVDO0FBQ0E7QUFDQTtBQUNPLDRCQUE0Qix3REFBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUNBQXlDLHNEQUFnQjtBQUN6RCx5Q0FBeUMsc0RBQWdCO0FBQ3pELHlDQUF5QyxzREFBZ0I7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLGtCQUFrQixzRUFBeUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3J5cHRvLWVzL2xpYi90cmlwbGVkZXMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBXb3JkQXJyYXksXG59IGZyb20gJy4vY29yZS5qcyc7XG5pbXBvcnQge1xuICBCbG9ja0NpcGhlcixcbn0gZnJvbSAnLi9jaXBoZXItY29yZS5qcyc7XG5cbi8vIFBlcm11dGVkIENob2ljZSAxIGNvbnN0YW50c1xuY29uc3QgUEMxID0gW1xuICA1NywgNDksIDQxLCAzMywgMjUsIDE3LCA5LCAxLFxuICA1OCwgNTAsIDQyLCAzNCwgMjYsIDE4LCAxMCwgMixcbiAgNTksIDUxLCA0MywgMzUsIDI3LCAxOSwgMTEsIDMsXG4gIDYwLCA1MiwgNDQsIDM2LCA2MywgNTUsIDQ3LCAzOSxcbiAgMzEsIDIzLCAxNSwgNywgNjIsIDU0LCA0NiwgMzgsXG4gIDMwLCAyMiwgMTQsIDYsIDYxLCA1MywgNDUsIDM3LFxuICAyOSwgMjEsIDEzLCA1LCAyOCwgMjAsIDEyLCA0LFxuXTtcblxuLy8gUGVybXV0ZWQgQ2hvaWNlIDIgY29uc3RhbnRzXG5jb25zdCBQQzIgPSBbXG4gIDE0LCAxNywgMTEsIDI0LCAxLCA1LFxuICAzLCAyOCwgMTUsIDYsIDIxLCAxMCxcbiAgMjMsIDE5LCAxMiwgNCwgMjYsIDgsXG4gIDE2LCA3LCAyNywgMjAsIDEzLCAyLFxuICA0MSwgNTIsIDMxLCAzNywgNDcsIDU1LFxuICAzMCwgNDAsIDUxLCA0NSwgMzMsIDQ4LFxuICA0NCwgNDksIDM5LCA1NiwgMzQsIDUzLFxuICA0NiwgNDIsIDUwLCAzNiwgMjksIDMyLFxuXTtcblxuLy8gQ3VtdWxhdGl2ZSBiaXQgc2hpZnQgY29uc3RhbnRzXG5jb25zdCBCSVRfU0hJRlRTID0gWzEsIDIsIDQsIDYsIDgsIDEwLCAxMiwgMTQsIDE1LCAxNywgMTksIDIxLCAyMywgMjUsIDI3LCAyOF07XG5cbi8vIFNCT1hlcyBhbmQgcm91bmQgcGVybXV0YXRpb24gY29uc3RhbnRzXG5jb25zdCBTQk9YX1AgPSBbXG4gIHtcbiAgICAweDA6IDB4ODA4MjAwLFxuICAgIDB4MTAwMDAwMDA6IDB4ODAwMCxcbiAgICAweDIwMDAwMDAwOiAweDgwODAwMixcbiAgICAweDMwMDAwMDAwOiAweDIsXG4gICAgMHg0MDAwMDAwMDogMHgyMDAsXG4gICAgMHg1MDAwMDAwMDogMHg4MDgyMDIsXG4gICAgMHg2MDAwMDAwMDogMHg4MDAyMDIsXG4gICAgMHg3MDAwMDAwMDogMHg4MDAwMDAsXG4gICAgMHg4MDAwMDAwMDogMHgyMDIsXG4gICAgMHg5MDAwMDAwMDogMHg4MDAyMDAsXG4gICAgMHhhMDAwMDAwMDogMHg4MjAwLFxuICAgIDB4YjAwMDAwMDA6IDB4ODA4MDAwLFxuICAgIDB4YzAwMDAwMDA6IDB4ODAwMixcbiAgICAweGQwMDAwMDAwOiAweDgwMDAwMixcbiAgICAweGUwMDAwMDAwOiAweDAsXG4gICAgMHhmMDAwMDAwMDogMHg4MjAyLFxuICAgIDB4ODAwMDAwMDogMHgwLFxuICAgIDB4MTgwMDAwMDA6IDB4ODA4MjAyLFxuICAgIDB4MjgwMDAwMDA6IDB4ODIwMixcbiAgICAweDM4MDAwMDAwOiAweDgwMDAsXG4gICAgMHg0ODAwMDAwMDogMHg4MDgyMDAsXG4gICAgMHg1ODAwMDAwMDogMHgyMDAsXG4gICAgMHg2ODAwMDAwMDogMHg4MDgwMDIsXG4gICAgMHg3ODAwMDAwMDogMHgyLFxuICAgIDB4ODgwMDAwMDA6IDB4ODAwMjAwLFxuICAgIDB4OTgwMDAwMDA6IDB4ODIwMCxcbiAgICAweGE4MDAwMDAwOiAweDgwODAwMCxcbiAgICAweGI4MDAwMDAwOiAweDgwMDIwMixcbiAgICAweGM4MDAwMDAwOiAweDgwMDAwMixcbiAgICAweGQ4MDAwMDAwOiAweDgwMDIsXG4gICAgMHhlODAwMDAwMDogMHgyMDIsXG4gICAgMHhmODAwMDAwMDogMHg4MDAwMDAsXG4gICAgMHgxOiAweDgwMDAsXG4gICAgMHgxMDAwMDAwMTogMHgyLFxuICAgIDB4MjAwMDAwMDE6IDB4ODA4MjAwLFxuICAgIDB4MzAwMDAwMDE6IDB4ODAwMDAwLFxuICAgIDB4NDAwMDAwMDE6IDB4ODA4MDAyLFxuICAgIDB4NTAwMDAwMDE6IDB4ODIwMCxcbiAgICAweDYwMDAwMDAxOiAweDIwMCxcbiAgICAweDcwMDAwMDAxOiAweDgwMDIwMixcbiAgICAweDgwMDAwMDAxOiAweDgwODIwMixcbiAgICAweDkwMDAwMDAxOiAweDgwODAwMCxcbiAgICAweGEwMDAwMDAxOiAweDgwMDAwMixcbiAgICAweGIwMDAwMDAxOiAweDgyMDIsXG4gICAgMHhjMDAwMDAwMTogMHgyMDIsXG4gICAgMHhkMDAwMDAwMTogMHg4MDAyMDAsXG4gICAgMHhlMDAwMDAwMTogMHg4MDAyLFxuICAgIDB4ZjAwMDAwMDE6IDB4MCxcbiAgICAweDgwMDAwMDE6IDB4ODA4MjAyLFxuICAgIDB4MTgwMDAwMDE6IDB4ODA4MDAwLFxuICAgIDB4MjgwMDAwMDE6IDB4ODAwMDAwLFxuICAgIDB4MzgwMDAwMDE6IDB4MjAwLFxuICAgIDB4NDgwMDAwMDE6IDB4ODAwMCxcbiAgICAweDU4MDAwMDAxOiAweDgwMDAwMixcbiAgICAweDY4MDAwMDAxOiAweDIsXG4gICAgMHg3ODAwMDAwMTogMHg4MjAyLFxuICAgIDB4ODgwMDAwMDE6IDB4ODAwMixcbiAgICAweDk4MDAwMDAxOiAweDgwMDIwMixcbiAgICAweGE4MDAwMDAxOiAweDIwMixcbiAgICAweGI4MDAwMDAxOiAweDgwODIwMCxcbiAgICAweGM4MDAwMDAxOiAweDgwMDIwMCxcbiAgICAweGQ4MDAwMDAxOiAweDAsXG4gICAgMHhlODAwMDAwMTogMHg4MjAwLFxuICAgIDB4ZjgwMDAwMDE6IDB4ODA4MDAyLFxuICB9LFxuICB7XG4gICAgMHgwOiAweDQwMDg0MDEwLFxuICAgIDB4MTAwMDAwMDogMHg0MDAwLFxuICAgIDB4MjAwMDAwMDogMHg4MDAwMCxcbiAgICAweDMwMDAwMDA6IDB4NDAwODAwMTAsXG4gICAgMHg0MDAwMDAwOiAweDQwMDAwMDEwLFxuICAgIDB4NTAwMDAwMDogMHg0MDA4NDAwMCxcbiAgICAweDYwMDAwMDA6IDB4NDAwMDQwMDAsXG4gICAgMHg3MDAwMDAwOiAweDEwLFxuICAgIDB4ODAwMDAwMDogMHg4NDAwMCxcbiAgICAweDkwMDAwMDA6IDB4NDAwMDQwMTAsXG4gICAgMHhhMDAwMDAwOiAweDQwMDAwMDAwLFxuICAgIDB4YjAwMDAwMDogMHg4NDAxMCxcbiAgICAweGMwMDAwMDA6IDB4ODAwMTAsXG4gICAgMHhkMDAwMDAwOiAweDAsXG4gICAgMHhlMDAwMDAwOiAweDQwMTAsXG4gICAgMHhmMDAwMDAwOiAweDQwMDgwMDAwLFxuICAgIDB4ODAwMDAwOiAweDQwMDA0MDAwLFxuICAgIDB4MTgwMDAwMDogMHg4NDAxMCxcbiAgICAweDI4MDAwMDA6IDB4MTAsXG4gICAgMHgzODAwMDAwOiAweDQwMDA0MDEwLFxuICAgIDB4NDgwMDAwMDogMHg0MDA4NDAxMCxcbiAgICAweDU4MDAwMDA6IDB4NDAwMDAwMDAsXG4gICAgMHg2ODAwMDAwOiAweDgwMDAwLFxuICAgIDB4NzgwMDAwMDogMHg0MDA4MDAxMCxcbiAgICAweDg4MDAwMDA6IDB4ODAwMTAsXG4gICAgMHg5ODAwMDAwOiAweDAsXG4gICAgMHhhODAwMDAwOiAweDQwMDAsXG4gICAgMHhiODAwMDAwOiAweDQwMDgwMDAwLFxuICAgIDB4YzgwMDAwMDogMHg0MDAwMDAxMCxcbiAgICAweGQ4MDAwMDA6IDB4ODQwMDAsXG4gICAgMHhlODAwMDAwOiAweDQwMDg0MDAwLFxuICAgIDB4ZjgwMDAwMDogMHg0MDEwLFxuICAgIDB4MTAwMDAwMDA6IDB4MCxcbiAgICAweDExMDAwMDAwOiAweDQwMDgwMDEwLFxuICAgIDB4MTIwMDAwMDA6IDB4NDAwMDQwMTAsXG4gICAgMHgxMzAwMDAwMDogMHg0MDA4NDAwMCxcbiAgICAweDE0MDAwMDAwOiAweDQwMDgwMDAwLFxuICAgIDB4MTUwMDAwMDA6IDB4MTAsXG4gICAgMHgxNjAwMDAwMDogMHg4NDAxMCxcbiAgICAweDE3MDAwMDAwOiAweDQwMDAsXG4gICAgMHgxODAwMDAwMDogMHg0MDEwLFxuICAgIDB4MTkwMDAwMDA6IDB4ODAwMDAsXG4gICAgMHgxYTAwMDAwMDogMHg4MDAxMCxcbiAgICAweDFiMDAwMDAwOiAweDQwMDAwMDEwLFxuICAgIDB4MWMwMDAwMDA6IDB4ODQwMDAsXG4gICAgMHgxZDAwMDAwMDogMHg0MDAwNDAwMCxcbiAgICAweDFlMDAwMDAwOiAweDQwMDAwMDAwLFxuICAgIDB4MWYwMDAwMDA6IDB4NDAwODQwMTAsXG4gICAgMHgxMDgwMDAwMDogMHg4NDAxMCxcbiAgICAweDExODAwMDAwOiAweDgwMDAwLFxuICAgIDB4MTI4MDAwMDA6IDB4NDAwODAwMDAsXG4gICAgMHgxMzgwMDAwMDogMHg0MDAwLFxuICAgIDB4MTQ4MDAwMDA6IDB4NDAwMDQwMDAsXG4gICAgMHgxNTgwMDAwMDogMHg0MDA4NDAxMCxcbiAgICAweDE2ODAwMDAwOiAweDEwLFxuICAgIDB4MTc4MDAwMDA6IDB4NDAwMDAwMDAsXG4gICAgMHgxODgwMDAwMDogMHg0MDA4NDAwMCxcbiAgICAweDE5ODAwMDAwOiAweDQwMDAwMDEwLFxuICAgIDB4MWE4MDAwMDA6IDB4NDAwMDQwMTAsXG4gICAgMHgxYjgwMDAwMDogMHg4MDAxMCxcbiAgICAweDFjODAwMDAwOiAweDAsXG4gICAgMHgxZDgwMDAwMDogMHg0MDEwLFxuICAgIDB4MWU4MDAwMDA6IDB4NDAwODAwMTAsXG4gICAgMHgxZjgwMDAwMDogMHg4NDAwMCxcbiAgfSxcbiAge1xuICAgIDB4MDogMHgxMDQsXG4gICAgMHgxMDAwMDA6IDB4MCxcbiAgICAweDIwMDAwMDogMHg0MDAwMTAwLFxuICAgIDB4MzAwMDAwOiAweDEwMTA0LFxuICAgIDB4NDAwMDAwOiAweDEwMDA0LFxuICAgIDB4NTAwMDAwOiAweDQwMDAwMDQsXG4gICAgMHg2MDAwMDA6IDB4NDAxMDEwNCxcbiAgICAweDcwMDAwMDogMHg0MDEwMDAwLFxuICAgIDB4ODAwMDAwOiAweDQwMDAwMDAsXG4gICAgMHg5MDAwMDA6IDB4NDAxMDEwMCxcbiAgICAweGEwMDAwMDogMHgxMDEwMCxcbiAgICAweGIwMDAwMDogMHg0MDEwMDA0LFxuICAgIDB4YzAwMDAwOiAweDQwMDAxMDQsXG4gICAgMHhkMDAwMDA6IDB4MTAwMDAsXG4gICAgMHhlMDAwMDA6IDB4NCxcbiAgICAweGYwMDAwMDogMHgxMDAsXG4gICAgMHg4MDAwMDogMHg0MDEwMTAwLFxuICAgIDB4MTgwMDAwOiAweDQwMTAwMDQsXG4gICAgMHgyODAwMDA6IDB4MCxcbiAgICAweDM4MDAwMDogMHg0MDAwMTAwLFxuICAgIDB4NDgwMDAwOiAweDQwMDAwMDQsXG4gICAgMHg1ODAwMDA6IDB4MTAwMDAsXG4gICAgMHg2ODAwMDA6IDB4MTAwMDQsXG4gICAgMHg3ODAwMDA6IDB4MTA0LFxuICAgIDB4ODgwMDAwOiAweDQsXG4gICAgMHg5ODAwMDA6IDB4MTAwLFxuICAgIDB4YTgwMDAwOiAweDQwMTAwMDAsXG4gICAgMHhiODAwMDA6IDB4MTAxMDQsXG4gICAgMHhjODAwMDA6IDB4MTAxMDAsXG4gICAgMHhkODAwMDA6IDB4NDAwMDEwNCxcbiAgICAweGU4MDAwMDogMHg0MDEwMTA0LFxuICAgIDB4ZjgwMDAwOiAweDQwMDAwMDAsXG4gICAgMHgxMDAwMDAwOiAweDQwMTAxMDAsXG4gICAgMHgxMTAwMDAwOiAweDEwMDA0LFxuICAgIDB4MTIwMDAwMDogMHgxMDAwMCxcbiAgICAweDEzMDAwMDA6IDB4NDAwMDEwMCxcbiAgICAweDE0MDAwMDA6IDB4MTAwLFxuICAgIDB4MTUwMDAwMDogMHg0MDEwMTA0LFxuICAgIDB4MTYwMDAwMDogMHg0MDAwMDA0LFxuICAgIDB4MTcwMDAwMDogMHgwLFxuICAgIDB4MTgwMDAwMDogMHg0MDAwMTA0LFxuICAgIDB4MTkwMDAwMDogMHg0MDAwMDAwLFxuICAgIDB4MWEwMDAwMDogMHg0LFxuICAgIDB4MWIwMDAwMDogMHgxMDEwMCxcbiAgICAweDFjMDAwMDA6IDB4NDAxMDAwMCxcbiAgICAweDFkMDAwMDA6IDB4MTA0LFxuICAgIDB4MWUwMDAwMDogMHgxMDEwNCxcbiAgICAweDFmMDAwMDA6IDB4NDAxMDAwNCxcbiAgICAweDEwODAwMDA6IDB4NDAwMDAwMCxcbiAgICAweDExODAwMDA6IDB4MTA0LFxuICAgIDB4MTI4MDAwMDogMHg0MDEwMTAwLFxuICAgIDB4MTM4MDAwMDogMHgwLFxuICAgIDB4MTQ4MDAwMDogMHgxMDAwNCxcbiAgICAweDE1ODAwMDA6IDB4NDAwMDEwMCxcbiAgICAweDE2ODAwMDA6IDB4MTAwLFxuICAgIDB4MTc4MDAwMDogMHg0MDEwMDA0LFxuICAgIDB4MTg4MDAwMDogMHgxMDAwMCxcbiAgICAweDE5ODAwMDA6IDB4NDAxMDEwNCxcbiAgICAweDFhODAwMDA6IDB4MTAxMDQsXG4gICAgMHgxYjgwMDAwOiAweDQwMDAwMDQsXG4gICAgMHgxYzgwMDAwOiAweDQwMDAxMDQsXG4gICAgMHgxZDgwMDAwOiAweDQwMTAwMDAsXG4gICAgMHgxZTgwMDAwOiAweDQsXG4gICAgMHgxZjgwMDAwOiAweDEwMTAwLFxuICB9LFxuICB7XG4gICAgMHgwOiAweDgwNDAxMDAwLFxuICAgIDB4MTAwMDA6IDB4ODAwMDEwNDAsXG4gICAgMHgyMDAwMDogMHg0MDEwNDAsXG4gICAgMHgzMDAwMDogMHg4MDQwMDAwMCxcbiAgICAweDQwMDAwOiAweDAsXG4gICAgMHg1MDAwMDogMHg0MDEwMDAsXG4gICAgMHg2MDAwMDogMHg4MDAwMDA0MCxcbiAgICAweDcwMDAwOiAweDQwMDA0MCxcbiAgICAweDgwMDAwOiAweDgwMDAwMDAwLFxuICAgIDB4OTAwMDA6IDB4NDAwMDAwLFxuICAgIDB4YTAwMDA6IDB4NDAsXG4gICAgMHhiMDAwMDogMHg4MDAwMTAwMCxcbiAgICAweGMwMDAwOiAweDgwNDAwMDQwLFxuICAgIDB4ZDAwMDA6IDB4MTA0MCxcbiAgICAweGUwMDAwOiAweDEwMDAsXG4gICAgMHhmMDAwMDogMHg4MDQwMTA0MCxcbiAgICAweDgwMDA6IDB4ODAwMDEwNDAsXG4gICAgMHgxODAwMDogMHg0MCxcbiAgICAweDI4MDAwOiAweDgwNDAwMDQwLFxuICAgIDB4MzgwMDA6IDB4ODAwMDEwMDAsXG4gICAgMHg0ODAwMDogMHg0MDEwMDAsXG4gICAgMHg1ODAwMDogMHg4MDQwMTA0MCxcbiAgICAweDY4MDAwOiAweDAsXG4gICAgMHg3ODAwMDogMHg4MDQwMDAwMCxcbiAgICAweDg4MDAwOiAweDEwMDAsXG4gICAgMHg5ODAwMDogMHg4MDQwMTAwMCxcbiAgICAweGE4MDAwOiAweDQwMDAwMCxcbiAgICAweGI4MDAwOiAweDEwNDAsXG4gICAgMHhjODAwMDogMHg4MDAwMDAwMCxcbiAgICAweGQ4MDAwOiAweDQwMDA0MCxcbiAgICAweGU4MDAwOiAweDQwMTA0MCxcbiAgICAweGY4MDAwOiAweDgwMDAwMDQwLFxuICAgIDB4MTAwMDAwOiAweDQwMDA0MCxcbiAgICAweDExMDAwMDogMHg0MDEwMDAsXG4gICAgMHgxMjAwMDA6IDB4ODAwMDAwNDAsXG4gICAgMHgxMzAwMDA6IDB4MCxcbiAgICAweDE0MDAwMDogMHgxMDQwLFxuICAgIDB4MTUwMDAwOiAweDgwNDAwMDQwLFxuICAgIDB4MTYwMDAwOiAweDgwNDAxMDAwLFxuICAgIDB4MTcwMDAwOiAweDgwMDAxMDQwLFxuICAgIDB4MTgwMDAwOiAweDgwNDAxMDQwLFxuICAgIDB4MTkwMDAwOiAweDgwMDAwMDAwLFxuICAgIDB4MWEwMDAwOiAweDgwNDAwMDAwLFxuICAgIDB4MWIwMDAwOiAweDQwMTA0MCxcbiAgICAweDFjMDAwMDogMHg4MDAwMTAwMCxcbiAgICAweDFkMDAwMDogMHg0MDAwMDAsXG4gICAgMHgxZTAwMDA6IDB4NDAsXG4gICAgMHgxZjAwMDA6IDB4MTAwMCxcbiAgICAweDEwODAwMDogMHg4MDQwMDAwMCxcbiAgICAweDExODAwMDogMHg4MDQwMTA0MCxcbiAgICAweDEyODAwMDogMHgwLFxuICAgIDB4MTM4MDAwOiAweDQwMTAwMCxcbiAgICAweDE0ODAwMDogMHg0MDAwNDAsXG4gICAgMHgxNTgwMDA6IDB4ODAwMDAwMDAsXG4gICAgMHgxNjgwMDA6IDB4ODAwMDEwNDAsXG4gICAgMHgxNzgwMDA6IDB4NDAsXG4gICAgMHgxODgwMDA6IDB4ODAwMDAwNDAsXG4gICAgMHgxOTgwMDA6IDB4MTAwMCxcbiAgICAweDFhODAwMDogMHg4MDAwMTAwMCxcbiAgICAweDFiODAwMDogMHg4MDQwMDA0MCxcbiAgICAweDFjODAwMDogMHgxMDQwLFxuICAgIDB4MWQ4MDAwOiAweDgwNDAxMDAwLFxuICAgIDB4MWU4MDAwOiAweDQwMDAwMCxcbiAgICAweDFmODAwMDogMHg0MDEwNDAsXG4gIH0sXG4gIHtcbiAgICAweDA6IDB4ODAsXG4gICAgMHgxMDAwOiAweDEwNDAwMDAsXG4gICAgMHgyMDAwOiAweDQwMDAwLFxuICAgIDB4MzAwMDogMHgyMDAwMDAwMCxcbiAgICAweDQwMDA6IDB4MjAwNDAwODAsXG4gICAgMHg1MDAwOiAweDEwMDAwODAsXG4gICAgMHg2MDAwOiAweDIxMDAwMDgwLFxuICAgIDB4NzAwMDogMHg0MDA4MCxcbiAgICAweDgwMDA6IDB4MTAwMDAwMCxcbiAgICAweDkwMDA6IDB4MjAwNDAwMDAsXG4gICAgMHhhMDAwOiAweDIwMDAwMDgwLFxuICAgIDB4YjAwMDogMHgyMTA0MDA4MCxcbiAgICAweGMwMDA6IDB4MjEwNDAwMDAsXG4gICAgMHhkMDAwOiAweDAsXG4gICAgMHhlMDAwOiAweDEwNDAwODAsXG4gICAgMHhmMDAwOiAweDIxMDAwMDAwLFxuICAgIDB4ODAwOiAweDEwNDAwODAsXG4gICAgMHgxODAwOiAweDIxMDAwMDgwLFxuICAgIDB4MjgwMDogMHg4MCxcbiAgICAweDM4MDA6IDB4MTA0MDAwMCxcbiAgICAweDQ4MDA6IDB4NDAwMDAsXG4gICAgMHg1ODAwOiAweDIwMDQwMDgwLFxuICAgIDB4NjgwMDogMHgyMTA0MDAwMCxcbiAgICAweDc4MDA6IDB4MjAwMDAwMDAsXG4gICAgMHg4ODAwOiAweDIwMDQwMDAwLFxuICAgIDB4OTgwMDogMHgwLFxuICAgIDB4YTgwMDogMHgyMTA0MDA4MCxcbiAgICAweGI4MDA6IDB4MTAwMDA4MCxcbiAgICAweGM4MDA6IDB4MjAwMDAwODAsXG4gICAgMHhkODAwOiAweDIxMDAwMDAwLFxuICAgIDB4ZTgwMDogMHgxMDAwMDAwLFxuICAgIDB4ZjgwMDogMHg0MDA4MCxcbiAgICAweDEwMDAwOiAweDQwMDAwLFxuICAgIDB4MTEwMDA6IDB4ODAsXG4gICAgMHgxMjAwMDogMHgyMDAwMDAwMCxcbiAgICAweDEzMDAwOiAweDIxMDAwMDgwLFxuICAgIDB4MTQwMDA6IDB4MTAwMDA4MCxcbiAgICAweDE1MDAwOiAweDIxMDQwMDAwLFxuICAgIDB4MTYwMDA6IDB4MjAwNDAwODAsXG4gICAgMHgxNzAwMDogMHgxMDAwMDAwLFxuICAgIDB4MTgwMDA6IDB4MjEwNDAwODAsXG4gICAgMHgxOTAwMDogMHgyMTAwMDAwMCxcbiAgICAweDFhMDAwOiAweDEwNDAwMDAsXG4gICAgMHgxYjAwMDogMHgyMDA0MDAwMCxcbiAgICAweDFjMDAwOiAweDQwMDgwLFxuICAgIDB4MWQwMDA6IDB4MjAwMDAwODAsXG4gICAgMHgxZTAwMDogMHgwLFxuICAgIDB4MWYwMDA6IDB4MTA0MDA4MCxcbiAgICAweDEwODAwOiAweDIxMDAwMDgwLFxuICAgIDB4MTE4MDA6IDB4MTAwMDAwMCxcbiAgICAweDEyODAwOiAweDEwNDAwMDAsXG4gICAgMHgxMzgwMDogMHgyMDA0MDA4MCxcbiAgICAweDE0ODAwOiAweDIwMDAwMDAwLFxuICAgIDB4MTU4MDA6IDB4MTA0MDA4MCxcbiAgICAweDE2ODAwOiAweDgwLFxuICAgIDB4MTc4MDA6IDB4MjEwNDAwMDAsXG4gICAgMHgxODgwMDogMHg0MDA4MCxcbiAgICAweDE5ODAwOiAweDIxMDQwMDgwLFxuICAgIDB4MWE4MDA6IDB4MCxcbiAgICAweDFiODAwOiAweDIxMDAwMDAwLFxuICAgIDB4MWM4MDA6IDB4MTAwMDA4MCxcbiAgICAweDFkODAwOiAweDQwMDAwLFxuICAgIDB4MWU4MDA6IDB4MjAwNDAwMDAsXG4gICAgMHgxZjgwMDogMHgyMDAwMDA4MCxcbiAgfSxcbiAge1xuICAgIDB4MDogMHgxMDAwMDAwOCxcbiAgICAweDEwMDogMHgyMDAwLFxuICAgIDB4MjAwOiAweDEwMjAwMDAwLFxuICAgIDB4MzAwOiAweDEwMjAyMDA4LFxuICAgIDB4NDAwOiAweDEwMDAyMDAwLFxuICAgIDB4NTAwOiAweDIwMDAwMCxcbiAgICAweDYwMDogMHgyMDAwMDgsXG4gICAgMHg3MDA6IDB4MTAwMDAwMDAsXG4gICAgMHg4MDA6IDB4MCxcbiAgICAweDkwMDogMHgxMDAwMjAwOCxcbiAgICAweGEwMDogMHgyMDIwMDAsXG4gICAgMHhiMDA6IDB4OCxcbiAgICAweGMwMDogMHgxMDIwMDAwOCxcbiAgICAweGQwMDogMHgyMDIwMDgsXG4gICAgMHhlMDA6IDB4MjAwOCxcbiAgICAweGYwMDogMHgxMDIwMjAwMCxcbiAgICAweDgwOiAweDEwMjAwMDAwLFxuICAgIDB4MTgwOiAweDEwMjAyMDA4LFxuICAgIDB4MjgwOiAweDgsXG4gICAgMHgzODA6IDB4MjAwMDAwLFxuICAgIDB4NDgwOiAweDIwMjAwOCxcbiAgICAweDU4MDogMHgxMDAwMDAwOCxcbiAgICAweDY4MDogMHgxMDAwMjAwMCxcbiAgICAweDc4MDogMHgyMDA4LFxuICAgIDB4ODgwOiAweDIwMDAwOCxcbiAgICAweDk4MDogMHgyMDAwLFxuICAgIDB4YTgwOiAweDEwMDAyMDA4LFxuICAgIDB4YjgwOiAweDEwMjAwMDA4LFxuICAgIDB4YzgwOiAweDAsXG4gICAgMHhkODA6IDB4MTAyMDIwMDAsXG4gICAgMHhlODA6IDB4MjAyMDAwLFxuICAgIDB4ZjgwOiAweDEwMDAwMDAwLFxuICAgIDB4MTAwMDogMHgxMDAwMjAwMCxcbiAgICAweDExMDA6IDB4MTAyMDAwMDgsXG4gICAgMHgxMjAwOiAweDEwMjAyMDA4LFxuICAgIDB4MTMwMDogMHgyMDA4LFxuICAgIDB4MTQwMDogMHgyMDAwMDAsXG4gICAgMHgxNTAwOiAweDEwMDAwMDAwLFxuICAgIDB4MTYwMDogMHgxMDAwMDAwOCxcbiAgICAweDE3MDA6IDB4MjAyMDAwLFxuICAgIDB4MTgwMDogMHgyMDIwMDgsXG4gICAgMHgxOTAwOiAweDAsXG4gICAgMHgxYTAwOiAweDgsXG4gICAgMHgxYjAwOiAweDEwMjAwMDAwLFxuICAgIDB4MWMwMDogMHgyMDAwLFxuICAgIDB4MWQwMDogMHgxMDAwMjAwOCxcbiAgICAweDFlMDA6IDB4MTAyMDIwMDAsXG4gICAgMHgxZjAwOiAweDIwMDAwOCxcbiAgICAweDEwODA6IDB4OCxcbiAgICAweDExODA6IDB4MjAyMDAwLFxuICAgIDB4MTI4MDogMHgyMDAwMDAsXG4gICAgMHgxMzgwOiAweDEwMDAwMDA4LFxuICAgIDB4MTQ4MDogMHgxMDAwMjAwMCxcbiAgICAweDE1ODA6IDB4MjAwOCxcbiAgICAweDE2ODA6IDB4MTAyMDIwMDgsXG4gICAgMHgxNzgwOiAweDEwMjAwMDAwLFxuICAgIDB4MTg4MDogMHgxMDIwMjAwMCxcbiAgICAweDE5ODA6IDB4MTAyMDAwMDgsXG4gICAgMHgxYTgwOiAweDIwMDAsXG4gICAgMHgxYjgwOiAweDIwMjAwOCxcbiAgICAweDFjODA6IDB4MjAwMDA4LFxuICAgIDB4MWQ4MDogMHgwLFxuICAgIDB4MWU4MDogMHgxMDAwMDAwMCxcbiAgICAweDFmODA6IDB4MTAwMDIwMDgsXG4gIH0sXG4gIHtcbiAgICAweDA6IDB4MTAwMDAwLFxuICAgIDB4MTA6IDB4MjAwMDQwMSxcbiAgICAweDIwOiAweDQwMCxcbiAgICAweDMwOiAweDEwMDQwMSxcbiAgICAweDQwOiAweDIxMDA0MDEsXG4gICAgMHg1MDogMHgwLFxuICAgIDB4NjA6IDB4MSxcbiAgICAweDcwOiAweDIxMDAwMDEsXG4gICAgMHg4MDogMHgyMDAwNDAwLFxuICAgIDB4OTA6IDB4MTAwMDAxLFxuICAgIDB4YTA6IDB4MjAwMDAwMSxcbiAgICAweGIwOiAweDIxMDA0MDAsXG4gICAgMHhjMDogMHgyMTAwMDAwLFxuICAgIDB4ZDA6IDB4NDAxLFxuICAgIDB4ZTA6IDB4MTAwNDAwLFxuICAgIDB4ZjA6IDB4MjAwMDAwMCxcbiAgICAweDg6IDB4MjEwMDAwMSxcbiAgICAweDE4OiAweDAsXG4gICAgMHgyODogMHgyMDAwNDAxLFxuICAgIDB4Mzg6IDB4MjEwMDQwMCxcbiAgICAweDQ4OiAweDEwMDAwMCxcbiAgICAweDU4OiAweDIwMDAwMDEsXG4gICAgMHg2ODogMHgyMDAwMDAwLFxuICAgIDB4Nzg6IDB4NDAxLFxuICAgIDB4ODg6IDB4MTAwNDAxLFxuICAgIDB4OTg6IDB4MjAwMDQwMCxcbiAgICAweGE4OiAweDIxMDAwMDAsXG4gICAgMHhiODogMHgxMDAwMDEsXG4gICAgMHhjODogMHg0MDAsXG4gICAgMHhkODogMHgyMTAwNDAxLFxuICAgIDB4ZTg6IDB4MSxcbiAgICAweGY4OiAweDEwMDQwMCxcbiAgICAweDEwMDogMHgyMDAwMDAwLFxuICAgIDB4MTEwOiAweDEwMDAwMCxcbiAgICAweDEyMDogMHgyMDAwNDAxLFxuICAgIDB4MTMwOiAweDIxMDAwMDEsXG4gICAgMHgxNDA6IDB4MTAwMDAxLFxuICAgIDB4MTUwOiAweDIwMDA0MDAsXG4gICAgMHgxNjA6IDB4MjEwMDQwMCxcbiAgICAweDE3MDogMHgxMDA0MDEsXG4gICAgMHgxODA6IDB4NDAxLFxuICAgIDB4MTkwOiAweDIxMDA0MDEsXG4gICAgMHgxYTA6IDB4MTAwNDAwLFxuICAgIDB4MWIwOiAweDEsXG4gICAgMHgxYzA6IDB4MCxcbiAgICAweDFkMDogMHgyMTAwMDAwLFxuICAgIDB4MWUwOiAweDIwMDAwMDEsXG4gICAgMHgxZjA6IDB4NDAwLFxuICAgIDB4MTA4OiAweDEwMDQwMCxcbiAgICAweDExODogMHgyMDAwNDAxLFxuICAgIDB4MTI4OiAweDIxMDAwMDEsXG4gICAgMHgxMzg6IDB4MSxcbiAgICAweDE0ODogMHgyMDAwMDAwLFxuICAgIDB4MTU4OiAweDEwMDAwMCxcbiAgICAweDE2ODogMHg0MDEsXG4gICAgMHgxNzg6IDB4MjEwMDQwMCxcbiAgICAweDE4ODogMHgyMDAwMDAxLFxuICAgIDB4MTk4OiAweDIxMDAwMDAsXG4gICAgMHgxYTg6IDB4MCxcbiAgICAweDFiODogMHgyMTAwNDAxLFxuICAgIDB4MWM4OiAweDEwMDQwMSxcbiAgICAweDFkODogMHg0MDAsXG4gICAgMHgxZTg6IDB4MjAwMDQwMCxcbiAgICAweDFmODogMHgxMDAwMDEsXG4gIH0sXG4gIHtcbiAgICAweDA6IDB4ODAwMDgyMCxcbiAgICAweDE6IDB4MjAwMDAsXG4gICAgMHgyOiAweDgwMDAwMDAsXG4gICAgMHgzOiAweDIwLFxuICAgIDB4NDogMHgyMDAyMCxcbiAgICAweDU6IDB4ODAyMDgyMCxcbiAgICAweDY6IDB4ODAyMDgwMCxcbiAgICAweDc6IDB4ODAwLFxuICAgIDB4ODogMHg4MDIwMDAwLFxuICAgIDB4OTogMHg4MDAwODAwLFxuICAgIDB4YTogMHgyMDgwMCxcbiAgICAweGI6IDB4ODAyMDAyMCxcbiAgICAweGM6IDB4ODIwLFxuICAgIDB4ZDogMHgwLFxuICAgIDB4ZTogMHg4MDAwMDIwLFxuICAgIDB4ZjogMHgyMDgyMCxcbiAgICAweDgwMDAwMDAwOiAweDgwMCxcbiAgICAweDgwMDAwMDAxOiAweDgwMjA4MjAsXG4gICAgMHg4MDAwMDAwMjogMHg4MDAwODIwLFxuICAgIDB4ODAwMDAwMDM6IDB4ODAwMDAwMCxcbiAgICAweDgwMDAwMDA0OiAweDgwMjAwMDAsXG4gICAgMHg4MDAwMDAwNTogMHgyMDgwMCxcbiAgICAweDgwMDAwMDA2OiAweDIwODIwLFxuICAgIDB4ODAwMDAwMDc6IDB4MjAsXG4gICAgMHg4MDAwMDAwODogMHg4MDAwMDIwLFxuICAgIDB4ODAwMDAwMDk6IDB4ODIwLFxuICAgIDB4ODAwMDAwMGE6IDB4MjAwMjAsXG4gICAgMHg4MDAwMDAwYjogMHg4MDIwODAwLFxuICAgIDB4ODAwMDAwMGM6IDB4MCxcbiAgICAweDgwMDAwMDBkOiAweDgwMjAwMjAsXG4gICAgMHg4MDAwMDAwZTogMHg4MDAwODAwLFxuICAgIDB4ODAwMDAwMGY6IDB4MjAwMDAsXG4gICAgMHgxMDogMHgyMDgyMCxcbiAgICAweDExOiAweDgwMjA4MDAsXG4gICAgMHgxMjogMHgyMCxcbiAgICAweDEzOiAweDgwMCxcbiAgICAweDE0OiAweDgwMDA4MDAsXG4gICAgMHgxNTogMHg4MDAwMDIwLFxuICAgIDB4MTY6IDB4ODAyMDAyMCxcbiAgICAweDE3OiAweDIwMDAwLFxuICAgIDB4MTg6IDB4MCxcbiAgICAweDE5OiAweDIwMDIwLFxuICAgIDB4MWE6IDB4ODAyMDAwMCxcbiAgICAweDFiOiAweDgwMDA4MjAsXG4gICAgMHgxYzogMHg4MDIwODIwLFxuICAgIDB4MWQ6IDB4MjA4MDAsXG4gICAgMHgxZTogMHg4MjAsXG4gICAgMHgxZjogMHg4MDAwMDAwLFxuICAgIDB4ODAwMDAwMTA6IDB4MjAwMDAsXG4gICAgMHg4MDAwMDAxMTogMHg4MDAsXG4gICAgMHg4MDAwMDAxMjogMHg4MDIwMDIwLFxuICAgIDB4ODAwMDAwMTM6IDB4MjA4MjAsXG4gICAgMHg4MDAwMDAxNDogMHgyMCxcbiAgICAweDgwMDAwMDE1OiAweDgwMjAwMDAsXG4gICAgMHg4MDAwMDAxNjogMHg4MDAwMDAwLFxuICAgIDB4ODAwMDAwMTc6IDB4ODAwMDgyMCxcbiAgICAweDgwMDAwMDE4OiAweDgwMjA4MjAsXG4gICAgMHg4MDAwMDAxOTogMHg4MDAwMDIwLFxuICAgIDB4ODAwMDAwMWE6IDB4ODAwMDgwMCxcbiAgICAweDgwMDAwMDFiOiAweDAsXG4gICAgMHg4MDAwMDAxYzogMHgyMDgwMCxcbiAgICAweDgwMDAwMDFkOiAweDgyMCxcbiAgICAweDgwMDAwMDFlOiAweDIwMDIwLFxuICAgIDB4ODAwMDAwMWY6IDB4ODAyMDgwMCxcbiAgfSxcbl07XG5cbi8vIE1hc2tzIHRoYXQgc2VsZWN0IHRoZSBTQk9YIGlucHV0XG5jb25zdCBTQk9YX01BU0sgPSBbXG4gIDB4ZjgwMDAwMDEsIDB4MWY4MDAwMDAsIDB4MDFmODAwMDAsIDB4MDAxZjgwMDAsXG4gIDB4MDAwMWY4MDAsIDB4MDAwMDFmODAsIDB4MDAwMDAxZjgsIDB4ODAwMDAwMWYsXG5dO1xuXG4vLyBTd2FwIGJpdHMgYWNyb3NzIHRoZSBsZWZ0IGFuZCByaWdodCB3b3Jkc1xuZnVuY3Rpb24gZXhjaGFuZ2VMUihvZmZzZXQsIG1hc2spIHtcbiAgY29uc3QgdCA9ICgodGhpcy5fbEJsb2NrID4+PiBvZmZzZXQpIF4gdGhpcy5fckJsb2NrKSAmIG1hc2s7XG4gIHRoaXMuX3JCbG9jayBePSB0O1xuICB0aGlzLl9sQmxvY2sgXj0gdCA8PCBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGV4Y2hhbmdlUkwob2Zmc2V0LCBtYXNrKSB7XG4gIGNvbnN0IHQgPSAoKHRoaXMuX3JCbG9jayA+Pj4gb2Zmc2V0KSBeIHRoaXMuX2xCbG9jaykgJiBtYXNrO1xuICB0aGlzLl9sQmxvY2sgXj0gdDtcbiAgdGhpcy5fckJsb2NrIF49IHQgPDwgb2Zmc2V0O1xufVxuXG4vKipcbiAqIERFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgREVTQWxnbyBleHRlbmRzIEJsb2NrQ2lwaGVyIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3Qga2V5ID0gdGhpcy5fa2V5O1xuICAgIGNvbnN0IGtleVdvcmRzID0ga2V5LndvcmRzO1xuXG4gICAgLy8gU2VsZWN0IDU2IGJpdHMgYWNjb3JkaW5nIHRvIFBDMVxuICAgIGNvbnN0IGtleUJpdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDU2OyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IGtleUJpdFBvcyA9IFBDMVtpXSAtIDE7XG4gICAgICBrZXlCaXRzW2ldID0gKGtleVdvcmRzW2tleUJpdFBvcyA+Pj4gNV0gPj4+ICgzMSAtIChrZXlCaXRQb3MgJSAzMikpKSAmIDE7XG4gICAgfVxuXG4gICAgLy8gQXNzZW1ibGUgMTYgc3Via2V5c1xuICAgIHRoaXMuX3N1YktleXMgPSBbXTtcbiAgICBjb25zdCBzdWJLZXlzID0gdGhpcy5fc3ViS2V5cztcbiAgICBmb3IgKGxldCBuU3ViS2V5ID0gMDsgblN1YktleSA8IDE2OyBuU3ViS2V5ICs9IDEpIHtcbiAgICAgIC8vIENyZWF0ZSBzdWJrZXlcbiAgICAgIHN1YktleXNbblN1YktleV0gPSBbXTtcbiAgICAgIGNvbnN0IHN1YktleSA9IHN1YktleXNbblN1YktleV07XG5cbiAgICAgIC8vIFNob3J0Y3V0XG4gICAgICBjb25zdCBiaXRTaGlmdCA9IEJJVF9TSElGVFNbblN1YktleV07XG5cbiAgICAgIC8vIFNlbGVjdCA0OCBiaXRzIGFjY29yZGluZyB0byBQQzJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjQ7IGkgKz0gMSkge1xuICAgICAgICAvLyBTZWxlY3QgZnJvbSB0aGUgbGVmdCAyOCBrZXkgYml0c1xuICAgICAgICBzdWJLZXlbKGkgLyA2KSB8IDBdIHw9IGtleUJpdHNbKChQQzJbaV0gLSAxKSArIGJpdFNoaWZ0KSAlIDI4XSA8PCAoMzEgLSAoaSAlIDYpKTtcblxuICAgICAgICAvLyBTZWxlY3QgZnJvbSB0aGUgcmlnaHQgMjgga2V5IGJpdHNcbiAgICAgICAgc3ViS2V5WzQgKyAoKGkgLyA2KSB8IDApXVxuICAgICAgICAgIHw9IGtleUJpdHNbMjggKyAoKChQQzJbaSArIDI0XSAtIDEpICsgYml0U2hpZnQpICUgMjgpXVxuICAgICAgICAgIDw8ICgzMSAtIChpICUgNikpO1xuICAgICAgfVxuXG4gICAgICAvLyBTaW5jZSBlYWNoIHN1YmtleSBpcyBhcHBsaWVkIHRvIGFuIGV4cGFuZGVkIDMyLWJpdCBpbnB1dCxcbiAgICAgIC8vIHRoZSBzdWJrZXkgY2FuIGJlIGJyb2tlbiBpbnRvIDggdmFsdWVzIHNjYWxlZCB0byAzMi1iaXRzLFxuICAgICAgLy8gd2hpY2ggYWxsb3dzIHRoZSBrZXkgdG8gYmUgdXNlZCB3aXRob3V0IGV4cGFuc2lvblxuICAgICAgc3ViS2V5WzBdID0gKHN1YktleVswXSA8PCAxKSB8IChzdWJLZXlbMF0gPj4+IDMxKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgNzsgaSArPSAxKSB7XG4gICAgICAgIHN1YktleVtpXSA+Pj49ICgoaSAtIDEpICogNCArIDMpO1xuICAgICAgfVxuICAgICAgc3ViS2V5WzddID0gKHN1YktleVs3XSA8PCA1KSB8IChzdWJLZXlbN10gPj4+IDI3KTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIGludmVyc2Ugc3Via2V5c1xuICAgIHRoaXMuX2ludlN1YktleXMgPSBbXTtcbiAgICBjb25zdCBpbnZTdWJLZXlzID0gdGhpcy5faW52U3ViS2V5cztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgIGludlN1YktleXNbaV0gPSBzdWJLZXlzWzE1IC0gaV07XG4gICAgfVxuICB9XG5cbiAgZW5jcnlwdEJsb2NrKE0sIG9mZnNldCkge1xuICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX3N1YktleXMpO1xuICB9XG5cbiAgZGVjcnlwdEJsb2NrKE0sIG9mZnNldCkge1xuICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludlN1YktleXMpO1xuICB9XG5cbiAgX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHN1YktleXMpIHtcbiAgICBjb25zdCBfTSA9IE07XG5cbiAgICAvLyBHZXQgaW5wdXRcbiAgICB0aGlzLl9sQmxvY2sgPSBNW29mZnNldF07XG4gICAgdGhpcy5fckJsb2NrID0gTVtvZmZzZXQgKyAxXTtcblxuICAgIC8vIEluaXRpYWwgcGVybXV0YXRpb25cbiAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgNCwgMHgwZjBmMGYwZik7XG4gICAgZXhjaGFuZ2VMUi5jYWxsKHRoaXMsIDE2LCAweDAwMDBmZmZmKTtcbiAgICBleGNoYW5nZVJMLmNhbGwodGhpcywgMiwgMHgzMzMzMzMzMyk7XG4gICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDgsIDB4MDBmZjAwZmYpO1xuICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCAxLCAweDU1NTU1NTU1KTtcblxuICAgIC8vIFJvdW5kc1xuICAgIGZvciAobGV0IHJvdW5kID0gMDsgcm91bmQgPCAxNjsgcm91bmQgKz0gMSkge1xuICAgICAgLy8gU2hvcnRjdXRzXG4gICAgICBjb25zdCBzdWJLZXkgPSBzdWJLZXlzW3JvdW5kXTtcbiAgICAgIGNvbnN0IGxCbG9jayA9IHRoaXMuX2xCbG9jaztcbiAgICAgIGNvbnN0IHJCbG9jayA9IHRoaXMuX3JCbG9jaztcblxuICAgICAgLy8gRmVpc3RlbCBmdW5jdGlvblxuICAgICAgbGV0IGYgPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA4OyBpICs9IDEpIHtcbiAgICAgICAgZiB8PSBTQk9YX1BbaV1bKChyQmxvY2sgXiBzdWJLZXlbaV0pICYgU0JPWF9NQVNLW2ldKSA+Pj4gMF07XG4gICAgICB9XG4gICAgICB0aGlzLl9sQmxvY2sgPSByQmxvY2s7XG4gICAgICB0aGlzLl9yQmxvY2sgPSBsQmxvY2sgXiBmO1xuICAgIH1cblxuICAgIC8vIFVuZG8gc3dhcCBmcm9tIGxhc3Qgcm91bmRcbiAgICBjb25zdCB0ID0gdGhpcy5fbEJsb2NrO1xuICAgIHRoaXMuX2xCbG9jayA9IHRoaXMuX3JCbG9jaztcbiAgICB0aGlzLl9yQmxvY2sgPSB0O1xuXG4gICAgLy8gRmluYWwgcGVybXV0YXRpb25cbiAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMSwgMHg1NTU1NTU1NSk7XG4gICAgZXhjaGFuZ2VSTC5jYWxsKHRoaXMsIDgsIDB4MDBmZjAwZmYpO1xuICAgIGV4Y2hhbmdlUkwuY2FsbCh0aGlzLCAyLCAweDMzMzMzMzMzKTtcbiAgICBleGNoYW5nZUxSLmNhbGwodGhpcywgMTYsIDB4MDAwMGZmZmYpO1xuICAgIGV4Y2hhbmdlTFIuY2FsbCh0aGlzLCA0LCAweDBmMGYwZjBmKTtcblxuICAgIC8vIFNldCBvdXRwdXRcbiAgICBfTVtvZmZzZXRdID0gdGhpcy5fbEJsb2NrO1xuICAgIF9NW29mZnNldCArIDFdID0gdGhpcy5fckJsb2NrO1xuICB9XG59XG5ERVNBbGdvLmtleVNpemUgPSA2NCAvIDMyO1xuREVTQWxnby5pdlNpemUgPSA2NCAvIDMyO1xuREVTQWxnby5ibG9ja1NpemUgPSA2NCAvIDMyO1xuXG4vKipcbiAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkRFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcbiAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkRFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcbiAqL1xuZXhwb3J0IGNvbnN0IERFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoREVTQWxnbyk7XG5cbi8qKlxuICogVHJpcGxlLURFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY2xhc3MgVHJpcGxlREVTQWxnbyBleHRlbmRzIEJsb2NrQ2lwaGVyIHtcbiAgX2RvUmVzZXQoKSB7XG4gICAgLy8gU2hvcnRjdXRzXG4gICAgY29uc3Qga2V5ID0gdGhpcy5fa2V5O1xuICAgIGNvbnN0IGtleVdvcmRzID0ga2V5LndvcmRzO1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUga2V5IGxlbmd0aCBpcyB2YWxpZCAoNjQsIDEyOCBvciA+PSAxOTIgYml0KVxuICAgIGlmIChrZXlXb3Jkcy5sZW5ndGggIT09IDIgJiYga2V5V29yZHMubGVuZ3RoICE9PSA0ICYmIGtleVdvcmRzLmxlbmd0aCA8IDYpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXkgbGVuZ3RoIC0gM0RFUyByZXF1aXJlcyB0aGUga2V5IGxlbmd0aCB0byBiZSA2NCwgMTI4LCAxOTIgb3IgPjE5Mi4nKTtcbiAgICB9XG5cbiAgICAvLyBFeHRlbmQgdGhlIGtleSBhY2NvcmRpbmcgdG8gdGhlIGtleWluZyBvcHRpb25zIGRlZmluZWQgaW4gM0RFUyBzdGFuZGFyZFxuICAgIGNvbnN0IGtleTEgPSBrZXlXb3Jkcy5zbGljZSgwLCAyKTtcbiAgICBjb25zdCBrZXkyID0ga2V5V29yZHMubGVuZ3RoIDwgNCA/IGtleVdvcmRzLnNsaWNlKDAsIDIpIDoga2V5V29yZHMuc2xpY2UoMiwgNCk7XG4gICAgY29uc3Qga2V5MyA9IGtleVdvcmRzLmxlbmd0aCA8IDYgPyBrZXlXb3Jkcy5zbGljZSgwLCAyKSA6IGtleVdvcmRzLnNsaWNlKDQsIDYpO1xuXG4gICAgLy8gQ3JlYXRlIERFUyBpbnN0YW5jZXNcbiAgICB0aGlzLl9kZXMxID0gREVTQWxnby5jcmVhdGVFbmNyeXB0b3IoV29yZEFycmF5LmNyZWF0ZShrZXkxKSk7XG4gICAgdGhpcy5fZGVzMiA9IERFU0FsZ28uY3JlYXRlRW5jcnlwdG9yKFdvcmRBcnJheS5jcmVhdGUoa2V5MikpO1xuICAgIHRoaXMuX2RlczMgPSBERVNBbGdvLmNyZWF0ZUVuY3J5cHRvcihXb3JkQXJyYXkuY3JlYXRlKGtleTMpKTtcbiAgfVxuXG4gIGVuY3J5cHRCbG9jayhNLCBvZmZzZXQpIHtcbiAgICB0aGlzLl9kZXMxLmVuY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuICAgIHRoaXMuX2RlczIuZGVjcnlwdEJsb2NrKE0sIG9mZnNldCk7XG4gICAgdGhpcy5fZGVzMy5lbmNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcbiAgfVxuXG4gIGRlY3J5cHRCbG9jayhNLCBvZmZzZXQpIHtcbiAgICB0aGlzLl9kZXMzLmRlY3J5cHRCbG9jayhNLCBvZmZzZXQpO1xuICAgIHRoaXMuX2RlczIuZW5jcnlwdEJsb2NrKE0sIG9mZnNldCk7XG4gICAgdGhpcy5fZGVzMS5kZWNyeXB0QmxvY2soTSwgb2Zmc2V0KTtcbiAgfVxufVxuVHJpcGxlREVTQWxnby5rZXlTaXplID0gMTkyIC8gMzI7XG5UcmlwbGVERVNBbGdvLml2U2l6ZSA9IDY0IC8gMzI7XG5UcmlwbGVERVNBbGdvLmJsb2NrU2l6ZSA9IDY0IC8gMzI7XG5cbi8qKlxuICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuVHJpcGxlREVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuVHJpcGxlREVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuICovXG5leHBvcnQgY29uc3QgVHJpcGxlREVTID0gQmxvY2tDaXBoZXIuX2NyZWF0ZUhlbHBlcihUcmlwbGVERVNBbGdvKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/tripledes.js\n");

/***/ }),

/***/ "./node_modules/crypto-es/lib/x64-core.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-es/lib/x64-core.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"X64Word\": function() { return /* binding */ X64Word; },\n/* harmony export */   \"X64WordArray\": function() { return /* binding */ X64WordArray; }\n/* harmony export */ });\n/* harmony import */ var _core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core.js */ \"./node_modules/crypto-es/lib/core.js\");\n\n\nconst X32WordArray = _core_js__WEBPACK_IMPORTED_MODULE_0__.WordArray;\n\n/**\n * A 64-bit word.\n */\nclass X64Word extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Base {\n  /**\n   * Initializes a newly created 64-bit word.\n   *\n   * @param {number} high The high 32 bits.\n   * @param {number} low The low 32 bits.\n   *\n   * @example\n   *\n   *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);\n   */\n  constructor(high, low) {\n    super();\n\n    this.high = high;\n    this.low = low;\n  }\n}\n\n/**\n * An array of 64-bit words.\n *\n * @property {Array} words The array of CryptoJS.x64.Word objects.\n * @property {number} sigBytes The number of significant bytes in this word array.\n */\nclass X64WordArray extends _core_js__WEBPACK_IMPORTED_MODULE_0__.Base {\n  /**\n   * Initializes a newly created word array.\n   *\n   * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.\n   * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.x64.WordArray.create();\n   *\n   *     var wordArray = CryptoJS.x64.WordArray.create([\n   *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n   *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n   *     ]);\n   *\n   *     var wordArray = CryptoJS.x64.WordArray.create([\n   *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),\n   *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)\n   *     ], 10);\n   */\n  constructor(words = [], sigBytes = words.length * 8) {\n    super();\n\n    this.words = words;\n    this.sigBytes = sigBytes;\n  }\n\n  /**\n   * Converts this 64-bit word array to a 32-bit word array.\n   *\n   * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.\n   *\n   * @example\n   *\n   *     var x32WordArray = x64WordArray.toX32();\n   */\n  toX32() {\n    // Shortcuts\n    const x64Words = this.words;\n    const x64WordsLength = x64Words.length;\n\n    // Convert\n    const x32Words = [];\n    for (let i = 0; i < x64WordsLength; i += 1) {\n      const x64Word = x64Words[i];\n      x32Words.push(x64Word.high);\n      x32Words.push(x64Word.low);\n    }\n\n    return X32WordArray.create(x32Words, this.sigBytes);\n  }\n\n  /**\n   * Creates a copy of this word array.\n   *\n   * @return {X64WordArray} The clone.\n   *\n   * @example\n   *\n   *     var clone = x64WordArray.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n\n    // Clone \"words\" array\n    clone.words = this.words.slice(0);\n    const { words } = clone;\n\n    // Clone each X64Word object\n    const wordsLength = words.length;\n    for (let i = 0; i < wordsLength; i += 1) {\n      words[i] = words[i].clone();\n    }\n\n    return clone;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2NyeXB0by1lcy9saWIveDY0LWNvcmUuanM/NzY2ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFHbUI7O0FBRW5CLHFCQUFxQiwrQ0FBUzs7QUFFOUI7QUFDQTtBQUNBO0FBQ08sc0JBQXNCLDBDQUFJO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNPLDJCQUEyQiwwQ0FBSTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLG9CQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFROztBQUVuQjtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9jcnlwdG8tZXMvbGliL3g2NC1jb3JlLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmFzZSxcbiAgV29yZEFycmF5LFxufSBmcm9tICcuL2NvcmUuanMnO1xuXG5jb25zdCBYMzJXb3JkQXJyYXkgPSBXb3JkQXJyYXk7XG5cbi8qKlxuICogQSA2NC1iaXQgd29yZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFg2NFdvcmQgZXh0ZW5kcyBCYXNlIHtcbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCA2NC1iaXQgd29yZC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhpZ2ggVGhlIGhpZ2ggMzIgYml0cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxvdyBUaGUgbG93IDMyIGJpdHMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgeDY0V29yZCA9IENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDAwMDEwMjAzLCAweDA0MDUwNjA3KTtcbiAgICovXG4gIGNvbnN0cnVjdG9yKGhpZ2gsIGxvdykge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmhpZ2ggPSBoaWdoO1xuICAgIHRoaXMubG93ID0gbG93O1xuICB9XG59XG5cbi8qKlxuICogQW4gYXJyYXkgb2YgNjQtYml0IHdvcmRzLlxuICpcbiAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiBDcnlwdG9KUy54NjQuV29yZCBvYmplY3RzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuICovXG5leHBvcnQgY2xhc3MgWDY0V29yZEFycmF5IGV4dGVuZHMgQmFzZSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiBDcnlwdG9KUy54NjQuV29yZCBvYmplY3RzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy54NjQuV29yZEFycmF5LmNyZWF0ZSgpO1xuICAgKlxuICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLng2NC5Xb3JkQXJyYXkuY3JlYXRlKFtcbiAgICogICAgICAgICBDcnlwdG9KUy54NjQuV29yZC5jcmVhdGUoMHgwMDAxMDIwMywgMHgwNDA1MDYwNyksXG4gICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MTgxOTFhMWIsIDB4MWMxZDFlMWYpXG4gICAqICAgICBdKTtcbiAgICpcbiAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy54NjQuV29yZEFycmF5LmNyZWF0ZShbXG4gICAqICAgICAgICAgQ3J5cHRvSlMueDY0LldvcmQuY3JlYXRlKDB4MDAwMTAyMDMsIDB4MDQwNTA2MDcpLFxuICAgKiAgICAgICAgIENyeXB0b0pTLng2NC5Xb3JkLmNyZWF0ZSgweDE4MTkxYTFiLCAweDFjMWQxZTFmKVxuICAgKiAgICAgXSwgMTApO1xuICAgKi9cbiAgY29uc3RydWN0b3Iod29yZHMgPSBbXSwgc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA4KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMud29yZHMgPSB3b3JkcztcbiAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgdGhpcyA2NC1iaXQgd29yZCBhcnJheSB0byBhIDMyLWJpdCB3b3JkIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJuIHtDcnlwdG9KUy5saWIuV29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkncyBkYXRhIGFzIGEgMzItYml0IHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqICAgICB2YXIgeDMyV29yZEFycmF5ID0geDY0V29yZEFycmF5LnRvWDMyKCk7XG4gICAqL1xuICB0b1gzMigpIHtcbiAgICAvLyBTaG9ydGN1dHNcbiAgICBjb25zdCB4NjRXb3JkcyA9IHRoaXMud29yZHM7XG4gICAgY29uc3QgeDY0V29yZHNMZW5ndGggPSB4NjRXb3Jkcy5sZW5ndGg7XG5cbiAgICAvLyBDb252ZXJ0XG4gICAgY29uc3QgeDMyV29yZHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHg2NFdvcmRzTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IHg2NFdvcmQgPSB4NjRXb3Jkc1tpXTtcbiAgICAgIHgzMldvcmRzLnB1c2goeDY0V29yZC5oaWdoKTtcbiAgICAgIHgzMldvcmRzLnB1c2goeDY0V29yZC5sb3cpO1xuICAgIH1cblxuICAgIHJldHVybiBYMzJXb3JkQXJyYXkuY3JlYXRlKHgzMldvcmRzLCB0aGlzLnNpZ0J5dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge1g2NFdvcmRBcnJheX0gVGhlIGNsb25lLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgICAgdmFyIGNsb25lID0geDY0V29yZEFycmF5LmNsb25lKCk7XG4gICAqL1xuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZSA9IHN1cGVyLmNsb25lLmNhbGwodGhpcyk7XG5cbiAgICAvLyBDbG9uZSBcIndvcmRzXCIgYXJyYXlcbiAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG4gICAgY29uc3QgeyB3b3JkcyB9ID0gY2xvbmU7XG5cbiAgICAvLyBDbG9uZSBlYWNoIFg2NFdvcmQgb2JqZWN0XG4gICAgY29uc3Qgd29yZHNMZW5ndGggPSB3b3Jkcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkc0xlbmd0aDsgaSArPSAxKSB7XG4gICAgICB3b3Jkc1tpXSA9IHdvcmRzW2ldLmNsb25lKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/crypto-es/lib/x64-core.js\n");

/***/ }),

/***/ "./node_modules/lodash.defaults/index.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash.defaults/index.js ***!
  \***********************************************/
/***/ (function(module) {

eval("/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as references for various `Number` constants. */\nvar MAX_SAFE_INTEGER = 9007199254740991;\n\n/** `Object#toString` result references. */\nvar argsTag = '[object Arguments]',\n    funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]';\n\n/** Used to detect unsigned integer values. */\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\n\n/**\n * A faster alternative to `Function#apply`, this function invokes `func`\n * with the `this` binding of `thisArg` and the arguments of `args`.\n *\n * @private\n * @param {Function} func The function to invoke.\n * @param {*} thisArg The `this` binding of `func`.\n * @param {Array} args The arguments to invoke `func` with.\n * @returns {*} Returns the result of `func`.\n */\nfunction apply(func, thisArg, args) {\n  switch (args.length) {\n    case 0: return func.call(thisArg);\n    case 1: return func.call(thisArg, args[0]);\n    case 2: return func.call(thisArg, args[0], args[1]);\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\n  }\n  return func.apply(thisArg, args);\n}\n\n/**\n * The base implementation of `_.times` without support for iteratee shorthands\n * or max array length checks.\n *\n * @private\n * @param {number} n The number of times to invoke `iteratee`.\n * @param {Function} iteratee The function invoked per iteration.\n * @returns {Array} Returns the array of results.\n */\nfunction baseTimes(n, iteratee) {\n  var index = -1,\n      result = Array(n);\n\n  while (++index < n) {\n    result[index] = iteratee(index);\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max;\n\n/**\n * Creates an array of the enumerable property names of the array-like `value`.\n *\n * @private\n * @param {*} value The value to query.\n * @param {boolean} inherited Specify returning inherited property names.\n * @returns {Array} Returns the array of property names.\n */\nfunction arrayLikeKeys(value, inherited) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  // Safari 9 makes `arguments.length` enumerable in strict mode.\n  var result = (isArray(value) || isArguments(value))\n    ? baseTimes(value.length, String)\n    : [];\n\n  var length = result.length,\n      skipIndexes = !!length;\n\n  for (var key in value) {\n    if ((inherited || hasOwnProperty.call(value, key)) &&\n        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Used by `_.defaults` to customize its `_.assignIn` use.\n *\n * @private\n * @param {*} objValue The destination value.\n * @param {*} srcValue The source value.\n * @param {string} key The key of the property to assign.\n * @param {Object} object The parent object of `objValue`.\n * @returns {*} Returns the value to assign.\n */\nfunction assignInDefaults(objValue, srcValue, key, object) {\n  if (objValue === undefined ||\n      (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {\n    return srcValue;\n  }\n  return objValue;\n}\n\n/**\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignValue(object, key, value) {\n  var objValue = object[key];\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\n      (value === undefined && !(key in object))) {\n    object[key] = value;\n  }\n}\n\n/**\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction baseKeysIn(object) {\n  if (!isObject(object)) {\n    return nativeKeysIn(object);\n  }\n  var isProto = isPrototype(object),\n      result = [];\n\n  for (var key in object) {\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\n *\n * @private\n * @param {Function} func The function to apply a rest parameter to.\n * @param {number} [start=func.length-1] The start position of the rest parameter.\n * @returns {Function} Returns the new function.\n */\nfunction baseRest(func, start) {\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\n  return function() {\n    var args = arguments,\n        index = -1,\n        length = nativeMax(args.length - start, 0),\n        array = Array(length);\n\n    while (++index < length) {\n      array[index] = args[start + index];\n    }\n    index = -1;\n    var otherArgs = Array(start + 1);\n    while (++index < start) {\n      otherArgs[index] = args[index];\n    }\n    otherArgs[start] = array;\n    return apply(func, this, otherArgs);\n  };\n}\n\n/**\n * Copies properties of `source` to `object`.\n *\n * @private\n * @param {Object} source The object to copy properties from.\n * @param {Array} props The property identifiers to copy.\n * @param {Object} [object={}] The object to copy properties to.\n * @param {Function} [customizer] The function to customize copied values.\n * @returns {Object} Returns `object`.\n */\nfunction copyObject(source, props, object, customizer) {\n  object || (object = {});\n\n  var index = -1,\n      length = props.length;\n\n  while (++index < length) {\n    var key = props[index];\n\n    var newValue = customizer\n      ? customizer(object[key], source[key], key, object, source)\n      : undefined;\n\n    assignValue(object, key, newValue === undefined ? source[key] : newValue);\n  }\n  return object;\n}\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\n/**\n * Checks if `value` is a valid array-like index.\n *\n * @private\n * @param {*} value The value to check.\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\n */\nfunction isIndex(value, length) {\n  length = length == null ? MAX_SAFE_INTEGER : length;\n  return !!length &&\n    (typeof value == 'number' || reIsUint.test(value)) &&\n    (value > -1 && value % 1 == 0 && value < length);\n}\n\n/**\n * Checks if the given arguments are from an iteratee call.\n *\n * @private\n * @param {*} value The potential iteratee value argument.\n * @param {*} index The potential iteratee index or key argument.\n * @param {*} object The potential iteratee object argument.\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\n *  else `false`.\n */\nfunction isIterateeCall(value, index, object) {\n  if (!isObject(object)) {\n    return false;\n  }\n  var type = typeof index;\n  if (type == 'number'\n        ? (isArrayLike(object) && isIndex(index, object.length))\n        : (type == 'string' && index in object)\n      ) {\n    return eq(object[index], value);\n  }\n  return false;\n}\n\n/**\n * Checks if `value` is likely a prototype object.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\n */\nfunction isPrototype(value) {\n  var Ctor = value && value.constructor,\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\n\n  return value === proto;\n}\n\n/**\n * This function is like\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\n * except that it includes inherited enumerable properties.\n *\n * @private\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n */\nfunction nativeKeysIn(object) {\n  var result = [];\n  if (object != null) {\n    for (var key in Object(object)) {\n      result.push(key);\n    }\n  }\n  return result;\n}\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is likely an `arguments` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\n *  else `false`.\n * @example\n *\n * _.isArguments(function() { return arguments; }());\n * // => true\n *\n * _.isArguments([1, 2, 3]);\n * // => false\n */\nfunction isArguments(value) {\n  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.\n  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&\n    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is array-like. A value is considered array-like if it's\n * not a function and has a `value.length` that's an integer greater than or\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\n * @example\n *\n * _.isArrayLike([1, 2, 3]);\n * // => true\n *\n * _.isArrayLike(document.body.children);\n * // => true\n *\n * _.isArrayLike('abc');\n * // => true\n *\n * _.isArrayLike(_.noop);\n * // => false\n */\nfunction isArrayLike(value) {\n  return value != null && isLength(value.length) && !isFunction(value);\n}\n\n/**\n * This method is like `_.isArrayLike` except that it also checks if `value`\n * is an object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array-like object,\n *  else `false`.\n * @example\n *\n * _.isArrayLikeObject([1, 2, 3]);\n * // => true\n *\n * _.isArrayLikeObject(document.body.children);\n * // => true\n *\n * _.isArrayLikeObject('abc');\n * // => false\n *\n * _.isArrayLikeObject(_.noop);\n * // => false\n */\nfunction isArrayLikeObject(value) {\n  return isObjectLike(value) && isArrayLike(value);\n}\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is a valid array-like length.\n *\n * **Note:** This method is loosely based on\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\n * @example\n *\n * _.isLength(3);\n * // => true\n *\n * _.isLength(Number.MIN_VALUE);\n * // => false\n *\n * _.isLength(Infinity);\n * // => false\n *\n * _.isLength('3');\n * // => false\n */\nfunction isLength(value) {\n  return typeof value == 'number' &&\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * This method is like `_.assignIn` except that it accepts `customizer`\n * which is invoked to produce the assigned values. If `customizer` returns\n * `undefined`, assignment is handled by the method instead. The `customizer`\n * is invoked with five arguments: (objValue, srcValue, key, object, source).\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @alias extendWith\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} sources The source objects.\n * @param {Function} [customizer] The function to customize assigned values.\n * @returns {Object} Returns `object`.\n * @see _.assignWith\n * @example\n *\n * function customizer(objValue, srcValue) {\n *   return _.isUndefined(objValue) ? srcValue : objValue;\n * }\n *\n * var defaults = _.partialRight(_.assignInWith, customizer);\n *\n * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar assignInWith = createAssigner(function(object, source, srcIndex, customizer) {\n  copyObject(source, keysIn(source), object, customizer);\n});\n\n/**\n * Assigns own and inherited enumerable string keyed properties of source\n * objects to the destination object for all destination properties that\n * resolve to `undefined`. Source objects are applied from left to right.\n * Once a property is set, additional values of the same property are ignored.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @since 0.1.0\n * @memberOf _\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @see _.defaultsDeep\n * @example\n *\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\n * // => { 'a': 1, 'b': 2 }\n */\nvar defaults = baseRest(function(args) {\n  args.push(undefined, assignInDefaults);\n  return apply(assignInWith, undefined, args);\n});\n\n/**\n * Creates an array of the own and inherited enumerable property names of `object`.\n *\n * **Note:** Non-object values are coerced to objects.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Object\n * @param {Object} object The object to query.\n * @returns {Array} Returns the array of property names.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.keysIn(new Foo);\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\n */\nfunction keysIn(object) {\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\n}\n\nmodule.exports = defaults;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC5kZWZhdWx0cy9pbmRleC5qcz8xM2NhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxNQUFNO0FBQ2pCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxFQUFFO0FBQ2IsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUU7QUFDYixXQUFXLEVBQUU7QUFDYixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsRUFBRTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFNBQVM7QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxHQUFHLFNBQVMsR0FBRyxTQUFTO0FBQzlDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUyxHQUFHLFNBQVMsR0FBRyxTQUFTO0FBQ2hELFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbG9kYXNoLmRlZmF1bHRzL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsb2Rhc2ggKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XCJucG1cIiAtbyAuL2BcbiAqIENvcHlyaWdodCBqUXVlcnkgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL2pxdWVyeS5vcmcvPlxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cbiAqIENvcHlyaWdodCBKZXJlbXkgQXNoa2VuYXMsIERvY3VtZW50Q2xvdWQgYW5kIEludmVzdGlnYXRpdmUgUmVwb3J0ZXJzICYgRWRpdG9yc1xuICovXG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICogd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgYHRoaXNBcmdgIGFuZCB0aGUgYXJndW1lbnRzIG9mIGBhcmdzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc3VsdCBvZiBgZnVuY2AuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnKTtcbiAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgfVxuICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIC8vIFNhZmFyaSA4LjEgbWFrZXMgYGFyZ3VtZW50cy5jYWxsZWVgIGVudW1lcmFibGUgaW4gc3RyaWN0IG1vZGUuXG4gIC8vIFNhZmFyaSA5IG1ha2VzIGBhcmd1bWVudHMubGVuZ3RoYCBlbnVtZXJhYmxlIGluIHN0cmljdCBtb2RlLlxuICB2YXIgcmVzdWx0ID0gKGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSlcbiAgICA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZylcbiAgICA6IFtdO1xuXG4gIHZhciBsZW5ndGggPSByZXN1bHQubGVuZ3RoLFxuICAgICAgc2tpcEluZGV4ZXMgPSAhIWxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChrZXkgPT0gJ2xlbmd0aCcgfHwgaXNJbmRleChrZXksIGxlbmd0aCkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBVc2VkIGJ5IGBfLmRlZmF1bHRzYCB0byBjdXN0b21pemUgaXRzIGBfLmFzc2lnbkluYCB1c2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgc291cmNlIHZhbHVlLlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25JbkRlZmF1bHRzKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgIChlcShvYmpWYWx1ZSwgb2JqZWN0UHJvdG9ba2V5XSkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkge1xuICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqVmFsdWU7XG59XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXN0YCB3aGljaCBkb2Vzbid0IHZhbGlkYXRlIG9yIGNvZXJjZSBhcmd1bWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlc3QoZnVuYywgc3RhcnQpIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gYXJyYXk7XG4gICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gIH07XG59XG5cbi8qKlxuICogQ29waWVzIHByb3BlcnRpZXMgb2YgYHNvdXJjZWAgdG8gYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycyB0byBjb3B5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29waWVkIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlPYmplY3Qoc291cmNlLCBwcm9wcywgb2JqZWN0LCBjdXN0b21pemVyKSB7XG4gIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcblxuICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSA9PT0gdW5kZWZpbmVkID8gc291cmNlW2tleV0gOiBuZXdWYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZW9mIHZhbHVlID09ICdudW1iZXInIHx8IHJlSXNVaW50LnRlc3QodmFsdWUpKSAmJlxuICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFBlcmZvcm1zIGFcbiAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gKlxuICogXy5lcShvYmplY3QsIG9iamVjdCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcShvYmplY3QsIG90aGVyKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcSgnYScsICdhJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5lcSgnYScsIE9iamVjdCgnYScpKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5lcShOYU4sIE5hTik7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGVxKHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgLy8gU2FmYXJpIDguMSBtYWtlcyBgYXJndW1lbnRzLmNhbGxlZWAgZW51bWVyYWJsZSBpbiBzdHJpY3QgbW9kZS5cbiAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAoIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKSB8fCBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBhcmdzVGFnKTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaXNBcnJheUxpa2VgIGV4Y2VwdCB0aGF0IGl0IGFsc28gY2hlY2tzIGlmIGB2YWx1ZWBcbiAqIGlzIGFuIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXlMaWtlT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBpc0FycmF5TGlrZSh2YWx1ZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOC05IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5IGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBpc09iamVjdCh2YWx1ZSkgPyBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiAhIXZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbkluYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYFxuICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICogaXMgaW52b2tlZCB3aXRoIGZpdmUgYXJndW1lbnRzOiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlKS5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAYWxpYXMgZXh0ZW5kV2l0aFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5hc3NpZ25XaXRoXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gKiB9XG4gKlxuICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICpcbiAqIGRlZmF1bHRzKHsgJ2EnOiAxIH0sIHsgJ2InOiAyIH0sIHsgJ2EnOiAzIH0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbnZhciBhc3NpZ25JbldpdGggPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIpIHtcbiAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xufSk7XG5cbi8qKlxuICogQXNzaWducyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZVxuICogb2JqZWN0cyB0byB0aGUgZGVzdGluYXRpb24gb2JqZWN0IGZvciBhbGwgZGVzdGluYXRpb24gcHJvcGVydGllcyB0aGF0XG4gKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gKiBPbmNlIGEgcHJvcGVydHkgaXMgc2V0LCBhZGRpdGlvbmFsIHZhbHVlcyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSBhcmUgaWdub3JlZC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqL1xudmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICBhcmdzLnB1c2godW5kZWZpbmVkLCBhc3NpZ25JbkRlZmF1bHRzKTtcbiAgcmV0dXJuIGFwcGx5KGFzc2lnbkluV2l0aCwgdW5kZWZpbmVkLCBhcmdzKTtcbn0pO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/lodash.defaults/index.js\n");

/***/ }),

/***/ "./node_modules/sturdy-websocket/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/sturdy-websocket/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nvar defaults = __webpack_require__(/*! lodash.defaults */ \"./node_modules/lodash.defaults/index.js\");\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\nvar SturdyWebSocket = /** @class */ (function () {\n    function SturdyWebSocket(url, protocolsOrOptions, options) {\n        this.url = url;\n        this.onclose = null;\n        this.onerror = null;\n        this.onmessage = null;\n        this.onopen = null;\n        this.ondown = null;\n        this.onreopen = null;\n        this.CONNECTING = SturdyWebSocket.CONNECTING;\n        this.OPEN = SturdyWebSocket.OPEN;\n        this.CLOSING = SturdyWebSocket.CLOSING;\n        this.CLOSED = SturdyWebSocket.CLOSED;\n        this.hasBeenOpened = false;\n        this.isClosed = false;\n        this.messageBuffer = [];\n        this.nextRetryTime = 0;\n        this.reconnectCount = 0;\n        this.lastKnownExtensions = \"\";\n        this.lastKnownProtocol = \"\";\n        this.listeners = {};\n        if (protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)) {\n            this.protocols = protocolsOrOptions;\n        }\n        else {\n            options = protocolsOrOptions;\n        }\n        this.options = defaults({}, options, SturdyWebSocket.DEFAULT_OPTIONS);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            }\n            else {\n                throw new Error(\"WebSocket not present in global scope and no \" +\n                    \"wsConstructor option was provided.\");\n            }\n        }\n        this.openNewWebSocket();\n    }\n    Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n        get: function () {\n            return this.binaryTypeInternal || \"blob\";\n        },\n        set: function (binaryType) {\n            this.binaryTypeInternal = binaryType;\n            if (this.ws) {\n                this.ws.binaryType = binaryType;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n        get: function () {\n            var sum = this.ws ? this.ws.bufferedAmount : 0;\n            var hasUnknownAmount = false;\n            this.messageBuffer.forEach(function (data) {\n                var byteLength = getDataByteLength(data);\n                if (byteLength != null) {\n                    sum += byteLength;\n                }\n                else {\n                    hasUnknownAmount = true;\n                }\n            });\n            if (hasUnknownAmount) {\n                this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\");\n            }\n            return sum;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n        get: function () {\n            return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n        get: function () {\n            return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n        get: function () {\n            return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    SturdyWebSocket.prototype.close = function (code, reason) {\n        if (this.ws) {\n            this.ws.close(code, reason);\n        }\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    };\n    SturdyWebSocket.prototype.send = function (data) {\n        if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        }\n        else {\n            this.messageBuffer.push(data);\n        }\n    };\n    SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    };\n    SturdyWebSocket.prototype.dispatchEvent = function (event) {\n        return this.dispatchEventOfType(event.type, event);\n    };\n    SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(function (l) { return l !== listener; });\n        }\n    };\n    SturdyWebSocket.prototype.openNewWebSocket = function () {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;\n        this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n        var ws = new wsConstructor(this.url, this.protocols);\n        ws.onclose = function (event) { return _this.handleClose(event); };\n        ws.onerror = function (event) { return _this.handleError(event); };\n        ws.onmessage = function (event) { return _this.handleMessage(event); };\n        ws.onopen = function (event) { return _this.handleOpen(event); };\n        this.connectTimeoutId = setTimeout(function () {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            _this.clearConnectTimeout();\n            ws.close();\n        }, connectTimeout);\n        this.ws = ws;\n    };\n    SturdyWebSocket.prototype.handleOpen = function (event) {\n        var _this = this;\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        var allClearResetTime = this.options.allClearResetTime;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        }\n        else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        }\n        else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(function (message) { return _this.send(message); });\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(function () {\n            _this.clearAllClearTimeout();\n            _this.nextRetryTime = 0;\n            _this.reconnectCount = 0;\n            var openTime = (allClearResetTime / 1000) | 0;\n            _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" +\n                \" retry time and count.\");\n        }, allClearResetTime);\n    };\n    SturdyWebSocket.prototype.handleMessage = function (event) {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    };\n    SturdyWebSocket.prototype.handleClose = function (event) {\n        var _this = this;\n        if (this.isClosed) {\n            return;\n        }\n        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.ws = undefined;\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n            return;\n        }\n        var willReconnect = shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n        }\n        else {\n            willReconnect.then(function (willReconnectResolved) {\n                if (_this.isClosed) {\n                    return;\n                }\n                _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n            });\n        }\n    };\n    SturdyWebSocket.prototype.handleError = function (event) {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    };\n    SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n        if (willReconnect) {\n            this.reconnect();\n        }\n        else {\n            this.stopReconnecting(event, denialReason);\n        }\n    };\n    SturdyWebSocket.prototype.reconnect = function () {\n        var _this = this;\n        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;\n        this.reconnectCount++;\n        var retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n        setTimeout(function () { return _this.openNewWebSocket(); }, retryTime);\n        var retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n    };\n    SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n        this.debugLog(debugReason);\n        this.shutdown();\n        this.dispatchEventOfType(\"close\", event);\n    };\n    SturdyWebSocket.prototype.shutdown = function () {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n    };\n    SturdyWebSocket.prototype.clearAllTimeouts = function () {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    };\n    SturdyWebSocket.prototype.clearConnectTimeout = function () {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    };\n    SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n        var _this = this;\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(function (listener) { return _this.callListener(listener, event); });\n        }\n        return !event || !event.defaultPrevented;\n    };\n    SturdyWebSocket.prototype.callListener = function (listener, event) {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        }\n        else {\n            listener.handleEvent.call(this, event);\n        }\n    };\n    SturdyWebSocket.prototype.debugLog = function (message) {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    };\n    SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n        var maxReconnectAttempts = this.options.maxReconnectAttempts;\n        return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n    };\n    SturdyWebSocket.DEFAULT_OPTIONS = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: function () { return true; },\n        wsConstructor: undefined,\n    };\n    SturdyWebSocket.CONNECTING = 0;\n    SturdyWebSocket.OPEN = 1;\n    SturdyWebSocket.CLOSING = 2;\n    SturdyWebSocket.CLOSED = 3;\n    return SturdyWebSocket;\n}());\nexports.default = SturdyWebSocket;\nfunction getDataByteLength(data) {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    }\n    else if (data instanceof Blob) {\n        return data.size;\n    }\n    else {\n        return undefined;\n    }\n}\nfunction pluralize(s, n) {\n    return n === 1 ? s : s + \"s\";\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3N0dXJkeS13ZWJzb2NrZXQvZGlzdC9pbmRleC5qcz8xYTY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLENBQUMsY0FBYyxFQUFDO0FBQzdELGVBQWUsbUJBQU8sQ0FBQyxnRUFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHVCQUF1QixFQUFFO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGlDQUFpQztBQUN4RSx1Q0FBdUMsaUNBQWlDO0FBQ3hFLHlDQUF5QyxtQ0FBbUM7QUFDNUUsc0NBQXNDLGdDQUFnQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsNEJBQTRCLEVBQUU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsaUNBQWlDLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLDRDQUE0QyxFQUFFO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsYUFBYSxFQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9zdHVyZHktd2Vic29ja2V0L2Rpc3QvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoXCJsb2Rhc2guZGVmYXVsdHNcIik7XG52YXIgU0hPVUxEX1JFQ09OTkVDVF9GQUxTRV9NRVNTQUdFID0gXCJQcm92aWRlZCBzaG91bGRSZWNvbm5lY3QoKSByZXR1cm5lZCBmYWxzZS4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbnZhciBTSE9VTERfUkVDT05ORUNUX1BST01JU0VfRkFMU0VfTUVTU0FHRSA9IFwiUHJvdmlkZWQgc2hvdWxkUmVjb25uZWN0KCkgcmVzb2x2ZWQgdG8gZmFsc2UuIENsb3NpbmcgcGVybWFuZW50bHkuXCI7XG52YXIgU3R1cmR5V2ViU29ja2V0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN0dXJkeVdlYlNvY2tldCh1cmwsIHByb3RvY29sc09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgICB0aGlzLm9ub3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMub25kb3duID0gbnVsbDtcbiAgICAgICAgdGhpcy5vbnJlb3BlbiA9IG51bGw7XG4gICAgICAgIHRoaXMuQ09OTkVDVElORyA9IFN0dXJkeVdlYlNvY2tldC5DT05ORUNUSU5HO1xuICAgICAgICB0aGlzLk9QRU4gPSBTdHVyZHlXZWJTb2NrZXQuT1BFTjtcbiAgICAgICAgdGhpcy5DTE9TSU5HID0gU3R1cmR5V2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICAgIHRoaXMuQ0xPU0VEID0gU3R1cmR5V2ViU29ja2V0LkNMT1NFRDtcbiAgICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQnVmZmVyID0gW107XG4gICAgICAgIHRoaXMubmV4dFJldHJ5VGltZSA9IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0Q291bnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnMgPSBcIlwiO1xuICAgICAgICB0aGlzLmxhc3RLbm93blByb3RvY29sID0gXCJcIjtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICAgICAgaWYgKHByb3RvY29sc09yT3B0aW9ucyA9PSBudWxsIHx8XG4gICAgICAgICAgICB0eXBlb2YgcHJvdG9jb2xzT3JPcHRpb25zID09PSBcInN0cmluZ1wiIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KHByb3RvY29sc09yT3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXMucHJvdG9jb2xzID0gcHJvdG9jb2xzT3JPcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHByb3RvY29sc09yT3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBkZWZhdWx0cyh7fSwgb3B0aW9ucywgU3R1cmR5V2ViU29ja2V0LkRFRkFVTFRfT1BUSU9OUyk7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLndzQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgV2ViU29ja2V0ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLndzQ29uc3RydWN0b3IgPSBXZWJTb2NrZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXZWJTb2NrZXQgbm90IHByZXNlbnQgaW4gZ2xvYmFsIHNjb3BlIGFuZCBubyBcIiArXG4gICAgICAgICAgICAgICAgICAgIFwid3NDb25zdHJ1Y3RvciBvcHRpb24gd2FzIHByb3ZpZGVkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW5OZXdXZWJTb2NrZXQoKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwiYmluYXJ5VHlwZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmluYXJ5VHlwZUludGVybmFsIHx8IFwiYmxvYlwiO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChiaW5hcnlUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgICAgIHRoaXMud3MuYmluYXJ5VHlwZSA9IGJpbmFyeVR5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcImJ1ZmZlcmVkQW1vdW50XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gdGhpcy53cyA/IHRoaXMud3MuYnVmZmVyZWRBbW91bnQgOiAwO1xuICAgICAgICAgICAgdmFyIGhhc1Vua25vd25BbW91bnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlci5mb3JFYWNoKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBnZXREYXRhQnl0ZUxlbmd0aChkYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZUxlbmd0aCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzVW5rbm93bkFtb3VudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaGFzVW5rbm93bkFtb3VudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWdMb2coXCJTb21lIGJ1ZmZlcmVkIGRhdGEgaGFkIHVua25vd24gbGVuZ3RoLiBidWZmZXJlZEFtb3VudCgpXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiByZXR1cm4gdmFsdWUgbWF5IGJlIGJlbG93IHRoZSBjb3JyZWN0IGFtb3VudC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3VtO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZSwgXCJleHRlbnNpb25zXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53cyA/IHRoaXMud3MuZXh0ZW5zaW9ucyA6IHRoaXMubGFzdEtub3duRXh0ZW5zaW9ucztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUsIFwicHJvdG9jb2xcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndzID8gdGhpcy53cy5wcm90b2NvbCA6IHRoaXMubGFzdEtub3duUHJvdG9jb2w7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLCBcInJlYWR5U3RhdGVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlzQ2xvc2VkID8gU3R1cmR5V2ViU29ja2V0LkNMT1NFRCA6IFN0dXJkeVdlYlNvY2tldC5PUEVOO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgICAgICBpZiAodGhpcy53cykge1xuICAgICAgICAgICAgdGhpcy53cy5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBwZXJtYW5lbnRseSBjbG9zZWQgYnkgY2xpZW50LlwiKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmICh0aGlzLndzICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gdGhpcy5PUEVOKSB7XG4gICAgICAgICAgICB0aGlzLndzLnNlbmQoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIucHVzaChkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5saXN0ZW5lcnNbdHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzW3R5cGVdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShldmVudC50eXBlLCBldmVudCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzW3R5cGVdKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXSA9IHRoaXMubGlzdGVuZXJzW3R5cGVdLmZpbHRlcihmdW5jdGlvbiAobCkgeyByZXR1cm4gbCAhPT0gbGlzdGVuZXI7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLm9wZW5OZXdXZWJTb2NrZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBjb25uZWN0VGltZW91dCA9IF9hLmNvbm5lY3RUaW1lb3V0LCB3c0NvbnN0cnVjdG9yID0gX2Eud3NDb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIk9wZW5pbmcgbmV3IFdlYlNvY2tldCB0byBcIiArIHRoaXMudXJsICsgXCIuXCIpO1xuICAgICAgICB2YXIgd3MgPSBuZXcgd3NDb25zdHJ1Y3Rvcih0aGlzLnVybCwgdGhpcy5wcm90b2NvbHMpO1xuICAgICAgICB3cy5vbmNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVDbG9zZShldmVudCk7IH07XG4gICAgICAgIHdzLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIF90aGlzLmhhbmRsZUVycm9yKGV2ZW50KTsgfTtcbiAgICAgICAgd3Mub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVNZXNzYWdlKGV2ZW50KTsgfTtcbiAgICAgICAgd3Mub25vcGVuID0gZnVuY3Rpb24gKGV2ZW50KSB7IHJldHVybiBfdGhpcy5oYW5kbGVPcGVuKGV2ZW50KTsgfTtcbiAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIHJ1bm5pbmcsIHdlIHN0aWxsIGhhdmVuJ3Qgb3BlbmVkIHRoZSB3ZWJzb2NrZXQuXG4gICAgICAgICAgICAvLyBLaWxsIGl0IHNvIHdlIGNhbiB0cnkgYWdhaW4uXG4gICAgICAgICAgICBfdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgICAgICB3cy5jbG9zZSgpO1xuICAgICAgICB9LCBjb25uZWN0VGltZW91dCk7XG4gICAgICAgIHRoaXMud3MgPSB3cztcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuaGFuZGxlT3BlbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoIXRoaXMud3MgfHwgdGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbGxDbGVhclJlc2V0VGltZSA9IHRoaXMub3B0aW9ucy5hbGxDbGVhclJlc2V0VGltZTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBvcGVuZWQuXCIpO1xuICAgICAgICBpZiAodGhpcy5iaW5hcnlUeXBlSW50ZXJuYWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy53cy5iaW5hcnlUeXBlID0gdGhpcy5iaW5hcnlUeXBlSW50ZXJuYWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeVR5cGVJbnRlcm5hbCA9IHRoaXMud3MuYmluYXJ5VHlwZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdFRpbWVvdXQoKTtcbiAgICAgICAgaWYgKHRoaXMuaGFzQmVlbk9wZW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwicmVvcGVuXCIsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcIm9wZW5cIiwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5oYXNCZWVuT3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIuZm9yRWFjaChmdW5jdGlvbiAobWVzc2FnZSkgeyByZXR1cm4gX3RoaXMuc2VuZChtZXNzYWdlKTsgfSk7XG4gICAgICAgIHRoaXMubWVzc2FnZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLmFsbENsZWFyVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jbGVhckFsbENsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgX3RoaXMubmV4dFJldHJ5VGltZSA9IDA7XG4gICAgICAgICAgICBfdGhpcy5yZWNvbm5lY3RDb3VudCA9IDA7XG4gICAgICAgICAgICB2YXIgb3BlblRpbWUgPSAoYWxsQ2xlYXJSZXNldFRpbWUgLyAxMDAwKSB8IDA7XG4gICAgICAgICAgICBfdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCByZW1haW5lZCBvcGVuIGZvciBcIiArIG9wZW5UaW1lICsgXCIgc2Vjb25kcy4gUmVzZXR0aW5nXCIgK1xuICAgICAgICAgICAgICAgIFwiIHJldHJ5IHRpbWUgYW5kIGNvdW50LlwiKTtcbiAgICAgICAgfSwgYWxsQ2xlYXJSZXNldFRpbWUpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwibWVzc2FnZVwiLCBldmVudCk7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZUNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5vcHRpb25zLCBtYXhSZWNvbm5lY3RBdHRlbXB0cyA9IF9hLm1heFJlY29ubmVjdEF0dGVtcHRzLCBzaG91bGRSZWNvbm5lY3QgPSBfYS5zaG91bGRSZWNvbm5lY3Q7XG4gICAgICAgIHRoaXMuY2xlYXJDb25uZWN0VGltZW91dCgpO1xuICAgICAgICB0aGlzLmNsZWFyQWxsQ2xlYXJUaW1lb3V0KCk7XG4gICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RLbm93bkV4dGVuc2lvbnMgPSB0aGlzLndzLmV4dGVuc2lvbnM7XG4gICAgICAgICAgICB0aGlzLmxhc3RLbm93blByb3RvY29sID0gdGhpcy53cy5wcm90b2NvbDtcbiAgICAgICAgICAgIHRoaXMud3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiZG93blwiLCBldmVudCk7XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdENvdW50ID49IG1heFJlY29ubmVjdEF0dGVtcHRzKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BSZWNvbm5lY3RpbmcoZXZlbnQsIHRoaXMuZ2V0VG9vTWFueUZhaWxlZFJlY29ubmVjdHNNZXNzYWdlKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aWxsUmVjb25uZWN0ID0gc2hvdWxkUmVjb25uZWN0KGV2ZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWxsUmVjb25uZWN0ID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVXaWxsUmVjb25uZWN0KHdpbGxSZWNvbm5lY3QsIGV2ZW50LCBTSE9VTERfUkVDT05ORUNUX0ZBTFNFX01FU1NBR0UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgd2lsbFJlY29ubmVjdC50aGVuKGZ1bmN0aW9uICh3aWxsUmVjb25uZWN0UmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVXaWxsUmVjb25uZWN0KHdpbGxSZWNvbm5lY3RSZXNvbHZlZCwgZXZlbnQsIFNIT1VMRF9SRUNPTk5FQ1RfUFJPTUlTRV9GQUxTRV9NRVNTQUdFKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZUVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudE9mVHlwZShcImVycm9yXCIsIGV2ZW50KTtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhcIldlYlNvY2tldCBlbmNvdW50ZXJlZCBhbiBlcnJvci5cIik7XG4gICAgfTtcbiAgICBTdHVyZHlXZWJTb2NrZXQucHJvdG90eXBlLmhhbmRsZVdpbGxSZWNvbm5lY3QgPSBmdW5jdGlvbiAod2lsbFJlY29ubmVjdCwgZXZlbnQsIGRlbmlhbFJlYXNvbikge1xuICAgICAgICBpZiAod2lsbFJlY29ubmVjdCkge1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFJlY29ubmVjdGluZyhldmVudCwgZGVuaWFsUmVhc29uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMub3B0aW9ucywgbWluUmVjb25uZWN0RGVsYXkgPSBfYS5taW5SZWNvbm5lY3REZWxheSwgbWF4UmVjb25uZWN0RGVsYXkgPSBfYS5tYXhSZWNvbm5lY3REZWxheSwgcmVjb25uZWN0QmFja29mZkZhY3RvciA9IF9hLnJlY29ubmVjdEJhY2tvZmZGYWN0b3I7XG4gICAgICAgIHRoaXMucmVjb25uZWN0Q291bnQrKztcbiAgICAgICAgdmFyIHJldHJ5VGltZSA9IHRoaXMubmV4dFJldHJ5VGltZTtcbiAgICAgICAgdGhpcy5uZXh0UmV0cnlUaW1lID0gTWF0aC5tYXgobWluUmVjb25uZWN0RGVsYXksIE1hdGgubWluKHRoaXMubmV4dFJldHJ5VGltZSAqIHJlY29ubmVjdEJhY2tvZmZGYWN0b3IsIG1heFJlY29ubmVjdERlbGF5KSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMub3Blbk5ld1dlYlNvY2tldCgpOyB9LCByZXRyeVRpbWUpO1xuICAgICAgICB2YXIgcmV0cnlUaW1lU2Vjb25kcyA9IChyZXRyeVRpbWUgLyAxMDAwKSB8IDA7XG4gICAgICAgIHRoaXMuZGVidWdMb2coXCJXZWJTb2NrZXQgd2FzIGNsb3NlZC4gUmUtb3BlbmluZyBpbiBcIiArIHJldHJ5VGltZVNlY29uZHMgKyBcIiBzZWNvbmRzLlwiKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuc3RvcFJlY29ubmVjdGluZyA9IGZ1bmN0aW9uIChldmVudCwgZGVidWdSZWFzb24pIHtcbiAgICAgICAgdGhpcy5kZWJ1Z0xvZyhkZWJ1Z1JlYXNvbik7XG4gICAgICAgIHRoaXMuc2h1dGRvd24oKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50T2ZUeXBlKFwiY2xvc2VcIiwgZXZlbnQpO1xuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5zaHV0ZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5pc0Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxUaW1lb3V0cygpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VCdWZmZXIgPSBbXTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2xlYXJBbGxUaW1lb3V0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhckNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuY2xlYXJBbGxDbGVhclRpbWVvdXQoKTtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2xlYXJDb25uZWN0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXRJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dElkKTtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5jbGVhckFsbENsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYWxsQ2xlYXJUaW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy5hbGxDbGVhclRpbWVvdXRJZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50T2ZUeXBlID0gZnVuY3Rpb24gKHR5cGUsIGV2ZW50KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcImNsb3NlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25jbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2xvc2UoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmVycm9yKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9ubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9ubWVzc2FnZShldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wZW5cIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbm9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbm9wZW4oZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkb3duXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25kb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25kb3duKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmVvcGVuXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25yZW9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbnJlb3BlbihldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlIGluIHRoaXMubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmxpc3RlbmVyc1t0eXBlXVxuICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7IHJldHVybiBfdGhpcy5jYWxsTGlzdGVuZXIobGlzdGVuZXIsIGV2ZW50KTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICFldmVudCB8fCAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuY2FsbExpc3RlbmVyID0gZnVuY3Rpb24gKGxpc3RlbmVyLCBldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGlzdGVuZXIuaGFuZGxlRXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZGVidWdMb2cgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlYnVnKSB7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tY29uc29sZVxuICAgICAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5wcm90b3R5cGUuZ2V0VG9vTWFueUZhaWxlZFJlY29ubmVjdHNNZXNzYWdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWF4UmVjb25uZWN0QXR0ZW1wdHMgPSB0aGlzLm9wdGlvbnMubWF4UmVjb25uZWN0QXR0ZW1wdHM7XG4gICAgICAgIHJldHVybiBcIkZhaWxlZCB0byByZWNvbm5lY3QgYWZ0ZXIgXCIgKyBtYXhSZWNvbm5lY3RBdHRlbXB0cyArIFwiIFwiICsgcGx1cmFsaXplKFwiYXR0ZW1wdFwiLCBtYXhSZWNvbm5lY3RBdHRlbXB0cykgKyBcIi4gQ2xvc2luZyBwZXJtYW5lbnRseS5cIjtcbiAgICB9O1xuICAgIFN0dXJkeVdlYlNvY2tldC5ERUZBVUxUX09QVElPTlMgPSB7XG4gICAgICAgIGFsbENsZWFyUmVzZXRUaW1lOiA1MDAwLFxuICAgICAgICBjb25uZWN0VGltZW91dDogNTAwMCxcbiAgICAgICAgZGVidWc6IGZhbHNlLFxuICAgICAgICBtaW5SZWNvbm5lY3REZWxheTogMTAwMCxcbiAgICAgICAgbWF4UmVjb25uZWN0RGVsYXk6IDMwMDAwLFxuICAgICAgICBtYXhSZWNvbm5lY3RBdHRlbXB0czogTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICByZWNvbm5lY3RCYWNrb2ZmRmFjdG9yOiAxLjUsXG4gICAgICAgIHNob3VsZFJlY29ubmVjdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbiAgICAgICAgd3NDb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuICAgIH07XG4gICAgU3R1cmR5V2ViU29ja2V0LkNPTk5FQ1RJTkcgPSAwO1xuICAgIFN0dXJkeVdlYlNvY2tldC5PUEVOID0gMTtcbiAgICBTdHVyZHlXZWJTb2NrZXQuQ0xPU0lORyA9IDI7XG4gICAgU3R1cmR5V2ViU29ja2V0LkNMT1NFRCA9IDM7XG4gICAgcmV0dXJuIFN0dXJkeVdlYlNvY2tldDtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdHVyZHlXZWJTb2NrZXQ7XG5mdW5jdGlvbiBnZXREYXRhQnl0ZUxlbmd0aChkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIFVURi0xNiBzdHJpbmdzIHVzZSB0d28gYnl0ZXMgcGVyIGNoYXJhY3Rlci5cbiAgICAgICAgcmV0dXJuIDIgKiBkYXRhLmxlbmd0aDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnNpemU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBsdXJhbGl6ZShzLCBuKSB7XG4gICAgcmV0dXJuIG4gPT09IDEgPyBzIDogcyArIFwic1wiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/sturdy-websocket/dist/index.js\n");

/***/ })

}]);